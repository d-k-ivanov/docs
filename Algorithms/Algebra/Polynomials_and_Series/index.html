<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="Dmitriy Ivanov">
    <link rel="canonical" href="https://d-k-ivanov.github.io/docs/Algorithms/Algebra/Polynomials_and_Series/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Polynomials and Series - Technical Info</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <link href="../../../css/extra.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Polynomials and Series", url: "#_top", children: [
              {title: "Basic Notion and Facts", url: "#basic-notion-and-facts" },
              {title: "Basic implementation", url: "#basic-implementation" },
              {title: "Arithmetic", url: "#arithmetic" },
              {title: "Calculating functions of polynomial", url: "#calculating-functions-of-polynomial" },
              {title: "Evaluation and Interpolation", url: "#evaluation-and-interpolation" },
              {title: "GCD and Resultants", url: "#gcd-and-resultants" },
              {title: "Problems", url: "#problems" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../mathjax-config.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-80208201-1', 'd-k-ivanov.github.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../Primality_Tests/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../Primality_Tests/" class="btn btn-xs btn-link">
        Primality Tests
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../Montgomery_Multiplication/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../Montgomery_Multiplication/" class="btn btn-xs btn-link">
        Montgomery Multiplication
      </a>
    </div>
    
  </div>

    

    <h1 id="polynomials-and-series">Polynomials and Series</h1>
<p>In this article we will cover common operations that you will probably have to do if you deal with polynomials.</p>
<h2 id="basic-notion-and-facts">Basic Notion and Facts</h2>
<p>Consider a polynomial <span><span class="MathJax_Preview">A(x) = a_0 + a_1 x + \dots + a_n x^n</span><script type="math/tex">A(x) = a_0 + a_1 x + \dots + a_n x^n</script></span> such that <span><span class="MathJax_Preview">a_n \neq 0</span><script type="math/tex">a_n \neq 0</script></span>.</p>
<ul>
<li>For simplicity we will write <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> instead of <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> wherever possible, which will be understandable from the context.</li>
<li>We will define the degree of polynomial <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> as <span><span class="MathJax_Preview">\deg A = n</span><script type="math/tex">\deg A = n</script></span>. It is convenient to say that <span><span class="MathJax_Preview">\deg A = -\infty</span><script type="math/tex">\deg A = -\infty</script></span> for <span><span class="MathJax_Preview">A(x) = 0</span><script type="math/tex">A(x) = 0</script></span>.</li>
<li>For arbitrary polynomials <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> and <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span> it holds that <span><span class="MathJax_Preview">\deg AB = \deg A + \deg B</span><script type="math/tex">\deg AB = \deg A + \deg B</script></span>.</li>
<li>Polynomials form an euclidean ring which means that for any polynomials <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> and <span><span class="MathJax_Preview">B \neq 0</span><script type="math/tex">B \neq 0</script></span> we can uniquely represent <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> as: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">A = D \cdot B + R,~ \deg R &lt; \deg B.</span><script type="math/tex">A = D \cdot B + R,~ \deg R < \deg B.</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">A = D \cdot B + R,~ \deg R &lt; \deg B.</span><script type="math/tex">A = D \cdot B + R,~ \deg R < \deg B.</script></span></script></span> Here <span><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span> is called remainder of <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> modulo <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span> and <span><span class="MathJax_Preview">D</span><script type="math/tex">D</script></span> is called quotient.</li>
<li>If <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> and <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span> have the same remainder modulo <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>, they're said to be equivalent modulo <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>, which is denoted as: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">A \equiv B \pmod{C}</span><script type="math/tex">A \equiv B \pmod{C}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">A \equiv B \pmod{C}</span><script type="math/tex">A \equiv B \pmod{C}</script></span></script></span></li>
<li>For any linear polynomial <span><span class="MathJax_Preview">x-r</span><script type="math/tex">x-r</script></span> it holds that: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">A(x) \equiv A(r) \pmod{x-r}</span><script type="math/tex">A(x) \equiv A(r) \pmod{x-r}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">A(x) \equiv A(r) \pmod{x-r}</span><script type="math/tex">A(x) \equiv A(r) \pmod{x-r}</script></span></script></span></li>
<li>In particular: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">A(r) = 0 \iff A(x) \equiv 0 \pmod {x-r}</span><script type="math/tex">A(r) = 0 \iff A(x) \equiv 0 \pmod {x-r}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">A(r) = 0 \iff A(x) \equiv 0 \pmod {x-r}</span><script type="math/tex">A(r) = 0 \iff A(x) \equiv 0 \pmod {x-r}</script></span></script></span> Which means that <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> is divisible by <span><span class="MathJax_Preview">x-r</span><script type="math/tex">x-r</script></span> <span><span class="MathJax_Preview">\iff</span><script type="math/tex">\iff</script></span> <span><span class="MathJax_Preview">A(r)=0</span><script type="math/tex">A(r)=0</script></span>.</li>
<li>If <span><span class="MathJax_Preview">A \equiv B \pmod{C \cdot D}</span><script type="math/tex">A \equiv B \pmod{C \cdot D}</script></span> then <span><span class="MathJax_Preview">A \equiv B \pmod{C}</span><script type="math/tex">A \equiv B \pmod{C}</script></span></li>
<li><span><span class="MathJax_Preview">A \equiv a_0 + a_1 x + \dots + a_{k-1} x^{k-1} \pmod{x^k}</span><script type="math/tex">A \equiv a_0 + a_1 x + \dots + a_{k-1} x^{k-1} \pmod{x^k}</script></span></li>
</ul>
<h2 id="basic-implementation">Basic implementation</h2>
<p><a href="https://github.com/e-maxx-eng/e-maxx-eng-aux/blob/master/src/polynomial.cpp">Here</a> you can find the basic implementation of polynomial algebra.</p>
<p>It supports all trivial operations and some other useful methods. The main class is <code>poly&lt;T&gt;</code> for polynomials with coefficients of class <code>T</code>.</p>
<p>All arithmetic operation <code>+</code>, <code>-</code>, <code>*</code>, <code>%</code> and <code>/</code> are supported, <code>%</code> and <code>/</code> standing for remainder and quotient in integer division.</p>
<p>There is also the class <code>modular&lt;m&gt;</code> for performing arithmetic operations on remainders modulo a prime number <code>m</code>.</p>
<p>Other useful functions:</p>
<ul>
<li><code>deriv()</code>: computes the derivative <span><span class="MathJax_Preview">P'(x)</span><script type="math/tex">P'(x)</script></span> of <span><span class="MathJax_Preview">P(x)</span><script type="math/tex">P(x)</script></span>.</li>
<li><code>integr()</code>: computes the indefinite integral <span><span class="MathJax_Preview">Q(x) = \int P(x)</span><script type="math/tex">Q(x) = \int P(x)</script></span> of <span><span class="MathJax_Preview">P(x)</span><script type="math/tex">P(x)</script></span> such that <span><span class="MathJax_Preview">Q(0)=0</span><script type="math/tex">Q(0)=0</script></span>.</li>
<li><code>inv(size_t n)</code>: calculate the first <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> coefficients of <span><span class="MathJax_Preview">P^{-1}(x)</span><script type="math/tex">P^{-1}(x)</script></span> in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span>.</li>
<li><code>log(size_t n)</code>: calculate the first <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> coefficients of <span><span class="MathJax_Preview">\ln P(x)</span><script type="math/tex">\ln P(x)</script></span> in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span>.</li>
<li><code>exp(size_t n)</code>: calculate the first <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> coefficients of <span><span class="MathJax_Preview">\exp P(x)</span><script type="math/tex">\exp P(x)</script></span> in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span>.</li>
<li><code>pow(size_t k, size_t n)</code>: calculate the first <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> coefficients for <span><span class="MathJax_Preview">P^{k}(x)</span><script type="math/tex">P^{k}(x)</script></span> in <span><span class="MathJax_Preview">O(n \log nk)</span><script type="math/tex">O(n \log nk)</script></span>.</li>
<li><code>deg()</code>: returns the degree of <span><span class="MathJax_Preview">P(x)</span><script type="math/tex">P(x)</script></span>.</li>
<li><code>lead()</code>: returns the coefficient of <span><span class="MathJax_Preview">x^{\deg P(x)}</span><script type="math/tex">x^{\deg P(x)}</script></span>.</li>
<li><code>resultant(poly&lt;T&gt; a, poly&lt;T&gt; b)</code>: computes the resultant of <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> and <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> in <span><span class="MathJax_Preview">O(|a| \cdot |b|)</span><script type="math/tex">O(|a| \cdot |b|)</script></span>.</li>
<li><code>bpow(T x, size_t n)</code>: computes <span><span class="MathJax_Preview">x^n</span><script type="math/tex">x^n</script></span>.</li>
<li><code>bpow(T x, size_t n, T m)</code>: computes <span><span class="MathJax_Preview">x^n \pmod{m}</span><script type="math/tex">x^n \pmod{m}</script></span>.</li>
<li><code>chirpz(T z, size_t n)</code>: computes <span><span class="MathJax_Preview">P(1), P(z), P(z^2), \dots, P(z^{n-1})</span><script type="math/tex">P(1), P(z), P(z^2), \dots, P(z^{n-1})</script></span> in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span>.</li>
<li><code>vector&lt;T&gt; eval(vector&lt;T&gt; x)</code>: evaluates <span><span class="MathJax_Preview">P(x_1), \dots, P(x_n)</span><script type="math/tex">P(x_1), \dots, P(x_n)</script></span> in <span><span class="MathJax_Preview">O(n \log^2 n)</span><script type="math/tex">O(n \log^2 n)</script></span>.</li>
<li><code>poly&lt;T&gt; inter(vector&lt;T&gt; x, vector&lt;T&gt; y)</code>: interpolates a polynomial by a set of pairs <span><span class="MathJax_Preview">P(x_i) = y_i</span><script type="math/tex">P(x_i) = y_i</script></span> in <span><span class="MathJax_Preview">O(n \log^2 n)</span><script type="math/tex">O(n \log^2 n)</script></span>.</li>
<li>And some more, feel free to explore the code!</li>
</ul>
<h2 id="arithmetic">Arithmetic</h2>
<h3 id="multiplication">Multiplication</h3>
<p>The very core operation is the multiplication of two polynomials, that is, given polynomial <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> and <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>:</p>
<div>
<div class="MathJax_Preview">A = a_0 + a_1 x + \dots + a_n x^n</div>
<script type="math/tex; mode=display">A = a_0 + a_1 x + \dots + a_n x^n</script>
</div>
<div>
<div class="MathJax_Preview">B = b_0 + b_1 x + \dots + b_m x^m</div>
<script type="math/tex; mode=display">B = b_0 + b_1 x + \dots + b_m x^m</script>
</div>
<p>You have to compute polynomial <span><span class="MathJax_Preview">C = A \cdot B</span><script type="math/tex">C = A \cdot B</script></span>: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">\boxed{C = \sum\limits_{i=0}^n \sum\limits_{j=0}^m a_i b_j x^{i+j}}  = c_0 + c_1 x + \dots + c_{n+m} x^{n+m}</span><script type="math/tex">\boxed{C = \sum\limits_{i=0}^n \sum\limits_{j=0}^m a_i b_j x^{i+j}}  = c_0 + c_1 x + \dots + c_{n+m} x^{n+m}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">\boxed{C = \sum\limits_{i=0}^n \sum\limits_{j=0}^m a_i b_j x^{i+j}}  = c_0 + c_1 x + \dots + c_{n+m} x^{n+m}</span><script type="math/tex">\boxed{C = \sum\limits_{i=0}^n \sum\limits_{j=0}^m a_i b_j x^{i+j}}  = c_0 + c_1 x + \dots + c_{n+m} x^{n+m}</script></span></script></span>
It can be computed in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span> via the <a href="/docs/#Algorithms/Algebra/Fast_Fourier_Transform/">Fast Fourier transform</a> and almost all methods here will use it as subroutine.</p>
<h3 id="inverse-series">Inverse series</h3>
<p>If <span><span class="MathJax_Preview">A(0) \neq 0</span><script type="math/tex">A(0) \neq 0</script></span> there always exists an infinite series <span><span class="MathJax_Preview">A^{-1}(x) = \sum\limits_{i=0}^\infty a_i'x^i</span><script type="math/tex">A^{-1}(x) = \sum\limits_{i=0}^\infty a_i'x^i</script></span> such that <span><span class="MathJax_Preview">A^{-1} A = 1</span><script type="math/tex">A^{-1} A = 1</script></span>.</p>
<p>It may be reasonable for us to calculate first <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> coefficients of <span><span class="MathJax_Preview">A^{-1}</span><script type="math/tex">A^{-1}</script></span>:</p>
<ol>
<li>Let's say that <span><span class="MathJax_Preview">A^{-1} \equiv B_k \pmod{x^{a}}</span><script type="math/tex">A^{-1} \equiv B_k \pmod{x^{a}}</script></span>. That means that <span><span class="MathJax_Preview">A B_k \equiv 1 \pmod {x^{a}}</span><script type="math/tex">A B_k \equiv 1 \pmod {x^{a}}</script></span>.</li>
<li>We want to find <span><span class="MathJax_Preview">B_{k+1} \equiv B_k + x^{a}C \pmod{x^{2a}}</span><script type="math/tex">B_{k+1} \equiv B_k + x^{a}C \pmod{x^{2a}}</script></span> such that <span><span class="MathJax_Preview">A B_{k+1} \equiv 1 \pmod{x^{2a}}</span><script type="math/tex">A B_{k+1} \equiv 1 \pmod{x^{2a}}</script></span>: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">A(B_k + x^{a}C) \equiv 1 \pmod{x^{2a}}</span><script type="math/tex">A(B_k + x^{a}C) \equiv 1 \pmod{x^{2a}}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">A(B_k + x^{a}C) \equiv 1 \pmod{x^{2a}}</span><script type="math/tex">A(B_k + x^{a}C) \equiv 1 \pmod{x^{2a}}</script></span></script></span></li>
<li>Note that since <span><span class="MathJax_Preview">A B_k \equiv 1 \pmod{x^{a}}</span><script type="math/tex">A B_k \equiv 1 \pmod{x^{a}}</script></span> it also holds that <span><span class="MathJax_Preview">A B_k \equiv 1 + x^a D \pmod{x^{2a}}</span><script type="math/tex">A B_k \equiv 1 + x^a D \pmod{x^{2a}}</script></span>. Thus: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">x^a(D+AC) \equiv 0 \pmod{x^{2a}} \implies D \equiv -AC \pmod{x^a} \implies C \equiv -B_k D \pmod{x^a}</span><script type="math/tex">x^a(D+AC) \equiv 0 \pmod{x^{2a}} \implies D \equiv -AC \pmod{x^a} \implies C \equiv -B_k D \pmod{x^a}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">x^a(D+AC) \equiv 0 \pmod{x^{2a}} \implies D \equiv -AC \pmod{x^a} \implies C \equiv -B_k D \pmod{x^a}</span><script type="math/tex">x^a(D+AC) \equiv 0 \pmod{x^{2a}} \implies D \equiv -AC \pmod{x^a} \implies C \equiv -B_k D \pmod{x^a}</script></span></script></span></li>
<li>From this we obtain that:</li>
</ol>
<div>
<div class="MathJax_Preview">x^a C \equiv -B_k x^a D  \equiv B_k(1-AB_k) \pmod{x^{2a}} \implies \boxed{B_{k+1} \equiv B_k(2-AB_k) \pmod{x^{2a}}}</div>
<script type="math/tex; mode=display">x^a C \equiv -B_k x^a D  \equiv B_k(1-AB_k) \pmod{x^{2a}} \implies \boxed{B_{k+1} \equiv B_k(2-AB_k) \pmod{x^{2a}}}</script>
</div>
<p>Thus starting with <span><span class="MathJax_Preview">B_0 \equiv a_0^{-1} \pmod x</span><script type="math/tex">B_0 \equiv a_0^{-1} \pmod x</script></span> we will compute the sequence <span><span class="MathJax_Preview">B_k</span><script type="math/tex">B_k</script></span> such that <span><span class="MathJax_Preview">AB_k \equiv 1 \pmod{x^{2^k}}</span><script type="math/tex">AB_k \equiv 1 \pmod{x^{2^k}}</script></span> with the complexity: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">T(n) = T(n/2) + O(n \log n) = O(n \log n)</span><script type="math/tex">T(n) = T(n/2) + O(n \log n) = O(n \log n)</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">T(n) = T(n/2) + O(n \log n) = O(n \log n)</span><script type="math/tex">T(n) = T(n/2) + O(n \log n) = O(n \log n)</script></span></script></span></p>
<h3 id="division-with-remainder">Division with remainder</h3>
<p>Consider two polynomials <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> and <span><span class="MathJax_Preview">B(x)</span><script type="math/tex">B(x)</script></span> of degrees <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> and <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>. As it was said earlier you can rewrite <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> as:</p>
<div>
<div class="MathJax_Preview">A(x) = B(x) D(x) + R(x), \deg R &lt; \deg B</div>
<script type="math/tex; mode=display">A(x) = B(x) D(x) + R(x), \deg R < \deg B</script>
</div>
<p>Let <span><span class="MathJax_Preview">n \geq m</span><script type="math/tex">n \geq m</script></span>, then you can immediately find out that <span><span class="MathJax_Preview">\deg D = n - m</span><script type="math/tex">\deg D = n - m</script></span> and that leading <span><span class="MathJax_Preview">n-m+1</span><script type="math/tex">n-m+1</script></span> coefficients of <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> don't influence <span><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>.</p>
<p>That means that you can recover <span><span class="MathJax_Preview">D(x)</span><script type="math/tex">D(x)</script></span> from the largest <span><span class="MathJax_Preview">n-m+1</span><script type="math/tex">n-m+1</script></span> coefficients of <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> and <span><span class="MathJax_Preview">B(x)</span><script type="math/tex">B(x)</script></span> if you consider it as a system of equations.</p>
<p>The formal way to do it is to consider the reversed polynomials:</p>
<div>
<div class="MathJax_Preview">A^R(x) = x^nA(x^{-1})= a_n + a_{n-1} x + \dots + a_0 x^n</div>
<script type="math/tex; mode=display">A^R(x) = x^nA(x^{-1})= a_n + a_{n-1} x + \dots + a_0 x^n</script>
</div>
<div>
<div class="MathJax_Preview">B^R(x) = x^m B(x^{-1}) = b_m + b_{m-1} x + \dots + b_0 x^m</div>
<script type="math/tex; mode=display">B^R(x) = x^m B(x^{-1}) = b_m + b_{m-1} x + \dots + b_0 x^m</script>
</div>
<div>
<div class="MathJax_Preview">D^R(x) = x^{n-m}D(x^{-1}) = d_{n-m} + d_{n-m-1} x + \dots + d_0 x^{n-m}</div>
<script type="math/tex; mode=display">D^R(x) = x^{n-m}D(x^{-1}) = d_{n-m} + d_{n-m-1} x + \dots + d_0 x^{n-m}</script>
</div>
<p>Using these terms you can rewrite that statement about the largest <span><span class="MathJax_Preview">n-m+1</span><script type="math/tex">n-m+1</script></span> coefficients as:</p>
<div>
<div class="MathJax_Preview">A^R(x) \equiv B^R(x) D^R(x) \pmod{x^{n-m+1}}</div>
<script type="math/tex; mode=display">A^R(x) \equiv B^R(x) D^R(x) \pmod{x^{n-m+1}}</script>
</div>
<p>From which you can unambiguously recover all coefficients of <span><span class="MathJax_Preview">D(x)</span><script type="math/tex">D(x)</script></span>:</p>
<div>
<div class="MathJax_Preview">\boxed{D^R(x) \equiv A^R(x) (B^R(x))^{-1} \pmod{x^{n-m+1}}}</div>
<script type="math/tex; mode=display">\boxed{D^R(x) \equiv A^R(x) (B^R(x))^{-1} \pmod{x^{n-m+1}}}</script>
</div>
<p>And from this in turn you can easily recover <span><span class="MathJax_Preview">R(x)</span><script type="math/tex">R(x)</script></span> as <span><span class="MathJax_Preview">R(x) = A(x) - B(x)D(x)</span><script type="math/tex">R(x) = A(x) - B(x)D(x)</script></span>.</p>
<h2 id="calculating-functions-of-polynomial">Calculating functions of polynomial</h2>
<h3 id="newtons-method">Newton's method</h3>
<p>Let's generalize the inverse series approach.
You want to find a polynomial <span><span class="MathJax_Preview">P(x)</span><script type="math/tex">P(x)</script></span> satisfying <span><span class="MathJax_Preview">F(P) = 0</span><script type="math/tex">F(P) = 0</script></span> where <span><span class="MathJax_Preview">F(x)</span><script type="math/tex">F(x)</script></span> is some function represented as:</p>
<div>
<div class="MathJax_Preview">F(x) = \sum\limits_{i=0}^\infty \alpha_i (x-\beta)^k</div>
<script type="math/tex; mode=display">F(x) = \sum\limits_{i=0}^\infty \alpha_i (x-\beta)^k</script>
</div>
<p>Where <span><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span> is some constant. It can be proven that if we introduce a new formal variable <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>, we can express <span><span class="MathJax_Preview">F(x)</span><script type="math/tex">F(x)</script></span> as:</p>
<div>
<div class="MathJax_Preview">F(x) = F(y) + (x-y)F'(y) + (x-y)^2 G(x,y)</div>
<script type="math/tex; mode=display">F(x) = F(y) + (x-y)F'(y) + (x-y)^2 G(x,y)</script>
</div>
<p>Where <span><span class="MathJax_Preview">F'(x)</span><script type="math/tex">F'(x)</script></span> is the derivative formal power series defined as <span><span class="MathJax_Preview">F'(x) = \sum\limits_{i=0}^\infty (k+1)\alpha_{i+1}(x-\beta)^k</span><script type="math/tex">F'(x) = \sum\limits_{i=0}^\infty (k+1)\alpha_{i+1}(x-\beta)^k</script></span> and <span><span class="MathJax_Preview">G(x, y)</span><script type="math/tex">G(x, y)</script></span> is some formal power series of <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>.</p>
<p>Given this we can find the coefficients of the solution iteratively:</p>
<ol>
<li>Assume that <span><span class="MathJax_Preview">F(Q_k) \equiv 0 \pmod{x^{a}}</span><script type="math/tex">F(Q_k) \equiv 0 \pmod{x^{a}}</script></span>, we want to find <span><span class="MathJax_Preview">Q_{k+1} \equiv Q_k + x^a C \pmod{x^{2a}}</span><script type="math/tex">Q_{k+1} \equiv Q_k + x^a C \pmod{x^{2a}}</script></span> such that <span><span class="MathJax_Preview">F(Q_{k+1}) \equiv 0 \pmod{x^{2a}}</span><script type="math/tex">F(Q_{k+1}) \equiv 0 \pmod{x^{2a}}</script></span>.</li>
<li>Pasting <span><span class="MathJax_Preview">x = Q_{k+1}</span><script type="math/tex">x = Q_{k+1}</script></span> and <span><span class="MathJax_Preview">y=Q_k</span><script type="math/tex">y=Q_k</script></span> in the formula above we get: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">F(Q_{k+1}) \equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) + (Q_{k+1} - Q_k)^2 G(x, y) \pmod x^{2a}</span><script type="math/tex">F(Q_{k+1}) \equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) + (Q_{k+1} - Q_k)^2 G(x, y) \pmod x^{2a}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">F(Q_{k+1}) \equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) + (Q_{k+1} - Q_k)^2 G(x, y) \pmod x^{2a}</span><script type="math/tex">F(Q_{k+1}) \equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) + (Q_{k+1} - Q_k)^2 G(x, y) \pmod x^{2a}</script></span></script></span></li>
<li>Since <span><span class="MathJax_Preview">Q_{k+1} - Q_k \equiv 0 \pmod{x^a}</span><script type="math/tex">Q_{k+1} - Q_k \equiv 0 \pmod{x^a}</script></span> we can say that <span><span class="MathJax_Preview">(Q_{k+1} - Q_k)^2 \equiv 0 \pmod{x^{2a}}</span><script type="math/tex">(Q_{k+1} - Q_k)^2 \equiv 0 \pmod{x^{2a}}</script></span>, thus: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">0 \equiv F(Q_{k+1}) \equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) \pmod{x^{2a}}</span><script type="math/tex">0 \equiv F(Q_{k+1}) \equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) \pmod{x^{2a}}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">0 \equiv F(Q_{k+1}) \equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) \pmod{x^{2a}}</span><script type="math/tex">0 \equiv F(Q_{k+1}) \equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) \pmod{x^{2a}}</script></span></script></span></li>
<li>From the last formula we derive the value of <span><span class="MathJax_Preview">Q_{k+1}</span><script type="math/tex">Q_{k+1}</script></span>: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">\boxed{Q_{k+1} = Q_k - \dfrac{F(Q_k)}{F'(Q_k)} \pmod{x^{2a}}}</span><script type="math/tex">\boxed{Q_{k+1} = Q_k - \dfrac{F(Q_k)}{F'(Q_k)} \pmod{x^{2a}}}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">\boxed{Q_{k+1} = Q_k - \dfrac{F(Q_k)}{F'(Q_k)} \pmod{x^{2a}}}</span><script type="math/tex">\boxed{Q_{k+1} = Q_k - \dfrac{F(Q_k)}{F'(Q_k)} \pmod{x^{2a}}}</script></span></script></span></li>
</ol>
<p>Thus knowing how to invert arbitrary polynomial and how to compute <span><span class="MathJax_Preview">F(Q_k)</span><script type="math/tex">F(Q_k)</script></span> quickly, we can find <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> coefficients of <span><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span> with the complexity: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">T(n) = T(n/2) + f(n)</span><script type="math/tex">T(n) = T(n/2) + f(n)</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">T(n) = T(n/2) + f(n)</span><script type="math/tex">T(n) = T(n/2) + f(n)</script></span></script></span> Where <span><span class="MathJax_Preview">f(n)</span><script type="math/tex">f(n)</script></span> is the maximum of <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span> needed to invert series and time needed to compute <span><span class="MathJax_Preview">F(Q_k)</span><script type="math/tex">F(Q_k)</script></span> which is usually also <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span>.</p>
<h3 id="logarithm">Logarithm</h3>
<p>For the function <span><span class="MathJax_Preview">\ln P(x)</span><script type="math/tex">\ln P(x)</script></span> it's known that: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">\boxed{(\ln P(x))' = \dfrac{P'(x)}{P(x)}}</span><script type="math/tex">\boxed{(\ln P(x))' = \dfrac{P'(x)}{P(x)}}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">\boxed{(\ln P(x))' = \dfrac{P'(x)}{P(x)}}</span><script type="math/tex">\boxed{(\ln P(x))' = \dfrac{P'(x)}{P(x)}}</script></span></script></span>
Thus we can calculate <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> coefficients of <span><span class="MathJax_Preview">\ln P(x)</span><script type="math/tex">\ln P(x)</script></span> in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span>.</p>
<h3 id="inverse-series_1">Inverse series</h3>
<p>Turns out, we can get the formula for <span><span class="MathJax_Preview">A^{-1}</span><script type="math/tex">A^{-1}</script></span> using Newton's method.
For this we take the equation <span><span class="MathJax_Preview">A=Q^{-1}</span><script type="math/tex">A=Q^{-1}</script></span>, thus:</p>
<div>
<div class="MathJax_Preview">F(Q) = Q^{-1} - A</div>
<script type="math/tex; mode=display">F(Q) = Q^{-1} - A</script>
</div>
<div>
<div class="MathJax_Preview">F'(Q) = -Q^{-2}</div>
<script type="math/tex; mode=display">F'(Q) = -Q^{-2}</script>
</div>
<div>
<div class="MathJax_Preview">\boxed{Q_{k+1} \equiv Q_k(2-AQ_k) \pmod{x^{2^{k+1}}}}</div>
<script type="math/tex; mode=display">\boxed{Q_{k+1} \equiv Q_k(2-AQ_k) \pmod{x^{2^{k+1}}}}</script>
</div>
<h3 id="exponent">Exponent</h3>
<p>Let's learn to calculate <span><span class="MathJax_Preview">e^{P(x)}=Q(x)</span><script type="math/tex">e^{P(x)}=Q(x)</script></span>. It should hold that <span><span class="MathJax_Preview">\ln Q = P</span><script type="math/tex">\ln Q = P</script></span>, thus: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">F(Q) = \ln Q - P</span><script type="math/tex">F(Q) = \ln Q - P</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">F(Q) = \ln Q - P</span><script type="math/tex">F(Q) = \ln Q - P</script></span></script></span> <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">F'(Q) = Q^{-1}</span><script type="math/tex">F'(Q) = Q^{-1}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">F'(Q) = Q^{-1}</span><script type="math/tex">F'(Q) = Q^{-1}</script></span></script></span> <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">\boxed{Q_{k+1} \equiv Q_k(1 + P - \ln Q_k) \pmod{x^{2^{k+1}}}}</span><script type="math/tex">\boxed{Q_{k+1} \equiv Q_k(1 + P - \ln Q_k) \pmod{x^{2^{k+1}}}}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">\boxed{Q_{k+1} \equiv Q_k(1 + P - \ln Q_k) \pmod{x^{2^{k+1}}}}</span><script type="math/tex">\boxed{Q_{k+1} \equiv Q_k(1 + P - \ln Q_k) \pmod{x^{2^{k+1}}}}</script></span></script></span></p>
<h3 id="kk-th-power"><span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>-th power</h3>
<p>Now we need to calculate <span><span class="MathJax_Preview">P^k(x)=Q</span><script type="math/tex">P^k(x)=Q</script></span>. This may be done via the following formula:</p>
<div>
<div class="MathJax_Preview">Q = \exp\left[k \ln P(x)\right]</div>
<script type="math/tex; mode=display">Q = \exp\left[k \ln P(x)\right]</script>
</div>
<p>Note though, that you can calculate the logarithms and the exponents correctly only if you can find some initial <span><span class="MathJax_Preview">Q_0</span><script type="math/tex">Q_0</script></span>.</p>
<p>To find it, you should calculate the logarithm or the exponent of the constant coefficient of the polynomial.</p>
<p>But the only reasonable way to do it is if <span><span class="MathJax_Preview">P(0)=1</span><script type="math/tex">P(0)=1</script></span> for <span><span class="MathJax_Preview">Q = \ln P</span><script type="math/tex">Q = \ln P</script></span> so <span><span class="MathJax_Preview">Q(0)=0</span><script type="math/tex">Q(0)=0</script></span> and if <span><span class="MathJax_Preview">P(0)=0</span><script type="math/tex">P(0)=0</script></span> for <span><span class="MathJax_Preview">Q = e^P</span><script type="math/tex">Q = e^P</script></span> so <span><span class="MathJax_Preview">Q(0)=1</span><script type="math/tex">Q(0)=1</script></span>.</p>
<p>Thus you can use formula above only if <span><span class="MathJax_Preview">P(0) = 1</span><script type="math/tex">P(0) = 1</script></span>. Otherwise if <span><span class="MathJax_Preview">P(x) = \alpha x^t T(x)</span><script type="math/tex">P(x) = \alpha x^t T(x)</script></span> where <span><span class="MathJax_Preview">T(0)=1</span><script type="math/tex">T(0)=1</script></span> you can write that:</p>
<div>
<div class="MathJax_Preview">\boxed{P^k(x) = \alpha^kx^{kt} \exp[k \ln T(x)]}</div>
<script type="math/tex; mode=display">\boxed{P^k(x) = \alpha^kx^{kt} \exp[k \ln T(x)]}</script>
</div>
<p>Note that you also can calculate some <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>-th root of a polynomial if you can calculate <span><span class="MathJax_Preview">\sqrt[k]{\alpha}</span><script type="math/tex">\sqrt[k]{\alpha}</script></span>, for example for <span><span class="MathJax_Preview">\alpha=1</span><script type="math/tex">\alpha=1</script></span>.</p>
<h2 id="evaluation-and-interpolation">Evaluation and Interpolation</h2>
<h3 id="chirp-z-transform">Chirp-z Transform</h3>
<p>For the particular case when you need to evaluate a polynomial in the points <span><span class="MathJax_Preview">x_r = z^{2r}</span><script type="math/tex">x_r = z^{2r}</script></span> you can do the following:</p>
<div>
<div class="MathJax_Preview">A(z^{2r}) = \sum\limits_{k=0}^n a_k z^{2kr}</div>
<script type="math/tex; mode=display">A(z^{2r}) = \sum\limits_{k=0}^n a_k z^{2kr}</script>
</div>
<p>Let's substitute <span><span class="MathJax_Preview">2kr = r^2+k^2-(r-k)^2</span><script type="math/tex">2kr = r^2+k^2-(r-k)^2</script></span>. Then this sum rewrites as:</p>
<div>
<div class="MathJax_Preview">\boxed{A(z^{2r}) = z^{r^2}\sum\limits_{k=0}^n (a_k z^{k^2}) z^{-(r-k)^2}}</div>
<script type="math/tex; mode=display">\boxed{A(z^{2r}) = z^{r^2}\sum\limits_{k=0}^n (a_k z^{k^2}) z^{-(r-k)^2}}</script>
</div>
<p>Which is up to the factor <span><span class="MathJax_Preview">z^{r^2}</span><script type="math/tex">z^{r^2}</script></span> equal to the convolution of the sequences <span><span class="MathJax_Preview">u_k = a_k z^{k^2}</span><script type="math/tex">u_k = a_k z^{k^2}</script></span> and <span><span class="MathJax_Preview">v_k = z^{-k^2}</span><script type="math/tex">v_k = z^{-k^2}</script></span>.</p>
<p>Note that <span><span class="MathJax_Preview">u_k</span><script type="math/tex">u_k</script></span> has indexes from <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span> to <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> here and <span><span class="MathJax_Preview">v_k</span><script type="math/tex">v_k</script></span> has indexes from <span><span class="MathJax_Preview">-n</span><script type="math/tex">-n</script></span> to <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> where <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> is the maximum power of <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span> which you need.</p>
<p>Now if you need to evaluate a polynomial in the points <span><span class="MathJax_Preview">x_r = z^{2r+1}</span><script type="math/tex">x_r = z^{2r+1}</script></span> you can reduce it to the previous task by the transformation <span><span class="MathJax_Preview">a_k \to a_k z^k</span><script type="math/tex">a_k \to a_k z^k</script></span>.</p>
<p>It gives us an <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span> algorithm when you need to compute values in powers of <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>, thus you may compute the DFT for non-powers of two.</p>
<h3 id="multi-point-evaluation">Multi-point Evaluation</h3>
<p>Assume you need to calculate <span><span class="MathJax_Preview">A(x_1), \dots, A(x_n)</span><script type="math/tex">A(x_1), \dots, A(x_n)</script></span>. As mentioned earlier, <span><span class="MathJax_Preview">A(x) \equiv A(x_i) \pmod{x-x_i}</span><script type="math/tex">A(x) \equiv A(x_i) \pmod{x-x_i}</script></span>. Thus you may do the following:</p>
<ol>
<li>Compute a segment tree such that in the segment <span><span class="MathJax_Preview">[l,r)</span><script type="math/tex">[l,r)</script></span> stands the product <span><span class="MathJax_Preview">P_{l, r}(x) = (x-x_l)(x-x_{l+1})\dots(x-x_{r-1})</span><script type="math/tex">P_{l, r}(x) = (x-x_l)(x-x_{l+1})\dots(x-x_{r-1})</script></span>.</li>
<li>Starting with <span><span class="MathJax_Preview">l=1</span><script type="math/tex">l=1</script></span> and <span><span class="MathJax_Preview">r=n</span><script type="math/tex">r=n</script></span> at the root node. Let <span><span class="MathJax_Preview">m=\lfloor(l+r)/2\rfloor</span><script type="math/tex">m=\lfloor(l+r)/2\rfloor</script></span>. Let's move down to <span><span class="MathJax_Preview">[l,m)</span><script type="math/tex">[l,m)</script></span> with the polynomial <span><span class="MathJax_Preview">A(x) \pmod{P_{l,m}(x)}</span><script type="math/tex">A(x) \pmod{P_{l,m}(x)}</script></span>.</li>
<li>This will recursively compute <span><span class="MathJax_Preview">A(x_l), \dots, A(x_{m-1})</span><script type="math/tex">A(x_l), \dots, A(x_{m-1})</script></span>, now do the same for <span><span class="MathJax_Preview">[m,r)</span><script type="math/tex">[m,r)</script></span> with <span><span class="MathJax_Preview">A(x) \pmod{P_{m,r}(x)}</span><script type="math/tex">A(x) \pmod{P_{m,r}(x)}</script></span>.</li>
<li>Concatenate the results from the first and second recursive call and return them.</li>
</ol>
<p>The whole procedure will run in <span><span class="MathJax_Preview">O(n \log^2 n)</span><script type="math/tex">O(n \log^2 n)</script></span>.</p>
<h3 id="interpolation">Interpolation</h3>
<p>There's a direct formula by Lagrange to interpolate a polynomial, given set of pairs <span><span class="MathJax_Preview">(x_i, y_i)</span><script type="math/tex">(x_i, y_i)</script></span>:</p>
<div>
<div class="MathJax_Preview">\boxed{A(x) = \sum\limits_{i=1}^n y_i \prod\limits_{j \neq i}\dfrac{x-x_j}{x_i - x_j}}</div>
<script type="math/tex; mode=display">\boxed{A(x) = \sum\limits_{i=1}^n y_i \prod\limits_{j \neq i}\dfrac{x-x_j}{x_i - x_j}}</script>
</div>
<p>Computing it directly is a hard thing but turns out, we may compute it in <span><span class="MathJax_Preview">O(n \log^2 n)</span><script type="math/tex">O(n \log^2 n)</script></span> with a divide and conquer approach:</p>
<p>Consider <span><span class="MathJax_Preview">P(x) = (x-x_1)\dots(x-x_n)</span><script type="math/tex">P(x) = (x-x_1)\dots(x-x_n)</script></span>. To know the coefficients of the denominators in <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> we should compute products like: <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">P_i = \prod\limits_{j \neq i} (x_i-x_j)</span><script type="math/tex">P_i = \prod\limits_{j \neq i} (x_i-x_j)</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">P_i = \prod\limits_{j \neq i} (x_i-x_j)</span><script type="math/tex">P_i = \prod\limits_{j \neq i} (x_i-x_j)</script></span></script></span></p>
<p>But if you consider the derivative <span><span class="MathJax_Preview">P'(x)</span><script type="math/tex">P'(x)</script></span> you'll find out that <span><span class="MathJax_Preview">P'(x_i) = P_i</span><script type="math/tex">P'(x_i) = P_i</script></span>. Thus you can compute <span><span class="MathJax_Preview">P_i</span><script type="math/tex">P_i</script></span>'s via evaluation in <span><span class="MathJax_Preview">O(n \log^2 n)</span><script type="math/tex">O(n \log^2 n)</script></span>.</p>
<p>Now consider the recursive algorithm done on same segment tree as in the multi-point evaluation. It starts in the leaves with the value <span><span class="MathJax_Preview">\dfrac{y_i}{P_i}</span><script type="math/tex">\dfrac{y_i}{P_i}</script></span> in each leaf.</p>
<p>When we return from the recursion we should merge the results from the left and the right vertices as <span><span class="MathJax_Preview">A_{l,r} = A_{l,m}P_{m,r} + P_{l,m} A_{m,r}</span><script type="math/tex">A_{l,r} = A_{l,m}P_{m,r} + P_{l,m} A_{m,r}</script></span>.</p>
<p>In this way when you return back to the root you'll have exactly <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> in it.
The total procedure also works in <span><span class="MathJax_Preview">O(n \log^2 n)</span><script type="math/tex">O(n \log^2 n)</script></span>.</p>
<h2 id="gcd-and-resultants">GCD and Resultants</h2>
<p>Assume you're given polynomials <span><span class="MathJax_Preview">A(x) = a_0 + a_1 x + \dots + a_n x^n</span><script type="math/tex">A(x) = a_0 + a_1 x + \dots + a_n x^n</script></span> and <span><span class="MathJax_Preview">B(x) = b_0 + b_1 x + \dots + b_m x^m</span><script type="math/tex">B(x) = b_0 + b_1 x + \dots + b_m x^m</script></span>.</p>
<p>Let <span><span class="MathJax_Preview">\lambda_0, \dots, \lambda_n</span><script type="math/tex">\lambda_0, \dots, \lambda_n</script></span> be the roots of <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> and let <span><span class="MathJax_Preview">\mu_0, \dots, \mu_m</span><script type="math/tex">\mu_0, \dots, \mu_m</script></span> be the roots of <span><span class="MathJax_Preview">B(x)</span><script type="math/tex">B(x)</script></span> counted with their multiplicities.</p>
<p>You want to know if <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> and <span><span class="MathJax_Preview">B(x)</span><script type="math/tex">B(x)</script></span> have any roots in common. There are two interconnected ways to do that.</p>
<h3 id="euclidean-algorithm">Euclidean algorithm</h3>
<p>Well, we already have an <a href="/docs/#Algorithms/Algebra/GCD_Euclidean_Algorithm/">article</a> about it. For an arbitrary euclidean domain you can write the Euclidean algorithm as easy as:</p>
<pre><code class="cpp">template&lt;typename T&gt;
T gcd(const T &amp;a, const T &amp;b) {
    return b == T(0) ? a : gcd(b, a % b);
}
</code></pre>

<p>It can be proven that for polynomials <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> and <span><span class="MathJax_Preview">B(x)</span><script type="math/tex">B(x)</script></span> it will work in <span><span class="MathJax_Preview">O(nm)</span><script type="math/tex">O(nm)</script></span>.</p>
<h3 id="resultant">Resultant</h3>
<p>Let's calculate the product <span><span class="MathJax_Preview">A(\mu_0)\cdots A(\mu_m)</span><script type="math/tex">A(\mu_0)\cdots A(\mu_m)</script></span>. It will be equal to zero if and only if some <span><span class="MathJax_Preview">\mu_i</span><script type="math/tex">\mu_i</script></span> is the root of <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span>.</p>
<p>For symmetry we can also multiply it with <span><span class="MathJax_Preview">b_m^n</span><script type="math/tex">b_m^n</script></span> and rewrite the whole product in the following form:
<span><span class="MathJax_Preview"><span><span class="MathJax_Preview">\boxed{\mathcal{R}(A, B) = b_m^n\prod\limits_{j=0}^m A(\mu_j) = b_m^n a_m^n \prod\limits_{i=0}^n \prod\limits_{j=0}^m (\mu_j - \lambda_i)= (-1)^{mn}a_n^m \prod\limits_{i=0}^n B(\lambda_i)}</span><script type="math/tex">\boxed{\mathcal{R}(A, B) = b_m^n\prod\limits_{j=0}^m A(\mu_j) = b_m^n a_m^n \prod\limits_{i=0}^n \prod\limits_{j=0}^m (\mu_j - \lambda_i)= (-1)^{mn}a_n^m \prod\limits_{i=0}^n B(\lambda_i)}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">\boxed{\mathcal{R}(A, B) = b_m^n\prod\limits_{j=0}^m A(\mu_j) = b_m^n a_m^n \prod\limits_{i=0}^n \prod\limits_{j=0}^m (\mu_j - \lambda_i)= (-1)^{mn}a_n^m \prod\limits_{i=0}^n B(\lambda_i)}</span><script type="math/tex">\boxed{\mathcal{R}(A, B) = b_m^n\prod\limits_{j=0}^m A(\mu_j) = b_m^n a_m^n \prod\limits_{i=0}^n \prod\limits_{j=0}^m (\mu_j - \lambda_i)= (-1)^{mn}a_n^m \prod\limits_{i=0}^n B(\lambda_i)}</script></span></script></span></p>
<p>The value defined above is called the resultant of the polynomials <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> and <span><span class="MathJax_Preview">B(x)</span><script type="math/tex">B(x)</script></span>. From the definition you may find the following properties:</p>
<ol>
<li><span><span class="MathJax_Preview">\mathcal R(A, B) = (-1)^{nm} \mathcal R(B, A)</span><script type="math/tex">\mathcal R(A, B) = (-1)^{nm} \mathcal R(B, A)</script></span>.</li>
<li><span><span class="MathJax_Preview">\mathcal R(A, B)= a_n^m b_m^n</span><script type="math/tex">\mathcal R(A, B)= a_n^m b_m^n</script></span> when <span><span class="MathJax_Preview">n=0</span><script type="math/tex">n=0</script></span> or <span><span class="MathJax_Preview">m=0</span><script type="math/tex">m=0</script></span>.</li>
<li>If <span><span class="MathJax_Preview">b_m=1</span><script type="math/tex">b_m=1</script></span> then <span><span class="MathJax_Preview">\mathcal R(A - CB, B) = \mathcal R(A, B)</span><script type="math/tex">\mathcal R(A - CB, B) = \mathcal R(A, B)</script></span> for an arbitrary polynomial <span><span class="MathJax_Preview">C(x)</span><script type="math/tex">C(x)</script></span> and <span><span class="MathJax_Preview">n,m \geq 1</span><script type="math/tex">n,m \geq 1</script></span>.</li>
<li>From this follows <span><span class="MathJax_Preview">\mathcal R(A, B) = b_m^{\deg(A) - \deg(A-CB)}\mathcal R(A - CB, B)</span><script type="math/tex">\mathcal R(A, B) = b_m^{\deg(A) - \deg(A-CB)}\mathcal R(A - CB, B)</script></span> for arbitrary <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span>, <span><span class="MathJax_Preview">B(x)</span><script type="math/tex">B(x)</script></span>, <span><span class="MathJax_Preview">C(x)</span><script type="math/tex">C(x)</script></span>.</li>
</ol>
<p>Miraculously it means that resultant of two polynomials is actually always from the same ring as their coefficients!</p>
<p>Also these properties allow us to calculate the resultant alongside the Euclidean algorithm, which works in <span><span class="MathJax_Preview">O(nm)</span><script type="math/tex">O(nm)</script></span>.</p>
<pre><code class="cpp">template&lt;typename T&gt;
T resultant(poly&lt;T&gt; a, poly&lt;T&gt; b) {
    if(b.is_zero()) {
        return 0;
    } else if(b.deg() == 0) {
        return bpow(b.lead(), a.deg());
    } else {
        int pw = a.deg();
        a %= b;
        pw -= a.deg();
        base mul = bpow(b.lead(), pw) * base((b.deg() &amp; a.deg() &amp; 1) ? -1 : 1);
        base ans = resultant(b, a);
        return ans * mul;
    }
}
</code></pre>

<h3 id="half-gcd-algorithm">Half-GCD algorithm</h3>
<p>There is a way to calculate the GCD and resultants in <span><span class="MathJax_Preview">O(n \log^2 n)</span><script type="math/tex">O(n \log^2 n)</script></span>. To do this you should note that if you consider <span><span class="MathJax_Preview">a(x) = a_0 + x^k a_1</span><script type="math/tex">a(x) = a_0 + x^k a_1</script></span> and <span><span class="MathJax_Preview">b(x) = b_0 + x^k b_1</span><script type="math/tex">b(x) = b_0 + x^k b_1</script></span> where <span><span class="MathJax_Preview">k=\min(\deg a, \deg b)/2</span><script type="math/tex">k=\min(\deg a, \deg b)/2</script></span> then basically the first few operations of Euclidean algorithm on <span><span class="MathJax_Preview">a(x)</span><script type="math/tex">a(x)</script></span> and <span><span class="MathJax_Preview">b(x)</span><script type="math/tex">b(x)</script></span> are defined by the Euclidean algorithm on <span><span class="MathJax_Preview">a_1(x)</span><script type="math/tex">a_1(x)</script></span> and <span><span class="MathJax_Preview">b_1(x)</span><script type="math/tex">b_1(x)</script></span> for which you may also calculate GCD recursively and then somehow memorize linear transforms you made with them and apply it to <span><span class="MathJax_Preview">a(x)</span><script type="math/tex">a(x)</script></span> and <span><span class="MathJax_Preview">b(x)</span><script type="math/tex">b(x)</script></span> to lower the degrees of polynomials. Implementation of this algorithm seems pretty tedious and technical thus it's not considered in this article yet.</p>
<h2 id="problems">Problems</h2>
<ul>
<li><a href="https://www.codechef.com/problems/RNG">CodeChef - RNG</a></li>
<li><a href="https://codeforces.com/gym/102129/problem/D">CodeForces - Basis Change</a></li>
<li><a href="https://codeforces.com/gym/102129/problem/G">CodeForces - Permutant</a></li>
<li><a href="https://codeforces.com/gym/102129/problem/C">CodeForces - Medium Hadron Collider</a></li>
</ul>

  <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://d-k-ivanov.github.io/">Main site</a>
      </p><p>Copyright &copy; 2016-2020 Dmitriy Ivanov. <script type="text/javascript"> (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)}; m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)}) (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym"); ym(40819844, "init", { clickmap:true, trackLinks:true, accurateTrackBounce:true }); </script> <noscript><div><img src="https://mc.yandex.ru/watch/40819844" style="position:absolute; left:-9999px;" alt="" /></div></noscript></p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>