<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="Dmitry Ivanov">
    <link rel="canonical" href="https://d-k-ivanov.github.io/docs/Algorithms/Combinatorics/Inclusion-Exclusion_Principle/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Inclusion-Exclusion Principle - Technical Info</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <link href="../../../css/extra.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Inclusion-Exclusion Principle", url: "#_top", children: [
              {title: "Statement", url: "#statement" },
              {title: "Proof", url: "#proof" },
              {title: "Generalization for calculating number of elements in exactly rr sets", url: "#generalization-for-calculating-number-of-elements-in-exactly-rr-sets" },
              {title: "Usage when solving problems", url: "#usage-when-solving-problems" },
              {title: "Practice Problems", url: "#practice-problems" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../mathjax-config.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-80208201-1', 'd-k-ivanov.github.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../Stars_and_Bars/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../Stars_and_Bars/" class="btn btn-xs btn-link">
        Stars and Bars
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../Generating_Combinations/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../Generating_Combinations/" class="btn btn-xs btn-link">
        Generating Combinations
      </a>
    </div>
    
  </div>

    

    <h1 id="inclusion-exclusion-principle">Inclusion-Exclusion Principle</h1>
<p>The inclusion-exclusion principle is an important combinatorial way to compute the size of a set or the probability of complex events. It relates the sizes of individual sets with their union.</p>
<h2 id="statement">Statement</h2>
<h3 id="the-verbal-formula">The verbal formula</h3>
<p>The inclusion-exclusion principle can be expressed as follows:</p>
<p>To compute the size of a union of multiple sets, it is necessary to sum the sizes of these sets <strong>separately</strong>, and then subtract the sizes of all <strong>pairwise</strong> intersections of the sets, then add back the size of the intersections of <strong>triples</strong> of the sets, subtract the size of <strong>quadruples</strong> of the sets, and so on, up to the intersection of <strong>all</strong> sets.</p>
<h3 id="the-formulation-in-terms-of-sets">The formulation in terms of sets</h3>
<p>The above definition can be expressed mathematically as follows:</p>
<div>
<div class="MathJax_Preview">\left| \bigcup_{i=1}^n A_i \right| = \sum_{i=1}^n|A_i| - \sum_{1\leq i&lt;j\leq n} |A_i \cap A_j| + \sum _{1\leq i&lt;j&lt;k\leq n}|A_i \cap A_j \cap A_k| - \cdots + (-1)^{n-1} | A_1 \cap \cdots \cap A_n |</div>
<script type="math/tex; mode=display">\left| \bigcup_{i=1}^n A_i \right| = \sum_{i=1}^n|A_i| - \sum_{1\leq i<j\leq n} |A_i \cap A_j| + \sum _{1\leq i<j<k\leq n}|A_i \cap A_j \cap A_k| - \cdots + (-1)^{n-1} | A_1 \cap \cdots \cap A_n |</script>
</div>
<p>And in a more compact way:</p>
<div>
<div class="MathJax_Preview">\left|\bigcup_{i=1}^n A_i \right| = \sum_{\emptyset \neq J\subseteq \\{1,2,\ldots ,n\\}} (-1)^{|J|-1}{\Biggl |}\bigcap_{j\in J}A_{j}{\Biggr |}</div>
<script type="math/tex; mode=display">\left|\bigcup_{i=1}^n A_i \right| = \sum_{\emptyset \neq J\subseteq \\{1,2,\ldots ,n\\}} (-1)^{|J|-1}{\Biggl |}\bigcap_{j\in J}A_{j}{\Biggr |}</script>
</div>
<h3 id="the-formulation-using-venn-diagrams">The formulation using Venn diagrams</h3>
<p>Let the diagram show three sets <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span>, <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span> and <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>:</p>
<p><img alt="Venn diagram" src="/docs/data/cs/venn-inclusion-exclusion.png" title="Venn diagram" /></p>
<p>Then the area of their union <span><span class="MathJax_Preview">A \cup B \cup C</span><script type="math/tex">A \cup B \cup C</script></span> is equal to the sum of the areas <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span>, <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span> and <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span> less double-covered areas <span><span class="MathJax_Preview">A \cap B</span><script type="math/tex">A \cap B</script></span>, <span><span class="MathJax_Preview">A \cap C</span><script type="math/tex">A \cap C</script></span>, <span><span class="MathJax_Preview">B \cap C</span><script type="math/tex">B \cap C</script></span>, but with the addition of the area covered by three sets <span><span class="MathJax_Preview">A \cap B \cap C</span><script type="math/tex">A \cap B \cap C</script></span>:</p>
<div>
<div class="MathJax_Preview">S(A \cup B \cup C) = S(A) + S(B) + S(C) - S(A \cap B) - S(A \cap C) - S(B \cap C) + S(A \cap B \cap C)</div>
<script type="math/tex; mode=display">S(A \cup B \cup C) = S(A) + S(B) + S(C) - S(A \cap B) - S(A \cap C) - S(B \cap C) + S(A \cap B \cap C)</script>
</div>
<p>It can also be generalized for an association of <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> sets.</p>
<h3 id="the-formulation-in-terms-of-probability-theory">The formulation in terms of probability theory</h3>
<p>If <span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span> <span><span class="MathJax_Preview">(i = 1,2...n)</span><script type="math/tex">(i = 1,2...n)</script></span> are events and <span><span class="MathJax_Preview">{\cal P}(A_i)</span><script type="math/tex">{\cal P}(A_i)</script></span> the probability of an event from <span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span> to occur, then the probability of their union (i.e. the probability that at least one of the events occur) is equal to:</p>
<div>
<div class="MathJax_Preview">\begin{eqnarray}
{\cal P} \left( \bigcup_{i=1}^n A_i \right) &amp;=&amp; \sum_{i=1}^n{\cal P}(A_i)\ - \sum_{1\leq i&lt;j\leq n} {\cal P}(A_i \cap A_j)\  + \\\\\\
&amp;+&amp; \sum _{1\leq i&lt;j&lt;k\leq n}{\cal P}(A_i \cap A_j \cap A_k) - \cdots + (-1)^{n-1} {\cal P}( A_1 \cap \cdots \cap A_n )
\end{eqnarray}</div>
<script type="math/tex; mode=display">\begin{eqnarray}
{\cal P} \left( \bigcup_{i=1}^n A_i \right) &=& \sum_{i=1}^n{\cal P}(A_i)\ - \sum_{1\leq i<j\leq n} {\cal P}(A_i \cap A_j)\  + \\\\\\
&+& \sum _{1\leq i<j<k\leq n}{\cal P}(A_i \cap A_j \cap A_k) - \cdots + (-1)^{n-1} {\cal P}( A_1 \cap \cdots \cap A_n )
\end{eqnarray}</script>
</div>
<p>And in a more compact way:</p>
<div>
<div class="MathJax_Preview">{\cal P} \left(\bigcup_{i=1}^n A_i \right) = \sum_{\emptyset \neq J\subseteq \\{1,2,\ldots ,n\\}} (-1)^{|J|-1}\ {\cal P}{\Biggl (}\bigcap_{j\in J}A_{j}{\Biggr )}</div>
<script type="math/tex; mode=display">{\cal P} \left(\bigcup_{i=1}^n A_i \right) = \sum_{\emptyset \neq J\subseteq \\{1,2,\ldots ,n\\}} (-1)^{|J|-1}\ {\cal P}{\Biggl (}\bigcap_{j\in J}A_{j}{\Biggr )}</script>
</div>
<h2 id="proof">Proof</h2>
<p>For the proof it is convenient to use the mathematical formulation in terms of set theory:</p>
<div>
<div class="MathJax_Preview">\left|\bigcup_{i=1}^n A_i \right| = \sum_{\emptyset \neq J\subseteq \\{1,2,\ldots ,n\\}} (-1)^{|J|-1}{\Biggl |}\bigcap_{j\in J}A_{j}{\Biggr |}</div>
<script type="math/tex; mode=display">\left|\bigcup_{i=1}^n A_i \right| = \sum_{\emptyset \neq J\subseteq \\{1,2,\ldots ,n\\}} (-1)^{|J|-1}{\Biggl |}\bigcap_{j\in J}A_{j}{\Biggr |}</script>
</div>
<p>We want to prove that any element contained in at least one of the sets <span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span> will occur in the formula only once (note that elements which are not present in any of the sets <span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span> will never be considered on the right part of the formula).</p>
<p>Consider an element <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> occurring in <span><span class="MathJax_Preview">k \geq 1</span><script type="math/tex">k \geq 1</script></span> sets <span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span>. We will show it is counted only once in the formula. Note that:</p>
<ul>
<li>in terms which <span><span class="MathJax_Preview">|J| = 1</span><script type="math/tex">|J| = 1</script></span>, the item <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> will be counted <strong><span><span class="MathJax_Preview">+\ k</span><script type="math/tex">+\ k</script></span></strong> times;</li>
<li>in terms which <span><span class="MathJax_Preview">|J| = 2</span><script type="math/tex">|J| = 2</script></span>, the item <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> will be counted <strong><span><span class="MathJax_Preview">-\ \binom{k}{2}</span><script type="math/tex">-\ \binom{k}{2}</script></span></strong> times - because it will be counted in those terms that include two of the <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> sets containing <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>;</li>
<li>in terms which <span><span class="MathJax_Preview">|J| = 3</span><script type="math/tex">|J| = 3</script></span>, the item <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> will be counted <strong><span><span class="MathJax_Preview">+\ \binom{k}{3}</span><script type="math/tex">+\ \binom{k}{3}</script></span></strong> times;</li>
<li><span><span class="MathJax_Preview">\cdots</span><script type="math/tex">\cdots</script></span></li>
<li>in terms which <span><span class="MathJax_Preview">|J| = k</span><script type="math/tex">|J| = k</script></span>, the item <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> will be counted <strong><span><span class="MathJax_Preview">(-1)^{k-1}\cdot \binom{k}{k}</span><script type="math/tex">(-1)^{k-1}\cdot \binom{k}{k}</script></span></strong> times;</li>
<li>in terms which <span><span class="MathJax_Preview">|J| \gt k</span><script type="math/tex">|J| \gt k</script></span>, the item <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> will be counted <strong>zero</strong> times;</li>
</ul>
<p>This leads us to the following sum of <a href="/docs/#Algorithms/Combinatorics/Binomial_Coefficients/">binomial coefficients</a>:</p>
<div>
<div class="MathJax_Preview"> T = \binom{k}{1} - \binom{k}{2} + \binom{k}{3} - \cdots + (-1)^{i-1}\cdot \binom{k}{i} + \cdots + (-1)^{k-1}\cdot \binom{k}{k}</div>
<script type="math/tex; mode=display"> T = \binom{k}{1} - \binom{k}{2} + \binom{k}{3} - \cdots + (-1)^{i-1}\cdot \binom{k}{i} + \cdots + (-1)^{k-1}\cdot \binom{k}{k}</script>
</div>
<p>This expression is very similar to the binomial expansion of <span><span class="MathJax_Preview">(1 - x)^k</span><script type="math/tex">(1 - x)^k</script></span>:</p>
<div>
<div class="MathJax_Preview"> (1 - x)^k = \binom{k}{0} - \binom{k}{1} \cdot x + \binom{k}{2} \cdot x^2 - \binom{k}{3} \cdot x^3 + \cdots + (-1)^k\cdot \binom{k}{k} \cdot x^k </div>
<script type="math/tex; mode=display"> (1 - x)^k = \binom{k}{0} - \binom{k}{1} \cdot x + \binom{k}{2} \cdot x^2 - \binom{k}{3} \cdot x^3 + \cdots + (-1)^k\cdot \binom{k}{k} \cdot x^k </script>
</div>
<p>When <span><span class="MathJax_Preview">x = 1</span><script type="math/tex">x = 1</script></span>, <span><span class="MathJax_Preview">(1 - x)^k</span><script type="math/tex">(1 - x)^k</script></span> looks a lot like <span><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>. However, the expression has an additional <span><span class="MathJax_Preview">\binom{k}{0} = 1</span><script type="math/tex">\binom{k}{0} = 1</script></span>, and it is multiplied by <span><span class="MathJax_Preview">-1</span><script type="math/tex">-1</script></span>. That leads us to <span><span class="MathJax_Preview">(1 - 1)^k = 1 - T</span><script type="math/tex">(1 - 1)^k = 1 - T</script></span>. Therefore <span><span class="MathJax_Preview">T = 1 - (1 - 1)^k = 1</span><script type="math/tex">T = 1 - (1 - 1)^k = 1</script></span>, what was required to prove. The element is counted only once.</p>
<h2 id="generalization-for-calculating-number-of-elements-in-exactly-rr-sets">Generalization for calculating number of elements in exactly <span><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> sets</h2>
<p>Inclusion-exclusion principle can be rewritten to calculate number of elements which are present in zero sets:</p>
<div>
<div class="MathJax_Preview">\left|\bigcap_{i=1}^n \overline{A_i}\right|=\sum_{m=0}^n (-1)^m \sum_{|X|=m} \left|\bigcap_{i\in X} A_{i}\right|</div>
<script type="math/tex; mode=display">\left|\bigcap_{i=1}^n \overline{A_i}\right|=\sum_{m=0}^n (-1)^m \sum_{|X|=m} \left|\bigcap_{i\in X} A_{i}\right|</script>
</div>
<p>Consider its generalization to calculate number of elements which are present in exactly <span><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> sets:</p>
<div>
<div class="MathJax_Preview">\left|\bigcup_{|B|=r}\left[\bigcap_{i \in B} A_i \cap \bigcap_{j \not\in B} \overline{A_j}\right]\right|=\sum_{m=r}^n (-1)^{m-r}\dbinom{m}{r} \sum_{|X|=m} \left|\bigcap_{i \in X} A_{i}\right|</div>
<script type="math/tex; mode=display">\left|\bigcup_{|B|=r}\left[\bigcap_{i \in B} A_i \cap \bigcap_{j \not\in B} \overline{A_j}\right]\right|=\sum_{m=r}^n (-1)^{m-r}\dbinom{m}{r} \sum_{|X|=m} \left|\bigcap_{i \in X} A_{i}\right|</script>
</div>
<p>To prove this formula, consider some particular <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>. Due to basic inclusion-exclusion principle we can say about it that:</p>
<div>
<div class="MathJax_Preview">\left|\bigcap_{i \in B} A_i \cap \bigcap_{j \not \in B} \overline{A_j}\right|=\sum_{m=r}^{n} (-1)^{m-r} \sum_{\substack{|X|=m \newline B \subset X}}\left|\bigcap_{i\in X} A_{i}\right|</div>
<script type="math/tex; mode=display">\left|\bigcap_{i \in B} A_i \cap \bigcap_{j \not \in B} \overline{A_j}\right|=\sum_{m=r}^{n} (-1)^{m-r} \sum_{\substack{|X|=m \newline B \subset X}}\left|\bigcap_{i\in X} A_{i}\right|</script>
</div>
<p>The sets on the left side do not intersect for different <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>, thus we can sum them up directly. Also one should note that any set <span><span class="MathJax_Preview">X</span><script type="math/tex">X</script></span> will always have coefficient <span><span class="MathJax_Preview">(-1)^{m-r}</span><script type="math/tex">(-1)^{m-r}</script></span> if it occurs and it will occur for exactly <span><span class="MathJax_Preview">\dbinom{m}{r}</span><script type="math/tex">\dbinom{m}{r}</script></span> sets <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>.</p>
<h2 id="usage-when-solving-problems">Usage when solving problems</h2>
<p>The inclusion-exclusion principle is hard to understand without studying its applications.</p>
<p>First, we will look at three simplest tasks "at paper", illustrating applications of the principle, and then consider more practical problems which are difficult to solve without inclusion-exclusion principle.</p>
<p>Tasks asking to "find the <strong>number</strong> of ways" are worth of note, as they sometimes lead to polynomial solutions, not necessarily exponential.</p>
<h3 id="a-simple-task-on-permutations">A simple task on permutations</h3>
<p>Task: count how many permutations of numbers from <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span> to <span><span class="MathJax_Preview">9</span><script type="math/tex">9</script></span> exist such that the first element is greater than <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> and the last one is less than <span><span class="MathJax_Preview">8</span><script type="math/tex">8</script></span>.</p>
<p>Let's count the number of "bad" permutations, that is, permutations in which the first element is <span><span class="MathJax_Preview">\leq 1</span><script type="math/tex">\leq 1</script></span> and/or the last is <span><span class="MathJax_Preview">\geq 8</span><script type="math/tex">\geq 8</script></span>.</p>
<p>We will denote by <span><span class="MathJax_Preview">X</span><script type="math/tex">X</script></span> the set of permutations in which the first element is <span><span class="MathJax_Preview">\leq 1</span><script type="math/tex">\leq 1</script></span> and <span><span class="MathJax_Preview">Y</span><script type="math/tex">Y</script></span> the set of permutations in which the last element is <span><span class="MathJax_Preview">\geq 8</span><script type="math/tex">\geq 8</script></span>. Then the number of "bad" permutations, as on the inclusion-exclusion formula, will be:</p>
<div>
<div class="MathJax_Preview"> |X \cup Y| = |X| + |Y| - |X \cap Y| </div>
<script type="math/tex; mode=display"> |X \cup Y| = |X| + |Y| - |X \cap Y| </script>
</div>
<p>After a simple combinatorial calculation, we will get to:</p>
<div>
<div class="MathJax_Preview"> 2 \cdot 9! + 2 \cdot 9! - 2 \cdot 2 \cdot 8! </div>
<script type="math/tex; mode=display"> 2 \cdot 9! + 2 \cdot 9! - 2 \cdot 2 \cdot 8! </script>
</div>
<p>The only thing left is to subtract this number from the total of <span><span class="MathJax_Preview">10!</span><script type="math/tex">10!</script></span> to get the number of "good" permutations.</p>
<h3 id="a-simple-task-on-0-1-2-sequences">A simple task on (0, 1, 2) sequences</h3>
<p>Task: count how many sequences of length <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> exist consisting only of numbers <span><span class="MathJax_Preview">0,1,2</span><script type="math/tex">0,1,2</script></span> such that each number occurs <strong>at least once</strong>.</p>
<p>Again let us turn to the inverse problem, i.e. we calculate the number of sequences which do <strong>not</strong> contain <strong>at least one</strong> of the numbers.</p>
<p>Let's denote by <span><span class="MathJax_Preview">A_i (i = 0,1,2)</span><script type="math/tex">A_i (i = 0,1,2)</script></span> the set of sequences in which the digit <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> does <strong>not</strong> occur.
The formula of inclusion-exclusion on the number of "bad" sequences will be:</p>
<div>
<div class="MathJax_Preview"> |A_0 \cup A_1 \cup A_2| = |A_0| + |A_1| + |A_2| - |A_0 \cap A_1| - |A_0 \cap A_2| - |A_1 \cap A_2| + |A_0 \cap A_1 \cap A_2| </div>
<script type="math/tex; mode=display"> |A_0 \cup A_1 \cup A_2| = |A_0| + |A_1| + |A_2| - |A_0 \cap A_1| - |A_0 \cap A_2| - |A_1 \cap A_2| + |A_0 \cap A_1 \cap A_2| </script>
</div>
<ul>
<li>The size of each <span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span> is <span><span class="MathJax_Preview">2^n</span><script type="math/tex">2^n</script></span>, as each sequence can only contain two of the digits.</li>
<li>The size of each pairwise intersection <span><span class="MathJax_Preview">A_i \cap A_j</span><script type="math/tex">A_i \cap A_j</script></span>  is equal to <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>, as there will be only one digit to build the sequence.</li>
<li>The size of the intersection of all three sets is equal to <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>, as there will be no digits to build the sequence.</li>
</ul>
<p>As we solved the inverse problem, we subtract it from the total of <span><span class="MathJax_Preview">3^n</span><script type="math/tex">3^n</script></span> sequences:</p>
<div>
<div class="MathJax_Preview">3^n - (3 \cdot 2^n - 3 \cdot 1 + 0)</div>
<script type="math/tex; mode=display">3^n - (3 \cdot 2^n - 3 \cdot 1 + 0)</script>
</div>
<h3 id="the-number-of-integer-solutions-to-the-equation">The number of integer solutions to the equation</h3>
<p>Consider the following equation:
<span><span class="MathJax_Preview"><span><span class="MathJax_Preview">x_1 + x_2 + x_3 + x_4 + x_5 + x_6 = 20</span><script type="math/tex">x_1 + x_2 + x_3 + x_4 + x_5 + x_6 = 20</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">x_1 + x_2 + x_3 + x_4 + x_5 + x_6 = 20</span><script type="math/tex">x_1 + x_2 + x_3 + x_4 + x_5 + x_6 = 20</script></span></script></span>
where <span><span class="MathJax_Preview">0 \le x_i \le 8 (i = 1,2,\ldots 6)</span><script type="math/tex">0 \le x_i \le 8 (i = 1,2,\ldots 6)</script></span>.</p>
<p>Task: count the number of solutions to the equation.</p>
<p>Forget the restriction on <span><span class="MathJax_Preview">x_i</span><script type="math/tex">x_i</script></span> for a moment and just count the number of nonnegative solutions to this equation. This is easily done using <a href="/docs/#Algorithms/Combinatorics/Binomial_Coefficients/">binomial coefficients</a>: we want to break a sequence of <span><span class="MathJax_Preview">20</span><script type="math/tex">20</script></span> units into <span><span class="MathJax_Preview">6</span><script type="math/tex">6</script></span> groups, which is the same as distributing <span><span class="MathJax_Preview">5</span><script type="math/tex">5</script></span> "walls" over <span><span class="MathJax_Preview">25</span><script type="math/tex">25</script></span> slots:</p>
<div>
<div class="MathJax_Preview">N_0 = \binom{25}{5}</div>
<script type="math/tex; mode=display">N_0 = \binom{25}{5}</script>
</div>
<p>We will now calculate the number of "bad" solutions with the inclusion-exclusion principle. The "bad" solutions will be those in which one or more <span><span class="MathJax_Preview">x_i</span><script type="math/tex">x_i</script></span> are greater than <span><span class="MathJax_Preview">9</span><script type="math/tex">9</script></span>.</p>
<p>Denote by <span><span class="MathJax_Preview">A_k (k = 1,2\ldots 6)</span><script type="math/tex">A_k (k = 1,2\ldots 6)</script></span> the set of solutions where <span><span class="MathJax_Preview">x_k \ge 9</span><script type="math/tex">x_k \ge 9</script></span>, and all other <span><span class="MathJax_Preview">x_i \ge 0 (i \ne k)</span><script type="math/tex">x_i \ge 0 (i \ne k)</script></span> (they may be <span><span class="MathJax_Preview">\ge 9</span><script type="math/tex">\ge 9</script></span> or not). To calculate the size of <span><span class="MathJax_Preview">A_k</span><script type="math/tex">A_k</script></span>, note that we have essentially the same combinatorial problem that was solved in the two paragraphs above, but now <span><span class="MathJax_Preview">9</span><script type="math/tex">9</script></span> of the units are excluded from the slots and definitely belong to the first group. Thus:</p>
<div>
<div class="MathJax_Preview"> | A_k | = \binom{16}{5} </div>
<script type="math/tex; mode=display"> | A_k | = \binom{16}{5} </script>
</div>
<p>Similarly, the size of the intersection between sets <span><span class="MathJax_Preview">A_k</span><script type="math/tex">A_k</script></span> and <span><span class="MathJax_Preview">A_p</span><script type="math/tex">A_p</script></span> is equal to:</p>
<div>
<div class="MathJax_Preview"> \left| A_k \cap A_p \right| = \binom{7}{5}</div>
<script type="math/tex; mode=display"> \left| A_k \cap A_p \right| = \binom{7}{5}</script>
</div>
<p>The size of each intersection of three sets is zero, since <span><span class="MathJax_Preview">20</span><script type="math/tex">20</script></span> units will not be enough for three or more variables greater than or equal to <span><span class="MathJax_Preview">9</span><script type="math/tex">9</script></span>.</p>
<p>Combining all this into the formula of inclusions-exceptions and given that we solved the inverse problem, we finally get the answer:</p>
<div>
<div class="MathJax_Preview">\binom{25}{5} - \left(\binom{6}{1} \cdot \binom{16}{5} - \binom{6}{2} \cdot \binom{7}{5}\right) </div>
<script type="math/tex; mode=display">\binom{25}{5} - \left(\binom{6}{1} \cdot \binom{16}{5} - \binom{6}{2} \cdot \binom{7}{5}\right) </script>
</div>
<h3 id="the-number-of-relative-primes-in-a-given-interval">The number of relative primes in a given interval</h3>
<p>Task: given two numbers <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> and <span><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span>, count the number of integers in the interval <span><span class="MathJax_Preview">[1;r]</span><script type="math/tex">[1;r]</script></span> that are relatively prime to n (their greatest common divisor is <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>).</p>
<p>Let's solve the inverse problem - compute the number of not mutually primes with <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>.</p>
<p>We will denote the prime factors of <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> as <span><span class="MathJax_Preview">p_i (i = 1\cdots k)</span><script type="math/tex">p_i (i = 1\cdots k)</script></span>.</p>
<p>How many numbers in the interval <span><span class="MathJax_Preview">[1;r]</span><script type="math/tex">[1;r]</script></span> are divisible by <span><span class="MathJax_Preview">p_i</span><script type="math/tex">p_i</script></span>? The answer to this question is:</p>
<div>
<div class="MathJax_Preview"> \left\lfloor \frac{ r }{ p_i } \right\rfloor </div>
<script type="math/tex; mode=display"> \left\lfloor \frac{ r }{ p_i } \right\rfloor </script>
</div>
<p>However, if we simply sum these numbers, some numbers will be summarized several times (those that share multiple <span><span class="MathJax_Preview">p_i</span><script type="math/tex">p_i</script></span> as their factors). Therefore, it is necessary to use the inclusion-exclusion principle.</p>
<p>We will iterate over all <span><span class="MathJax_Preview">2^k</span><script type="math/tex">2^k</script></span> subsets of <span><span class="MathJax_Preview">p_i</span><script type="math/tex">p_i</script></span>s, calculate their product and add or subtract the number of multiples of their product.</p>
<p>Here is a C++ implementation:</p>
<pre><code class="cpp">int solve (int n, int r) {
    vector&lt;int&gt; p;
    for (int i=2; i*i&lt;=n; ++i)
        if (n % i == 0) {
            p.push_back (i);
            while (n % i == 0)
                n /= i;
        }
    if (n &gt; 1)
        p.push_back (n);

    int sum = 0;
    for (int msk=1; msk&lt;(1&lt;&lt;p.size()); ++msk) {
        int mult = 1,
            bits = 0;
        for (int i=0; i&lt;(int)p.size(); ++i)
            if (msk &amp; (1&lt;&lt;i)) {
                ++bits;
                mult *= p[i];
            }

        int cur = r / mult;
        if (bits % 2 == 1)
            sum += cur;
        else
            sum -= cur;
    }

    return r - sum;
}
</code></pre>

<p>Asymptotics of the solution is <span><span class="MathJax_Preview">O (\sqrt{n})</span><script type="math/tex">O (\sqrt{n})</script></span>.</p>
<h3 id="the-number-of-integers-in-a-given-interval-which-are-multiple-of-at-least-one-of-the-given-numbers">The number of integers in a given interval which are multiple of at least one of the given numbers</h3>
<p>Given <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> numbers <span><span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script></span> and number <span><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span>. You want to count the number of integers in the interval <span><span class="MathJax_Preview">[1; r]</span><script type="math/tex">[1; r]</script></span> that are multiple of at least one of the <span><span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script></span>.</p>
<p>The solution algorithm is almost identical to the one for previous task — construct the formula of inclusion-exclusion on the numbers <span><span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script></span>, i.e. each term in this formula is the number of numbers divisible by a given subset of numbers <span><span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script></span> (in other words, divisible by their <a href="/docs/#Algorithms/Algebra/GCD_Euclidean_Algorithm/">least common multiple</a>).</p>
<p>So we will now iterate over all <span><span class="MathJax_Preview">2^n</span><script type="math/tex">2^n</script></span> subsets of integers <span><span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script></span> with <span><span class="MathJax_Preview">O(n \log r)</span><script type="math/tex">O(n \log r)</script></span> operations to find their least common multiple, adding or subtracting the number of multiples of it in the interval. Asymptotics is <span><span class="MathJax_Preview">O (2^n\cdot n\cdot \log r)</span><script type="math/tex">O (2^n\cdot n\cdot \log r)</script></span>.</p>
<h3 id="the-number-of-strings-that-satisfy-a-given-pattern">The number of strings that satisfy a given pattern</h3>
<p>Consider <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> patterns of strings of the same length, consisting only of letters (<span><span class="MathJax_Preview">a...z</span><script type="math/tex">a...z</script></span>) or question marks. You're also given a number <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>. A string matches a pattern if it has the same length as the pattern, and at each position, either the corresponding characters are equal or the character in the pattern is a question mark. The task is to count the number of strings that match exactly <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> of the patterns (first problem) and at least <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> of the patterns (second problem).</p>
<p>Notice first that we can easily count the number of strings that satisfy at once all of the specified patterns. To do this, simply "cross" patterns: iterate though the positions ("slots") and look at a position over all patterns. If all patterns have a question mark in this position, the character can be any letter from <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> to <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>. Otherwise, the character of this position is uniquely defined by the patterns that do not contain a question mark.</p>
<p>Learn now to solve the first version of the problem: when the string must satisfy exactly <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> of the patterns.</p>
<p>To solve it, iterate and fix a specific subset <span><span class="MathJax_Preview">X</span><script type="math/tex">X</script></span> from the set of patterns consisting of <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> patterns. Then we have to count the number of strings that satisfy this set of patterns, and only matches it, that is, they don't match any other pattern. We will use the inclusion-exclusion principle in a slightly different manner: we sum on all supersets <span><span class="MathJax_Preview">Y</span><script type="math/tex">Y</script></span> (subsets from the original set of strings that contain <span><span class="MathJax_Preview">X</span><script type="math/tex">X</script></span>), and either add to the current answer of subtract it from the number of strings:</p>
<div>
<div class="MathJax_Preview"> ans(X) = \sum_{Y \supseteq X} (-1)^{|Y|-k} \cdot f(Y) </div>
<script type="math/tex; mode=display"> ans(X) = \sum_{Y \supseteq X} (-1)^{|Y|-k} \cdot f(Y) </script>
</div>
<p>Where <span><span class="MathJax_Preview">f(Y)</span><script type="math/tex">f(Y)</script></span> is the number of strings that match <span><span class="MathJax_Preview">Y</span><script type="math/tex">Y</script></span> (at least <span><span class="MathJax_Preview">Y</span><script type="math/tex">Y</script></span>).</p>
<p>(If you have a hard time figuring out this, you can try drawing Venn Diagrams.)</p>
<p>If we sum up on all <span><span class="MathJax_Preview">ans(X)</span><script type="math/tex">ans(X)</script></span>, we will get the final answer:</p>
<div>
<div class="MathJax_Preview"> ans = \sum_{X ~ : ~ |X| = k} ans(X) </div>
<script type="math/tex; mode=display"> ans = \sum_{X ~ : ~ |X| = k} ans(X) </script>
</div>
<p>However, asymptotics of this solution is <span><span class="MathJax_Preview">O(3^k \cdot k)</span><script type="math/tex">O(3^k \cdot k)</script></span>. To improve it, notice that different <span><span class="MathJax_Preview">ans(X)</span><script type="math/tex">ans(X)</script></span> computations very often share <span><span class="MathJax_Preview">Y</span><script type="math/tex">Y</script></span> sets.</p>
<p>We will reverse the formula of inclusion-exclusion and sum in terms of <span><span class="MathJax_Preview">Y</span><script type="math/tex">Y</script></span> sets. Now it becomes clear that the same set <span><span class="MathJax_Preview">Y</span><script type="math/tex">Y</script></span> would be taken into account in the computation of <span><span class="MathJax_Preview">ans(X)</span><script type="math/tex">ans(X)</script></span> of <span><span class="MathJax_Preview">\binom{|Y|}{k}</span><script type="math/tex">\binom{|Y|}{k}</script></span> sets with the same sign <span><span class="MathJax_Preview">(-1)^{|Y| - k}</span><script type="math/tex">(-1)^{|Y| - k}</script></span>.</p>
<div>
<div class="MathJax_Preview"> ans = \sum_{Y ~ : ~ |Y| \ge k} (-1)^{|Y|-k} \cdot \binom{|Y|}{k} \cdot f(Y) </div>
<script type="math/tex; mode=display"> ans = \sum_{Y ~ : ~ |Y| \ge k} (-1)^{|Y|-k} \cdot \binom{|Y|}{k} \cdot f(Y) </script>
</div>
<p>Now our solution has asymptotics <span><span class="MathJax_Preview">O(2^k \cdot k)</span><script type="math/tex">O(2^k \cdot k)</script></span>.</p>
<p>We will now solve the second version of the problem: find the number of strings that match <strong>at least</strong> <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> of the patterns.</p>
<p>Of course, we can just use the solution to the first version of the problem and add the answers for sets with size greater than <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>. However, you may notice that in this problem, a set |Y| is considered in the formula for all sets with size <span><span class="MathJax_Preview">\ge k</span><script type="math/tex">\ge k</script></span> which are contained in <span><span class="MathJax_Preview">Y</span><script type="math/tex">Y</script></span>. That said, we can write the part of the expression that is being multiplied by <span><span class="MathJax_Preview">f(Y)</span><script type="math/tex">f(Y)</script></span> as:</p>
<div>
<div class="MathJax_Preview"> (-1)^{|Y|-k} \cdot \binom{|Y|}{k} + (-1)^{|Y|-k-1} \cdot \binom{|Y|}{k+1} + (-1)^{|Y|-k-2} \cdot \binom{|Y|}{k+2} + \cdots + (-1)^{|Y|-|Y|} \cdot \binom{|Y|}{|Y|} </div>
<script type="math/tex; mode=display"> (-1)^{|Y|-k} \cdot \binom{|Y|}{k} + (-1)^{|Y|-k-1} \cdot \binom{|Y|}{k+1} + (-1)^{|Y|-k-2} \cdot \binom{|Y|}{k+2} + \cdots + (-1)^{|Y|-|Y|} \cdot \binom{|Y|}{|Y|} </script>
</div>
<p>Looking at Graham's (Graham, Knuth, Patashnik. "Concrete mathematics" [1998] ), we see a well-known formula for <a href="/docs/#Algorithms/Combinatorics/Binomial_Coefficients/">binomial coefficients</a>:</p>
<div>
<div class="MathJax_Preview"> \sum_{k=0}^m (-1)^k \cdot \binom{n}{k} = (-1)^m \cdot \binom{n-1}{m} </div>
<script type="math/tex; mode=display"> \sum_{k=0}^m (-1)^k \cdot \binom{n}{k} = (-1)^m \cdot \binom{n-1}{m} </script>
</div>
<p>Applying it here, we find that the entire sum of binomial coefficients is minimized:</p>
<div>
<div class="MathJax_Preview"> (-1)^{|Y|-k} \cdot \binom{|Y|-1}{|Y|-k} </div>
<script type="math/tex; mode=display"> (-1)^{|Y|-k} \cdot \binom{|Y|-1}{|Y|-k} </script>
</div>
<p>Thus, for this task, we also obtained a solution with the asymptotics <span><span class="MathJax_Preview">O(2^k \cdot k)</span><script type="math/tex">O(2^k \cdot k)</script></span>:</p>
<div>
<div class="MathJax_Preview"> ans = \sum_{Y ~ : ~ |Y| \ge k} (-1)^{|Y|-k} \cdot \binom{|Y|-1}{|Y|-k} \cdot f(Y) </div>
<script type="math/tex; mode=display"> ans = \sum_{Y ~ : ~ |Y| \ge k} (-1)^{|Y|-k} \cdot \binom{|Y|-1}{|Y|-k} \cdot f(Y) </script>
</div>
<h3 id="the-number-of-ways-of-going-from-a-cell-to-another">The number of ways of going from a cell to another</h3>
<p>There is a field <span><span class="MathJax_Preview">n \times m</span><script type="math/tex">n \times m</script></span>, and <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> of its cells are impassable walls. A robot is initially at the cell <span><span class="MathJax_Preview">(1,1)</span><script type="math/tex">(1,1)</script></span> (bottom left). The robot can only move right or up, and eventually it needs to get into the cell <span><span class="MathJax_Preview">(n,m)</span><script type="math/tex">(n,m)</script></span>, avoiding all obstacles. You need to count the number of ways he can do it.</p>
<p>Assume that the sizes <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> and <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> are very large (say, <span><span class="MathJax_Preview">10^9</span><script type="math/tex">10^9</script></span>), and the number <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> is small (around <span><span class="MathJax_Preview">100</span><script type="math/tex">100</script></span>).</p>
<p>For now, sort the obstacles by their coordinate <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>, and in case of equality — coordinate <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>.</p>
<p>Also just learn how to solve a problem without obstacles: i.e. learn how to count the number of ways to get from one cell to another. In one axis, we need to go through <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> cells, and on the other, <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> cells. From simple combinatorics, we get a formula using <a href="/docs/#Algorithms/Combinatorics/Binomial_Coefficients/">binomial coefficients</a>:</p>
<div>
<div class="MathJax_Preview">\binom{x+y}{x}</div>
<script type="math/tex; mode=display">\binom{x+y}{x}</script>
</div>
<p>Now to count the number of ways to get from one cell to another, avoiding all obstacles, you can use inclusion-exclusion to solve the inverse problem: count the number of ways to walk through the board stepping at a subset of obstacles (and subtract it from the total number of ways).</p>
<p>When iterating over a subset of the obstacles that we'll step, to count the number of ways to do this simply multiply the number of all paths from starting cell to the first of the selected obstacles, a first obstacle to the second, and so on, and then add or subtract this number from the answer, in accordance with the standard formula of inclusion-exclusion.</p>
<p>However, this will again be non-polynomial in complexity <span><span class="MathJax_Preview">O(2^k \cdot k)</span><script type="math/tex">O(2^k \cdot k)</script></span>.</p>
<p>Here goes a polynomial solution:</p>
<p>We will use dynamic programming: let's compute the numbers <span><span class="MathJax_Preview">d[i][j]</span><script type="math/tex">d[i][j]</script></span> — the number of ways to get from the <span><span class="MathJax_Preview">i-th</span><script type="math/tex">i-th</script></span> point to <span><span class="MathJax_Preview">j-th</span><script type="math/tex">j-th</script></span>, without stepping on any other obstacle (except for <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> and <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>, of course). We will compute this number for all the obstacle cells, and also the starting and ending ones (all possible pairs of cells from these).</p>
<p>Let's forget for a second the obstacles and just count the number of paths from cell <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> to <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>. We need to consider some "bad" paths, the ones that pass through the obstacles, and subtract them from the total number of ways of going from <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> to <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>.</p>
<p>When considering an obstacle <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> between <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> and <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> (<span><span class="MathJax_Preview">i &lt; t &lt; j</span><script type="math/tex">i < t < j</script></span>), on which we can step, we see that the number of paths from <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> to <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> that pass through <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> which have <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> as the <strong>first obstacle between <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> and <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span></strong>. We can compute that as: <span><span class="MathJax_Preview">d[i][t]</span><script type="math/tex">d[i][t]</script></span> multiplied by the number of arbitrary paths from <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> to <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>. We can count the number of "bad" ways summing this for all <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> between <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> and <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>.</p>
<p>We can compute <span><span class="MathJax_Preview">d[i][j]</span><script type="math/tex">d[i][j]</script></span> in <span><span class="MathJax_Preview">O(k)</span><script type="math/tex">O(k)</script></span> for <span><span class="MathJax_Preview">O(k^2)</span><script type="math/tex">O(k^2)</script></span> pairs, so this solution has complexity <span><span class="MathJax_Preview">O(k^3)</span><script type="math/tex">O(k^3)</script></span>.</p>
<h3 id="the-number-of-coprime-quadruples">The number of coprime quadruples</h3>
<p>You're given <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> numbers: <span><span class="MathJax_Preview">a_1, a_2, \ldots, a_n</span><script type="math/tex">a_1, a_2, \ldots, a_n</script></span>. You are required to count the number of ways to choose four numbers so that their combined greatest common divisor is equal to one.</p>
<p>We will solve the inverse problem — compute the number of "bad" quadruples, i.e. quadruples in which all numbers are divisible by a number <span><span class="MathJax_Preview">d &gt; 1</span><script type="math/tex">d > 1</script></span>.</p>
<p>We will use the inclusion-exclusion principle while summing over all possible groups of four numbers divisible by a divisor <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>.</p>
<div>
<div class="MathJax_Preview">ans = \sum_{d \ge 2} (-1)^{deg(d)-1} \cdot f(d)</div>
<script type="math/tex; mode=display">ans = \sum_{d \ge 2} (-1)^{deg(d)-1} \cdot f(d)</script>
</div>
<p>where <span><span class="MathJax_Preview">deg(d)</span><script type="math/tex">deg(d)</script></span> is the number of primes in the factorization of the number <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span> and <span><span class="MathJax_Preview">f(d)</span><script type="math/tex">f(d)</script></span> the number of quadruples divisible by <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>.</p>
<p>To calculate the function <span><span class="MathJax_Preview">f(d)</span><script type="math/tex">f(d)</script></span>, you just have to count the number of multiples of <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span> (as mentioned on a previous task) and use <a href="/docs/#Algorithms/Combinatorics/Binomial_Coefficients/">binomial coefficients</a> to count the number of ways to choose four of them.</p>
<p>Thus, using the formula of inclusions-exclusions we sum the number of groups of four divisible by a prime number, then subtract the number of quadruples which are divisible by the product of two primes, add quadruples divisible by three primes, etc.</p>
<h3 id="the-number-of-harmonic-triplets">The number of harmonic triplets</h3>
<p>You are given a number <span><span class="MathJax_Preview">n \le 10^6</span><script type="math/tex">n \le 10^6</script></span>. You are required to count the number of triples <span><span class="MathJax_Preview">2 \le a &lt; b &lt; c \le n</span><script type="math/tex">2 \le a < b < c \le n</script></span> that satisfy one of the following conditions:</p>
<ul>
<li>or <span><span class="MathJax_Preview">{\rm gcd}(a,b) = {\rm gcd}(a,c) = {\rm gcd}(b,c) = 1</span><script type="math/tex">{\rm gcd}(a,b) = {\rm gcd}(a,c) = {\rm gcd}(b,c) = 1</script></span>,</li>
<li>or <span><span class="MathJax_Preview">{\rm gcd}(a,b) &gt; 1, {\rm gcd}(a,c) &gt; 1, {\rm gcd}(b,c) &gt; 1</span><script type="math/tex">{\rm gcd}(a,b) > 1, {\rm gcd}(a,c) > 1, {\rm gcd}(b,c) > 1</script></span>.</li>
</ul>
<p>First, go straight to the inverse problem — i.e. count the number of non-harmonic triples.</p>
<p>Second, note that any non-harmonic triplet is made of a pair of coprimes and a third number that is not coprime with at least one from the pair.</p>
<p>Thus, the number of non-harmonic triples that contain <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> is equal the number of integers from <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span> to <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> that are coprimes with <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> multiplied by the number of integers that are not coprime with <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>.</p>
<p>Either <span><span class="MathJax_Preview">gcd(a,b) = 1 \wedge gcd(a,c) &gt; 1 \wedge gcd(b,c) &gt; 1</span><script type="math/tex">gcd(a,b) = 1 \wedge gcd(a,c) > 1 \wedge gcd(b,c) > 1</script></span></p>
<p>or <span><span class="MathJax_Preview">gcd(a,b) = 1 \wedge gcd(a,c) = 1 \wedge gcd(b,c) &gt; 1</span><script type="math/tex">gcd(a,b) = 1 \wedge gcd(a,c) = 1 \wedge gcd(b,c) > 1</script></span></p>
<p>In both of these cases, it will be counted twice. The first case will be counted when <span><span class="MathJax_Preview">i = a</span><script type="math/tex">i = a</script></span> and when <span><span class="MathJax_Preview">i = b</span><script type="math/tex">i = b</script></span>. The second case will be counted when <span><span class="MathJax_Preview">i = b</span><script type="math/tex">i = b</script></span> and when <span><span class="MathJax_Preview">i = c</span><script type="math/tex">i = c</script></span>. Therefore, to compute the number of non-harmonic triples, we sum this calculation through all <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> from <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span> to <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> and divide it by <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span>.</p>
<p>Now all we have left to solve is to learn to count the number of coprimes to <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> in the interval <span><span class="MathJax_Preview">[2;n]</span><script type="math/tex">[2;n]</script></span>. Although this problem has already been mentioned, the above solution is not suitable here — it would require the factorization of each of the integers from <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span> to <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>, and then iterating through all subsets of these primes.</p>
<p>A faster solution is possible with such modification of the sieve of Eratosthenes:</p>
<ol>
<li>
<p>First, we find all numbers in the interval <span><span class="MathJax_Preview">[2;n]</span><script type="math/tex">[2;n]</script></span> such that its simple factorization does not include a prime factor twice. We will also need to know, for these numbers, how many factors it includes.</p>
<ul>
<li>To do this we will maintain an array <span><span class="MathJax_Preview">deg[i]</span><script type="math/tex">deg[i]</script></span> to store the number of primes in the factorization of <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>, and an array <span><span class="MathJax_Preview">good[i]</span><script type="math/tex">good[i]</script></span>, to mark either if <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> contains each factor at most twice (<span><span class="MathJax_Preview">good[i] = 1</span><script type="math/tex">good[i] = 1</script></span>) or not (<span><span class="MathJax_Preview">good[i] = 0</span><script type="math/tex">good[i] = 0</script></span>). When iterating from <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span> to <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>, if we reach a number that has <span><span class="MathJax_Preview">deg</span><script type="math/tex">deg</script></span> equal to <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>, then it is a prime and its <span><span class="MathJax_Preview">deg</span><script type="math/tex">deg</script></span> is <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>.</li>
<li>During the sieve of Eratosthenes, we will iterate <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> from <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span> to <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>. When processing a prime number we go through all of its multiples and increase their <span><span class="MathJax_Preview">deg[]</span><script type="math/tex">deg[]</script></span>. If one of these multiples is multiple of the square of <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>, then we can put <span><span class="MathJax_Preview">good</span><script type="math/tex">good</script></span> as false.</li>
</ul>
</li>
<li>
<p>Second, we need to calculate the answer for all <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> from <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span> to <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>, i.e., the array <span><span class="MathJax_Preview">cnt[]</span><script type="math/tex">cnt[]</script></span> — the number of integers not coprime with <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>.</p>
<ul>
<li>To do this, remember how the formula of inclusion-exclusion works — actually here we implement the same concept, but with inverted logic: we iterate over a component (a product of primes from the factorization) and add or subtract its term on the formula of inclusion-exclusion of each of its multiples.</li>
<li>So, let's say we are processing a number <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> such that <span><span class="MathJax_Preview">good[i] = true</span><script type="math/tex">good[i] = true</script></span>, i.e., it is involved in the formula of inclusion-exclusion. Iterate through all numbers that are multiples of <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>, and either add or subtract <span><span class="MathJax_Preview">\lfloor N/i \rfloor</span><script type="math/tex">\lfloor N/i \rfloor</script></span> from their <span><span class="MathJax_Preview">cnt[]</span><script type="math/tex">cnt[]</script></span> (the signal depends on <span><span class="MathJax_Preview">deg[i]</span><script type="math/tex">deg[i]</script></span>: if <span><span class="MathJax_Preview">deg[i]</span><script type="math/tex">deg[i]</script></span> is odd, then we must add, otherwise subtract).</li>
</ul>
</li>
</ol>
<p>Here's a C++ implementation:</p>
<pre><code class="cpp">int n;
bool good[MAXN];
int deg[MAXN], cnt[MAXN];

long long solve() {
    memset (good, 1, sizeof good);
    memset (deg, 0, sizeof deg);
    memset (cnt, 0, sizeof cnt);

    long long ans_bad = 0;
    for (int i=2; i&lt;=n; ++i) {
        if (good[i]) {
            if (deg[i] == 0)  deg[i] = 1;
            for (int j=1; i*j&lt;=n; ++j) {
                if (j &gt; 1 &amp;&amp; deg[i] == 1)
                    if (j % i == 0)
                        good[i*j] = false;
                    else
                        ++deg[i*j];
                cnt[i*j] += (n / i) * (deg[i]%2==1 ? +1 : -1);
            }
        }
        ans_bad += (cnt[i] - 1) * 1ll * (n-1 - cnt[i]);
    }

    return (n-1) * 1ll * (n-2) * (n-3) / 6 - ans_bad / 2;
}
</code></pre>

<p>The asymptotics of our solution is <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span>, as for almost every number up to <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> we make <span><span class="MathJax_Preview">n/i</span><script type="math/tex">n/i</script></span> iterations on the nested loop.</p>
<h3 id="the-number-of-permutations-without-fixed-points-derangements">The number of permutations without fixed points (derangements)</h3>
<p>Prove that the number of permutations of length <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> without fixed points (i.e. no number <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> is in position <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> - also called a derangement) is equal to the following number:</p>
<div>
<div class="MathJax_Preview">n! - \binom{n}{1} \cdot (n-1)! + \binom{n}{2} \cdot (n-2)! - \binom{n}{3} \cdot (n-3)! + \cdots \pm \binom{n}{n} \cdot (n-n)! </div>
<script type="math/tex; mode=display">n! - \binom{n}{1} \cdot (n-1)! + \binom{n}{2} \cdot (n-2)! - \binom{n}{3} \cdot (n-3)! + \cdots \pm \binom{n}{n} \cdot (n-n)! </script>
</div>
<p>and approximately equal to:</p>
<div>
<div class="MathJax_Preview"> \frac{ n! }{ e } </div>
<script type="math/tex; mode=display"> \frac{ n! }{ e } </script>
</div>
<p>(if you round this expression to the nearest whole number — you get exactly the number of permutations without fixed points)</p>
<p>Denote by <span><span class="MathJax_Preview">A_k</span><script type="math/tex">A_k</script></span> the set of permutations of length <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> with a fixed point at position <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> (<span><span class="MathJax_Preview">1 \le k \le n</span><script type="math/tex">1 \le k \le n</script></span>) (i.e. element <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> is at position <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>).</p>
<p>We now use the formula of inclusion-exclusion to count the number of permutations with at least one fixed point. For this we need to learn to count sizes of an intersection of sets <span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span>, as follows:</p>
<div>
<div class="MathJax_Preview">\begin{eqnarray}
\left| A_p \right| &amp;=&amp; (n-1)!\ , \\\\\\
\left| A_p \cap A_q \right| &amp;=&amp; (n-2)!\ , \\\\\\
\left| A_p \cap A_q \cap A_r \right| &amp;=&amp; (n-3)!\ , \\\\\\
\cdots ,
\end{eqnarray}</div>
<script type="math/tex; mode=display">\begin{eqnarray}
\left| A_p \right| &=& (n-1)!\ , \\\\\\
\left| A_p \cap A_q \right| &=& (n-2)!\ , \\\\\\
\left| A_p \cap A_q \cap A_r \right| &=& (n-3)!\ , \\\\\\
\cdots ,
\end{eqnarray}</script>
</div>
<p>because if we know that the number of fixed points is equal <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>, then we know the position of <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> elements of the permutation, and all other <span><span class="MathJax_Preview">(n-x)</span><script type="math/tex">(n-x)</script></span> elements can be placed anywhere.</p>
<p>Substituting this into the formula of inclusion-exclusion, and given that the number of ways to choose a subset of size <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> from the set of <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> elements is equal to <span><span class="MathJax_Preview">\binom{n}{x}</span><script type="math/tex">\binom{n}{x}</script></span>, we obtain a formula for the number of permutations with at least one fixed point:</p>
<div>
<div class="MathJax_Preview">\binom{n}{1} \cdot (n-1)! - \binom{n}{2} \cdot (n-2)! + \binom{n}{3} \cdot (n-3)! - \cdots \pm \binom{n}{n} \cdot (n-n)! </div>
<script type="math/tex; mode=display">\binom{n}{1} \cdot (n-1)! - \binom{n}{2} \cdot (n-2)! + \binom{n}{3} \cdot (n-3)! - \cdots \pm \binom{n}{n} \cdot (n-n)! </script>
</div>
<p>Then the number of permutations without fixed points is equal to:</p>
<div>
<div class="MathJax_Preview">n! - \binom{n}{1} \cdot (n-1)! + \binom{n}{2} \cdot (n-2)! - \binom{n}{3} \cdot (n-3)! + \cdots \pm \binom{n}{n} \cdot (n-n)! </div>
<script type="math/tex; mode=display">n! - \binom{n}{1} \cdot (n-1)! + \binom{n}{2} \cdot (n-2)! - \binom{n}{3} \cdot (n-3)! + \cdots \pm \binom{n}{n} \cdot (n-n)! </script>
</div>
<p>Simplifying this expression, we obtain <strong>exact and approximate expressions for the number of permutations without fixed points</strong>:</p>
<div>
<div class="MathJax_Preview"> n! \left( 1 - \frac{1}{1!} + \frac{1}{2!} - \frac{1}{3!} + \cdots \pm \frac{1}{n!} \right ) \approx \frac{n!}{e} </div>
<script type="math/tex; mode=display"> n! \left( 1 - \frac{1}{1!} + \frac{1}{2!} - \frac{1}{3!} + \cdots \pm \frac{1}{n!} \right ) \approx \frac{n!}{e} </script>
</div>
<p>(because the sum in brackets are the first <span><span class="MathJax_Preview">n+1</span><script type="math/tex">n+1</script></span> terms of the expansion in Taylor series <span><span class="MathJax_Preview">e^{-1}</span><script type="math/tex">e^{-1}</script></span>)</p>
<p>It is worth noting that a similar problem can be solved this way: when you need the fixed points were not among the <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> first elements of permutations (and not among all, as we just solved). The formula obtained is as the given above accurate formula, but it will go up to the sum of <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>, instead of <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>.</p>
<h2 id="practice-problems">Practice Problems</h2>
<p>A list of tasks that can be solved using the principle of inclusions-exclusions:</p>
<ul>
<li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=1266">UVA #10325 "The Lottery" [difficulty: low]</a></li>
<li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2906">UVA #11806 "Cheerleaders" [difficulty: low]</a></li>
<li><a href="http://www.topcoder.com/stat?c=problem_statement&amp;pm=10875">TopCoder SRM 477 "CarelessSecretary" [difficulty: low]</a></li>
<li><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=6658&amp;rd=10068">TopCoder TCHS 16 "Divisibility" [difficulty: low]</a></li>
<li><a href="http://www.spoj.com/problems/NGM2/">SPOJ #6285 NGM2 , "Another Game With Numbers" [difficulty: low]</a></li>
<li><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=8470">TopCoder SRM 382 "CharmingTicketsEasy" [difficulty: medium]</a></li>
<li><a href="http://www.topcoder.com/stat?c=problem_statement&amp;pm=8307">TopCoder SRM 390 "SetOfPatterns" [difficulty: medium]</a></li>
<li><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=2013">TopCoder SRM 176 "Deranged" [difficulty: medium]</a></li>
<li><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=10702&amp;rd=14144&amp;rm=303184&amp;cr=22697599">TopCoder SRM 457 "TheHexagonsDivOne" [difficulty: medium]</a></li>
<li><a href="http://esci.ru/ttb/statement-62.htm">Test&gt;&gt;&gt;thebest "HarmonicTriples" (in Russian) [difficulty: medium]</a></li>
<li><a href="http://www.spoj.com/problems/MSKYCODE/">SPOJ #4191 MSKYCODE "Sky Code" [difficulty: medium]</a></li>
<li><a href="http://www.spoj.com/problems/SQFREE/">SPOJ #4168 SQFREE "Square-free integers" [difficulty: medium]</a></li>
<li><a href="http://www.codechef.com/JAN11/problems/COUNTREL/">CodeChef "Count Relations" [difficulty: medium]</a></li>
<li><a href="http://www.spoj.com/problems/KPRIMESB/">SPOJ - Almost Prime Numbers Again</a></li>
<li><a href="http://www.spoj.com/problems/IITKWPCH/">SPOJ - Find number of Pair of Friends</a></li>
<li><a href="http://www.spoj.com/problems/SUBSET/">SPOJ - Balanced Cow Subsets</a></li>
<li><a href="http://www.spoj.com/problems/EASYMATH/">SPOJ - EASY MATH [difficulty: medium]</a></li>
<li><a href="https://www.spoj.com/problems/MOMOS/">SPOJ - MOMOS - FEASTOFPIGS [difficulty: easy]</a></li>
</ul>

  <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://d-k-ivanov.github.io/">Main site</a>
      </p><p>Copyright &copy; 2016-2020 Dmitriy Ivanov. <script type="text/javascript"> (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)}; m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)}) (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym"); ym(40819844, "init", { clickmap:true, trackLinks:true, accurateTrackBounce:true }); </script> <noscript><div><img src="https://mc.yandex.ru/watch/40819844" style="position:absolute; left:-9999px;" alt="" /></div></noscript></p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>