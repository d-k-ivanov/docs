<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="Dmitriy Ivanov">
    <link rel="canonical" href="https://d-k-ivanov.github.io/docs/Dev Langs/C_and_Cpp/Modern_CPP_Features/CPP17/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>C++17 - Technical Info</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/extra.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "C++17", url: "#_top", children: [
              {title: "Overview", url: "#overview" },
              {title: "C++17 Language Features", url: "#c17-language-features" },
              {title: "C++17 Library Features", url: "#c17-library-features" },
              {title: "Acknowledgements", url: "#acknowledgements" },
              {title: "Author", url: "#author" },
              {title: "Content Contributors", url: "#content-contributors" },
              {title: "License", url: "#license" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-80208201-1', 'd-k-ivanov.github.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../Overview/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../Overview/" class="btn btn-xs btn-link">
        C++17/14/11
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../CPP14/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../CPP14/" class="btn btn-xs btn-link">
        C++14
      </a>
    </div>
    
  </div>

    

    <h1 id="c17">C++17</h1>
<h2 id="overview">Overview</h2>
<p>Many of these descriptions and examples come from various resources (see <a href="#acknowledgements">Acknowledgements</a> section), summarized in my own words.</p>
<p>C++17 includes the following new language features:
- <a href="#template-argument-deduction-for-class-templates">template argument deduction for class templates</a>
- <a href="#declaring-non-type-template-parameters-with-auto">declaring non-type template parameters with auto</a>
- <a href="#folding-expressions">folding expressions</a>
- <a href="#new-rules-for-auto-deduction-from-braced-init-list">new rules for auto deduction from braced-init-list</a>
- <a href="#constexpr-lambda">constexpr lambda</a>
- <a href="#lambda-capture-this-by-value">lambda capture this by value</a>
- <a href="#inline-variables">inline variables</a>
- <a href="#nested-namespaces">nested namespaces</a>
- <a href="#structured-bindings">structured bindings</a>
- <a href="#selection-statements-with-initializer">selection statements with initializer</a>
- <a href="#constexpr-if">constexpr if</a>
- <a href="#utf-8-character-literals">utf-8 character literals</a>
- <a href="#direct-list-initialization-of-enums">direct-list-initialization of enums</a></p>
<p>C++17 includes the following new library features:
- <a href="#stdvariant">std::variant</a>
- <a href="#stdoptional">std::optional</a>
- <a href="#stdany">std::any</a>
- <a href="#stdstring_view">std::string_view</a>
- <a href="#stdinvoke">std::invoke</a>
- <a href="#stdapply">std::apply</a>
- <a href="#stdfilesystem">std::filesystem</a>
- <a href="#stdbyte">std::byte</a>
- <a href="#splicing-for-maps-and-sets">splicing for maps and sets</a>
- <a href="#parallel-algorithms">parallel algorithms</a></p>
<h2 id="c17-language-features">C++17 Language Features</h2>
<h3 id="template-argument-deduction-for-class-templates">Template argument deduction for class templates</h3>
<p>Automatic template argument deduction much like how it's done for functions, but now including class constructors.</p>
<pre><code class="c++">template &lt;typename T = float&gt;
struct MyContainer {
  T val;
  MyContainer() : val() {}
  MyContainer(T val) : val(val) {}
  // ...
};
MyContainer c1 {1}; // OK MyContainer&lt;int&gt;
MyContainer c2; // OK MyContainer&lt;float&gt;
</code></pre>

<h3 id="declaring-non-type-template-parameters-with-auto">Declaring non-type template parameters with auto</h3>
<p>Following the deduction rules of <code>auto</code>, while respecting the non-type template parameter list of allowable types[*], template arguments can be deduced from the types of its arguments:</p>
<pre><code class="c++">template &lt;auto... seq&gt;
struct my_integer_sequence {
  // Implementation here ...
};

// Explicitly pass type `int` as template argument.
auto seq = std::integer_sequence&lt;int, 0, 1, 2&gt;();
// Type is deduced to be `int`.
auto seq2 = my_integer_sequence&lt;0, 1, 2&gt;();
</code></pre>

<p>* - For example, you cannot use a <code>double</code> as a template parameter type, which also makes this an invalid deduction using <code>auto</code>.</p>
<h3 id="folding-expressions">Folding expressions</h3>
<p>A fold expression performs a fold of a template parameter pack over a binary operator.
* An expression of the form <code>(... op e)</code> or <code>(e op ...)</code>, where <code>op</code> is a fold-operator and <code>e</code> is an unexpanded parameter pack, are called <em>unary folds</em>.
* An expression of the form <code>(e1 op ... op e2)</code>, where <code>op</code> are fold-operators, is called a <em>binary fold</em>. Either <code>e1</code> or <code>e2</code> is an unexpanded parameter pack, but not both.</p>
<pre><code class="c++">template&lt;typename... Args&gt;
bool logicalAnd(Args... args) {
    // Binary folding.
    return (true &amp;&amp; ... &amp;&amp; args);
}
bool b = true;
bool&amp; b2 = b;
logicalAnd(b, b2, true); // == true
</code></pre>

<pre><code class="c++">template&lt;typename... Args&gt;
auto sum(Args... args) {
    // Unary folding.
    return (... + args);
}
sum(1.0, 2.0f, 3); // == 6.0
</code></pre>

<h3 id="new-rules-for-auto-deduction-from-braced-init-list">New rules for auto deduction from braced-init-list</h3>
<p>Changes to <code>auto</code> deduction when used with the uniform initialization syntax. Previously, <code>auto x {3};</code> deduces a <code>std::initializer_list&lt;int&gt;</code>, which now deduces to <code>int</code>.</p>
<pre><code class="c++">auto x1 {1, 2, 3}; // error: not a single element
auto x2 = {1, 2, 3}; // decltype(x2) is std::initializer_list&lt;int&gt;
auto x3 {3}; // decltype(x3) is int
auto x4 {3.0}; // decltype(x4) is double
</code></pre>

<h3 id="constexpr-lambda">constexpr lambda</h3>
<p>Compile-time lambdas using <code>constexpr</code>.</p>
<pre><code class="c++">auto identity = [](int n) constexpr { return n; };
static_assert(identity(123) == 123);
</code></pre>

<pre><code class="c++">constexpr auto add = [](int x, int y) {
  auto L = [=] { return x; };
  auto R = [=] { return y; };
  return [=] { return L() + R(); };
};

static_assert(add(1, 2)() == 3);
</code></pre>

<pre><code class="c++">constexpr int addOne(int n) {
  return [n] { return n + 1; }();
}

static_assert(addOne(1) == 2);
</code></pre>

<h3 id="lambda-capture-this-by-value">Lambda capture <code>this</code> by value</h3>
<p>Capturing <code>this</code> in a lambda's environment was previously reference-only. An example of where this is problematic is asynchronous code using callbacks that require an object to be available, potentially past its lifetime. <code>*this</code> (C++17) will now make a copy of the current object, while <code>this</code> (C++11) continues to capture by reference.</p>
<pre><code class="c++">struct MyObj {
  int value {123};
  auto getValueCopy() {
    return [*this] { return value; };
  }
  auto getValueRef() {
    return [this] { return value; };
  }
};
MyObj mo;
auto valueCopy = mo.getValueCopy();
auto valueRef = mo.getValueRef();
mo.value = 321;
valueCopy(); // 123
valueRef(); // 321
</code></pre>

<h3 id="inline-variables">Inline variables</h3>
<p>The inline specifier can be applied to variables as well as to functions. A variable declared inline has the same semantics as a function declared inline.</p>
<pre><code class="c++">// Disassembly example using compiler explorer.
struct S { int x; };
inline S x1 = S{321}; // mov esi, dword ptr [x1]
                      // x1: .long 321

S x2 = S{123};        // mov eax, dword ptr [.L_ZZ4mainE2x2]
                      // mov dword ptr [rbp - 8], eax
                      // .L_ZZ4mainE2x2: .long 123
</code></pre>

<h3 id="nested-namespaces">Nested namespaces</h3>
<p>Using the namespace resolution operator to create nested namespace definitions.</p>
<pre><code class="c++">namespace A {
  namespace B {
    namespace C {
      int i;
    }
  }
}
// vs.
namespace A::B::C {
  int i;
}
</code></pre>

<h3 id="structured-bindings">Structured bindings</h3>
<p>A proposal for de-structuring initialization, that would allow writing <code>auto [ x, y, z ] = expr;</code> where the type of <code>expr</code> was a tuple-like object, whose elements would be bound to the variables <code>x</code>, <code>y</code>, and <code>z</code> (which this construct declares). <em>Tuple-like objects</em> include <code>std::tuple</code>, <code>std::pair</code>, <code>std::array</code>, and aggregate structures.</p>
<pre><code class="c++">using Coordinate = std::pair&lt;int, int&gt;;
Coordinate origin() {
  return Coordinate{0, 0};
}

const auto [ x, y ] = origin();
x; // == 0
y; // == 0
</code></pre>

<h3 id="selection-statements-with-initializer">Selection statements with initializer</h3>
<p>New versions of the <code>if</code> and <code>switch</code> statements which simplify common code patterns and help users keep scopes tight.</p>
<pre><code class="c++">{
  std::lock_guard&lt;std::mutex&gt; lk(mx);
  if (v.empty()) v.push_back(val);
}
// vs.
if (std::lock_guard&lt;std::mutex&gt; lk(mx); v.empty()) {
  v.push_back(val);
}
</code></pre>

<pre><code class="c++">Foo gadget(args);
switch (auto s = gadget.status()) {
  case OK: gadget.zip(); break;
  case Bad: throw BadFoo(s.message());
}
// vs.
switch (Foo gadget(args); auto s = gadget.status()) {
  case OK: gadget.zip(); break;
  case Bad: throw BadFoo(s.message());
}
</code></pre>

<h3 id="constexpr-if">constexpr if</h3>
<p>Write code that is instantiated depending on a compile-time condition.</p>
<pre><code class="c++">template &lt;typename T&gt;
constexpr bool isIntegral() {
  if constexpr (std::is_integral&lt;T&gt;::value) {
    return true;
  } else {
    return false;
  }
}
static_assert(isIntegral&lt;int&gt;() == true);
static_assert(isIntegral&lt;char&gt;() == true);
static_assert(isIntegral&lt;double&gt;() == false);
struct S {};
static_assert(isIntegral&lt;S&gt;() == false);
</code></pre>

<h3 id="utf-8-character-literals">UTF-8 Character Literals</h3>
<p>A character literal that begins with <code>u8</code> is a character literal of type <code>char</code>. The value of a UTF-8 character literal is equal to its ISO 10646 code point value.</p>
<pre><code class="c++">char x = u8'x';
</code></pre>

<h3 id="direct-list-initialization-of-enums">Direct List Initialization of Enums</h3>
<p>Enums can now be initialized using braced syntax.</p>
<pre><code class="c++">enum byte : unsigned char {};
byte b {0}; // OK
byte c {-1}; // ERROR
byte d = byte{1}; // OK
byte e = byte{256}; // ERROR
</code></pre>

<h2 id="c17-library-features">C++17 Library Features</h2>
<h3 id="stdvariant">std::variant</h3>
<p>The class template <code>std::variant</code> represents a type-safe <code>union</code>. An instance of <code>std::variant</code> at any given time holds a value of one of its alternative types (it's also possible for it to be valueless).</p>
<pre><code class="c++">std::variant&lt;int, double&gt; v{ 12 };
std::get&lt;int&gt;(v); // == 12
std::get&lt;0&gt;(v); // == 12
v = 12.0;
std::get&lt;double&gt;(v); // == 12.0
std::get&lt;1&gt;(v); // == 12.0
</code></pre>

<h3 id="stdoptional">std::optional</h3>
<p>The class template <code>std::optional</code> manages an optional contained value, i.e. a value that may or may not be present. A common use case for optional is the return value of a function that may fail.</p>
<pre><code class="c++">std::optional&lt;std::string&gt; create(bool b) {
  if (b) {
    return &quot;Godzilla&quot;;
  } else {
    return {};
  }
}

create(false).value_or(&quot;empty&quot;); // == &quot;empty&quot;
create(true).value(); // == &quot;Godzilla&quot;
// optional-returning factory functions are usable as conditions of while and if
if (auto str = create(true)) {
  // ...
}
</code></pre>

<h3 id="stdany">std::any</h3>
<p>A type-safe container for single values of any type.</p>
<pre><code class="c++">std::any x {5};
x.has_value() // == true
std::any_cast&lt;int&gt;(x) // == 5
std::any_cast&lt;int&amp;&gt;(x) = 10;
std::any_cast&lt;int&gt;(x) // == 10
</code></pre>

<h3 id="stdstring_view">std::string_view</h3>
<p>A non-owning reference to a string. Useful for providing an abstraction on top of strings (e.g. for parsing).</p>
<pre><code class="c++">// Regular strings.
std::string_view cppstr {&quot;foo&quot;};
// Wide strings.
std::wstring_view wcstr_v {L&quot;baz&quot;};
// Character arrays.
char array[3] = {'b', 'a', 'r'};
std::string_view array_v(array, std::size(array));
</code></pre>

<pre><code class="c++">std::string str {&quot;   trim me&quot;};
std::string_view v {str};
v.remove_prefix(std::min(v.find_first_not_of(&quot; &quot;), v.size()));
str; //  == &quot;   trim me&quot;
v; // == &quot;trim me&quot;
</code></pre>

<h3 id="stdinvoke">std::invoke</h3>
<p>Invoke a <code>Callable</code> object with parameters. Examples of <code>Callable</code> objects are <code>std::function</code> or <code>std::bind</code> where an object can be called similarly to a regular function.</p>
<pre><code class="c++">template &lt;typename Callable&gt;
class Proxy {
    Callable c;
public:
    Proxy(Callable c): c(c) {}
    template &lt;class... Args&gt;
    decltype(auto) operator()(Args&amp;&amp;... args) {
        // ...
        return std::invoke(c, std::forward&lt;Args&gt;(args)...);
    }
};
auto add = [](int x, int y) {
  return x + y;
};
Proxy&lt;decltype(add)&gt; p {add};
p(1, 2); // == 3
</code></pre>

<h3 id="stdapply">std::apply</h3>
<p>Invoke a <code>Callable</code> object with a tuple of arguments.</p>
<pre><code class="c++">auto add = [](int x, int y) {
  return x + y;
};
std::apply(add, std::make_tuple(1, 2)); // == 3
</code></pre>

<h3 id="stdfilesystem">std::filesystem</h3>
<p>The new <code>std::filesystem</code> library provides a standard way to manipulate files, directories, and paths in a filesystem.</p>
<p>Here, a big file is copied to a temporary path if there is available space:</p>
<pre><code class="c++">const auto bigFilePath {&quot;bigFileToCopy&quot;};
if (std::filesystem::exists(bigFilePath)) {   
  const auto bigFileSize {std::filesystem::file_size(bigFilePath)};
  std::filesystem::path tmpPath {&quot;/tmp&quot;};
  if (std::filesystem::space(tmpPath).available &gt; bigFileSize) {
    std::filesystem::create_directory(tmpPath.append(&quot;example&quot;));
    std::filesystem::copy_file(bigFilePath, tmpPath.append(&quot;newFile&quot;));
  }
}
</code></pre>

<h3 id="stdbyte">std::byte</h3>
<p>The new <code>std::byte</code> type provides a standard way of representing data as a byte. Benefits of using <code>std::byte</code> over <code>char</code> or <code>unsigned char</code> is that it is not a character type, and is also not an arithmetic type; while the only operator overloads available are bitwise operations.</p>
<pre><code class="c++">std::byte a {0};
std::byte b {0xFF};
int i = std::to_integer&lt;int&gt;(b); // 0xFF
std::byte c = a &amp; b;
int j = std::to_integer&lt;int&gt;(c); // 0
</code></pre>

<p>Note that <code>std::byte</code> is simply an enum, and braced initialization of enums become possible thanks to <a href="#direct-list-initialization-of-enums">direct-list-initialization of enums</a>.</p>
<h3 id="splicing-for-maps-and-sets">Splicing for maps and sets</h3>
<p>Moving nodes and merging containers without the overhead of expensive copies, moves, or heap allocations/deallocations.</p>
<p>Moving elements from one map to another:</p>
<pre><code class="c++">std::map&lt;int, string&gt; src {{1, &quot;one&quot;}, {2, &quot;two&quot;}, {3, &quot;buckle my shoe&quot;}};
std::map&lt;int, string&gt; dst {{3, &quot;three&quot;}};
dst.insert(src.extract(src.find(1))); // Cheap remove and insert of { 1, &quot;one&quot; } from `src` to `dst`.
dst.insert(src.extract(2)); // Cheap remove and insert of { 2, &quot;two&quot; } from `src` to `dst`.
// dst == { { 1, &quot;one&quot; }, { 2, &quot;two&quot; }, { 3, &quot;three&quot; } };
</code></pre>

<p>Inserting an entire set:</p>
<pre><code class="c++">std::set&lt;int&gt; src {1, 3, 5};
std::set&lt;int&gt; dst {2, 4, 5};
dst.merge(src);
// src == { 5 }
// dst == { 1, 2, 3, 4, 5 }
</code></pre>

<p>Inserting elements which outlive the container:</p>
<pre><code class="c++">auto elementFactory() {
  std::set&lt;...&gt; s;
  s.emplace(...);
  return s.extract(s.begin());
}
s2.insert(elementFactory());
</code></pre>

<p>Changing the key of a map element:</p>
<pre><code class="c++">std::map&lt;int, string&gt; m {{1, &quot;one&quot;}, {2, &quot;two&quot;}, {3, &quot;three&quot;}};
auto e = m.extract(2);
e.key() = 4;
m.insert(std::move(e));
// m == { { 1, &quot;one&quot; }, { 3, &quot;three&quot; }, { 4, &quot;two&quot; } }
</code></pre>

<h3 id="parallel-algorithms">Parallel algorithms</h3>
<p>Many of the STL algorithms, such as the <code>copy</code>, <code>find</code> and <code>sort</code> methods, started to support the <em>parallel execution policies</em>: <code>seq</code>, <code>par</code> and <code>par_unseq</code> which translate to "sequentially", "parallel" and "parallel unsequenced".</p>
<pre><code class="c++">std::vector&lt;int&gt; longVector;
// Find element using parallel execution policy
auto result1 = std::find(std::execution::par, std::begin(longVector), std::end(longVector), 2);
// Sort elements using sequential execution policy
auto result2 = std::sort(std::execution::seq, std::begin(longVector), std::end(longVector));
</code></pre>

<h2 id="acknowledgements">Acknowledgements</h2>
<ul>
<li><a href="http://en.cppreference.com/w/cpp">cppreference</a> - especially useful for finding examples and documentation of new library features.</li>
<li><a href="http://thbecker.net/articles/rvalue_references/section_01.html">C++ Rvalue References Explained</a> - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li>
<li><a href="http://clang.llvm.org/cxx_status.html">clang</a> and <a href="https://gcc.gnu.org/projects/cxx-status.html">gcc</a>'s standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li>
<li><a href="https://godbolt.org/">Compiler explorer</a></li>
<li><a href="https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996">Scott Meyers' Effective Modern C++</a> - highly recommended book!</li>
<li><a href="https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw">Jason Turner's C++ Weekly</a> - nice collection of C++-related videos.</li>
<li><a href="http://stackoverflow.com/questions/7027523/what-can-i-do-with-a-moved-from-object">What can I do with a moved-from object?</a></li>
<li><a href="http://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto">What are some uses of decltype(auto)?</a></li>
<li>And many more SO posts I'm forgetting...</li>
</ul>
<h2 id="author">Author</h2>
<p>Anthony Calandra</p>
<h2 id="content-contributors">Content Contributors</h2>
<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>
<h2 id="license">License</h2>
<pre><code>The MIT License (MIT)
Copyright (c) 2016 Anthony Calandra
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</code></pre>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../Overview/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../Overview/" class="btn btn-xs btn-link">
        C++17/14/11
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../CPP14/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../CPP14/" class="btn btn-xs btn-link">
        C++14
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
      <p>
        <a href="https://d-k-ivanov.github.io/">Main site</a>
      </p><p>Copyright &copy; 2016-2018 Dmitriy Ivanov. <script type="text/javascript"> (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)}; m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)}) (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym"); ym(40819844, "init", { clickmap:true, trackLinks:true, accurateTrackBounce:true }); </script> <noscript><div><img src="https://mc.yandex.ru/watch/40819844" style="position:absolute; left:-9999px;" alt="" /></div></noscript></p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>