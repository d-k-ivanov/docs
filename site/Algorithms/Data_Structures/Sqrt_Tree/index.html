<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="Dmitriy Ivanov">
    <link rel="canonical" href="https://d-k-ivanov.github.io/docs/Algorithms/Data_Structures/Sqrt_Tree/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Sqrt Tree - Technical Info</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <link href="../../../css/extra.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Sqrt Tree", url: "#_top", children: [
              {title: "Description", url: "#description" },
              {title: "Updating elements", url: "#updating-elements" },
              {title: "Implementation", url: "#implementation" },
              {title: "Problems", url: "#problems" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../mathjax-config.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-80208201-1', 'd-k-ivanov.github.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../Stack_and_Queue_Modification/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../Stack_and_Queue_Modification/" class="btn btn-xs btn-link">
        Stack and Queue Modification
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../Sqrt%20_Decomposition/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../Sqrt%20_Decomposition/" class="btn btn-xs btn-link">
        Sqrt Decomposition
      </a>
    </div>
    
  </div>

    

    <h1 id="sqrt-tree">Sqrt Tree</h1>
<p>Given an array <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> that contains <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> elements and the operation <span><span class="MathJax_Preview">\circ</span><script type="math/tex">\circ</script></span> that satisfies associative property: <span><span class="MathJax_Preview">(x \circ y) \circ z = x \circ (y \circ z)</span><script type="math/tex">(x \circ y) \circ z = x \circ (y \circ z)</script></span> is true for any <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>, <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>, <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>.</p>
<p>So, such operations as <span><span class="MathJax_Preview">\gcd</span><script type="math/tex">\gcd</script></span>, <span><span class="MathJax_Preview">\min</span><script type="math/tex">\min</script></span>, <span><span class="MathJax_Preview">\max</span><script type="math/tex">\max</script></span>, <span><span class="MathJax_Preview">+</span><script type="math/tex">+</script></span>, <span><span class="MathJax_Preview">\text{and}</span><script type="math/tex">\text{and}</script></span>, <span><span class="MathJax_Preview">\text{or}</span><script type="math/tex">\text{or}</script></span>, <span><span class="MathJax_Preview">\text{xor}</span><script type="math/tex">\text{xor}</script></span>, etc. satisfy these conditions.</p>
<p>Also we have some queries <span><span class="MathJax_Preview">q(l, r)</span><script type="math/tex">q(l, r)</script></span>. For each query, we need to compute <span><span class="MathJax_Preview">a_l \circ a_{l+1} \circ \dots \circ a_r</span><script type="math/tex">a_l \circ a_{l+1} \circ \dots \circ a_r</script></span>.</p>
<p>Sqrt Tree can process such queries in <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> time with <span><span class="MathJax_Preview">O(n \cdot \log \log n)</span><script type="math/tex">O(n \cdot \log \log n)</script></span> preprocessing time and <span><span class="MathJax_Preview">O(n \cdot \log \log n)</span><script type="math/tex">O(n \cdot \log \log n)</script></span> memory.</p>
<h2 id="description">Description</h2>
<h3 id="building-sqrt-decomposition">Building sqrt decomposition</h3>
<p>Let's make a <a href="/docs/#Algorithms/Data_Structures/Sqrt_Decomposition/">sqrt decomposition</a>. We divide our array in <span><span class="MathJax_Preview">\sqrt{n}</span><script type="math/tex">\sqrt{n}</script></span> blocks, each block has size <span><span class="MathJax_Preview">\sqrt{n}</span><script type="math/tex">\sqrt{n}</script></span>. For each block, we compute:</p>
<ul>
<li>Answers to the queries that lie in the block and begin at the beginning of the block (<span><span class="MathJax_Preview">\text{prefixOp}</span><script type="math/tex">\text{prefixOp}</script></span>)</li>
<li>Answers to the queries that lie in the block and end at the end of the block (<span><span class="MathJax_Preview">\text{suffixOp}</span><script type="math/tex">\text{suffixOp}</script></span>)</li>
</ul>
<p>And we'll compute an additional array:</p>
<ul>
<li><span><span class="MathJax_Preview">\text{between}_{i, j}</span><script type="math/tex">\text{between}_{i, j}</script></span> (for <span><span class="MathJax_Preview">i \le j</span><script type="math/tex">i \le j</script></span>) - answer to the query that begins at the start of block <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> and ends at the end of block <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>. Note that we have <span><span class="MathJax_Preview">\sqrt{n}</span><script type="math/tex">\sqrt{n}</script></span> blocks, so the size of this array will be <span><span class="MathJax_Preview">O(\sqrt{n}^2) = O(n)</span><script type="math/tex">O(\sqrt{n}^2) = O(n)</script></span>.</li>
</ul>
<p>Let's see the example.</p>
<p>Let <span><span class="MathJax_Preview">\circ</span><script type="math/tex">\circ</script></span> be <span><span class="MathJax_Preview">+</span><script type="math/tex">+</script></span> (we calculate sum on a segment) and we have the following array <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>:</p>
<p><code>{1, 2, 3, 4, 5, 6, 7, 8, 9}</code></p>
<p>It will be divided onto three blocks: <code>{1, 2, 3}</code>, <code>{4, 5, 6}</code> and <code>{7, 8, 9}</code>.</p>
<p>For first block <span><span class="MathJax_Preview">\text{prefixOp}</span><script type="math/tex">\text{prefixOp}</script></span> is <code>{1, 3, 6}</code> and <span><span class="MathJax_Preview">\text{suffixOp}</span><script type="math/tex">\text{suffixOp}</script></span> is <code>{6, 5, 3}</code>.</p>
<p>For second block <span><span class="MathJax_Preview">\text{prefixOp}</span><script type="math/tex">\text{prefixOp}</script></span> is <code>{4, 9, 15}</code> and <span><span class="MathJax_Preview">\text{suffixOp}</span><script type="math/tex">\text{suffixOp}</script></span> is <code>{15, 11, 6}</code>.</p>
<p>For third block <span><span class="MathJax_Preview">\text{prefixOp}</span><script type="math/tex">\text{prefixOp}</script></span> is <code>{7, 15, 24}</code> and <span><span class="MathJax_Preview">\text{suffixOp}</span><script type="math/tex">\text{suffixOp}</script></span> is <code>{24, 17, 9}</code>.</p>
<p><span><span class="MathJax_Preview">\text{between}</span><script type="math/tex">\text{between}</script></span> array is:</p>
<pre><code>{
    {6, 21, 45},
    {0, 15, 39},
    {0, 0,  24}
}
</code></pre>

<p>(we assume that invalid elements where <span><span class="MathJax_Preview">i &gt; j</span><script type="math/tex">i > j</script></span> are filled with zeroes)</p>
<p>It's obvious to see that these arrays can be easily calculated in <span><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span> time and memory.</p>
<p>We already can answer some queries using these arrays. If the query doesn't fit into one block, we can divide it onto three parts: suffix of a block, then some segment of contiguous blocks and then prefix of some block. We can answer a query by dividing it into three parts and taking our operation of some value from <span><span class="MathJax_Preview">\text{suffixOp}</span><script type="math/tex">\text{suffixOp}</script></span>, then some value from <span><span class="MathJax_Preview">\text{between}</span><script type="math/tex">\text{between}</script></span>, then some value from <span><span class="MathJax_Preview">\text{prefixOp}</span><script type="math/tex">\text{prefixOp}</script></span>.</p>
<p>But if we have queries that entirely fit into one block, we cannot process them using these three arrays. So, we need to do something.</p>
<h3 id="making-a-tree">Making a tree</h3>
<p>We cannot answer only the queries that entirely fit in one block. But what <strong>if we build the same structure as described above for each block?</strong> Yes, we can do it. And we do it recursively, until we reach the block size of <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> or <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span>. Answers for such blocks can be calculated easily in <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>.</p>
<p>So, we get a tree. Each node of the tree represents some segment of the array. Node that represents array segment with size <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> has <span><span class="MathJax_Preview">\sqrt{k}</span><script type="math/tex">\sqrt{k}</script></span> children -- for each block. Also each node contains the three arrays described above for the segment it contains. The root of the tree represents the entire array. Nodes with segment lengths <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> or <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span> are leaves.</p>
<p>Also it's obvious that the height of this tree is <span><span class="MathJax_Preview">O(\log \log n)</span><script type="math/tex">O(\log \log n)</script></span>, because if some vertex of the tree represents an array with length <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>, then its children have length <span><span class="MathJax_Preview">\sqrt{k}</span><script type="math/tex">\sqrt{k}</script></span>. <span><span class="MathJax_Preview">\log(\sqrt{k}) = \frac{\log{k}}{2}</span><script type="math/tex">\log(\sqrt{k}) = \frac{\log{k}}{2}</script></span>, so <span><span class="MathJax_Preview">\log k</span><script type="math/tex">\log k</script></span> decreases two times every layer of the tree and so its height is <span><span class="MathJax_Preview">O(\log \log n)</span><script type="math/tex">O(\log \log n)</script></span>. The time for building and memory usage will be <span><span class="MathJax_Preview">O(n \cdot \log \log n)</span><script type="math/tex">O(n \cdot \log \log n)</script></span>, because every element of the array appears exactly once on each layer of the tree.</p>
<p>Now we can answer the queries in <span><span class="MathJax_Preview">O(\log \log n)</span><script type="math/tex">O(\log \log n)</script></span>. We can go down on the tree until we meet a segment with length <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> or <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span> (answer for it can be calculated in <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> time) or meet the first segment in which our query doesn't fit entirely into one block. See the first section on how to answer the query in this case.</p>
<p>OK, now we can do <span><span class="MathJax_Preview">O(\log \log n)</span><script type="math/tex">O(\log \log n)</script></span> per query. Can it be done faster?</p>
<h3 id="optimizing-the-query-complexity">Optimizing the query complexity</h3>
<p>One of the most obvious optimization is to binary search the tree node we need. Using binary search, we can reach the <span><span class="MathJax_Preview">O(\log \log \log n)</span><script type="math/tex">O(\log \log \log n)</script></span> complexity per query. Can we do it even faster?</p>
<p>The answer is yes. Let's assume the following two things:</p>
<ol>
<li>Each block size is a power of two.</li>
<li>All the blocks are equal on each layer.</li>
</ol>
<p>To reach this, we can add some zero elements to our array so that its size becomes a power of two.</p>
<p>When we use this, some block sizes may become twice larger to be a power of two, but it still be <span><span class="MathJax_Preview">O(\sqrt{k})</span><script type="math/tex">O(\sqrt{k})</script></span> in size and we keep linear complexity for building the arrays in a segment.</p>
<p>Now, we can easily check if the query fits entirely into a block with size <span><span class="MathJax_Preview">2^k</span><script type="math/tex">2^k</script></span>. Let's write the ranges of the query, <span><span class="MathJax_Preview">l</span><script type="math/tex">l</script></span> and <span><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> (we use 0-indexation) in binary form. For instance, let's assume <span><span class="MathJax_Preview">k=4, l=39, r=46</span><script type="math/tex">k=4, l=39, r=46</script></span>. The binary representation of <span><span class="MathJax_Preview">l</span><script type="math/tex">l</script></span> and <span><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> is:</p>
<p><span><span class="MathJax_Preview">l = 39_{10} = 100111_2</span><script type="math/tex">l = 39_{10} = 100111_2</script></span></p>
<p><span><span class="MathJax_Preview">r = 46_{10} = 101110_2</span><script type="math/tex">r = 46_{10} = 101110_2</script></span></p>
<p>Remember that one layer contains segments of the equal size, and the block on one layer have also equal size (in our case, their size is <span><span class="MathJax_Preview">2^k = 2^4 = 16</span><script type="math/tex">2^k = 2^4 = 16</script></span>. The blocks cover the array entirely, so the first block covers elements <span><span class="MathJax_Preview">(0 - 15)</span><script type="math/tex">(0 - 15)</script></span> (<span><span class="MathJax_Preview">(000000_2 - 001111_2)</span><script type="math/tex">(000000_2 - 001111_2)</script></span> in binary), the second one covers elements <span><span class="MathJax_Preview">(16 - 31)</span><script type="math/tex">(16 - 31)</script></span> (<span><span class="MathJax_Preview">(010000_2 - 011111_2)</span><script type="math/tex">(010000_2 - 011111_2)</script></span> in binary) and so on. We see that the indices of the positions covered by one block may differ only in <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> (in our case, <span><span class="MathJax_Preview">4</span><script type="math/tex">4</script></span>) last bits. In our case <span><span class="MathJax_Preview">l</span><script type="math/tex">l</script></span> and <span><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> have equal bits except four lowest, so they lie in one block.</p>
<p>So, we need to check if nothing more that <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> smallest bits differ (or <span><span class="MathJax_Preview">l\ \text{xor}\ r</span><script type="math/tex">l\ \text{xor}\ r</script></span> doesn't exceed <span><span class="MathJax_Preview">2^k-1</span><script type="math/tex">2^k-1</script></span>).</p>
<p>Using this observation, we can find a layer that is suitable to answer the query quickly. How to do this:</p>
<ol>
<li>
<p>For each <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> that doesn't exceed the array size, we find the highest bit that is equal to <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>. To do this quickly, we use DP and a precalculated array.</p>
</li>
<li>
<p>Now, for each <span><span class="MathJax_Preview">q(l, r)</span><script type="math/tex">q(l, r)</script></span> we find the highest bit of <span><span class="MathJax_Preview">l\ \text{xor}\ r</span><script type="math/tex">l\ \text{xor}\ r</script></span> and, using this information, it's easy to choose the layer on which we can process the query easily. We can also use a precalculated array here.</p>
</li>
</ol>
<p>For more details, see the code below.</p>
<p>So, using this, we can answer the queries in <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> each. Hooray! :)</p>
<h2 id="updating-elements">Updating elements</h2>
<p>We can also update elements in Sqrt Tree. Both single element updates and updates on a segment are supported.</p>
<h3 id="updating-a-single-element">Updating a single element</h3>
<p>Consider a query <span><span class="MathJax_Preview">\text{update}(x, val)</span><script type="math/tex">\text{update}(x, val)</script></span> that does the assignment <span><span class="MathJax_Preview">a_x = val</span><script type="math/tex">a_x = val</script></span>. We need to perform this query fast enough.</p>
<h4 id="naive-approach">Naive approach</h4>
<p>First, let's take a look of what is changed in the tree when a single element changes. Consider a tree node with length <span><span class="MathJax_Preview">l</span><script type="math/tex">l</script></span> and its arrays: <span><span class="MathJax_Preview">\text{prefixOp}</span><script type="math/tex">\text{prefixOp}</script></span>, <span><span class="MathJax_Preview">\text{suffixOp}</span><script type="math/tex">\text{suffixOp}</script></span> and <span><span class="MathJax_Preview">\text{between}</span><script type="math/tex">\text{between}</script></span>. It is easy to see that only <span><span class="MathJax_Preview">O(\sqrt{l})</span><script type="math/tex">O(\sqrt{l})</script></span> elements from <span><span class="MathJax_Preview">\text{prefixOp}</span><script type="math/tex">\text{prefixOp}</script></span> and <span><span class="MathJax_Preview">\text{suffixOp}</span><script type="math/tex">\text{suffixOp}</script></span> change (only inside the block with the changed element). <span><span class="MathJax_Preview">O(l)</span><script type="math/tex">O(l)</script></span> elements are changed in <span><span class="MathJax_Preview">\text{between}</span><script type="math/tex">\text{between}</script></span>. Therefore, <span><span class="MathJax_Preview">O(l)</span><script type="math/tex">O(l)</script></span> elements in the tree node are updated.</p>
<p>We remember that any element <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> is present in exactly one tree node at each layer. Root node (layer <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>) has length <span><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span>, nodes on layer <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> have length <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span>, nodes on layer <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span> have length <span><span class="MathJax_Preview">O(\sqrt{\sqrt{n}})</span><script type="math/tex">O(\sqrt{\sqrt{n}})</script></span>, etc. So the time complexity per update is <span><span class="MathJax_Preview">O(n + \sqrt{n} + \sqrt{\sqrt{n}} + \dots) = O(n)</span><script type="math/tex">O(n + \sqrt{n} + \sqrt{\sqrt{n}} + \dots) = O(n)</script></span>.</p>
<p>But it's too slow. Can it be done faster?</p>
<h4 id="an-sqrt-tree-inside-the-sqrt-tree">An sqrt-tree inside the sqrt-tree</h4>
<p>Note that the bottleneck of updating is rebuilding <span><span class="MathJax_Preview">\text{between}</span><script type="math/tex">\text{between}</script></span> of the root node. To optimize the tree, let's get rid of this array! Instead of <span><span class="MathJax_Preview">\text{between}</span><script type="math/tex">\text{between}</script></span> array, we store another sqrt-tree for the root node. Let's call it <span><span class="MathJax_Preview">\text{index}</span><script type="math/tex">\text{index}</script></span>. It plays the same role as <span><span class="MathJax_Preview">\text{between}</span><script type="math/tex">\text{between}</script></span>&mdash; answers the queries on segments of blocks. Note that the rest of the tree nodes don't have <span><span class="MathJax_Preview">\text{index}</span><script type="math/tex">\text{index}</script></span>, they keep their <span><span class="MathJax_Preview">\text{between}</span><script type="math/tex">\text{between}</script></span> arrays.</p>
<p>A sqrt-tree is <em>indexed</em>, if its root node has <span><span class="MathJax_Preview">\text{index}</span><script type="math/tex">\text{index}</script></span>. A sqrt-tree with <span><span class="MathJax_Preview">\text{between}</span><script type="math/tex">\text{between}</script></span> array in its root node is <em>unindexed</em>. Note that <span><span class="MathJax_Preview">\text{index}</span><script type="math/tex">\text{index}</script></span> <strong>is <em>unindexed</em> itself</strong>.</p>
<p>So, we have the following algorithm for updating an <em>indexed</em> tree:</p>
<ul>
<li>
<p>Update <span><span class="MathJax_Preview">\text{prefixOp}</span><script type="math/tex">\text{prefixOp}</script></span> and <span><span class="MathJax_Preview">\text{suffixOp}</span><script type="math/tex">\text{suffixOp}</script></span> in <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span>.</p>
</li>
<li>
<p>Update <span><span class="MathJax_Preview">\text{index}</span><script type="math/tex">\text{index}</script></span>. It has length <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span> and we need to update only one item in it (that represents the changed block). So, the time complexity for this step is <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span>. We can use the algorithm described in the beginning of this section (the "slow" one) to do it.</p>
</li>
<li>
<p>Go into the child node that represents the changed block and update it in <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span> with the "slow" algorithm.</p>
</li>
</ul>
<p>Note that the query complexity is still <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>: we need to use <span><span class="MathJax_Preview">\text{index}</span><script type="math/tex">\text{index}</script></span> in query no more than once, and this will take <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> time.</p>
<p>So, total time complexity for updating a single element is <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span>. Hooray! :)</p>
<h3 id="updating-a-segment">Updating a segment</h3>
<p>Sqrt-tree also can do things like assigning an element on a segment. <span><span class="MathJax_Preview">\text{massUpdate}(x, l, r)</span><script type="math/tex">\text{massUpdate}(x, l, r)</script></span> means <span><span class="MathJax_Preview">a_i = x</span><script type="math/tex">a_i = x</script></span> for all <span><span class="MathJax_Preview">l \le i \le r</span><script type="math/tex">l \le i \le r</script></span>.</p>
<p>There are two approaches to do this: one of them does <span><span class="MathJax_Preview">\text{massUpdate}</span><script type="math/tex">\text{massUpdate}</script></span> in <span><span class="MathJax_Preview">O(\sqrt{n}\cdot \log \log n)</span><script type="math/tex">O(\sqrt{n}\cdot \log \log n)</script></span>, keeping <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> per query. The second one does <span><span class="MathJax_Preview">\text{massUpdate}</span><script type="math/tex">\text{massUpdate}</script></span> in <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span>, but the query complexity becomes <span><span class="MathJax_Preview">O(\log \log n)</span><script type="math/tex">O(\log \log n)</script></span>.</p>
<p>We will do lazy propagation in the same way as it is done in segment trees: we mark some nodes as <em>lazy</em>, meaning that we'll push them when it's necessary. But one thing is different from segment trees: pushing a node is expensive, so it cannot be done in queries. On the layer <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>, pushing a node takes <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span> time. So, we don't push nodes inside queries, we only look if the current node or its parent are <em>lazy</em>, and just take it into account while performing queries.</p>
<h4 id="first-approach">First approach</h4>
<p>In the first approach, we say that only nodes on layer <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> (with length <span><span class="MathJax_Preview">O(\sqrt{n}</span><script type="math/tex">O(\sqrt{n}</script></span>) can be <em>lazy</em>. When pushing such node, it updates all its subtree including itself in <span><span class="MathJax_Preview">O(\sqrt{n}\cdot \log \log n)</span><script type="math/tex">O(\sqrt{n}\cdot \log \log n)</script></span>. The <span><span class="MathJax_Preview">\text{massUpdate}</span><script type="math/tex">\text{massUpdate}</script></span> process is done as follows:</p>
<ul>
<li>
<p>Consider the nodes on layer <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> and blocks corresponding to them.</p>
</li>
<li>
<p>Some blocks are entirely covered by <span><span class="MathJax_Preview">\text{massUpdate}</span><script type="math/tex">\text{massUpdate}</script></span>. Mark them as <em>lazy</em> in <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span>.</p>
</li>
<li>
<p>Some blocks are partially covered. Note there are no more than two blocks of this kind. Rebuild them in <span><span class="MathJax_Preview">O(\sqrt{n}\cdot \log \log n)</span><script type="math/tex">O(\sqrt{n}\cdot \log \log n)</script></span>. If they were <em>lazy</em>, take it into account.</p>
</li>
<li>
<p>Update <span><span class="MathJax_Preview">\text{prefixOp}</span><script type="math/tex">\text{prefixOp}</script></span> and <span><span class="MathJax_Preview">\text{suffixOp}</span><script type="math/tex">\text{suffixOp}</script></span> for partially covered blocks in <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span> (because there are only two such blocks).</p>
</li>
<li>
<p>Rebuild the <span><span class="MathJax_Preview">\text{index}</span><script type="math/tex">\text{index}</script></span> in <span><span class="MathJax_Preview">O(\sqrt{n}\cdot \log \log n)</span><script type="math/tex">O(\sqrt{n}\cdot \log \log n)</script></span>.</p>
</li>
</ul>
<p>So we can do <span><span class="MathJax_Preview">\text{massUpdate}</span><script type="math/tex">\text{massUpdate}</script></span> fast. But how lazy propagation affects queries? They will have the following modifications:</p>
<ul>
<li>
<p>If our query entirely lies in a <em>lazy</em> block, calculate it and take <em>lazy</em> into account. <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>.</p>
</li>
<li>
<p>If our query consists of many blocks, some of which are <em>lazy</em>, we need to take care of <em>lazy</em> only on the leftmost and the rightmost block. The rest of the blocks are calculated using <span><span class="MathJax_Preview">\text{index}</span><script type="math/tex">\text{index}</script></span>, which already knows the answer on <em>lazy</em> block (because it's rebuilt after each modification). <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>.</p>
</li>
</ul>
<p>The query complexity still remains <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>.</p>
<h4 id="second-approach">Second approach</h4>
<p>In this approach, each node can be <em>lazy</em> (except root). Even nodes in <span><span class="MathJax_Preview">\text{index}</span><script type="math/tex">\text{index}</script></span> can be <em>lazy</em>. So, while processing a query, we have to look for <em>lazy</em> tags in all the parent nodes, i. e. query complexity will be <span><span class="MathJax_Preview">O(\log \log n)</span><script type="math/tex">O(\log \log n)</script></span>.</p>
<p>But <span><span class="MathJax_Preview">\text{massUpdate}</span><script type="math/tex">\text{massUpdate}</script></span> becomes faster. It looks in the following way:</p>
<ul>
<li>
<p>Some blocks are fully covered with <span><span class="MathJax_Preview">\text{massUpdate}</span><script type="math/tex">\text{massUpdate}</script></span>. So, <em>lazy</em> tags are added to them. It is <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span>.</p>
</li>
<li>
<p>Update <span><span class="MathJax_Preview">\text{prefixOp}</span><script type="math/tex">\text{prefixOp}</script></span> and <span><span class="MathJax_Preview">\text{suffixOp}</span><script type="math/tex">\text{suffixOp}</script></span> for partially covered blocks in <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span> (because there are only two such blocks).</p>
</li>
<li>
<p>Do not forget to update the index. It is <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span> (we use the same <span><span class="MathJax_Preview">\text{massUpdate}</span><script type="math/tex">\text{massUpdate}</script></span> algorithm).</p>
</li>
<li>
<p>Update <span><span class="MathJax_Preview">\text{between}</span><script type="math/tex">\text{between}</script></span> array for <em>unindexed</em> subtrees.</p>
</li>
<li>
<p>Go into the nodes representing partially covered blocks and call <span><span class="MathJax_Preview">\text{massUpdate}</span><script type="math/tex">\text{massUpdate}</script></span> recursively.</p>
</li>
</ul>
<p>Note that when we do the recursive call, we do prefix or suffix <span><span class="MathJax_Preview">\text{massUpdate}</span><script type="math/tex">\text{massUpdate}</script></span>. But for prefix and suffix updates we can have no more than one partially covered child. So, we visit one node on layer <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>, two nodes on layer <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span> and two nodes on any deeper level. So, the time complexity is <span><span class="MathJax_Preview">O(\sqrt{n} + \sqrt{\sqrt{n}} + \dots) = O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n} + \sqrt{\sqrt{n}} + \dots) = O(\sqrt{n})</script></span>. The approach here is similar to the segment tree mass update.</p>
<h2 id="implementation">Implementation</h2>
<p>The following implementation of Sqrt Tree can perform the following operations: build in <span><span class="MathJax_Preview">O(n \cdot \log \log n)</span><script type="math/tex">O(n \cdot \log \log n)</script></span>, answer queries in <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> and update an element in <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span>.</p>
<pre><code class="cpp">SqrtTreeItem op(const SqrtTreeItem &amp;a, const SqrtTreeItem &amp;b);

inline int log2Up(int n) {
    int res = 0;
    while ((1 &lt;&lt; res) &lt; n) {
        res++;
    }
    return res;
}

class SqrtTree {
private:
    int n, lg, indexSz;
    vector&lt;SqrtTreeItem&gt; v;
    vector&lt;int&gt; clz, layers, onLayer;
    vector&lt; vector&lt;SqrtTreeItem&gt; &gt; pref, suf, between;

    inline void buildBlock(int layer, int l, int r) {
        pref[layer][l] = v[l];
        for (int i = l+1; i &lt; r; i++) {
            pref[layer][i] = op(pref[layer][i-1], v[i]);
        }
        suf[layer][r-1] = v[r-1];
        for (int i = r-2; i &gt;= l; i--) {
            suf[layer][i] = op(v[i], suf[layer][i+1]);
        }
    }

    inline void buildBetween(int layer, int lBound, int rBound, int betweenOffs) {
        int bSzLog = (layers[layer]+1) &gt;&gt; 1;
        int bCntLog = layers[layer] &gt;&gt; 1;
        int bSz = 1 &lt;&lt; bSzLog;
        int bCnt = (rBound - lBound + bSz - 1) &gt;&gt; bSzLog;
        for (int i = 0; i &lt; bCnt; i++) {
            SqrtTreeItem ans;
            for (int j = i; j &lt; bCnt; j++) {
                SqrtTreeItem add = suf[layer][lBound + (j &lt;&lt; bSzLog)];
                ans = (i == j) ? add : op(ans, add);
                between[layer-1][betweenOffs + lBound + (i &lt;&lt; bCntLog) + j] = ans;
            }
        }
    }

    inline void buildBetweenZero() {
        int bSzLog = (lg+1) &gt;&gt; 1;
        for (int i = 0; i &lt; indexSz; i++) {
            v[n+i] = suf[0][i &lt;&lt; bSzLog];
        }
        build(1, n, n + indexSz, (1 &lt;&lt; lg) - n);
    }

    inline void updateBetweenZero(int bid) {
        int bSzLog = (lg+1) &gt;&gt; 1;
        v[n+bid] = suf[0][bid &lt;&lt; bSzLog];
        update(1, n, n + indexSz, (1 &lt;&lt; lg) - n, n+bid);
    }

    void build(int layer, int lBound, int rBound, int betweenOffs) {
        if (layer &gt;= (int)layers.size()) {
            return;
        }
        int bSz = 1 &lt;&lt; ((layers[layer]+1) &gt;&gt; 1);
        for (int l = lBound; l &lt; rBound; l += bSz) {
            int r = min(l + bSz, rBound);
            buildBlock(layer, l, r);
            build(layer+1, l, r, betweenOffs);
        }
        if (layer == 0) {
            buildBetweenZero();
        } else {
            buildBetween(layer, lBound, rBound, betweenOffs);
        }
    }

    void update(int layer, int lBound, int rBound, int betweenOffs, int x) {
        if (layer &gt;= (int)layers.size()) {
            return;
        }
        int bSzLog = (layers[layer]+1) &gt;&gt; 1;
        int bSz = 1 &lt;&lt; bSzLog;
        int blockIdx = (x - lBound) &gt;&gt; bSzLog;
        int l = lBound + (blockIdx &lt;&lt; bSzLog);
        int r = min(l + bSz, rBound);
        buildBlock(layer, l, r);
        if (layer == 0) {
            updateBetweenZero(blockIdx);
        } else {
            buildBetween(layer, lBound, rBound, betweenOffs);
        }
        update(layer+1, l, r, betweenOffs, x);
    }

    inline SqrtTreeItem query(int l, int r, int betweenOffs, int base) {
        if (l == r) {
            return v[l];
        }
        if (l + 1 == r) {
            return op(v[l], v[r]);
        }
        int layer = onLayer[clz[(l - base) ^ (r - base)]];
        int bSzLog = (layers[layer]+1) &gt;&gt; 1;
        int bCntLog = layers[layer] &gt;&gt; 1;
        int lBound = (((l - base) &gt;&gt; layers[layer]) &lt;&lt; layers[layer]) + base;
        int lBlock = ((l - lBound) &gt;&gt; bSzLog) + 1;
        int rBlock = ((r - lBound) &gt;&gt; bSzLog) - 1;
        SqrtTreeItem ans = suf[layer][l];
        if (lBlock &lt;= rBlock) {
            SqrtTreeItem add = (layer == 0) ? (
                query(n + lBlock, n + rBlock, (1 &lt;&lt; lg) - n, n)
            ) : (
                between[layer-1][betweenOffs + lBound + (lBlock &lt;&lt; bCntLog) + rBlock]
            );
            ans = op(ans, add);
        }
        ans = op(ans, pref[layer][r]);
        return ans;
    }
public:
    inline SqrtTreeItem query(int l, int r) {
        return query(l, r, 0, 0);
    }

    inline void update(int x, const SqrtTreeItem &amp;item) {
        v[x] = item;
        update(0, 0, n, 0, x);
    }

    SqrtTree(const vector&lt;SqrtTreeItem&gt;&amp; a)
        : n((int)a.size()), lg(log2Up(n)), v(a), clz(1 &lt;&lt; lg), onLayer(lg+1) {
        clz[0] = 0;
        for (int i = 1; i &lt; (int)clz.size(); i++) {
            clz[i] = clz[i &gt;&gt; 1] + 1;
        }
        int tlg = lg;
        while (tlg &gt; 1) {
            onLayer[tlg] = (int)layers.size();
            layers.push_back(tlg);
            tlg = (tlg+1) &gt;&gt; 1;
        }
        for (int i = lg-1; i &gt;= 0; i--) {
            onLayer[i] = max(onLayer[i], onLayer[i+1]);
        }
        int betweenLayers = max(0, (int)layers.size() - 1);
        int bSzLog = (lg+1) &gt;&gt; 1;
        int bSz = 1 &lt;&lt; bSzLog;
        indexSz = (n + bSz - 1) &gt;&gt; bSzLog;
        v.resize(n + indexSz);
        pref.assign(layers.size(), vector&lt;SqrtTreeItem&gt;(n + indexSz));
        suf.assign(layers.size(), vector&lt;SqrtTreeItem&gt;(n + indexSz));
        between.assign(betweenLayers, vector&lt;SqrtTreeItem&gt;((1 &lt;&lt; lg) + bSz));
        build(0, 0, n, 0);
    }
};

</code></pre>

<h2 id="problems">Problems</h2>
<p><a href="https://www.codechef.com/NOV17/problems/SEGPROD">CodeChef - SEGPROD</a></p>

  <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://d-k-ivanov.github.io/">Main site</a>
      </p><p>Copyright &copy; 2016-2020 Dmitriy Ivanov. <script type="text/javascript"> (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)}; m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)}) (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym"); ym(40819844, "init", { clickmap:true, trackLinks:true, accurateTrackBounce:true }); </script> <noscript><div><img src="https://mc.yandex.ru/watch/40819844" style="position:absolute; left:-9999px;" alt="" /></div></noscript></p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>