<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="Dmitry Ivanov">
    <link rel="canonical" href="https://d-k-ivanov.github.io/docs/Algorithms/Graph_Theory/Depth_First_Search/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Depth First Search - Technical Info</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <link href="../../../css/extra.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Depth First Search", url: "#_top", children: [
              {title: "Description of the algorithm", url: "#description-of-the-algorithm" },
              {title: "Applications of Depth First Search", url: "#applications-of-depth-first-search" },
              {title: "Classification of edges of a graph", url: "#classification-of-edges-of-a-graph" },
              {title: "Implementation", url: "#implementation" },
              {title: "Practice Problems", url: "#practice-problems" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../mathjax-config.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-80208201-1', 'd-k-ivanov.github.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../Dijkstra_Algorithm/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../Dijkstra_Algorithm/" class="btn btn-xs btn-link">
        Dijkstra Algorithm
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../DEsopo-Pape_Algorithm/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../DEsopo-Pape_Algorithm/" class="btn btn-xs btn-link">
        DÂ´Esopo-Pape Algorithm
      </a>
    </div>
    
  </div>

    

    <h1 id="depth-first-search">Depth First Search<a class="headerlink" href="#depth-first-search" title="Permanent link">#</a></h1>
<p>Depth First Search is one of the main graph algorithms.</p>
<p>Depth First Search finds the lexicographical first path in the graph from a source vertex <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> to each vertex.
Depth First Search will also find the shortest paths in a tree (because there only exists one simple path), but on general graphs this is not the case.</p>
<p>The algorithm works in <span><span class="MathJax_Preview">O(m + n)</span><script type="math/tex">O(m + n)</script></span> time where <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> is the number of vertices and <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> is the number of edges.</p>
<h2 id="description-of-the-algorithm">Description of the algorithm<a class="headerlink" href="#description-of-the-algorithm" title="Permanent link">#</a></h2>
<p>The idea behind DFS is to go as deep into the graph as possible, and backtrack once you are at a vertex without any unvisited adjacent vertices.</p>
<p>It is very easy to describe / implement the algorithm recursively:
We start the search at one vertex.
After visiting a vertex, we further perform a DFS for each adjacent vertex that we haven't visited before.
This way we visit all vertices that are reachable from the starting vertex.</p>
<p>For more details check out the implementation.</p>
<h2 id="applications-of-depth-first-search">Applications of Depth First Search<a class="headerlink" href="#applications-of-depth-first-search" title="Permanent link">#</a></h2>
<ul>
<li>
<p>Find any path in the graph from source vertex <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> to all vertices.</p>
</li>
<li>
<p>Find lexicographical first path in the graph from source <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> to all vertices.</p>
</li>
<li>
<p>Check if a vertex in a tree is an ancestor of some other vertex:</p>
</li>
</ul>
<p>At the beginning and end of each search call we remember the entry and exit "time" of each vertex.
  Now you can find the answer for any pair of vertices <span><span class="MathJax_Preview">(i, j)</span><script type="math/tex">(i, j)</script></span> in <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>:
  vertex <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> is an ancestor of vertex <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> if and only if <span><span class="MathJax_Preview">\text{entry}[i] &lt; \text{entry}[j]</span><script type="math/tex">\text{entry}[i] < \text{entry}[j]</script></span> and <span><span class="MathJax_Preview">\text{exit}[i] &gt; \text{exit}[j]</span><script type="math/tex">\text{exit}[i] > \text{exit}[j]</script></span>.</p>
<ul>
<li>
<p>Find the lowest common ancestor (LCA) of two vertices.</p>
</li>
<li>
<p>Topological sorting:</p>
</li>
</ul>
<p>Run a series of depth first searches so as to visit each vertex exactly once in <span><span class="MathJax_Preview">O(n + m)</span><script type="math/tex">O(n + m)</script></span> time.
  The required topological ordering will be the vertices sorted in descending order of exit time.</p>
<ul>
<li>
<p>Check whether a given graph is acyclic and find cycles in a graph. (As mentioned above by counting back edges in every connected components).</p>
</li>
<li>
<p>Find strongly connected components in a directed graph:</p>
</li>
</ul>
<p>First do a topological sorting of the graph.
  Then transpose the graph and run another series of depth first searches in the order defined by the topological sort. For each DFS call the component created by it is a strongly connected component.</p>
<ul>
<li>Find bridges in an undirected graph:</li>
</ul>
<p>First convert the given graph into a directed graph by running a series of depth first searches and making each edge directed as we go through it, in the direction we went. Second, find the strongly connected components in this directed graph. Bridges are the edges whose ends belong to different strongly connected components.</p>
<h2 id="classification-of-edges-of-a-graph">Classification of edges of a graph<a class="headerlink" href="#classification-of-edges-of-a-graph" title="Permanent link">#</a></h2>
<p>We can classify the edges using the entry and exit time of the end nodes <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> and <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> of the edges <span><span class="MathJax_Preview">(u,v)</span><script type="math/tex">(u,v)</script></span>.
These classifications are often used for problems like <a href="/docs/#Algorithms/Graph_Theory/Bridge_Searching/">finding bridges</a> and <a href="/docs/#Algorithms/Graph_Theory/Cut_Points/">finding articulation points</a>.</p>
<p>We perform a DFS and classify the encountered edges using the following rules:</p>
<p>If <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is not visited:</p>
<ul>
<li>Tree Edge - If <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is visited after <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> then edge <span><span class="MathJax_Preview">(u,v)</span><script type="math/tex">(u,v)</script></span> is called a tree edge. In other words, if <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is visited for the first time and <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> is currently being visited then <span><span class="MathJax_Preview">(u,v)</span><script type="math/tex">(u,v)</script></span> is called tree edge.
These edges form a DFS tree and hence the name tree edges.</li>
</ul>
<p>If <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is visited before <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>:</p>
<ul>
<li>
<p>Back edges - If <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is an ancestor of <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, then the edge <span><span class="MathJax_Preview">(u,v)</span><script type="math/tex">(u,v)</script></span> is a back edge. <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is an ancestor exactly if we already entered <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>, but not exited it yet. Back edges complete a cycle as there is a path from ancestor <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> to descendant <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> (in the recursion of DFS) and an edge from descendant <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> to ancestor <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> (back edge), thus a cycle is formed. Cycles can be detected using back edges.</p>
</li>
<li>
<p>Forward Edges - If <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is a descendant of <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, then edge <span><span class="MathJax_Preview">(u, v)</span><script type="math/tex">(u, v)</script></span> is a forward edge. In other words, if we already visited and exited <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> and <span><span class="MathJax_Preview">\text{entry}[u] &lt; \text{entry}[v]</span><script type="math/tex">\text{entry}[u] < \text{entry}[v]</script></span> then the edge <span><span class="MathJax_Preview">(u,v)</span><script type="math/tex">(u,v)</script></span> forms a forward edge.</p>
</li>
<li>Cross Edges: if <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is neither an ancestor or descendant of <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, then edge <span><span class="MathJax_Preview">(u, v)</span><script type="math/tex">(u, v)</script></span> is a cross edge. In other words, if we already visited and exited <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> and <span><span class="MathJax_Preview">\text{entry}[u] &gt; \text{entry}[v]</span><script type="math/tex">\text{entry}[u] > \text{entry}[v]</script></span> then <span><span class="MathJax_Preview">(u,v)</span><script type="math/tex">(u,v)</script></span> is a cross edge.</li>
</ul>
<p>Note: Forward edges and cross edges only exist in directed graphs.</p>
<h2 id="implementation">Implementation<a class="headerlink" href="#implementation" title="Permanent link">#</a></h2>
<pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; adj; // graph represented as an adjacency list
int n; // number of vertices

vector&lt;bool&gt; visited;

void dfs(int v) {
    visited[v] = true;
    for (int u : adj[v]) {
        if (!visited[u])
            dfs(u);
    }
}
</code></pre>
<p>This is the most simple implementation of Depth First Search.
As described in the applications it might be useful to also compute the entry and exit times and vertex color.
We will color all vertices with the color 0, if we haven't visited them, with the color 1 if we visited them, and with the color 2, if we already exited the vertex.</p>
<p>Here is a generic implementation that additionally computes those:</p>
<pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; adj; // graph represented as an adjacency list
int n; // number of vertices

vector&lt;int&gt; color;

vector&lt;int&gt; time_in, time_out;
int dfs_timer = 0;

void dfs(int v) {
    time_in[v] = dfs_timer++;
    color[v] = 1;
    for (int u : adj[v])
        if (color[u] == 0)
            dfs(u);
    color[v] = 2;
    time_out[v] = dfs_timer++;
}
</code></pre>
<h2 id="practice-problems">Practice Problems<a class="headerlink" href="#practice-problems" title="Permanent link">#</a></h2>
<ul>
<li><a href="http://www.spoj.com/problems/ABCPATH/">SPOJ: ABCPATH</a></li>
<li><a href="http://www.spoj.com/problems/EAGLE1/">SPOJ: EAGLE1</a></li>
<li><a href="http://codeforces.com/problemset/problem/580/C">Codeforces: Kefa and Park</a></li>
<li><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1242">Timus:Werewolf</a></li>
<li><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1709">Timus:Penguin Avia</a></li>
<li><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1106">Timus:Two Teams</a></li>
<li><a href="http://www.spoj.com/problems/ADASEA/">SPOJ - Ada and Island</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=598">UVA 657 - The die is cast</a></li>
<li><a href="http://www.spoj.com/problems/KOZE/">SPOJ - Sheep</a></li>
<li><a href="http://www.spoj.com/problems/RIOI_2_3/">SPOJ - Path of the Rightenous Man</a></li>
<li><a href="http://www.spoj.com/problems/MAKEMAZE/">SPOJ - Validate the Maze</a></li>
<li><a href="http://www.spoj.com/problems/GHOSTS/">SPOJ - Ghosts having Fun</a></li>
<li><a href="http://codeforces.com/contest/781/problem/C">Codeforces - Underground Lab</a></li>
<li><a href="https://devskill.com/CodingProblems/ViewProblem/3">DevSkills - Maze Tester</a></li>
<li><a href="https://devskill.com/CodingProblems/ViewProblem/17">DevSkills - Tourist</a></li>
<li><a href="http://codeforces.com/contest/734/problem/E">Codeforces - Anton and Tree</a></li>
<li><a href="http://codeforces.com/contest/727/problem/A">Codeforces - Transformation: From A to B</a></li>
<li><a href="http://codeforces.com/contest/723/problem/E">Codeforces - One Way Reform</a></li>
<li><a href="http://codeforces.com/contest/709/problem/E">Codeforces - Centroids</a></li>
<li><a href="http://codeforces.com/contest/710/problem/E">Codeforces - Generate a String</a></li>
<li><a href="http://codeforces.com/contest/758/problem/E">Codeforces - Broken Tree</a></li>
<li><a href="http://codeforces.com/contest/761/problem/E">Codeforces - Dasha and Puzzle</a></li>
<li><a href="http://codeforces.com/contest/638/problem/B">Codeforces - Making genome In Berland</a></li>
<li><a href="http://codeforces.com/contest/638/problem/C">Codeforces - Road Improvement</a></li>
<li><a href="http://codeforces.com/contest/767/problem/C">Codeforces - Garland</a></li>
<li><a href="http://codeforces.com/contest/794/problem/D">Codeforces - Labeling Cities</a></li>
<li><a href="http://codeforces.com/contest/802/problem/K">Codeforces - Send the Fool Futher!</a></li>
<li><a href="http://codeforces.com/contest/813/problem/C">Codeforces - The tag Game</a></li>
<li><a href="http://codeforces.com/contest/841/problem/D">Codeforces - Leha and Another game about graphs</a></li>
<li><a href="http://codeforces.com/contest/845/problem/G">Codeforces - Shortest path problem</a></li>
<li><a href="http://codeforces.com/contest/844/problem/E">Codeforces - Upgrading Tree</a></li>
<li><a href="http://codeforces.com/contest/849/problem/C">Codeforces - From Y to Y</a></li>
<li><a href="http://codeforces.com/contest/846/problem/E">Codeforces - Chemistry in Berland</a></li>
<li><a href="http://codeforces.com/contest/861/problem/F">Codeforces - Wizards Tour</a></li>
<li><a href="http://codeforces.com/contest/24/problem/A">Codeforces - Ring Road</a></li>
<li><a href="http://codeforces.com/contest/29/problem/C">Codeforces - Mail Stamps</a></li>
<li><a href="http://codeforces.com/contest/29/problem/D">Codeforces - Ant on the Tree</a></li>
<li><a href="http://www.spoj.com/problems/CAC/">SPOJ - Cactus</a></li>
<li><a href="http://www.spoj.com/problems/AMR10J/">SPOJ - Mixing Chemicals</a></li>
</ul>

  <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://d-k-ivanov.github.io/">Main site</a>
      </p><p>Copyright &copy; 2016-2020 Dmitry Ivanov. <script type="text/javascript"> (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)}; m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)}) (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym"); ym(40819844, "init", { clickmap:true, trackLinks:true, accurateTrackBounce:true }); </script> <noscript><div><img src="https://mc.yandex.ru/watch/40819844" style="position:absolute; left:-9999px;" alt="" /></div></noscript></p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>