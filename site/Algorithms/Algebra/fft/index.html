<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="Dmitriy Ivanov">
    <link rel="canonical" href="https://d-k-ivanov.github.io/docs/Algorithms/Algebra/fft/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Fast Fourier transform - Technical Info</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <link href="../../../css/extra.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Fast Fourier transform", url: "#_top", children: [
              {title: "Discrete Fourier transform", url: "#discrete-fourier-transform" },
              {title: "Number theoretic transform", url: "#number-theoretic-transform" },
              {title: "Multiplication with arbitrary modulus", url: "#multiplication-with-arbitrary-modulus" },
              {title: "Applications", url: "#applications" },
              {title: "Practice problems", url: "#practice-problems" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../mathjax-config.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-80208201-1', 'd-k-ivanov.github.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../fibonacci-numbers/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../fibonacci-numbers/" class="btn btn-xs btn-link">
        Fibonacci Numbers
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../factorization/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../factorization/" class="btn btn-xs btn-link">
        Integer factorization
      </a>
    </div>
    
  </div>

    

    <h1 id="fast-fourier-transform">Fast Fourier transform</h1>
<p>In this article we will discuss an algorithm that allows us to multiply two polynomials of length <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span> time, which is better than the trivial multiplication which takes <span><span class="MathJax_Preview">O(n^2)</span><script type="math/tex">O(n^2)</script></span> time.
Obviously also multiplying two long numbers can be reduced to multiplying polynomials, so also two long numbers can be multiplied in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span> time (where <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> is the number of digits in the numbers).</p>
<p>The discovery of the <strong>Fast Fourier transformation (FFT)</strong> is attributed to Cooley and Tukey, who published an algorithm in 1965.
But in fact the FFT has been discovered repeatedly before, but the importance of it was not understood before the inventions of modern computers.
Some researchers attribute the discovery of the FFT to Runge and KÃ¶nig in 1924.
But actually Gauss developed such a method already in 1805, but never published it.</p>
<h2 id="discrete-fourier-transform">Discrete Fourier transform</h2>
<p>Let there be a polynomial of degree <span><span class="MathJax_Preview">n - 1</span><script type="math/tex">n - 1</script></span>:</p>
<div>
<div class="MathJax_Preview">A(x) = a_0 x^0 + a_1 x^1 + \dots + a_{n-1} x^{n-1}</div>
<script type="math/tex; mode=display">A(x) = a_0 x^0 + a_1 x^1 + \dots + a_{n-1} x^{n-1}</script>
</div>
<p>Without loss of generality we assume that <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> - the number of coefficients - is a power of <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span>.
If <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> is not a power of <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span>, then we simply add the missing terms <span><span class="MathJax_Preview">a_i x^i</span><script type="math/tex">a_i x^i</script></span> and set the coefficients <span><span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script></span> to <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>.</p>
<p>The theory of complex numbers tells us that the equation <span><span class="MathJax_Preview">x^n = 1</span><script type="math/tex">x^n = 1</script></span> has <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> complex solutions (called the <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>-th roots of unity), and the solutions are of the form <span><span class="MathJax_Preview">w_{n, k} = e^{\frac{2 k \pi i}{n}}</span><script type="math/tex">w_{n, k} = e^{\frac{2 k \pi i}{n}}</script></span> with <span><span class="MathJax_Preview">k = 0 \dots n-1</span><script type="math/tex">k = 0 \dots n-1</script></span>.
Additionally these complex numbers have some very interesting properties:
e.g. the principal <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>-th root <span><span class="MathJax_Preview">w_n = w_{n, 1} = e^{\frac{2 \pi i}{n}}</span><script type="math/tex">w_n = w_{n, 1} = e^{\frac{2 \pi i}{n}}</script></span> can be used to describe all other <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>-th roots: <span><span class="MathJax_Preview">w_{n, k} = (w_n)^k</span><script type="math/tex">w_{n, k} = (w_n)^k</script></span>.</p>
<p>The <strong>discrete Fourier transform (DFT)</strong> of the polynomial <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> (or equivalently the vector of coefficients <span><span class="MathJax_Preview">(a_0, a_1, \dots, a_{n-1})</span><script type="math/tex">(a_0, a_1, \dots, a_{n-1})</script></span> is defined as the values of the polynomial at the points <span><span class="MathJax_Preview">x = w_{n, k}</span><script type="math/tex">x = w_{n, k}</script></span>, i.e. it is the vector:</p>
<div>
<div class="MathJax_Preview">\begin{align}
\text{DFT}(a_0, a_1, \dots, a_{n-1}) &amp;= (y_0, y_1, \dots, y_{n-1}) \\\\
&amp;= (A(w_{n, 0}), A(w_{n, 1}), \dots, A(w_{n, n-1})) \\\\
&amp;= (A(w_n^0), A(w_n^1), \dots, A(w_n^{n-1}))
\end{align}</div>
<script type="math/tex; mode=display">\begin{align}
\text{DFT}(a_0, a_1, \dots, a_{n-1}) &= (y_0, y_1, \dots, y_{n-1}) \\\\
&= (A(w_{n, 0}), A(w_{n, 1}), \dots, A(w_{n, n-1})) \\\\
&= (A(w_n^0), A(w_n^1), \dots, A(w_n^{n-1}))
\end{align}</script>
</div>
<p>Similarly the <strong>inverse discrete Fourier transform</strong> is defined:
The inverse DFT of values of the polynomial <span><span class="MathJax_Preview">(y_0, y_1, \dots, y_{n-1})</span><script type="math/tex">(y_0, y_1, \dots, y_{n-1})</script></span> are the coefficients of the polynomial <span><span class="MathJax_Preview">(a_0, a_1, \dots, a_{n-1})</span><script type="math/tex">(a_0, a_1, \dots, a_{n-1})</script></span>.</p>
<div>
<div class="MathJax_Preview">\text{InverseDFT}(y_0, y_1, \dots, y_{n-1}) = (a_0, a_1, \dots, a_{n-1})</div>
<script type="math/tex; mode=display">\text{InverseDFT}(y_0, y_1, \dots, y_{n-1}) = (a_0, a_1, \dots, a_{n-1})</script>
</div>
<p>Thus, if a direct DFT computes the values of the polynomial at the points at the <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>-th roots, the inverse DFT can restore the coefficients of the polynomial using those values.</p>
<h3 id="application-of-the-dft-fast-multiplication-of-polynomials">Application of the DFT: fast multiplication of polynomials</h3>
<p>Let there be two polynomials <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> and <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>.
We compute the DFT for each of them: <span><span class="MathJax_Preview">\text{DFT}(A)</span><script type="math/tex">\text{DFT}(A)</script></span> and <span><span class="MathJax_Preview">\text{DFT}(B)</span><script type="math/tex">\text{DFT}(B)</script></span>.</p>
<p>What happens if we multiply these polynomials?
Obviously at each point the values are simply multiplied, i.e.</p>
<div>
<div class="MathJax_Preview">(A \cdot B)(x) = A(x) \cdot B(x).</div>
<script type="math/tex; mode=display">(A \cdot B)(x) = A(x) \cdot B(x).</script>
</div>
<p>This means that if we multiply the vectors <span><span class="MathJax_Preview">\text{DFT}(A)</span><script type="math/tex">\text{DFT}(A)</script></span> and <span><span class="MathJax_Preview">\text{DFT}(B)</span><script type="math/tex">\text{DFT}(B)</script></span> - by multiplying each element of one vector by the corresponding element of the other vector - then we get nothing other than the DFT of the polynomial <span><span class="MathJax_Preview">\text{DFT}(A \cdot B)</span><script type="math/tex">\text{DFT}(A \cdot B)</script></span>:</p>
<div>
<div class="MathJax_Preview">\text{DFT}(A \cdot B) = \text{DFT}(A) \cdot \text{DFT}(B)</div>
<script type="math/tex; mode=display">\text{DFT}(A \cdot B) = \text{DFT}(A) \cdot \text{DFT}(B)</script>
</div>
<p>Finally, applying the inverse DFT, we obtain:</p>
<div>
<div class="MathJax_Preview">A \cdot B = \text{InverseDFT}(\text{DFT}(A) \cdot \text{DFT}(B))</div>
<script type="math/tex; mode=display">A \cdot B = \text{InverseDFT}(\text{DFT}(A) \cdot \text{DFT}(B))</script>
</div>
<p>On the right the product of the two DFTs we mean the pairwise product of the vector elements.
This can be computed in <span><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span> time.
If we can compute the DFT and the inverse DFT in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span>, then we can compute the product of the two polynomials (and consequently also two long numbers) with the same time complexity.</p>
<p>It should be noted, that the two polynomials should have the same degree.
Otherwise the two result vectors of the DFT have different length.
We can accomplish this by adding coefficients with the value <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>.</p>
<p>And also, since the result of the product of two polynomials is a polynomial of degree <span><span class="MathJax_Preview">2 (n - 1)</span><script type="math/tex">2 (n - 1)</script></span>, we have to double the degrees of each polynomial (again by padding <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>s).
From a vector with <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> values we cannot reconstruct the desired polynomial with <span><span class="MathJax_Preview">2n - 1</span><script type="math/tex">2n - 1</script></span> coefficients.</p>
<h3 id="fast-fourier-transform_1">Fast Fourier Transform</h3>
<p>The <strong>fast Fourier transform</strong> is a method that allows computing the DFT in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span> time.
The basic idea of the FFT is to apply divide and conquer.
We divide the coefficient vector of the polynomial into two vectors, recursively compute the DFT for each of them, and combine the results to compute the DFT of the complete polynomial.</p>
<p>So let there be a polynomial <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> with degree <span><span class="MathJax_Preview">n - 1</span><script type="math/tex">n - 1</script></span>, where <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> is a power of <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span>, and <span><span class="MathJax_Preview">n &gt; 1</span><script type="math/tex">n > 1</script></span>:
<span><span class="MathJax_Preview"><span><span class="MathJax_Preview">A(x) = a_0 x^0 + a_1 x^1 + \dots + a_{n-1} x^{n-1}</span><script type="math/tex">A(x) = a_0 x^0 + a_1 x^1 + \dots + a_{n-1} x^{n-1}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">A(x) = a_0 x^0 + a_1 x^1 + \dots + a_{n-1} x^{n-1}</span><script type="math/tex">A(x) = a_0 x^0 + a_1 x^1 + \dots + a_{n-1} x^{n-1}</script></span></script></span></p>
<p>We divide it into two smaller polynomials, the one containing only the coefficients of the even positions, and the one containing the coefficients of the odd positions:</p>
<div>
<div class="MathJax_Preview">\begin{align}
A_0(x) &amp;= a_0 x^0 + a_2 x^1 + \dots + a_{n-2} x^{\frac{n}{2}-1} \\\\
A_1(x) &amp;= a_1 x^0 + a_3 x^1 + \dots + a_{n-1} x^{\frac{n}{2}-1}
\end{align}</div>
<script type="math/tex; mode=display">\begin{align}
A_0(x) &= a_0 x^0 + a_2 x^1 + \dots + a_{n-2} x^{\frac{n}{2}-1} \\\\
A_1(x) &= a_1 x^0 + a_3 x^1 + \dots + a_{n-1} x^{\frac{n}{2}-1}
\end{align}</script>
</div>
<p>It is easy to see that</p>
<div>
<div class="MathJax_Preview">A(x) = A_0(x^2) + x A_1(x^2).</div>
<script type="math/tex; mode=display">A(x) = A_0(x^2) + x A_1(x^2).</script>
</div>
<p>The polynomials <span><span class="MathJax_Preview">A_0</span><script type="math/tex">A_0</script></span> and <span><span class="MathJax_Preview">A_1</span><script type="math/tex">A_1</script></span> are only half as much coefficients as the polynomial <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span>.
If we can compute the <span><span class="MathJax_Preview">\text{DFT}(A)</span><script type="math/tex">\text{DFT}(A)</script></span> in linear time using <span><span class="MathJax_Preview">\text{DFT}(A_0)</span><script type="math/tex">\text{DFT}(A_0)</script></span> and <span><span class="MathJax_Preview">\text{DFT}(A_1)</span><script type="math/tex">\text{DFT}(A_1)</script></span>, then we get the recurrence <span><span class="MathJax_Preview">T_{\text{DFT}}(n) = 2 T_{\text{DFT}}\left(\frac{n}{2}\right) + O(n)</span><script type="math/tex">T_{\text{DFT}}(n) = 2 T_{\text{DFT}}\left(\frac{n}{2}\right) + O(n)</script></span> for the time complexity, which results in <span><span class="MathJax_Preview">T_{\text{DFT}}(n) = O(n \log n)</span><script type="math/tex">T_{\text{DFT}}(n) = O(n \log n)</script></span> by the <strong>master theorem</strong>.</p>
<p>Let's learn how we can accomplish that.</p>
<p>Suppose we have computed the vectors <span><span class="MathJax_Preview">\left(y_k^0\right)\_{k=0}^{n/2-1} = \text{DFT}(A_0)</span><script type="math/tex">\left(y_k^0\right)\_{k=0}^{n/2-1} = \text{DFT}(A_0)</script></span> and <span><span class="MathJax_Preview">\left(y_k^1\right)\_{k=0}^{n/2-1} = \text{DFT}(A_1)</span><script type="math/tex">\left(y_k^1\right)\_{k=0}^{n/2-1} = \text{DFT}(A_1)</script></span>.
Let us find a expression for <span><span class="MathJax_Preview">\left(y_k\right)_{k=0}^{n-1} = \text{DFT}(A)</span><script type="math/tex">\left(y_k\right)_{k=0}^{n-1} = \text{DFT}(A)</script></span>.</p>
<p>For the first <span><span class="MathJax_Preview">\frac{n}{2}</span><script type="math/tex">\frac{n}{2}</script></span> values we can just use the previously noted equation <span><span class="MathJax_Preview">A(x) = A_0(x^2) + x A_1(x^2)</span><script type="math/tex">A(x) = A_0(x^2) + x A_1(x^2)</script></span>:</p>
<div>
<div class="MathJax_Preview">y_k = y_k^0 + w_n^k y_k^1, \quad k = 0 \dots \frac{n}{2} - 1.</div>
<script type="math/tex; mode=display">y_k = y_k^0 + w_n^k y_k^1, \quad k = 0 \dots \frac{n}{2} - 1.</script>
</div>
<p>However for the second <span><span class="MathJax_Preview">\frac{n}{2}</span><script type="math/tex">\frac{n}{2}</script></span> values we need to find a slightly, different expression:</p>
<div>
<div class="MathJax_Preview">\begin{align}
y_{k+n/2} &amp;= A\left(w_n^{k+n/2}\right) \\\\
&amp;= A_0\left(w_n^{2k+n}\right) + w_n^{k + n/2} A_1\left(w_n^{2k+n}\right) \\\\
&amp;= A_0\left(w_n^{2k} w_n^n\right) + w_n^k w_n^{n/2} A_1\left(w_n^{2k} w_n^n\right) \\\\
&amp;= A_0\left(w_n^{2k}\right) - w_n^k A_1\left(w_n^{2k}\right) \\\\
&amp;= y_k^0 - w_n^k y_k^1
\end{align}</div>
<script type="math/tex; mode=display">\begin{align}
y_{k+n/2} &= A\left(w_n^{k+n/2}\right) \\\\
&= A_0\left(w_n^{2k+n}\right) + w_n^{k + n/2} A_1\left(w_n^{2k+n}\right) \\\\
&= A_0\left(w_n^{2k} w_n^n\right) + w_n^k w_n^{n/2} A_1\left(w_n^{2k} w_n^n\right) \\\\
&= A_0\left(w_n^{2k}\right) - w_n^k A_1\left(w_n^{2k}\right) \\\\
&= y_k^0 - w_n^k y_k^1
\end{align}</script>
</div>
<p>Here we used again <span><span class="MathJax_Preview">A(x) = A_0(x^2) + x A_1(x^2)</span><script type="math/tex">A(x) = A_0(x^2) + x A_1(x^2)</script></span> and the two identities <span><span class="MathJax_Preview">w_n^n = 1</span><script type="math/tex">w_n^n = 1</script></span> and <span><span class="MathJax_Preview">w_n^{n/2} = -1</span><script type="math/tex">w_n^{n/2} = -1</script></span>.</p>
<p>Therefore we get the desired formulas for computing the whole vector <span><span class="MathJax_Preview">(y_k)</span><script type="math/tex">(y_k)</script></span>:</p>
<div>
<div class="MathJax_Preview">\begin{align}
y_k &amp;= y_k^0 + w_n^k y_k^1, &amp;\quad k = 0 \dots \frac{n}{2} - 1, \\\\
y_{k+n/2} &amp;= y_k^0 - w_n^k y_k^1, &amp;\quad k = 0 \dots \frac{n}{2} - 1.
\end{align}</div>
<script type="math/tex; mode=display">\begin{align}
y_k &= y_k^0 + w_n^k y_k^1, &\quad k = 0 \dots \frac{n}{2} - 1, \\\\
y_{k+n/2} &= y_k^0 - w_n^k y_k^1, &\quad k = 0 \dots \frac{n}{2} - 1.
\end{align}</script>
</div>
<p>(This pattern <span><span class="MathJax_Preview">a + b</span><script type="math/tex">a + b</script></span> and <span><span class="MathJax_Preview">a - b</span><script type="math/tex">a - b</script></span> is sometimes called a <strong>butterfly</strong>.)</p>
<p>Thus we learned how to compute the DFT in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span> time.</p>
<h3 id="inverse-fft">Inverse FFT</h3>
<p>Let the vector <span><span class="MathJax_Preview">(y_0, y_1, \dots y_{n-1})</span><script type="math/tex">(y_0, y_1, \dots y_{n-1})</script></span> - the values of polynomial <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> of degree <span><span class="MathJax_Preview">n - 1</span><script type="math/tex">n - 1</script></span> in the points <span><span class="MathJax_Preview">x = w_n^k</span><script type="math/tex">x = w_n^k</script></span> - be given.
We want to restore the coefficients <span><span class="MathJax_Preview">(a_0, a_1, \dots, a_{n-1})</span><script type="math/tex">(a_0, a_1, \dots, a_{n-1})</script></span> of the polynomial.
This known problem is called <strong>interpolation</strong>, and there are general algorithms for solving it.
But in this special case (since we know the values of the points at the roots of unity), we can obtains a much simpler algorithm (that is practically the same as the direct FFT).</p>
<p>We can write the DFT, according to its definition, in the matrix form:</p>
<div>
<div class="MathJax_Preview">
\begin{pmatrix}
w_n^0 &amp; w_n^0 &amp; w_n^0 &amp; w_n^0 &amp; \cdots &amp; w_n^0 \\\\
w_n^0 &amp; w_n^1 &amp; w_n^2 &amp; w_n^3 &amp; \cdots &amp; w_n^{n-1} \\\\
w_n^0 &amp; w_n^2 &amp; w_n^4 &amp; w_n^6 &amp; \cdots &amp; w_n^{2(n-1)} \\\\
w_n^0 &amp; w_n^3 &amp; w_n^6 &amp; w_n^9 &amp; \cdots &amp; w_n^{3(n-1)} \\\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\
w_n^0 &amp; w_n^{n-1} &amp; w_n^{2(n-1)} &amp; w_n^{3(n-1)} &amp; \cdots &amp; w_n^{(n-1)(n-1)}
\end{pmatrix} \begin{pmatrix}
a_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \vdots \\\\ a_{n-1}
\end{pmatrix} = \begin{pmatrix}
y_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \vdots \\\\ y_{n-1}
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\begin{pmatrix}
w_n^0 & w_n^0 & w_n^0 & w_n^0 & \cdots & w_n^0 \\\\
w_n^0 & w_n^1 & w_n^2 & w_n^3 & \cdots & w_n^{n-1} \\\\
w_n^0 & w_n^2 & w_n^4 & w_n^6 & \cdots & w_n^{2(n-1)} \\\\
w_n^0 & w_n^3 & w_n^6 & w_n^9 & \cdots & w_n^{3(n-1)} \\\\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\\\
w_n^0 & w_n^{n-1} & w_n^{2(n-1)} & w_n^{3(n-1)} & \cdots & w_n^{(n-1)(n-1)}
\end{pmatrix} \begin{pmatrix}
a_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \vdots \\\\ a_{n-1}
\end{pmatrix} = \begin{pmatrix}
y_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \vdots \\\\ y_{n-1}
\end{pmatrix}
</script>
</div>
<p>This matrix is called the <strong>Vandermonde matrix</strong>.</p>
<p>Thus we can compute the vector <span><span class="MathJax_Preview">(a_0, a_1, \dots, a_{n-1})</span><script type="math/tex">(a_0, a_1, \dots, a_{n-1})</script></span> by multiplying the vector <span><span class="MathJax_Preview">(y_0, y_1, \dots y_{n-1})</span><script type="math/tex">(y_0, y_1, \dots y_{n-1})</script></span> from the left with the inverse of the matrix:</p>
<div>
<div class="MathJax_Preview">
\begin{pmatrix}
a_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \vdots \\\\ a_{n-1}
\end{pmatrix} = \begin{pmatrix}
w_n^0 &amp; w_n^0 &amp; w_n^0 &amp; w_n^0 &amp; \cdots &amp; w_n^0 \\\\
w_n^0 &amp; w_n^1 &amp; w_n^2 &amp; w_n^3 &amp; \cdots &amp; w_n^{n-1} \\\\
w_n^0 &amp; w_n^2 &amp; w_n^4 &amp; w_n^6 &amp; \cdots &amp; w_n^{2(n-1)} \\\\
w_n^0 &amp; w_n^3 &amp; w_n^6 &amp; w_n^9 &amp; \cdots &amp; w_n^{3(n-1)} \\\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\
w_n^0 &amp; w_n^{n-1} &amp; w_n^{2(n-1)} &amp; w_n^{3(n-1)} &amp; \cdots &amp; w_n^{(n-1)(n-1)}
\end{pmatrix}^{-1} \begin{pmatrix}
y_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \vdots \\\\ y_{n-1}
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\begin{pmatrix}
a_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \vdots \\\\ a_{n-1}
\end{pmatrix} = \begin{pmatrix}
w_n^0 & w_n^0 & w_n^0 & w_n^0 & \cdots & w_n^0 \\\\
w_n^0 & w_n^1 & w_n^2 & w_n^3 & \cdots & w_n^{n-1} \\\\
w_n^0 & w_n^2 & w_n^4 & w_n^6 & \cdots & w_n^{2(n-1)} \\\\
w_n^0 & w_n^3 & w_n^6 & w_n^9 & \cdots & w_n^{3(n-1)} \\\\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\\\
w_n^0 & w_n^{n-1} & w_n^{2(n-1)} & w_n^{3(n-1)} & \cdots & w_n^{(n-1)(n-1)}
\end{pmatrix}^{-1} \begin{pmatrix}
y_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \vdots \\\\ y_{n-1}
\end{pmatrix}
</script>
</div>
<p>A quick check can verify that the inverse of the matrix has the following form:</p>
<div>
<div class="MathJax_Preview">
\frac{1}{n}
\begin{pmatrix}
w_n^0 &amp; w_n^0 &amp; w_n^0 &amp; w_n^0 &amp; \cdots &amp; w_n^0 \\\\
w_n^0 &amp; w_n^{-1} &amp; w_n^{-2} &amp; w_n^{-3} &amp; \cdots &amp; w_n^{-(n-1)} \\\\
w_n^0 &amp; w_n^{-2} &amp; w_n^{-4} &amp; w_n^{-6} &amp; \cdots &amp; w_n^{-2(n-1)} \\\\
w_n^0 &amp; w_n^{-3} &amp; w_n^{-6} &amp; w_n^{-9} &amp; \cdots &amp; w_n^{-3(n-1)} \\\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\
w_n^0 &amp; w_n^{-(n-1)} &amp; w_n^{-2(n-1)} &amp; w_n^{-3(n-1)} &amp; \cdots &amp; w_n^{-(n-1)(n-1)}
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\frac{1}{n}
\begin{pmatrix}
w_n^0 & w_n^0 & w_n^0 & w_n^0 & \cdots & w_n^0 \\\\
w_n^0 & w_n^{-1} & w_n^{-2} & w_n^{-3} & \cdots & w_n^{-(n-1)} \\\\
w_n^0 & w_n^{-2} & w_n^{-4} & w_n^{-6} & \cdots & w_n^{-2(n-1)} \\\\
w_n^0 & w_n^{-3} & w_n^{-6} & w_n^{-9} & \cdots & w_n^{-3(n-1)} \\\\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\\\
w_n^0 & w_n^{-(n-1)} & w_n^{-2(n-1)} & w_n^{-3(n-1)} & \cdots & w_n^{-(n-1)(n-1)}
\end{pmatrix}
</script>
</div>
<p>Thus we obtain the formula:</p>
<div>
<div class="MathJax_Preview">a_k = \frac{1}{n} \sum_{j=0}^{n-1} y_j w_n^{-k j}</div>
<script type="math/tex; mode=display">a_k = \frac{1}{n} \sum_{j=0}^{n-1} y_j w_n^{-k j}</script>
</div>
<p>Comparing this to the formula for <span><span class="MathJax_Preview">y_k</span><script type="math/tex">y_k</script></span></p>
<div>
<div class="MathJax_Preview">y_k = \sum_{j=0}^{n-1} a_j w_n^{k j},</div>
<script type="math/tex; mode=display">y_k = \sum_{j=0}^{n-1} a_j w_n^{k j},</script>
</div>
<p>we notice that these problems are almost the same, so the coefficients <span><span class="MathJax_Preview">a_k</span><script type="math/tex">a_k</script></span> can be found by the same divide and conquer algorithm, as well as the direct FFT, only instead of <span><span class="MathJax_Preview">w_n^k</span><script type="math/tex">w_n^k</script></span> we have to use <span><span class="MathJax_Preview">w_n^{-k}</span><script type="math/tex">w_n^{-k}</script></span>, and at the end we need to divide the resulting coefficients by <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>.</p>
<p>Thus the computation of the inverse DFT is almost the same as the calculation of the direct DFT, and it also can be performed in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span> time.</p>
<h3 id="implementation">Implementation</h3>
<p>Here we present a simple recursive <strong>implementation of the FFT</strong> and the inverse FFT, both in one function, since the difference between the forward and the inverse FFT are so minimal.
To store the complex numbers we use the complex type in the C++ STL.</p>
<p>```cpp fft_recursive
using cd = complex<double>;
const double PI = acos(-1);</p>
<p>void fft(vector<cd> &amp; a, bool invert) {
    int n = a.size();
    if (n == 1)
        return;</p>
<pre><code>vector&lt;cd&gt; a0(n / 2), a1(n / 2);
for (int i = 0; 2 * i &lt; n; i++) {
    a0[i] = a[2*i];
    a1[i] = a[2*i+1];
}
fft(a0, invert);
fft(a1, invert);

double ang = 2 * PI / n * (invert ? -1 : 1);
cd w(1), wn(cos(ang), sin(ang));
for (int i = 0; 2 * i &lt; n; i++) {
    a[i] = a0[i] + w * a1[i];
    a[i + n/2] = a0[i] - w * a1[i];
    if (invert) {
        a[i] /= 2;
        a[i + n/2] /= 2;
    }
    w *= wn;
}
</code></pre>
<p>}</p>
<pre><code>
The function gets passed a vector of coefficients, and the function will compute the DFT or inverse DFT and store the result again in this vector.
The argument $\text{invert}$ shows whether the direct or the inverse DFT should be computed.
Inside the function we first check if the length of the vector is equal to one, if this is the case then we don't have to do anything.
Otherwise we divide the vector $a$ into two vectors $a0$ and $a1$ and compute the DFT for both recursively.
Then we initialize the value $wn$ and a variable $w$, which will contain the current power of $wn$.
Then the values of the resulting DFT are computed using the above formulas.

If the flag $\text{invert}$ is set, then we replace $wn$ with $wn^{-1}$, and each of the values of the result is divided by $2$ (since this will be done in each level of the recursion, this will end up dividing the final values by $n$).

Using this function we can create a function for **multiplying two polynomials**:

```cpp fft_multiply
vector&lt;int&gt; multiply(vector&lt;int&gt; const&amp; a, vector&lt;int&gt; const&amp; b) {
    vector&lt;cd&gt; fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n = 1;
    while (n &lt; a.size() + b.size())
        n &lt;&lt;= 1;
    fa.resize(n);
    fb.resize(n);

    fft(fa, false);
    fft(fb, false);
    for (int i = 0; i &lt; n; i++)
        fa[i] *= fb[i];
    fft(fa, true);

    vector&lt;int&gt; result(n);
    for (int i = 0; i &lt; n; i++)
        result[i] = round(fa[i].real());
    return result;
}
</code></pre>

<p>This function works with polynomials with integer coefficients, however you can also adjust it to work with other types.
Since there is some error when working with complex numbers, we need round the resulting coefficients at the end.</p>
<p>Finally the function for <strong>multiplying</strong> two long numbers practically doesn't differ from the function for multiplying polynomials.
The only thing we have to do afterwards, is to normalize the number:</p>
<pre><code class="cpp">    int carry = 0;
    for (int i = 0; i &lt; n; i++)
        result[i] += carry;
        carry = result[i] / 10;
        result[i] %= 10;
    }
</code></pre>

<p>Since the length of the product of two numbers never exceed the total length of both numbers, the size of the vector is enough to perform all carry operations.</p>
<h3 id="improved-implementation-in-place-computation">Improved implementation: in-place computation</h3>
<p>To increase the efficiency we will switch from the recursive implementation to an iterative one.
In the above recursive implementation we explicitly separated the vector <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> into two vectors - the element on the even positions got assigned to one temporary vector, and the elements on odd positions to another.
However if we reorder the elements in a certain way, we don't need to create these temporary vectors (i.e. all the calculations can be done "in-place", right in the vector <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> itself).</p>
<p>Note that at the first recursion level, the elements whose lowest bit of the position was zero got assigned to the vector <span><span class="MathJax_Preview">a_0</span><script type="math/tex">a_0</script></span>, and the ones with a one as the lowest bit of the position got assigned to <span><span class="MathJax_Preview">a_1</span><script type="math/tex">a_1</script></span>.
In the second recursion level the same thing happens, but with the second lowest bit instead, etc.
Therefore if we reverse the bits of the position of each coefficient, and sort them by these reversed values, we get the desired order (it is called the bit-reversal permutation).</p>
<p>For example the desired order for <span><span class="MathJax_Preview">n = 8</span><script type="math/tex">n = 8</script></span> has the form:</p>
<div>
<div class="MathJax_Preview">a = \left\\{ \left[ (a_0, a_4), (a_2, a_6) \right], \left[ (a_1, a_5), (a_3, a_7) \right] \right\\}</div>
<script type="math/tex; mode=display">a = \left\\{ \left[ (a_0, a_4), (a_2, a_6) \right], \left[ (a_1, a_5), (a_3, a_7) \right] \right\\}</script>
</div>
<p>Indeed in the first recursion level (surrounded by curly braces), the vector gets divided into two parts <span><span class="MathJax_Preview">[a_0, a_2, a_4, a_6]</span><script type="math/tex">[a_0, a_2, a_4, a_6]</script></span> and <span><span class="MathJax_Preview">[a_1, a_3, a_5, a_7]</span><script type="math/tex">[a_1, a_3, a_5, a_7]</script></span>.
As we see, in the bit-reversal permutation this corresponds to simply dividing the vector into two halves: the first <span><span class="MathJax_Preview">\frac{n}{2}</span><script type="math/tex">\frac{n}{2}</script></span> elements and the last <span><span class="MathJax_Preview">\frac{n}{2}</span><script type="math/tex">\frac{n}{2}</script></span> elements.
Then there is a recursive call for each halve.
Let the resulting DFT for each of them be returned in place of the elements themselves (i.e. the first half and the second half of the vector <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> respectively.</p>
<div>
<div class="MathJax_Preview">a = \left\\{[y_0^0, y_1^0, y_2^0, y_3^0], [y_0^1, y_1^1, y_2^1, y_3^1]\right\\}</div>
<script type="math/tex; mode=display">a = \left\\{[y_0^0, y_1^0, y_2^0, y_3^0], [y_0^1, y_1^1, y_2^1, y_3^1]\right\\}</script>
</div>
<p>Now we want to combine the two DFTs into one for the complete vector.
The order of the elements is ideal, and we can also perform the union directly in this vector.
We can take the elements <span><span class="MathJax_Preview">y_0^0</span><script type="math/tex">y_0^0</script></span> and <span><span class="MathJax_Preview">y_0^1</span><script type="math/tex">y_0^1</script></span> and perform the butterfly transform.
The place of the resulting two values is the same as the place of the two initial values, so we get:</p>
<div>
<div class="MathJax_Preview">a = \left\\{[y_0^0 + w_n^0 y_0^1, y_1^0, y_2^0, y_3^0], [y_0^0 - w_n^0 y_0^1, y_1^1, y_2^1, y_3^1]\right\\}</div>
<script type="math/tex; mode=display">a = \left\\{[y_0^0 + w_n^0 y_0^1, y_1^0, y_2^0, y_3^0], [y_0^0 - w_n^0 y_0^1, y_1^1, y_2^1, y_3^1]\right\\}</script>
</div>
<p>Similarly we can compute the butterfly transform of <span><span class="MathJax_Preview">y_1^0</span><script type="math/tex">y_1^0</script></span> and <span><span class="MathJax_Preview">y_1^1</span><script type="math/tex">y_1^1</script></span> and put the results in their place, and so on.
As a result we get:</p>
<div>
<div class="MathJax_Preview">a = \left\\{[y_0^0 + w_n^0 y_0^1, y_1^0 + w_n^1 y_1^1, y_2^0 + w_n^2 y_2^1, y_3^0 + w_n^3 y_3^1], [y_0^0 - w_n^0 y_0^1, y_1^0 - w_n^1 y_1^1, y_2^0 - w_n^2 y_2^1, y_3^0 - w_n^3 y_3^1]\right\\}</div>
<script type="math/tex; mode=display">a = \left\\{[y_0^0 + w_n^0 y_0^1, y_1^0 + w_n^1 y_1^1, y_2^0 + w_n^2 y_2^1, y_3^0 + w_n^3 y_3^1], [y_0^0 - w_n^0 y_0^1, y_1^0 - w_n^1 y_1^1, y_2^0 - w_n^2 y_2^1, y_3^0 - w_n^3 y_3^1]\right\\}</script>
</div>
<p>Thus we computed the required DFT from the vector <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>.</p>
<p>Here we described the process of computing the DFT only at the first recursion level, but the same works obviously also for all other levels.
Thus, after applying the bit-reversal permutation, we can compute the DFT in-place, without any additional memory.</p>
<p>This additionally allows us to get rid of the recursion.
We just start at the lowest level, i.e. we divide the vector into pairs and apply the butterfly transform to them.
This results with the vector <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> with the work of the last level applied.
In the next step we divide the vector into vectors of size <span><span class="MathJax_Preview">4</span><script type="math/tex">4</script></span>, and again apply the butterfly transform, which gives us the DFT for each block of size <span><span class="MathJax_Preview">4</span><script type="math/tex">4</script></span>.
And so on.
Finally in the last step we obtained the result of the DFTs of both halves of <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>, and by applying the butterfly transform we obtain the DFT for the complete vector <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>.</p>
<p>```cpp fft_implementation_iterative
using cd = complex<double>;
const double PI = acos(-1);</p>
<p>int reverse(int num, int lg_n) {
    int res = 0;
    for (int i = 0; i &lt; lg_n; i++) {
        if (num &amp; (1 &lt;&lt; i))
            res |= 1 &lt;&lt; (lg_n - 1 - i);
    }
    return res;
}</p>
<p>void fft(vector<cd> &amp; a, bool invert) {
    int n = a.size();
    int lg_n = 0;
    while ((1 &lt;&lt; lg_n) &lt; n)
        lg_n++;</p>
<pre><code>for (int i = 0; i &lt; n; i++) {
    if (i &lt; reverse(i, lg_n))
        swap(a[i], a[reverse(i, lg_n)]);
}

for (int len = 2; len &lt;= n; len &lt;&lt;= 1) {
    double ang = 2 * PI / len * (invert ? -1 : 1);
    cd wlen(cos(ang), sin(ang));
    for (int i = 0; i &lt; n; i += len) {
        cd w(1);
        for (int j = 0; j &lt; len / 2; j++) {
            cd u = a[i+j], v = a[i+j+len/2] * w;
            a[i+j] = u + v;
            a[i+j+len/2] = u - v;
            w *= wlen;
        }
    }
}

if (invert) {
    for (cd &amp; x : a)
        x /= n;
}
</code></pre>
<p>}</p>
<pre><code>
At first we apply the bit-reversal permutation by swapping the each element with the element of the reversed position.
Then the $\log n - 1$ states of the algorithm we compute the DFT for each block of the corresponding size $\text{len}$.
For all those blocks we have the same root of unity $\text{wlen}$.
We iterate all blocks and perform the butterfly transform on each of them.

We can further optimize the reversal of the bits.
In the previous implementation we iterated all bits of the index and created the bitwise reversed index.
However we can reverse the bits in a different way.

Suppose that $j$ already contains the reverse of $i$.
Then by to go to $i + 1$, we have to increment $i$, and we also have to increment $j$, but in a &quot;reversed&quot; number system.
Adding one in the conventional binary system is equivalent to flip all tailing ones into zeros and flipping the zero right before them into a one.
Equivalently in the &quot;reversed&quot; number system, we flip all leading ones, and the also the next zero.

Thus we get the following implementation:

```cpp fft_implementation_iterative_opt
using cd = complex&lt;double&gt;;
const double PI = acos(-1);

void fft(vector&lt;cd&gt; &amp; a, bool invert) {
    int n = a.size();

    for (int i = 1, j = 0; i &lt; n; i++) {
        int bit = n &gt;&gt; 1;
        for (; j &amp; bit; bit &gt;&gt;= 1)
            j ^= bit;
        j ^= bit;

        if (i &lt; j)
            swap(a[i], a[j]);
    }

    for (int len = 2; len &lt;= n; len &lt;&lt;= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (int i = 0; i &lt; n; i += len) {
            cd w(1);
            for (int j = 0; j &lt; len / 2; j++) {
                cd u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }

    if (invert) {
        for (cd &amp; x : a)
            x /= n;
    }
}
</code></pre>

<p>Additionally we can precompute the bit-reversal permutation beforehand.
This is especially useful when the size <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> is the same for all calls.
But even when we only have three calls (which are necessary for multiplying two polynomials), the effect is noticeable.
Also we can precompute all roots of unity and their powers.</p>
<h2 id="number-theoretic-transform">Number theoretic transform</h2>
<p>Now we switch the objective a little bit.
We still want to multiply two polynomials in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span> time, but this time we want to compute the coefficients modulo some prime number <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>.
Of course for this task we can use the normal DFT and apply the modulo operator to the result.
However, doing so might lead to rounding errors, especially when dealing with large numbers.
The <strong>number theoretic transform (NTT)</strong> has the advantage, that it only works with integer, and therefore the result are guaranteed to be correct.</p>
<p>The discrete Fourier transform is based on complex numbers, and the <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>-th roots of unity.
To efficiently compute it, we extensively use properties of the roots (e.g. that there is one root that generates all other roots by exponentiation).</p>
<p>But the same properties hold for the <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>-th roots of unity in modular arithmetic.
A <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>-th root of unity under a primitive field is such a number <span><span class="MathJax_Preview">w_n</span><script type="math/tex">w_n</script></span> that satisfies:</p>
<div>
<div class="MathJax_Preview">\begin{align}
(w_n)^n &amp;= 1 \pmod{p}, \\\\
(w_n)^k &amp;\ne 1 \pmod{p}, \quad 1 \le k &lt; n.
\end{align}</div>
<script type="math/tex; mode=display">\begin{align}
(w_n)^n &= 1 \pmod{p}, \\\\
(w_n)^k &\ne 1 \pmod{p}, \quad 1 \le k < n.
\end{align}</script>
</div>
<p>The other <span><span class="MathJax_Preview">n-1</span><script type="math/tex">n-1</script></span> roots can be obtained as powers of the root <span><span class="MathJax_Preview">w_n</span><script type="math/tex">w_n</script></span>.</p>
<p>To apply it in the fast Fourier transform algorithm, we need a root to exist for some <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>, which is a power of <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span>, and also for all smaller powers.
We can notice the following interesting property:</p>
<div>
<div class="MathJax_Preview">\begin{align}
(w_n^2)^m = w_n^n &amp;= 1 \pmod{p}, \quad \text{with } m = \frac{n}{2}\\\\
(w_n^2)^k = w_n^{2k} &amp;\ne 1 \pmod{p}, \quad 1 \le k &lt; m.
\end{align}</div>
<script type="math/tex; mode=display">\begin{align}
(w_n^2)^m = w_n^n &= 1 \pmod{p}, \quad \text{with } m = \frac{n}{2}\\\\
(w_n^2)^k = w_n^{2k} &\ne 1 \pmod{p}, \quad 1 \le k < m.
\end{align}</script>
</div>
<p>Thus if <span><span class="MathJax_Preview">w_n</span><script type="math/tex">w_n</script></span> is a <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>-th root of unity, then <span><span class="MathJax_Preview">w_n^2</span><script type="math/tex">w_n^2</script></span> is a <span><span class="MathJax_Preview">\frac{n}{2}</span><script type="math/tex">\frac{n}{2}</script></span>-th root of unity.
And consequently for all smaller powers of two there exist roots of the required degree, and they can be computed using <span><span class="MathJax_Preview">w_n</span><script type="math/tex">w_n</script></span>.</p>
<p>For computing the inverse DFT, we need the inverse <span><span class="MathJax_Preview">w_n^{-1}</span><script type="math/tex">w_n^{-1}</script></span> of <span><span class="MathJax_Preview">w_n</span><script type="math/tex">w_n</script></span>.
But for a prime modulus the inverse always exists.</p>
<p>Thus all the properties that we need from the complex roots are also available in modular arithmetic, provided that we have a large enough module <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> for which a <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>-th root of unity exists.</p>
<p>For example we can take the following values: module <span><span class="MathJax_Preview">p = 7340033</span><script type="math/tex">p = 7340033</script></span>, <span><span class="MathJax_Preview">w_{2^{20}} = 5</span><script type="math/tex">w_{2^{20}} = 5</script></span>.
If this module is not enough, we need to find a different pair.
We can use that fact that for modules of the form <span><span class="MathJax_Preview">p = c 2^k + 1</span><script type="math/tex">p = c 2^k + 1</script></span> (and <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> is prime), there always exists the <span><span class="MathJax_Preview">2^k</span><script type="math/tex">2^k</script></span>-th root of unity.
It can be shown that <span><span class="MathJax_Preview">g^c</span><script type="math/tex">g^c</script></span> is such a <span><span class="MathJax_Preview">2^k</span><script type="math/tex">2^k</script></span>-th root of unity, where <span><span class="MathJax_Preview">g</span><script type="math/tex">g</script></span> is a <a href="/docs/#Algorithms/algebra/primitive-root/">primitive root</a> of <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>.</p>
<p>```cpp fft_implementation_modular_arithmetic
const int mod = 7340033;
const int root = 5;
const int root_1 = 4404020;
const int root_pw = 1 &lt;&lt; 20;</p>
<p>void fft(vector<int> &amp; a, bool invert) {
    int n = a.size();</p>
<pre><code>for (int i = 1, j = 0; i &lt; n; i++) {
    int bit = n &gt;&gt; 1;
    for (; j &amp; bit; bit &gt;&gt;= 1)
        j ^= bit;
    j ^= bit;

    if (i &lt; j)
        swap(a[i], a[j]);
}

for (int len = 2; len &lt;= n; len &lt;&lt;= 1) {
    int wlen = invert ? root_1 : root;
    for (int i = len; i &lt; root_pw; i &lt;&lt;= 1)
        wlen = (int)(1LL * wlen * wlen % mod);

    for (int i = 0; i &lt; n; i += len) {
        int w = 1;
        for (int j = 0; j &lt; len / 2; j++) {
            int u = a[i+j], v = (int)(1LL * a[i+j+len/2] * w % mod);
            a[i+j] = u + v &lt; mod ? u + v : u + v - mod;
            a[i+j+len/2] = u - v &gt;= 0 ? u - v : u - v + mod;
            w = (int)(1LL * w * wlen % mod);
        }
    }
}

if (invert) {
    int n_1 = inverse(n, mod);
    for (int &amp; x : a)
        x = (int)(1LL * x * n_1 % mod);
}
</code></pre>
<p>}
```</p>
<p>Here the function <code>inverse</code> computes the modular inverse (see <a href="/docs/#Algorithms/algebra/module-inverse/">Modular Multiplicative Inverse</a>).
The constants <code>mod</code>, <code>root</code>, <code>root_pw</code> determine the module and the root, and <code>root_1</code> is the inverse of <code>root</code> modulo <code>mod</code>.</p>
<p>In practice this implementation is slower than the implementation using complex numbers (due to the huge number of modulo operations), but it has some advantages such as less memory usage and no rounding errors.</p>
<h2 id="multiplication-with-arbitrary-modulus">Multiplication with arbitrary modulus</h2>
<p>Here we want to achieve the same goal as in previous section.
Multiplying two polynomial <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> and <span><span class="MathJax_Preview">B(x)</span><script type="math/tex">B(x)</script></span>, and computing the coefficients modulo some number <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>.
The number theoretic transform only works for certain prime numbers.
What about the case when the modulus is not of the desired form?</p>
<p>One option would be to perform multiple number theoretic transforms with different prime numbers of the form <span><span class="MathJax_Preview">c 2^k + 1</span><script type="math/tex">c 2^k + 1</script></span>, then apply the <a href="/docs/#Algorithms/algebra/chinese-remainder-theorem/">Chinese Remainder Theorem</a> to compute the final coefficients.</p>
<p>Another options is to distribute the polynomials <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> and <span><span class="MathJax_Preview">B(x)</span><script type="math/tex">B(x)</script></span> into two smaller polynomials each
<span><span class="MathJax_Preview"><span><span class="MathJax_Preview">\begin{align}
A(x) &amp;= A_1(x) + A_2(x) \cdot C \\\\
B(x) &amp;= B_1(x) + B_2(x) \cdot C
\end{align}</span><script type="math/tex">\begin{align}
A(x) &= A_1(x) + A_2(x) \cdot C \\\\
B(x) &= B_1(x) + B_2(x) \cdot C
\end{align}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">\begin{align}
A(x) &amp;= A_1(x) + A_2(x) \cdot C \\\\
B(x) &amp;= B_1(x) + B_2(x) \cdot C
\end{align}</span><script type="math/tex">\begin{align}
A(x) &= A_1(x) + A_2(x) \cdot C \\\\
B(x) &= B_1(x) + B_2(x) \cdot C
\end{align}</script></span></script></span>
with <span><span class="MathJax_Preview">C \approx \sqrt{M}</span><script type="math/tex">C \approx \sqrt{M}</script></span>.</p>
<p>Then the product of <span><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> and <span><span class="MathJax_Preview">B(x)</span><script type="math/tex">B(x)</script></span> can then be represented as:
<span><span class="MathJax_Preview"><span><span class="MathJax_Preview">A(x) \cdot B(x) = A_1(x) \cdot B_1(x) + \left(A_1(x) \cdot B_2(x) + A_2(x) \cdot B_1(x)\right)\cdot C + \left(A_2(x) \cdot B_2(x)\right)\cdot C^2</span><script type="math/tex">A(x) \cdot B(x) = A_1(x) \cdot B_1(x) + \left(A_1(x) \cdot B_2(x) + A_2(x) \cdot B_1(x)\right)\cdot C + \left(A_2(x) \cdot B_2(x)\right)\cdot C^2</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">A(x) \cdot B(x) = A_1(x) \cdot B_1(x) + \left(A_1(x) \cdot B_2(x) + A_2(x) \cdot B_1(x)\right)\cdot C + \left(A_2(x) \cdot B_2(x)\right)\cdot C^2</span><script type="math/tex">A(x) \cdot B(x) = A_1(x) \cdot B_1(x) + \left(A_1(x) \cdot B_2(x) + A_2(x) \cdot B_1(x)\right)\cdot C + \left(A_2(x) \cdot B_2(x)\right)\cdot C^2</script></span></script></span></p>
<p>The polynomials <span><span class="MathJax_Preview">A_1(x)</span><script type="math/tex">A_1(x)</script></span>, <span><span class="MathJax_Preview">A_2(x)</span><script type="math/tex">A_2(x)</script></span>, <span><span class="MathJax_Preview">B_1(x)</span><script type="math/tex">B_1(x)</script></span> and <span><span class="MathJax_Preview">B_2(x)</span><script type="math/tex">B_2(x)</script></span> contain only coefficients smaller than <span><span class="MathJax_Preview">\sqrt{M}</span><script type="math/tex">\sqrt{M}</script></span>, therefore the coefficients of all the appearing products are smaller than <span><span class="MathJax_Preview">M \cdot n</span><script type="math/tex">M \cdot n</script></span>, which is usually small enough to handle with typical floating point types.</p>
<p>This approach therefore requires computing the products of polynomials with smaller coefficients (by using the normal FFT and inverse FFT), and then the original product can be restored using modular addition and multiplication in <span><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span> time.</p>
<h2 id="applications">Applications</h2>
<p>DFT can be used in a huge variety of other problems, which at the first glance have nothing to do with multiplying polynomials.</p>
<h3 id="all-possible-sums">All possible sums</h3>
<p>We are given two arrays <span><span class="MathJax_Preview">a[]</span><script type="math/tex">a[]</script></span> and <span><span class="MathJax_Preview">b[]</span><script type="math/tex">b[]</script></span>.
We have to find all possible sums <span><span class="MathJax_Preview">a[i] + b[j]</span><script type="math/tex">a[i] + b[j]</script></span>, and for each sum count how often it appears.</p>
<p>For example for <span><span class="MathJax_Preview">a = [1,~ 2,~ 3]</span><script type="math/tex">a = [1,~ 2,~ 3]</script></span> and <span><span class="MathJax_Preview">b = [2,~ 4]</span><script type="math/tex">b = [2,~ 4]</script></span> we get:
then sum <span><span class="MathJax_Preview">3</span><script type="math/tex">3</script></span> can be obtained in <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> way, the sum <span><span class="MathJax_Preview">4</span><script type="math/tex">4</script></span> also in <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> way, <span><span class="MathJax_Preview">5</span><script type="math/tex">5</script></span> in <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span>, <span><span class="MathJax_Preview">6</span><script type="math/tex">6</script></span> in <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>, <span><span class="MathJax_Preview">7</span><script type="math/tex">7</script></span> in <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>.</p>
<p>We construct for the arrays <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> and <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> two polynomials <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> and <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>.
The numbers of the array will act as the exponents in the polynomial (<span><span class="MathJax_Preview">a[i] \Rightarrow x^{a[i]}</span><script type="math/tex">a[i] \Rightarrow x^{a[i]}</script></span>); and the coefficients of this term will by how often the number appears in the array.</p>
<p>Then, by multiplying these two polynomials in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span> time, we get a polynomial <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>, where the exponents will tell us which sums can be obtained, and the coefficients tell us how often.
To demonstrate this on the example:
<span><span class="MathJax_Preview"><span><span class="MathJax_Preview">(1 x^1 + 1 x^2 + 1 x^3) (1 x^2 + 1 x^4) = 1 x^3 + 1 x^4 + 2 x^5 + 1 x^6 + 1 x^7</span><script type="math/tex">(1 x^1 + 1 x^2 + 1 x^3) (1 x^2 + 1 x^4) = 1 x^3 + 1 x^4 + 2 x^5 + 1 x^6 + 1 x^7</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">(1 x^1 + 1 x^2 + 1 x^3) (1 x^2 + 1 x^4) = 1 x^3 + 1 x^4 + 2 x^5 + 1 x^6 + 1 x^7</span><script type="math/tex">(1 x^1 + 1 x^2 + 1 x^3) (1 x^2 + 1 x^4) = 1 x^3 + 1 x^4 + 2 x^5 + 1 x^6 + 1 x^7</script></span></script></span></p>
<h3 id="all-possible-scalar-products">All possible scalar products</h3>
<p>We are given two arrays <span><span class="MathJax_Preview">a[]</span><script type="math/tex">a[]</script></span> and <span><span class="MathJax_Preview">b[]</span><script type="math/tex">b[]</script></span> of length <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>.
We have to compute the products of <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> with every cyclic shift of <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>.</p>
<p>We generate two new arrays of size <span><span class="MathJax_Preview">2n</span><script type="math/tex">2n</script></span>:
We reverse <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> and append <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> zeros to it.
And we just append <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> to itself.
When we multiply these two arrays as polynomials, and look at the coefficients <span><span class="MathJax_Preview">c[n-1],~ c[n],~ \dots,~ c[2n-2]</span><script type="math/tex">c[n-1],~ c[n],~ \dots,~ c[2n-2]</script></span> of the product <span><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span>, we get:</p>
<div>
<div class="MathJax_Preview">c[k] = \sum_{i+j=k} a[i] b[j]</div>
<script type="math/tex; mode=display">c[k] = \sum_{i+j=k} a[i] b[j]</script>
</div>
<p>And since all the elements <span><span class="MathJax_Preview">a[i] = 0</span><script type="math/tex">a[i] = 0</script></span> for <span><span class="MathJax_Preview">i \ge n</span><script type="math/tex">i \ge n</script></span>:</p>
<div>
<div class="MathJax_Preview">c[k] = \sum_{i=0}^{n-1} a[i] b[k-i]</div>
<script type="math/tex; mode=display">c[k] = \sum_{i=0}^{n-1} a[i] b[k-i]</script>
</div>
<p>It is easy to see that this sum is just the scalar product of the vector <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> with the <span><span class="MathJax_Preview">(k - (n - 1))</span><script type="math/tex">(k - (n - 1))</script></span>-th cyclic left shift of <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>.
Thus these coefficients are the answer to the problem, and we were still able to obtain it in <span><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span> time.
Note here that <span><span class="MathJax_Preview">c[2n-1]</span><script type="math/tex">c[2n-1]</script></span> also gives us the <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>-th cyclic shift but that is the same as the <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>-th cyclic shift so we don't need to consider that separately into our answer.</p>
<h3 id="two-stripes">Two stripes</h3>
<p>We are given two Boolean stripes (cyclic arrays of values <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span> and <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>) <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> and <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>.
We want to find all ways to attach the first stripe to the second one, such that at no position we have a <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> of the first stripe next to a <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> of the second stripe.</p>
<p>The problem doesn't actually differ much from the previous problem.
Attaching two stripes just means that we perform a cyclic shift on the second array, and we can attach the two stripes, if scalar product of the two arrays is <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>.</p>
<h3 id="string-matching">String matching</h3>
<p>We are given two strings, a text <span><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span> and a pattern <span><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span>, consisting of lowercase letters.
We have to compute all the occurrences of the pattern in the text.</p>
<p>We create a polynomial for each string (<span><span class="MathJax_Preview">T[i]</span><script type="math/tex">T[i]</script></span> and <span><span class="MathJax_Preview">P[I]</span><script type="math/tex">P[I]</script></span> are numbers between <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span> and <span><span class="MathJax_Preview">25</span><script type="math/tex">25</script></span> corresponding to the <span><span class="MathJax_Preview">26</span><script type="math/tex">26</script></span> letters of the alphabet):
<span><span class="MathJax_Preview"><span><span class="MathJax_Preview">A(x) = a_0 x^0 + a_1 x^1 + \dots + a_{n-1} x^{n-1}, \quad n = |T|</span><script type="math/tex">A(x) = a_0 x^0 + a_1 x^1 + \dots + a_{n-1} x^{n-1}, \quad n = |T|</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">A(x) = a_0 x^0 + a_1 x^1 + \dots + a_{n-1} x^{n-1}, \quad n = |T|</span><script type="math/tex">A(x) = a_0 x^0 + a_1 x^1 + \dots + a_{n-1} x^{n-1}, \quad n = |T|</script></span></script></span>
with
<span><span class="MathJax_Preview"><span><span class="MathJax_Preview">a_i = \cos(\alpha_i) + i \sin(\alpha_i), \quad \alpha_i = \frac{2 \pi T[i]}{26}.</span><script type="math/tex">a_i = \cos(\alpha_i) + i \sin(\alpha_i), \quad \alpha_i = \frac{2 \pi T[i]}{26}.</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">a_i = \cos(\alpha_i) + i \sin(\alpha_i), \quad \alpha_i = \frac{2 \pi T[i]}{26}.</span><script type="math/tex">a_i = \cos(\alpha_i) + i \sin(\alpha_i), \quad \alpha_i = \frac{2 \pi T[i]}{26}.</script></span></script></span></p>
<p>And
<span><span class="MathJax_Preview"><span><span class="MathJax_Preview">B(x) = b_0 x^0 + b_1 x^1 + \dots + b_{m-1} x^{m-1}, \quad m = |P|</span><script type="math/tex">B(x) = b_0 x^0 + b_1 x^1 + \dots + b_{m-1} x^{m-1}, \quad m = |P|</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">B(x) = b_0 x^0 + b_1 x^1 + \dots + b_{m-1} x^{m-1}, \quad m = |P|</span><script type="math/tex">B(x) = b_0 x^0 + b_1 x^1 + \dots + b_{m-1} x^{m-1}, \quad m = |P|</script></span></script></span>
with
<span><span class="MathJax_Preview"><span><span class="MathJax_Preview">b_i = \cos(\beta_i) - i \sin(\beta_i), \quad \beta_i = \frac{2 \pi P[m-i-1]}{26}.</span><script type="math/tex">b_i = \cos(\beta_i) - i \sin(\beta_i), \quad \beta_i = \frac{2 \pi P[m-i-1]}{26}.</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">b_i = \cos(\beta_i) - i \sin(\beta_i), \quad \beta_i = \frac{2 \pi P[m-i-1]}{26}.</span><script type="math/tex">b_i = \cos(\beta_i) - i \sin(\beta_i), \quad \beta_i = \frac{2 \pi P[m-i-1]}{26}.</script></span></script></span></p>
<p>Notice that with the expression <span><span class="MathJax_Preview">P[m-i-1]</span><script type="math/tex">P[m-i-1]</script></span> explicitly reverses the pattern.</p>
<p>The <span><span class="MathJax_Preview">(m-1+i)</span><script type="math/tex">(m-1+i)</script></span>th coefficients of the product of the two polynomials <span><span class="MathJax_Preview">C(x) = A(x) \cdot B(x)</span><script type="math/tex">C(x) = A(x) \cdot B(x)</script></span> will tell us, if the pattern appears in the text at position <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>.</p>
<p>$$c_{m-1+i} = \sum_{j = 0}^{m-1} a_{i+j} \cdot b_{m-1-j} = \sum_{j=0}^{m-1} \left(\cos(\alpha_{i+j}) + i \sin(\alpha_{i+j})\right) \cdot \left(\cos(\beta_j) - i \sin(\beta_j)\right)
$$
with <span><span class="MathJax_Preview">\alpha_{i+j} = \frac{2 \pi T[i+j]}{26}</span><script type="math/tex">\alpha_{i+j} = \frac{2 \pi T[i+j]}{26}</script></span> and <span><span class="MathJax_Preview">\beta_j = \frac{2 \pi P[j]}{26}</span><script type="math/tex">\beta_j = \frac{2 \pi P[j]}{26}</script></span></p>
<p>If there is a match, than <span><span class="MathJax_Preview">T[i+j] = P[j]</span><script type="math/tex">T[i+j] = P[j]</script></span>, and therefore <span><span class="MathJax_Preview">\alpha_{i+j} = \beta_j</span><script type="math/tex">\alpha_{i+j} = \beta_j</script></span>.
This gives (using the Pythagorean trigonometric identity):</p>
<div>
<div class="MathJax_Preview">\begin{align}
c_{m-1+i} &amp;= \sum_{j = 0}^{m-1}  \left(\cos(\alpha_{i+j}) + i \sin(\alpha_{i+j})\right) \cdot \left(\cos(\alpha_{i+j}) - i \sin(\alpha_{i+j})\right) \\\\
&amp;= \sum_{j = 0}^{m-1} \cos(\alpha_{i+j})^2 + \sin(\alpha_{i+j})^2 = \sum_{j = 0}^{m-1} 1 = m
\end{align}</div>
<script type="math/tex; mode=display">\begin{align}
c_{m-1+i} &= \sum_{j = 0}^{m-1}  \left(\cos(\alpha_{i+j}) + i \sin(\alpha_{i+j})\right) \cdot \left(\cos(\alpha_{i+j}) - i \sin(\alpha_{i+j})\right) \\\\
&= \sum_{j = 0}^{m-1} \cos(\alpha_{i+j})^2 + \sin(\alpha_{i+j})^2 = \sum_{j = 0}^{m-1} 1 = m
\end{align}</script>
</div>
<p>If there isn't a match, then at least a character is different, which leads that one of the products <span><span class="MathJax_Preview">a_{i+1} \cdot b_{m-1-j}</span><script type="math/tex">a_{i+1} \cdot b_{m-1-j}</script></span> is not equal to <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>, which leads to the coefficient <span><span class="MathJax_Preview">c_{m-1+i} \ne m</span><script type="math/tex">c_{m-1+i} \ne m</script></span>.</p>
<h3 id="string-matching-with-wildcards">String matching with wildcards</h3>
<p>This is an extension of the previous problem.
This time we allow that the pattern contains the wildcard character <span><span class="MathJax_Preview">\*</span><script type="math/tex">\*</script></span>, which can match every possible letter.
E.g. the pattern <span><span class="MathJax_Preview">a*c</span><script type="math/tex">a*c</script></span> appears in the text <span><span class="MathJax_Preview">abccaacc</span><script type="math/tex">abccaacc</script></span> at exactly three positions, at index <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>, index <span><span class="MathJax_Preview">4</span><script type="math/tex">4</script></span> and index <span><span class="MathJax_Preview">5</span><script type="math/tex">5</script></span>.</p>
<p>We create the exact same polynomials, except that we set <span><span class="MathJax_Preview">b_i = 0</span><script type="math/tex">b_i = 0</script></span> if <span><span class="MathJax_Preview">P[m-i-1] = *</span><script type="math/tex">P[m-i-1] = *</script></span>.
If <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> is the number of wildcards in <span><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span>, then we will have a match of <span><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span> in <span><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span> at index <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> if <span><span class="MathJax_Preview">c_{m-1+i} = m - x</span><script type="math/tex">c_{m-1+i} = m - x</script></span>.</p>
<h2 id="practice-problems">Practice problems</h2>
<ul>
<li><a href="http://www.spoj.com/problems/POLYMUL/">SPOJ - POLYMUL</a></li>
<li><a href="http://www.spoj.com/problems/MAXMATCH/">SPOJ - MAXMATCH</a></li>
<li><a href="http://www.spoj.com/problems/ADAMATCH/">SPOJ - ADAMATCH</a></li>
<li><a href="http://codeforces.com/problemset/problem/954/I">Codeforces - Yet Another String Matching Problem</a></li>
<li><a href="http://codeforces.com/problemset/problem/958/F3">Codeforces - Lightsabers (hard)</a></li>
<li><a href="https://open.kattis.com/problems/kinversions">Kattis - K-Inversions</a></li>
<li><a href="http://codeforces.com/contest/754/problem/E">Codeforces - Dasha and cyclic table</a></li>
</ul>

  <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://d-k-ivanov.github.io/">Main site</a>
      </p><p>Copyright &copy; 2016-2020 Dmitriy Ivanov. <script type="text/javascript"> (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)}; m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)}) (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym"); ym(40819844, "init", { clickmap:true, trackLinks:true, accurateTrackBounce:true }); </script> <noscript><div><img src="https://mc.yandex.ru/watch/40819844" style="position:absolute; left:-9999px;" alt="" /></div></noscript></p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>