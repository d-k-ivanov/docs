<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="Dmitry Ivanov">
    <link rel="canonical" href="https://d-k-ivanov.github.io/docs/Algorithms/Combinatorics/Binomial_Coefficients/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Binomial Coefficients - Technical Info</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <link href="../../../css/extra.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Binomial Coefficients", url: "#_top", children: [
              {title: "Calculation", url: "#calculation" },
              {title: "Properties", url: "#properties" },
              {title: "Calculation", url: "#calculation_1" },
              {title: "Computing binomial coefficients modulo mm", url: "#computing-binomial-coefficients-modulo-mm" },
              {title: "Practice Problems", url: "#practice-problems" },
              {title: "References", url: "#references" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../mathjax-config.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-80208201-1', 'd-k-ivanov.github.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../Bishops_on_Chessboard/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../Bishops_on_Chessboard/" class="btn btn-xs btn-link">
        Bishops on Chessboard
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../Balanced_Bracket_Sequences/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../Balanced_Bracket_Sequences/" class="btn btn-xs btn-link">
        Balanced Bracket Sequences
      </a>
    </div>
    
  </div>

    

    <h1 id="binomial-coefficients">Binomial Coefficients</h1>
<p>Binomial coefficients <span><span class="MathJax_Preview">\binom n k</span><script type="math/tex">\binom n k</script></span> are the number of ways to select a set of <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> elements from <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> different elements without taking into account the order of arrangement of these elements (i.e., the number of unordered sets).</p>
<p>Binomial coefficients are also the coefficients in the expansion of <span><span class="MathJax_Preview">(a + b) ^ n</span><script type="math/tex">(a + b) ^ n</script></span> (so-called binomial theorem):</p>
<div>
<div class="MathJax_Preview"> (a+b)^n = \binom n 0 a^n + \binom n 1 a^{n-1} b + \binom n 2 a^{n-2} b^2 + \cdots + \binom n k a^{n-k} b^k + \cdots + \binom n n b^n </div>
<script type="math/tex; mode=display"> (a+b)^n = \binom n 0 a^n + \binom n 1 a^{n-1} b + \binom n 2 a^{n-2} b^2 + \cdots + \binom n k a^{n-k} b^k + \cdots + \binom n n b^n </script>
</div>
<p>It is believed that this formula, as well as the triangle which allows efficient calculation of the coefficients, was discovered by Blaise Pascal in the 17th century. Nevertheless, it was known to the Chinese mathematician Yang Hui, who lived in the 13th century. Perhaps it was discovered by a Persian scholar Omar Khayyam. Moreover, Indian mathematician Pingala, who lived  earlier in the 3rd. BC, got similar results. The merit of the Newton is that he generalized this formula for exponents that are not natural.</p>
<h2 id="calculation">Calculation</h2>
<p><strong>Analytic formula</strong> for the calculation:</p>
<div>
<div class="MathJax_Preview"> \binom n k = \frac {n!} {k!(n-k)!} </div>
<script type="math/tex; mode=display"> \binom n k = \frac {n!} {k!(n-k)!} </script>
</div>
<p>This formula can be easily deduced from the problem of ordered arrangement (number of ways to select <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> different elements from <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> different elements). First, let's count the number of ordered selections of <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> elements. There are <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> ways to select the first element, <span><span class="MathJax_Preview">n-1</span><script type="math/tex">n-1</script></span> ways to select the second element, <span><span class="MathJax_Preview">n-2</span><script type="math/tex">n-2</script></span> ways to select the third element, and so on. As a result, we get the formula of the number of ordered arrangements: <span><span class="MathJax_Preview">n (n-1) (n-2) \cdots (n - k + 1) = \frac {n!} {(n-k)!}</span><script type="math/tex">n (n-1) (n-2) \cdots (n - k + 1) = \frac {n!} {(n-k)!}</script></span>. We can easily move to unordered arrangements, noting that each unordered arrangement corresponds to exactly <span><span class="MathJax_Preview">k!</span><script type="math/tex">k!</script></span> ordered arrangements (<span><span class="MathJax_Preview">k!</span><script type="math/tex">k!</script></span> is the number of possible permutations of <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> elements). We get the final formula by dividing <span><span class="MathJax_Preview">\frac {n!} {(n-k)!}</span><script type="math/tex">\frac {n!} {(n-k)!}</script></span> by <span><span class="MathJax_Preview">k!</span><script type="math/tex">k!</script></span>.</p>
<p><strong>Recurrence formula</strong> (which is associated with the famous "Pascal's Triangle"):</p>
<div>
<div class="MathJax_Preview"> \binom n k = \binom {n-1} {k-1} + \binom {n-1} k </div>
<script type="math/tex; mode=display"> \binom n k = \binom {n-1} {k-1} + \binom {n-1} k </script>
</div>
<p>It is easy to deduce this using the analytic formula.</p>
<p>Note that for <span><span class="MathJax_Preview">n \lt k</span><script type="math/tex">n \lt k</script></span> the value of <span><span class="MathJax_Preview">\binom n k</span><script type="math/tex">\binom n k</script></span> is assumed to be zero.</p>
<h2 id="properties">Properties</h2>
<p>Binomial coefficients have many different properties. Here are the simplest of them:</p>
<ul>
<li>Symmetry rule:</li>
</ul>
<div>
<div class="MathJax_Preview"> \binom n k = \binom n {n-k} </div>
<script type="math/tex; mode=display"> \binom n k = \binom n {n-k} </script>
</div>
<ul>
<li>Factoring in:</li>
</ul>
<div>
<div class="MathJax_Preview"> \binom n k = \frac n k \binom {n-1} {k-1} </div>
<script type="math/tex; mode=display"> \binom n k = \frac n k \binom {n-1} {k-1} </script>
</div>
<ul>
<li>Sum over <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>:</li>
</ul>
<div>
<div class="MathJax_Preview"> \sum_{k = 0}^n \binom n k = 2 ^ n </div>
<script type="math/tex; mode=display"> \sum_{k = 0}^n \binom n k = 2 ^ n </script>
</div>
<ul>
<li>Sum over <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>:</li>
</ul>
<div>
<div class="MathJax_Preview"> \sum_{m = 0}^n \binom m k = \binom {n + 1} {k + 1} </div>
<script type="math/tex; mode=display"> \sum_{m = 0}^n \binom m k = \binom {n + 1} {k + 1} </script>
</div>
<ul>
<li>Sum over <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> and <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>:</li>
</ul>
<div>
<div class="MathJax_Preview"> \sum_{k = 0}^m  \binom {n + k} k = \binom {n + m + 1} m </div>
<script type="math/tex; mode=display"> \sum_{k = 0}^m  \binom {n + k} k = \binom {n + m + 1} m </script>
</div>
<ul>
<li>Sum of the squares:</li>
</ul>
<div>
<div class="MathJax_Preview"> {\binom n 0}^2 + {\binom n 1}^2 + \cdots + {\binom n n}^2 = \binom {2n} n </div>
<script type="math/tex; mode=display"> {\binom n 0}^2 + {\binom n 1}^2 + \cdots + {\binom n n}^2 = \binom {2n} n </script>
</div>
<ul>
<li>Weighted sum:</li>
</ul>
<div>
<div class="MathJax_Preview"> 1 \binom n 1 + 2 \binom n 2 + \cdots + n \binom n n = n 2^{n-1} </div>
<script type="math/tex; mode=display"> 1 \binom n 1 + 2 \binom n 2 + \cdots + n \binom n n = n 2^{n-1} </script>
</div>
<ul>
<li>Connection with the <a href="/docs/#Algorithms/Algebra/Fibonacci_Numbers/">Fibonacci numbers</a>:</li>
</ul>
<div>
<div class="MathJax_Preview"> \binom n 0 + \binom {n-1} 1 + \cdots + \binom {n-k} k + \cdots + \binom 0 n = F_{n+1} </div>
<script type="math/tex; mode=display"> \binom n 0 + \binom {n-1} 1 + \cdots + \binom {n-k} k + \cdots + \binom 0 n = F_{n+1} </script>
</div>
<h2 id="calculation_1">Calculation</h2>
<h3 id="straightforward-calculation-using-analytical-formula">Straightforward calculation using analytical formula</h3>
<p>The first, straightforward formula is very easy to code, but this method is likely to overflow even for relatively small values of <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> and <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> (even if the answer completely fit into some datatype, the calculation of the intermediate factorials can lead to overflow). Therefore, this method often can only be used with <a href="/docs/#Algorithms/Algebra/Arbitrary-Precision_Arithmetic/">long arithmetic</a>:</p>
<pre><code class="cpp">int C(int n, int k) {
    int res = 1;
    for (int i = n - k + 1; i &lt;= n; ++i)
        res *= i;
    for (int i = 2; i &lt;= k; ++i)
        res /= i;
}
</code></pre>

<h3 id="improved-implementation">Improved implementation</h3>
<p>Note that in the above implementation numerator and denominator have the same number of factors (<span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>), each of which is greater than or equal to 1. Therefore, we can replace our fraction with a product <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> fractions, each of which is real-valued. However, on each step after multiplying current answer by each of the next fractions the answer will still be integer (this follows from the property of factoring in). C++ implementation:</p>
<pre><code class="cpp">int C(int n, int k) {
    double res = 1;
    for (int i = 1; i &lt;= k; ++i)
        res = res * (n - k + i) / i;
    return (int)(res + 0.01);
}
</code></pre>

<p>Here we carefully cast the floating point number to an integer, taking into account that due to the accumulated errors, it may be slightly less than the true value (for example, <span><span class="MathJax_Preview">2.99999</span><script type="math/tex">2.99999</script></span> instead of <span><span class="MathJax_Preview">3</span><script type="math/tex">3</script></span>).</p>
<h3 id="pascals-triangle">Pascal's Triangle</h3>
<p>By using the recurrence relation we can construct a table of binomial coefficients (Pascal's triangle) and take the result from it. The advantage of this method is that intermediate results never exceed the answer and calculating each new table element requires only one addition. The flaw is slow execution for large <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> and <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> if you just need a single value and not the whole table (because in order to calculate <span><span class="MathJax_Preview">\binom n k</span><script type="math/tex">\binom n k</script></span> you will need to build a table of all <span><span class="MathJax_Preview">\binom i j, 1 \le i \le n, 1 \le j \le n</span><script type="math/tex">\binom i j, 1 \le i \le n, 1 \le j \le n</script></span>, or at least to <span><span class="MathJax_Preview">1 \le j \le \min (i, 2k)</span><script type="math/tex">1 \le j \le \min (i, 2k)</script></span>). The time complexity can be considered to be <span><span class="MathJax_Preview">\mathcal{O}(n^2)</span><script type="math/tex">\mathcal{O}(n^2)</script></span>.
C++ implementation:</p>
<pre><code class="cpp">const int maxn = ...;
int C[maxn + 1][maxn + 1];
C[0][0] = 1;
for (int n = 1; n &lt;= maxn; ++n) {
    C[n][0] = C[n][n] = 1;
    for (int k = 1; k &lt; n; ++k)
        C[n][k] = C[n - 1][k - 1] + C[n - 1][k];
}
</code></pre>

<p>If the entire table of values is not necessary, storing only two last rows of it is sufficient (current <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>-th row and the previous <span><span class="MathJax_Preview">n-1</span><script type="math/tex">n-1</script></span>-th).</p>
<h3 id="calculation-in-o1o1">Calculation in <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span></h3>
<p>Finally, in some situations it is beneficial to precompute all the factorials in order to produce any necessary binomial coefficient with only two divisions later. This can be advantageous when using <a href="/docs/#Algorithms/Algebra/Arbitrary-Precision_Arithmetic/">long arithmetic</a>, when the memory does not allow precomputation of the whole Pascal's triangle.</p>
<h2 id="computing-binomial-coefficients-modulo-mm">Computing binomial coefficients modulo <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span></h2>
<p>Quite often you come across the problem of computing binomial coefficients modulo some <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>.</p>
<h3 id="binomial-coefficient-for-small-nn">Binomial coefficient for small <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span></h3>
<p>The previously discussed approach of Pascal's triangle can be used to calculate all values of <span><span class="MathJax_Preview">\binom{n}{k} \bmod m</span><script type="math/tex">\binom{n}{k} \bmod m</script></span> for reasonably small <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>, since it requires time complexity <span><span class="MathJax_Preview">\mathcal{O}(n^2)</span><script type="math/tex">\mathcal{O}(n^2)</script></span>. This approach can handle any modulo, since only addition operations are used.</p>
<h3 id="binomial-coefficient-modulo-large-prime">Binomial coefficient modulo large prime</h3>
<p>The formula for the binomial coefficients is
<span><span class="MathJax_Preview"><span><span class="MathJax_Preview">\binom n k = \frac {n!} {k!(n-k)!},</span><script type="math/tex">\binom n k = \frac {n!} {k!(n-k)!},</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">\binom n k = \frac {n!} {k!(n-k)!},</span><script type="math/tex">\binom n k = \frac {n!} {k!(n-k)!},</script></span></script></span>
so if we want to compute it modulo some prime <span><span class="MathJax_Preview">m &gt; n</span><script type="math/tex">m > n</script></span> we get
<span><span class="MathJax_Preview"><span><span class="MathJax_Preview">\binom n k \equiv n! \cdot (k!)^{-1} \cdot ((n-k)!)^{-1} \mod m.</span><script type="math/tex">\binom n k \equiv n! \cdot (k!)^{-1} \cdot ((n-k)!)^{-1} \mod m.</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">\binom n k \equiv n! \cdot (k!)^{-1} \cdot ((n-k)!)^{-1} \mod m.</span><script type="math/tex">\binom n k \equiv n! \cdot (k!)^{-1} \cdot ((n-k)!)^{-1} \mod m.</script></span></script></span></p>
<p>First we precompute all factorials modulo <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> up to <span><span class="MathJax_Preview">\text{MAXN}!</span><script type="math/tex">\text{MAXN}!</script></span> in <span><span class="MathJax_Preview">O(\text{MAXN})</span><script type="math/tex">O(\text{MAXN})</script></span> time.</p>
<pre><code class="cpp">factorial[0] = 1;
for (int i = 1; i &lt;= MAXN; i++) {
    factorial[i] = factorial[i - 1] * i % m;
}
</code></pre>

<p>And afterwards we can compute the binomial coefficient in <span><span class="MathJax_Preview">O(\log m)</span><script type="math/tex">O(\log m)</script></span> time.</p>
<pre><code class="cpp">long long binomial_coefficient(int n, int k) {
    return factorial[n] * inverse(factorial[k]) % m * inverse(factorial[n - k]) % m;
}
</code></pre>

<p>We even can compute the binomial coefficient in <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> time if we precompute the inverses of all factorials in <span><span class="MathJax_Preview">O(\text{MAXN} \log m)</span><script type="math/tex">O(\text{MAXN} \log m)</script></span> using the regular method for computing the inverse, or even in <span><span class="MathJax_Preview">O(\text{MAXN})</span><script type="math/tex">O(\text{MAXN})</script></span> time using the congruence <span><span class="MathJax_Preview">(x!)^{-1} \equiv ((x-1)!)^{-1} \cdot x^{-1}</span><script type="math/tex">(x!)^{-1} \equiv ((x-1)!)^{-1} \cdot x^{-1}</script></span> and the method for <a href="/docs/#Algorithms/Algebra/Modular_Multiplicative_Inverse/">computing all inverses</a> in <span><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span>.</p>
<h3 id="binomial-coefficient-modulo-prime-power-mod-prime-pow">Binomial coefficient modulo prime power  {#mod-prime-pow}</h3>
<p>Here we want to compute the binomial coefficient modulo some prime power, i.e. <span><span class="MathJax_Preview">m = p^b</span><script type="math/tex">m = p^b</script></span> for some prime <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>.
If <span><span class="MathJax_Preview">p &gt; \max(k, n-k)</span><script type="math/tex">p > \max(k, n-k)</script></span>, then we can use the same method as described in the previous section.
But if <span><span class="MathJax_Preview">p \le \max(k, n-k)</span><script type="math/tex">p \le \max(k, n-k)</script></span>, then at least one of <span><span class="MathJax_Preview">k!</span><script type="math/tex">k!</script></span> and <span><span class="MathJax_Preview">(n-k)!</span><script type="math/tex">(n-k)!</script></span> are not coprime with <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>, and therefore we cannot compute the inverses - they don't exist.
Nevertheless we can compute the binomial coefficient.</p>
<p>The idea is the following:
We compute for each <span><span class="MathJax_Preview">x!</span><script type="math/tex">x!</script></span> the biggest exponent <span><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span> such that <span><span class="MathJax_Preview">p^c</span><script type="math/tex">p^c</script></span> divides <span><span class="MathJax_Preview">x!</span><script type="math/tex">x!</script></span>, i.e. <span><span class="MathJax_Preview">p^c ~|~ x!</span><script type="math/tex">p^c ~|~ x!</script></span>.
Let <span><span class="MathJax_Preview">c(x)</span><script type="math/tex">c(x)</script></span> be that number.
And let <span><span class="MathJax_Preview">g(x) := \frac{x!}{p^{c(x)}}</span><script type="math/tex">g(x) := \frac{x!}{p^{c(x)}}</script></span>.
Then we can write the binomial coefficient as:
<span><span class="MathJax_Preview"><span><span class="MathJax_Preview">\binom n k = \frac {g(n) p^{c(n)}} {g(k) p^{c(k)} g(n-k) p^{c(n-k)}} = \frac {g(n)} {g(k) g(n-k)}p^{c(n) - c(k) - c(n-k)}</span><script type="math/tex">\binom n k = \frac {g(n) p^{c(n)}} {g(k) p^{c(k)} g(n-k) p^{c(n-k)}} = \frac {g(n)} {g(k) g(n-k)}p^{c(n) - c(k) - c(n-k)}</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">\binom n k = \frac {g(n) p^{c(n)}} {g(k) p^{c(k)} g(n-k) p^{c(n-k)}} = \frac {g(n)} {g(k) g(n-k)}p^{c(n) - c(k) - c(n-k)}</span><script type="math/tex">\binom n k = \frac {g(n) p^{c(n)}} {g(k) p^{c(k)} g(n-k) p^{c(n-k)}} = \frac {g(n)} {g(k) g(n-k)}p^{c(n) - c(k) - c(n-k)}</script></span></script></span></p>
<p>The interesting thing is, that <span><span class="MathJax_Preview">g(x)</span><script type="math/tex">g(x)</script></span> is now free from the prime divisor <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>.
Therefore <span><span class="MathJax_Preview">g(x)</span><script type="math/tex">g(x)</script></span> is coprime to m, and we can compute the modular inverses of <span><span class="MathJax_Preview">g(k)</span><script type="math/tex">g(k)</script></span> and <span><span class="MathJax_Preview">g(n-k)</span><script type="math/tex">g(n-k)</script></span>.</p>
<p>After precomputing all values for <span><span class="MathJax_Preview">g</span><script type="math/tex">g</script></span> and <span><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span>, which can be done efficiently using dynamic programming in <span><span class="MathJax_Preview">\mathcal{O}(n)</span><script type="math/tex">\mathcal{O}(n)</script></span>, we can compute the binomial coefficient in <span><span class="MathJax_Preview">O(\log m)</span><script type="math/tex">O(\log m)</script></span> time.
Or precompute all inverses and all powers of <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>, and then compute the binomial coefficient in <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>.</p>
<p>Notice, if <span><span class="MathJax_Preview">c(n) - c(k) - c(n-k) \ge b</span><script type="math/tex">c(n) - c(k) - c(n-k) \ge b</script></span>, than <span><span class="MathJax_Preview">p^b ~|~ p^{c(n) - c(k) - c(n-k)}</span><script type="math/tex">p^b ~|~ p^{c(n) - c(k) - c(n-k)}</script></span>, and the binomial coefficient is <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>.</p>
<h3 id="binomial-coefficient-modulo-an-arbitrary-number">Binomial coefficient modulo an arbitrary number</h3>
<p>Now we compute the binomial coefficient modulo some arbitrary modulus <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>.</p>
<p>Let the prime factorization of <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> be <span><span class="MathJax_Preview">m = p_1^{e_1} p_2^{e_2} \cdots p_h^{e_h}</span><script type="math/tex">m = p_1^{e_1} p_2^{e_2} \cdots p_h^{e_h}</script></span>.
We can compute the binomial coefficient modulo <span><span class="MathJax_Preview">p_i^{e_i}</span><script type="math/tex">p_i^{e_i}</script></span> for every <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>.
This gives us <span><span class="MathJax_Preview">h</span><script type="math/tex">h</script></span> different congruences.
Since all moduli <span><span class="MathJax_Preview">p_i^{e_i}</span><script type="math/tex">p_i^{e_i}</script></span> are coprime, we can apply the <a href="/docs/#Algorithms/Algebra/Chinese_Remainder_Theorem/">Chinese Remainder Theorem</a> to compute the binomial coefficient modulo the product of the moduli, which is the desired binomial coefficient modulo <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>.</p>
<h3 id="binomial-coefficient-for-large-nn-and-small-modulo">Binomial coefficient for large <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> and small modulo</h3>
<p>When <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> is too large, the <span><span class="MathJax_Preview">\mathcal{O}(n)</span><script type="math/tex">\mathcal{O}(n)</script></span> algorithms discussed above become impractical. However, if the modulo <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> is small there are still ways to calculate <span><span class="MathJax_Preview">\binom{n}{k} \bmod m</span><script type="math/tex">\binom{n}{k} \bmod m</script></span>.</p>
<p>When the modulo <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> is prime, there are 2 options:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Lucas's_theorem">Lucas's theorem</a> can be applied which breaks the problem of computing <span><span class="MathJax_Preview">\binom{n}{k} \bmod m</span><script type="math/tex">\binom{n}{k} \bmod m</script></span> into <span><span class="MathJax_Preview">\log_m n</span><script type="math/tex">\log_m n</script></span> problems of the form <span><span class="MathJax_Preview">\binom{x_i}{y_i} \bmod m</span><script type="math/tex">\binom{x_i}{y_i} \bmod m</script></span> where <span><span class="MathJax_Preview">x_i, y_i &lt; m</span><script type="math/tex">x_i, y_i < m</script></span>.  If each reduced coefficient is calculated using precomputed factorials and inverse factorials, the complexity is <span><span class="MathJax_Preview">\mathcal{O}(m + \log_m n)</span><script type="math/tex">\mathcal{O}(m + \log_m n)</script></span>.</li>
<li>The method of computing <a href="/docs/#Algorithms/Algebra/Factorial_Modulo_P/">factorial modulo P</a> can be used to get the required <span><span class="MathJax_Preview">g</span><script type="math/tex">g</script></span> and <span><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span> values and use them as described in the section of <a href="#mod-prime-pow">modulo prime power</a>. This takes <span><span class="MathJax_Preview">\mathcal{O}(m \log_m n)</span><script type="math/tex">\mathcal{O}(m \log_m n)</script></span>.</li>
</ul>
<p>When <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> is not prime but square-free, the prime factors of <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> can be obtained and the coefficient modulo each prime factor can be calculated using either of the above methods, and the overall answer can be obtained by the Chinese Remainder Theorem.</p>
<p>When <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> is not square-free, a <a href="https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf">generalization of Lucas's theorem for prime powers</a> can be applied instead of Lucas's theorem.</p>
<h2 id="practice-problems">Practice Problems</h2>
<ul>
<li><a href="https://www.codechef.com/LTIME24/problems/NWAYS/">Codechef - Number of ways</a></li>
<li><a href="http://codeforces.com/problemset/problem/407/C">Codeforces - Curious Array</a></li>
<li><a href="http://www.lightoj.com/volume_showproblem.php?problem=1419">LightOj - Necklaces</a></li>
<li><a href="https://www.hackerearth.com/problem/algorithm/binomial-coefficient-1/description/">HACKEREARTH: Binomial Coefficient</a></li>
<li><a href="http://www.spoj.com/problems/ADATEAMS/">SPOJ - Ada and Teams</a></li>
<li><a href="https://devskill.com/CodingProblems/ViewProblem/61">DevSkill - Drive In Grid</a></li>
<li><a href="http://www.spoj.com/problems/UCV2013E/">SPOJ - Greedy Walking</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=5137">UVa 13214 - The Robot's Grid</a></li>
<li><a href="http://www.spoj.com/problems/GOODB/">SPOJ - Good Predictions</a></li>
<li><a href="http://www.spoj.com/problems/HC12/">SPOJ - Card Game</a></li>
<li><a href="http://www.spoj.com/problems/HLP_RAMS/">SPOJ - Topper Rama Rao</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=5095">UVa 13184 - Counting Edges and Graphs</a></li>
<li><a href="http://codeforces.com/contest/785/problem/D">Codeforces - Anton and School 2</a></li>
<li><a href="https://devskill.com/CodingProblems/ViewProblem/255">DevSkill - Parandthesis</a></li>
<li><a href="http://codeforces.com/contest/760/problem/F">Codeforces - Bacterial Melee</a></li>
<li><a href="http://codeforces.com/contest/872/problem/E">Codeforces - Points, Lines and Ready-made Titles</a></li>
<li><a href="https://www.spoj.com/problems/DCEPC13D/">SPOJ - The Ultimate Riddle</a></li>
<li><a href="https://www.codechef.com/MAY17/problems/SANDWICH/">CodeChef - Long Sandwich</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="https://fishi.devtail.io/weblog/2015/06/25/computing-large-binomial-coefficients-modulo-prime-non-prime/">Blog fishi.devtail.io</a></li>
<li><a href="https://math.stackexchange.com/questions/95491/n-choose-k-bmod-m-using-chinese-remainder-theorem">Question on Mathematics StackExchange</a></li>
<li><a href="https://discuss.codechef.com/questions/98129/your-approach-to-solve-sandwich">Question on CodeChef Discuss</a></li>
</ul>

  <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://d-k-ivanov.github.io/">Main site</a>
      </p><p>Copyright &copy; 2016-2020 Dmitriy Ivanov. <script type="text/javascript"> (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)}; m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)}) (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym"); ym(40819844, "init", { clickmap:true, trackLinks:true, accurateTrackBounce:true }); </script> <noscript><div><img src="https://mc.yandex.ru/watch/40819844" style="position:absolute; left:-9999px;" alt="" /></div></noscript></p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>