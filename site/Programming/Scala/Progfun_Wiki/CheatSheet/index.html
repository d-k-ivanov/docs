<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="Dmitry Ivanov">
    <link rel="canonical" href="https://d-k-ivanov.github.io/docs/Programming/Scala/Progfun_Wiki/CheatSheet/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Cheat Sheet - Technical Info</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/extra.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Evaluation Rules", url: "#_top", children: [
          ]},
          {title: "Higher order functions", url: "#higher-order-functions", children: [
          ]},
          {title: "Currying", url: "#currying", children: [
          ]},
          {title: "Classes", url: "#classes", children: [
          ]},
          {title: "Operators", url: "#operators", children: [
          ]},
          {title: "Class hierarchies", url: "#class-hierarchies", children: [
          ]},
          {title: "Class Organization", url: "#class-organization", children: [
          ]},
          {title: "Type Parameters", url: "#type-parameters", children: [
          ]},
          {title: "Variance", url: "#variance", children: [
          ]},
          {title: "Pattern Matching", url: "#pattern-matching", children: [
              {title: "Options", url: "#options" },
              {title: "Pattern Matching in Anonymous Functions", url: "#pattern-matching-in-anonymous-functions" },
          ]},
          {title: "Collections", url: "#collections", children: [
              {title: "Base Classes", url: "#base-classes" },
              {title: "Immutable Collections", url: "#immutable-collections" },
              {title: "Mutable Collections", url: "#mutable-collections" },
              {title: "Examples", url: "#examples" },
          ]},
          {title: "Pairs (similar for larger Tuples)", url: "#pairs-similar-for-larger-tuples", children: [
          ]},
          {title: "Ordering", url: "#ordering", children: [
          ]},
          {title: "For-Comprehensions", url: "#for-comprehensions", children: [
              {title: "Example 1", url: "#example-1" },
              {title: "Translation Rules", url: "#translation-rules" },
              {title: "Example 2", url: "#example-2" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../mathjax-config.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-80208201-1', 'd-k-ivanov.github.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    

    <p>This cheat sheet originated from the forum, credits to Laurent Poulain.
We copied it and changed or added a few things.
There are certainly a lot of things that can be improved! If you would like to contribute, you have two options:</p>
<ul>
<li>
<p>Click the "Edit" button on this file on GitHub:<br />
<a href="https://github.com/lampepfl/progfun-wiki/blob/gh-pages/CheatSheet.md">https://github.com/lampepfl/progfun-wiki/blob/gh-pages/CheatSheet.md</a><br />
  You can submit a pull request directly from there without checking out the git repository to your local machine.</p>
</li>
<li>
<p>Fork the repository <a href="https://github.com/lampepfl/progfun-wiki">https://github.com/lampepfl/progfun-wiki</a> and check it out locally. To preview your changes, you need <a href="http://jekyllrb.com/">jekyll</a>. Navigate to your checkout and invoke <code>jekyll serve</code>, then open the page <a href="http://localhost:4000/CheatSheet.html">http://localhost:4000/CheatSheet.html</a>.</p>
</li>
</ul>
<h2 id="evaluation-rules">Evaluation Rules</h2>
<ul>
<li>Call by value: evaluates the function arguments before calling the function</li>
<li>Call by name: evaluates the function first, and then evaluates the arguments if need be</li>
</ul>
<!-- code -->

<pre><code class="language-scala">    def example = 2      // evaluated when called
    val example = 2      // evaluated immediately
    lazy val example = 2 // evaluated once when needed

    def square(x: Double)    // call by value
    def square(x: =&gt; Double) // call by name
    def myFct(bindings: Int*) = { ... } // bindings is a sequence of int, containing a varying # of arguments
</code></pre>
<h2 id="higher-order-functions">Higher order functions</h2>
<p>These are functions that take a function as a parameter or return functions.</p>
<pre><code class="language-scala">    // sum takes a function that takes an integer and returns an integer then 
    // returns a function that takes two integers and returns an integer  
    def sum(f: Int =&gt; Int): (Int, Int) =&gt; Int = {  
      def sumf(a: Int, b: Int): Int = f(a) + f(b)  
      sumf  
    } 

    // same as above. Its type is (Int =&gt; Int) =&gt; (Int, Int) =&gt; Int  
    def sum(f: Int =&gt; Int)(a: Int, b: Int): Int = { ... } 

    // Called like this
    sum((x: Int) =&gt; x * x * x)          // Anonymous function, i.e. does not have a name  
    sum(x =&gt; x * x * x)                 // Same anonymous function with type inferred

    def cube(x: Int) = x * x * x  
    sum(x =&gt; x * x * x)(1, 10) // sum of 1 cubed and 10 cubed
    sum(cube)(1, 10)           // same as above      
</code></pre>
<h2 id="currying">Currying</h2>
<p>Converting a function with multiple arguments into a function with a
single argument that returns another function.</p>
<pre><code class="language-scala">    def f(a: Int, b: Int): Int // uncurried version (type is (Int, Int) =&gt; Int)
    def f(a: Int)(b: Int): Int // curried version (type is Int =&gt; Int =&gt; Int)
</code></pre>
<p>To curry an existing function :  </p>
<pre><code class="language-scala">    val f2: (Int, Int) =&gt; Int = f // uncurried version (type is (Int, Int) =&gt; Int)
    val f3: Int =&gt; Int =&gt; Int = f2.curried // transform it to a curried version (type is Int =&gt; Int =&gt; Int)
    val f4: (Int, Int) =&gt; Int = Function.uncurried(f3) // go back to the uncurried version (type is (Int, Int) =&gt; Int)
</code></pre>
<h2 id="classes">Classes</h2>
<pre><code class="language-scala">    class MyClass(x: Int, val y: Int,
                          var z: Int) {       // Defines a new type MyClass with a constructor
                                              // x will not be available outside MyClass
                                              // val will generate a getter for y
                                              // var will generate a getter and a setter for z
      require(y &gt; 0, &quot;y must be positive&quot;)    // precondition, triggering an IllegalArgumentException if not met  
      def this (x: Int) = { ... }             // auxiliary constructor   
      def nb1 = x                             // public method computed every time it is called    
      private def test(a: Int): Int = { ... } // private method  
      val nb3 = x + y                         // computed only once  
      override def toString =                 // overridden method  
          x + &quot;, &quot; + y 
    }

    new MyClass(1, 2, 3) // creates a new object of type
</code></pre>
<p><code>this</code> references the current object, <code>assert(&lt;condition&gt;)</code> issues <code>AssertionError</code> if condition
is not met. See <a href="https://www.scala-lang.org/api/current/scala/Predef$.html"><code>scala.Predef</code></a> for <code>require</code>, <code>assume</code> and <code>assert</code>.</p>
<h2 id="operators">Operators</h2>
<p><code>myObject myMethod 1</code> is the same as calling <code>myObject.myMethod(1)</code></p>
<p>Operator (i.e. function) names can be alphanumeric, symbolic (e.g. <code>x1</code>, <code>*</code>, <code>+?%&amp;</code>, <code>vector_++</code>, <code>counter_=</code>)</p>
<p>The precedence of an operator is determined by its first character, with the following increasing order of priority:</p>
<pre><code>(all letters)
|
^
&amp;
&lt; &gt;
= !
:
+ -
* / %
(all other special characters)
</code></pre>
<p>The associativity of an operator is determined by its last character: Right-associative if ending with <code>:</code>, Left-associative otherwise.</p>
<p>Note that assignment operators have lowest precedence. (Read Scala Language Specification 2.9 sections 6.12.3, 6.12.4 for more info)</p>
<h2 id="class-hierarchies">Class hierarchies</h2>
<pre><code class="language-scala">    abstract class TopLevel {    // abstract class  
      def method1(x: Int): Int   // abstract method  
      def method2(x: Int): Int = { ... }  
    }

    class Level1 extends TopLevel {  
      def method1(x: Int): Int = { ... }  
      override def method2(x: Int): Int = { ...} // TopLevel's method2 needs to be explicitly overridden  
    }

    object MyObject extends TopLevel { ... } // defines a singleton object. No other instance can be created
</code></pre>
<p>To create a runnable application in Scala:</p>
<pre><code class="language-scala">    object Hello {  
      def main(args: Array[String]) = println(&quot;Hello world&quot;)  
    }
</code></pre>
<p>or</p>
<pre><code class="language-scala">    object Hello extends App {
      println(&quot;Hello World&quot;)
    }
</code></pre>
<h2 id="class-organization">Class Organization</h2>
<ul>
<li>
<p>Classes and objects are organized in packages (<code>package myPackage</code>).</p>
</li>
<li>
<p>They can be referenced through import statements (<code>import myPackage.MyClass</code>, <code>import myPackage._</code>,
<code>import myPackage.{MyClass1, MyClass2}</code>, <code>import myPackage.{MyClass1 =&gt; A}</code>)</p>
</li>
<li>
<p>They can also be directly referenced in the code with the fully qualified name (<code>new myPackage.MyClass1</code>)</p>
</li>
<li>
<p>All members of packages <code>scala</code> and <code>java.lang</code> as well as all members of the object <code>scala.Predef</code> are automatically imported.</p>
</li>
<li>
<p>Traits are similar to Java interfaces, except they can have non-abstract members:</p>
</li>
</ul>
<pre><code class="language-scala">        trait Planar { ... }
        class Square extends Shape with Planar
</code></pre>
<ul>
<li>
<p>General object hierarchy:</p>
</li>
<li>
<p><code>scala.Any</code> base type of all types. Has methods <code>hashCode</code> and <code>toString</code> that can be overridden</p>
</li>
<li><code>scala.AnyVal</code> base type of all primitive types. (<code>scala.Double</code>, <code>scala.Float</code>, etc.)</li>
<li><code>scala.AnyRef</code> base type of all reference types. (alias of <code>java.lang.Object</code>, supertype of <code>java.lang.String</code>, <code>scala.List</code>, any user-defined class)</li>
<li><code>scala.Null</code> is a subtype of any <code>scala.AnyRef</code> (<code>null</code> is the only instance of type <code>Null</code>), and <code>scala.Nothing</code> is a subtype of any other type without any instance.</li>
</ul>
<h2 id="type-parameters">Type Parameters</h2>
<p>Conceptually similar to C++ templates or Java generics. These can apply to classes, traits or functions.</p>
<pre><code class="language-scala">    class MyClass[T](arg1: T) { ... }  
    new MyClass[Int](1)  
    new MyClass(1)   // the type is being inferred, i.e. determined based on the value arguments  
</code></pre>
<p>It is possible to restrict the type being used, e.g.</p>
<pre><code class="language-scala">    def myFct[T &lt;: TopLevel](arg: T): T = { ... } // T must derive from TopLevel or be TopLevel
    def myFct[T &gt;: Level1](arg: T): T = { ... }   // T must be a supertype of Level1
    def myFct[T &gt;: Level1 &lt;: TopLevel](arg: T): T = { ... }
</code></pre>
<h2 id="variance">Variance</h2>
<p>Given <code>A &lt;: B</code></p>
<p>If <code>C[A] &lt;: C[B]</code>, <code>C</code> is covariant</p>
<p>If <code>C[A] &gt;: C[B]</code>, <code>C</code> is contravariant</p>
<p>Otherwise C is nonvariant</p>
<pre><code class="language-scala">    class C[+A] { ... } // C is covariant
    class C[-A] { ... } // C is contravariant
    class C[A]  { ... } // C is nonvariant
</code></pre>
<p>For a function, if <code>A2 &lt;: A1</code> and <code>B1 &lt;: B2</code>, then <code>A1 =&gt; B1 &lt;: A2 =&gt; B2</code>.</p>
<p>Functions must be contravariant in their argument types and covariant in their result types, e.g.</p>
<pre><code class="language-scala">    trait Function1[-T, +U] {
      def apply(x: T): U
    } // Variance check is OK because T is contravariant and U is covariant

    class Array[+T] {
      def update(x: T)
    } // variance checks fails
</code></pre>
<p>Find out more about variance in
<a href="https://class.coursera.org/progfun-2012-001/lecture/81">lecture 4.4</a>
and <a href="https://class.coursera.org/progfun-2012-001/lecture/83">lecture 4.5</a></p>
<h2 id="pattern-matching">Pattern Matching</h2>
<p>Pattern matching is used for decomposing data structures:</p>
<pre><code class="language-scala">    unknownObject match {
      case MyClass(n) =&gt; ...
      case MyClass2(a, b) =&gt; ...
    }
</code></pre>
<p>Here are a few example patterns</p>
<pre><code class="language-scala">    (someList: List[T]) match {
      case Nil =&gt; ...          // empty list
      case x :: Nil =&gt; ...     // list with only one element
      case List(x) =&gt; ...      // same as above
      case x :: xs =&gt; ...      // a list with at least one element. x is bound to the head,
                               // xs to the tail. xs could be Nil or some other list.
      case 1 :: 2 :: cs =&gt; ... // lists that starts with 1 and then 2
      case (x, y) :: ps =&gt; ... // a list where the head element is a pair
      case _ =&gt; ...            // default case if none of the above matches
    }
</code></pre>
<p>The last example shows that every pattern consists of sub-patterns: it
only matches lists with at least one element, where that element is a
pair. <code>x</code> and <code>y</code> are again patterns that could match only specific
types.</p>
<h3 id="options">Options</h3>
<p>Pattern matching can also be used for <code>Option</code> values. Some
functions (like <code>Map.get</code>) return a value of type <code>Option[T]</code> which
is either a value of type <code>Some[T]</code> or the value <code>None</code>:</p>
<pre><code class="language-scala">    val myMap = Map(&quot;a&quot; -&gt; 42, &quot;b&quot; -&gt; 43)
    def getMapValue(s: String): String = {
      myMap get s match {
        case Some(nb) =&gt; &quot;Value found: &quot; + nb
        case None =&gt; &quot;No value found&quot;
      }
    }
    getMapValue(&quot;a&quot;)  // &quot;Value found: 42&quot;
    getMapValue(&quot;c&quot;)  // &quot;No value found&quot;
</code></pre>
<p>Most of the times when you write a pattern match on an option value,
the same expression can be written more concisely using combinator
methods of the <code>Option</code> class. For example, the function <code>getMapValue</code>
can be written as follows: </p>
<pre><code class="language-scala">    def getMapValue(s: String): String =
      myMap.get(s).map(&quot;Value found: &quot; + _).getOrElse(&quot;No value found&quot;)
</code></pre>
<h3 id="pattern-matching-in-anonymous-functions">Pattern Matching in Anonymous Functions</h3>
<p>Pattern matches are also used quite often in anonymous functions:</p>
<pre><code class="language-scala">    val pairs: List[(Char, Int)] = ('a', 2) :: ('b', 3) :: Nil
    val chars: List[Char] = pairs.map(p =&gt; p match {
      case (ch, num) =&gt; ch
    })
</code></pre>
<p>Instead of <code>p =&gt; p match { case ... }</code>, you can simply write <code>{case ...}</code>, so the above example becomes more concise:</p>
<pre><code class="language-scala">    val chars: List[Char] = pairs map {
      case (ch, num) =&gt; ch
    }
</code></pre>
<h2 id="collections">Collections</h2>
<p>Scala defines several collection classes:</p>
<h3 id="base-classes">Base Classes</h3>
<ul>
<li><a href="https://www.scala-lang.org/api/current/scala/collection/Iterable.html"><code>Iterable</code></a> (collections you can iterate on)</li>
<li><a href="https://www.scala-lang.org/api/current/scala/collection/Seq.html"><code>Seq</code></a> (ordered sequences)</li>
<li><a href="https://www.scala-lang.org/api/current/scala/collection/Set.html"><code>Set</code></a></li>
<li><a href="https://www.scala-lang.org/api/current/scala/collection/Map.html"><code>Map</code></a> (lookup data structure)</li>
</ul>
<h3 id="immutable-collections">Immutable Collections</h3>
<ul>
<li><a href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html"><code>List</code></a> (linked list, provides fast sequential access)</li>
<li><a href="https://www.scala-lang.org/api/current/scala/collection/immutable/Stream.html"><code>Stream</code></a> (same as List, except that the tail is evaluated only on demand)</li>
<li><a href="https://www.scala-lang.org/api/current/scala/collection/immutable/Vector.html"><code>Vector</code></a> (array-like type, implemented as tree of blocks, provides fast random access)</li>
<li><a href="https://www.scala-lang.org/api/current/scala/collection/immutable/Range.html"><code>Range</code></a> (ordered sequence of integers with equal spacing)</li>
<li><a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><code>String</code></a> (Java type, implicitly converted to a character sequence, so you can treat every string like a <code>Seq[Char]</code>)</li>
<li><a href="https://www.scala-lang.org/api/current/scala/collection/immutable/Map.html"><code>Map</code></a> (collection that maps keys to values)</li>
<li><a href="https://www.scala-lang.org/api/current/scala/collection/immutable/Set.html"><code>Set</code></a> (collection without duplicate elements)</li>
</ul>
<h3 id="mutable-collections">Mutable Collections</h3>
<p>Most of the immutable collections above have a mutable counterpart, e.g.: </p>
<ul>
<li><a href="https://www.scala-lang.org/api/current/scala/Array.html"><code>Array</code></a> (Scala arrays are native JVM arrays at runtime, therefore they are very performant)</li>
<li>Scala also has mutable maps and sets; these should only be used if there are performance issues with immutable types</li>
</ul>
<h3 id="examples">Examples</h3>
<p>NOTE: For the correct code convention of using postfix or not, read <a href="https://docs.scala-lang.org/style/method-invocation.html">this</a></p>
<pre><code class="language-scala">    val fruitList = List(&quot;apples&quot;, &quot;oranges&quot;, &quot;pears&quot;)
    // Alternative syntax for lists
    val fruit = &quot;apples&quot; :: (&quot;oranges&quot; :: (&quot;pears&quot; :: Nil)) // parens optional, :: (pronounced cons) is right-associative
    fruit.head   // &quot;apples&quot;
    fruit.tail   // List(&quot;oranges&quot;, &quot;pears&quot;)
    val empty = List()
    val empty = Nil

    val nums = Vector(&quot;louis&quot;, &quot;frank&quot;, &quot;hiromi&quot;)
    nums(1)                     // element at index 1, returns &quot;frank&quot;, complexity O(log(n))
    nums.updated(2, &quot;helena&quot;)   // new vector with a different string at index 2, complexity O(log(n))

    val fruitSet = Set(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;banana&quot;)
    fruitSet.size    // returns 3: there are no duplicates, only one banana

    val r: Range = 1 until 5 // 1, 2, 3, 4
    val s: Range = 1 to 5    // 1, 2, 3, 4, 5
    1 to 10 by 3  // 1, 4, 7, 10
    6 to 1 by -2  // 6, 4, 2

    val s = (1 to 6).toSet
    s map (_ + 2) // adds 2 to each element of the set

    val s = &quot;Hello World&quot;
    s filter (c =&gt; c.isUpper) // returns &quot;HW&quot;; strings can be treated as Seq[Char]

    // Operations on sequences
    val xs = List(...)
    xs.length         // number of elements, complexity O(n)
    xs.last           // last element (exception if xs is empty), complexity O(n)
    xs.init           // all elements of xs but the last (exception if xs is empty), complexity O(n)
    xs take n         // first n elements of xs
    xs drop n         // the rest of the collection after taking n elements
    xs splitAt n      // same as (xs take n, xs drop n)
    xs(n)             // the nth element of xs, complexity O(n)
    xs ++ ys          // concatenation, complexity O(n)
    xs.reverse        // reverse the order, complexity O(n)
    xs updated(n, x)  // same list than xs, except at index n where it contains x, complexity O(n)
    xs indexOf x      // the index of the first element equal to x (-1 otherwise)
    xs contains x     // same as xs indexOf x &gt;= 0
    xs filter p       // returns a list of the elements that satisfy the predicate p
    xs filterNot p    // filter with negated p 
    xs partition p    // same as (xs filter p, xs filterNot p)
    xs takeWhile p    // the longest prefix consisting of elements that satisfy p
    xs dropWhile p    // the remainder of the list after any leading element satisfying p have been removed
    xs span p         // same as (xs takeWhile p, xs dropWhile p)

    List(x1, ..., xn) reduceLeft op    // (...(x1 op x2) op x3) op ...) op xn
    List(x1, ..., xn).foldLeft(z)(op)  // (...( z op x1) op x2) op ...) op xn
    List(x1, ..., xn) reduceRight op   // x1 op (... (x{n-1} op xn) ...)
    List(x1, ..., xn).foldRight(z)(op) // x1 op (... (    xn op  z) ...)

    xs exists p    // true if there is at least one element for which predicate p is true
    xs forall p    // true if p(x) is true for all elements
    xs zip ys      // returns a list of pairs which groups elements with same index together
    xs unzip       // opposite of zip: returns a pair of two lists
    xs.flatMap f   // applies the function to all elements and concatenates the result
    xs.sum         // sum of elements of the numeric collection
    xs.product     // product of elements of the numeric collection
    xs.max         // maximum of collection
    xs.min         // minimum of collection
    xs.flatten     // flattens a collection of collection into a single-level collection
    xs groupBy f   // returns a map which points to a list of elements
    xs distinct    // sequence of distinct entries (removes duplicates)

    x +: xs  // creates a new collection with leading element x
    xs :+ x  // creates a new collection with trailing element x

    // Operations on maps
    val myMap = Map(&quot;I&quot; -&gt; 1, &quot;V&quot; -&gt; 5, &quot;X&quot; -&gt; 10)  // create a map
    myMap(&quot;I&quot;)      // =&gt; 1  
    myMap(&quot;A&quot;)      // =&gt; java.util.NoSuchElementException  
    myMap get &quot;A&quot;   // =&gt; None 
    myMap get &quot;I&quot;   // =&gt; Some(1)
    myMap.updated(&quot;V&quot;, 15)  // returns a new map where &quot;V&quot; maps to 15 (entry is updated)
                            // if the key (&quot;V&quot; here) does not exist, a new entry is added

    // Operations on Streams
    val xs = Stream(1, 2, 3)
    val xs = Stream.cons(1, Stream.cons(2, Stream.cons(3, Stream.empty))) // same as above
    (1 to 1000).toStream // =&gt; Stream(1, ?)
    x #:: xs // Same as Stream.cons(x, xs)
             // In the Stream's cons operator, the second parameter (the tail)
             // is defined as a &quot;call by name&quot; parameter.
             // Note that x::xs always produces a List
    def integers(start: Int = 0): Stream[Int] = start #:: integers(start + 1) // infinite sequence of integers starting at &quot;start&quot;
    integers(0) drop 10 take 100 // New stream starting at 10
</code></pre>
<h2 id="pairs-similar-for-larger-tuples">Pairs (similar for larger Tuples)</h2>
<pre><code class="language-scala">    val pair = (&quot;answer&quot;, 42)   // type: (String, Int)
    val (label, value) = pair   // label = &quot;answer&quot;, value = 42  
    pair._1 // &quot;answer&quot;  
    pair._2 // 42  
</code></pre>
<h2 id="ordering">Ordering</h2>
<p>There is already a class in the standard library that represents orderings: <code>scala.math.Ordering[T]</code> which contains
comparison functions such as <code>lt()</code> and <code>gt()</code> for standard types. Types with a single natural ordering should inherit from 
the trait <code>scala.math.Ordered[T]</code>.</p>
<pre><code class="language-scala">    import math.Ordering  

    def msort[T](xs: List[T])(implicit ord: Ordering) = { ...}  
    msort(fruits)(Ordering.String)  
    msort(fruits)   // the compiler figures out the right ordering  
</code></pre>
<h2 id="for-comprehensions">For-Comprehensions</h2>
<p>A for-comprehension is syntactic sugar for <code>map</code>, <code>flatMap</code> and <code>filter</code> operations on collections.</p>
<p>The general form is <code>for (s) yield e</code></p>
<ul>
<li><code>s</code> is a sequence of generators and filters</li>
<li><code>p &lt;- e</code> is a generator</li>
<li><code>if f</code> is a filter</li>
<li>If there are several generators (equivalent of a nested loop), the last generator varies faster than the first</li>
<li>You can use <code>{ s }</code> instead of <code>( s )</code> if you want to use multiple lines without requiring semicolons</li>
<li><code>e</code> is an element of the resulting collection</li>
</ul>
<h3 id="example-1">Example 1</h3>
<pre><code class="language-scala">    // list all combinations of numbers x and y where x is drawn from
    // 1 to M and y is drawn from 1 to N
    for (x &lt;- 1 to M; y &lt;- 1 to N)
      yield (x,y)
</code></pre>
<p>is equivalent to</p>
<pre><code class="language-scala">    (1 to M) flatMap (x =&gt; (1 to N) map (y =&gt; (x, y)))
</code></pre>
<h3 id="translation-rules">Translation Rules</h3>
<p>A for-expression looks like a traditional for loop but works differently internally</p>
<p><code>for (x &lt;- e1) yield e2</code> is translated to <code>e1.map(x =&gt; e2)</code></p>
<p><code>for (x &lt;- e1 if f; s) yield e2</code> is translated to <code>for (x &lt;- e1.withFilter(x =&gt; f); s) yield e2</code></p>
<p><code>for (x &lt;- e1; y &lt;- e2; s) yield e3</code> is translated to <code>e1.flatMap(x =&gt; for (y &lt;- e2; s) yield e3)</code></p>
<p>Note: s is a (potentially empty) sequence of fields (generators and filters)</p>
<p>This means you can use a for-comprehension for your own type, as long
as you define <code>map</code>, <code>flatMap</code> and <code>filter</code>.</p>
<p>For more, see <a href="https://class.coursera.org/progfun-2012-001/lecture/111">lecture 6.5</a>.</p>
<h3 id="example-2">Example 2</h3>
<pre><code class="language-scala">    for {  
      i &lt;- 1 until n  
      j &lt;- 1 until i  
      if isPrime(i + j)  
    } yield (i, j)  
</code></pre>
<p>is equivalent to</p>
<pre><code class="language-scala">    for (i &lt;- 1 until n; j &lt;- 1 until i if isPrime(i + j))
        yield (i, j)  
</code></pre>
<p>is equivalent to</p>
<pre><code class="language-scala">    (1 until n).flatMap(i =&gt; (1 until i).filter(j =&gt; isPrime(i + j)).map(j =&gt; (i, j)))
</code></pre>

  <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://d-k-ivanov.github.io/">Main site</a>
      </p><p>Copyright &copy; 2016-2020 Dmitry Ivanov. <script type="text/javascript"> (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)}; m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)}) (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym"); ym(40819844, "init", { clickmap:true, trackLinks:true, accurateTrackBounce:true }); </script> <noscript><div><img src="https://mc.yandex.ru/watch/40819844" style="position:absolute; left:-9999px;" alt="" /></div></noscript></p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>