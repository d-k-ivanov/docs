<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="Dmitry Ivanov">
    <link rel="canonical" href="https://d-k-ivanov.github.io/docs/Programming/CSharp/CodeStyle/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>CodeStyle - Technical Info</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <link href="../../../css/extra.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Introduction", url: "#_top", children: [
          ]},
          {title: "Guiding Principles", url: "#guiding-principles", children: [
          ]},
          {title: "The Rundown", url: "#the-rundown", children: [
          ]},
          {title: "General Guidelines", url: "#general-guidelines", children: [
              {title: "File Layout", url: "#file-layout" },
              {title: "using Directives", url: "#using-directives" },
              {title: "Declaring Types", url: "#declaring-types" },
          ]},
          {title: "Member Declarations", url: "#member-declarations", children: [
              {title: "Methods", url: "#methods" },
              {title: "Properties", url: "#properties" },
              {title: "Type Inference", url: "#type-inference" },
              {title: "Object and Collection Initializers", url: "#object-and-collection-initializers" },
              {title: "Indentation", url: "#indentation" },
              {title: "Where to put spaces[1]", url: "#where-to-put-spaces1" },
              {title: "Where to put braces", url: "#where-to-put-braces" },
              {title: "Long Argument Lists", url: "#long-argument-lists" },
              {title: "Casing", url: "#casing" },
              {title: "Instance Fields", url: "#instance-fields" },
              {title: "this", url: "#this" },
          ]},
          {title: "Comments", url: "#comments", children: [
              {title: "Simple Comments", url: "#simple-comments" },
              {title: "Multiline comments", url: "#multiline-comments" },
              {title: "Commenting Out Code", url: "#commenting-out-code" },
          ]},
          {title: "Naming", url: "#naming", children: [
              {title: "Constants", url: "#constants" },
          ]},
          {title: "Lambdas", url: "#lambdas", children: [
          ]},
          {title: "Credits", url: "#credits", children: [
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../mathjax-config.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-80208201-1', 'd-k-ivanov.github.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    

    <h2 id="introduction">Introduction</h2>
<p>These documents contain guidelines for writing consistent, lucid, enticing, modern C#.</p>
<p>If you take issue with anything here, please open a pull request with your recommended changes and include an argument for <em>and against</em> their adoption; explain the benefits of your proposed change, and also any drawbacks.</p>
<h2 id="guiding-principles">Guiding Principles</h2>
<ul>
<li>Be consistent.</li>
<li>Don't rewrite existing code to follow this guide.</li>
<li>Don't violate a guideline without a good reason.</li>
<li>A reason is good when you can convince a teammate, not just when you like it.</li>
<li>Assume your reader knows C# and English.</li>
<li>Prefer clarity to 'performance'.</li>
<li>Prefer clarity to .NET dogma.</li>
<li>Write comments that people want to read, with correct spelling and grammar.</li>
</ul>
<h2 id="the-rundown">The Rundown</h2>
<ul>
<li>Indent with spaces.</li>
<li>Max line length is 120 columns.</li>
<li>Use spaces and empty lines precisely.</li>
<li>Braces generally go on their own lines.</li>
<li>Never put a space before <code>[</code>.</li>
<li>Always put a space before <code>{</code>.</li>
<li>Always put a space before <code>(</code> except for method invocations or when following another <code>(</code>.</li>
</ul>
<h2 id="general-guidelines">General Guidelines</h2>
<h3 id="file-layout">File Layout</h3>
<p>Layout your <code>.cs</code> files like this:</p>
<pre><code class="language-txt">File Header

Using Directives

Namespace Declaration

    Type Declaration

        Constants
        Static Fields
        Static Auto-Properties
        Static Delegates
        Static Events
        Static Enums
        Static Constructors
        Static Complex Properties
        Static Methods
        Static Structs
        Static Interfaces
        Static Classes
        Fields
        Auto-Properties
        Delegates
        Events
        Enums
        Constructors
        Finalizers (Destructors)
        Complex Properties
        Methods
        Structs
        Interfaces
        Classes
</code></pre>
<p>Within each of these groups order by access:</p>
<pre><code class="language-txt">public
internal
protected
private
</code></pre>
<p>An exception to this layout is manual properties with a backing field used exclusively via the property; these members should occur in the file together in the properties section. If your backing field is accessed anywhere other than inside the property definition, stick to normal layout rules.</p>
<pre><code class="language-csharp">string name;
public string Name {
    get { return name; }
    set { name = value; }
}
</code></pre>
<h3 id="using-directives">using Directives</h3>
<p>Group using directives by common prefix, with shorter namespaces coming before longer ones, creating neat clusters of statements separated by single empty lines.</p>
<p>Namespaces should be ordered in increasing order of platform specificity, with .NET namespaces first, then library or component namespaces, then Xamarin namespaces, then application namespaces:</p>
<pre><code class="language-csharp">// Beautiful:
using System;
using System.Linq;
using System.Collections.Generic;

using MyLib;
using MyLib.Extensions;

using MonoTouch.UIKit;
using MonoTouch.Foundation;

using MyApp;

// Disaster:
using MyLib.Extensions;
using MonoTouch.Foundation;
using System.Collections.Generic;
using System;
using System.Linq;
using MonoTouch.UIKit;
using MyLib;
</code></pre>
<p>Prune redundant namespaces aggressively.</p>
<h3 id="declaring-types">Declaring Types</h3>
<p>Leave an empty line between every type definition:</p>
<pre><code class="language-csharp">// Perfect.
namespace MyApp
{
    enum Direction { Left, Right }

    class ImportantThing
    {
        ...
    }
}

// Wrong - missing and empty line between type definitions.
namespace MyApp
{
    enum Direction { Left, Right }
    class ImportantThing
    {
        ...
    }
}

// Wrong - more than one empty line.
namespace MyApp
{
    enum Direction { Left, Right }


    class ImportantThing
    {
        ...
    }
}
</code></pre>
<p>Put a space before and after <code>:</code> when listing base classes and interfaces.</p>
<pre><code class="language-csharp">// Perfect.
class MyClass : BaseClass, IDoesThis
{
}

// Wrong.
class MyClass: BaseClass, IDoesThis
{
}
</code></pre>
<h4 id="enums">Enums</h4>
<p>Simple enums may be defined on a single line:</p>
<pre><code class="language-csharp">enum Edge { Left, Right, Bottom, Top }
</code></pre>
<p>Larger enums should list entries on separate lines and always end in a comma:</p>
<pre><code class="language-csharp">enum StringSplitOptions
{
    None = 0,
    RemoveEmptyEntries = 1,
}
</code></pre>
<h2 id="member-declarations">Member Declarations</h2>
<p>Leave an empty line before every method, property, indexer, constructor, and destructor:</p>
<pre><code class="language-csharp">class Person
{
    string name;

    public Person(string name)
    {
        this.name = name;
    }
}
</code></pre>
<p>Automatic properties don't need to be preceded by an empty line:</p>
<pre><code class="language-csharp">class Person
{
    string Name { get; set; }
    int Age { get; set; }

    ...
}
</code></pre>
<h3 id="methods">Methods</h3>
<pre><code class="language-csharp">public async Task&lt;string[]&gt; Query&lt;TDatabase&gt;(User user, TDatabase database, Role role = Role.Admin)
    : where TDatabase : IDatabase
{
}
</code></pre>
<h3 id="properties">Properties</h3>
<p>Declare automatic properties on a single line with the exact spacing shown below:</p>
<pre><code class="language-csharp">// Perfect.
string Name { get; set; }
</code></pre>
<p>Simple properties may define <code>get</code> and <code>set</code> on a single line each, with <code>get</code> first:</p>
<pre><code class="language-csharp">// Perfect.
string Name {
    get { return name; }
    set { name = value; }
}
</code></pre>
<p>Also note the single spaces before and after <code>{</code>, and the space before <code>}</code>.</p>
<p>Complex properties go like this:</p>
<pre><code class="language-csharp">// Perfect.
string Name {
    get {
        return name;
    }
    set {
        name = value;
    }
}
</code></pre>
<h3 id="type-inference">Type Inference</h3>
<p>Use it. Less typing is almost always better than more typing, with some important exceptions.</p>
<p>Use <code>var</code> when the type is repeated on the right-hand side of the assignment:</p>
<pre><code class="language-csharp">// Perfect!
var users = new Dictionary&lt;UserId, User&gt;();

// Bloated.
Dictionary&lt;UserId, User&gt; users = new Dictionary&lt;UserId, User&gt;();
</code></pre>
<p>Don't use <code>var</code> for capturing the return type of a method or property when the type is not evident:</p>
<pre><code class="language-csharp">// Horrendous.
var things = Interpret(data);

// Much better.
HashMap&lt;Thing&gt; things = Interpret(data);

// Even better.
var things = InterpretAs&lt;Thing&gt;(data);

</code></pre>
<p>Omit the type when using array initializers:</p>
<pre><code class="language-csharp">// Could be better:
database.UpdateUserIds(new int[] { 1, 2, 3 });

// Better:
database.UpdateUserIds(new [] { 1, 2, 3 });
</code></pre>
<h3 id="object-and-collection-initializers">Object and Collection Initializers</h3>
<p>Use them.</p>
<p>For simple initializers, you may do a one-liner:</p>
<pre><code class="language-csharp">// Perfect.
var person = new Person(&quot;Vinny&quot;) { Age = 50 };

// Acceptable.
var person = new Person(&quot;Vinny&quot;) {
    Age = 50,
};
</code></pre>
<p>Omit the <code>()</code> when using parameterless constructors:</p>
<pre><code class="language-csharp">// Perfect.
var person = new Person { Name = &quot;Bob&quot;, Age = 75 };

// Wrong.
var person = new Person() { Name = &quot;Bob&quot;, Age = 75 };
</code></pre>
<p>In general, each expression should be on a separate line, and every line should end with a comma <code>,</code>:</p>
<pre><code class="language-csharp">// Very nice collection initializer.
var entries = new Dictionary&lt;string, int&gt; {
    { &quot;key1&quot;, 1 },
    { &quot;key2&quot;, 2 },
};

// Very nice object initializer.
var contact = new Person {
    Name = &quot;David Siegel&quot;,
    SocialSecurityNumber = 123456789,
    Address = &quot;1234 Montgomery Circle Drive East&quot;,
};

// Bad collection initializer – multiple entries on one line.
var entries = new Dictionary&lt;string, int&gt; {
    { &quot;key1&quot;, 1 }, { &quot;key2&quot;, 2 },
};
</code></pre>
<h3 id="indentation">Indentation</h3>
<p><code>switch</code> statements have the case at the same indentation as the <code>switch</code>:</p>
<pre><code class="language-csharp">switch (x) {
case 'a':
    ...
case 'b':
    ...
}
</code></pre>
<h3 id="where-to-put-spaces1">Where to put spaces[1]</h3>
<p>We prefer to put a space before an open parenthesis only in control flow statements, but not in normal method/delegate/lambda calls, or expressions. This makes method invocations stand out from simple logical groupings. For example, this is good:</p>
<pre><code class="language-csharp">// Flow control...
if (awesome) ...
foreach (var foo in foos) ...
while (hazMonkeys) ...

// Logical grouping...
var result = b * (4 + i);

// Method invocation.
Foo(database);
Debug.Assert(5 + (3 * 4) &amp;&amp; &quot;laws of math are failing me&quot;);

// Consider
A = result ?? (int) compute (foo (b + 1));

// At first glance it Looks very similar to:
A = result ?? (int) compute (foo) (b + 1);


// Whereas:
A = result ?? (int) compute(foo(b + 1));

// Looks more immediately distinct from
A = result ?? (int) compute(foo)(b + 1);
</code></pre>
<p>The reason for doing this is not completely arbitrary. This style makes control flow operators stand out more, and makes expressions flow better. The function call operator binds very tightly as a postfix operator. In some cases, such as when C# is embedded in Razor markup, inserting a space before an opening parenthesis will cause compilation to fail.</p>
<p>[1] Adapted from <a href="http://llvm.org/docs/CodingStandards.html#spaces-before-parentheses">LLVM Coding Standards</a></p>
<p>Do not put a space before the left angle bracket in a generic type:</p>
<pre><code class="language-csharp">// Perfect.
var scores = new List&lt;int&gt;();

// Incorrect.
var scores = new List &lt;int&gt;();
</code></pre>
<p>Do not put spaces inside parentheses, square brackets, or angle brackets:</p>
<pre><code class="language-csharp">// Wrong - spaces inside.
Initialize( database );
products[ i ];
new List&lt; int &gt;();
</code></pre>
<p>Separate type parameters to generic types by a space:</p>
<pre><code class="language-csharp">// Excellent.
var users = new Dictionary&lt;UserId, User&gt;();

// Worthless.
var users = new Dictionary&lt;UserId,User&gt;();
</code></pre>
<p>Put a space between the type and the identifier what casting:</p>
<pre><code class="language-csharp">// Great.
var person = (Person) sender;

// Bad.
var person = (Person)sender;
</code></pre>
<h3 id="where-to-put-braces">Where to put braces</h3>
<p>Inside a code block, put the opening brace on the same line as the statement:</p>
<pre><code class="language-csharp">// Lovely.
if (you.Love(someone)) {
    someone.SetFree();
}

// Wrong.
if (you.Love(someone))
{
    someone.SetFree();
}
</code></pre>
<p>Omitting braces for single line if statements is fine, however braces are always acceptable:</p>
<pre><code class="language-csharp">// Lovely.
if (you.Like(it))
    it.PutOn(ring);

// Acceptable.
if (you.Like(it)) {
    it.PutOn(ring);
}
</code></pre>
<p>Very short statements may be one-liners, especially when the body is a <code>return</code>:</p>
<pre><code class="language-csharp">// Lovely.
if (condition) return;

// Acceptable, but a little complex for a one-liner.
if (people.All(p =&gt; p.IsAdmin)) return new AdminPage();

// Wrong - too complex for a single line:
if (people.Where(p =&gt; p.IsAdmin).Average(p =&gt; p.Age) &gt; 21) return DrinkDispenser.FireWater;
</code></pre>
<p>Always use braces with nested or multi-line conditions:</p>
<pre><code class="language-csharp">// Perfect.
if (a) {
    if (b) {
        code();
    }
}

// Acceptable.
if (a) {
    if (b)
        code();
}

// Wrong.
if (a)
    if (b)
        code ();
</code></pre>
<p>When defining a method, put the opening brace on its own line:</p>
<pre><code class="language-csharp">// Correct.
void LaunchRockets()
{
}

// Wrong.
void LaunchRockets() {
}
</code></pre>
<p>When defining a property, keep the opening brace on the same line:</p>
<pre><code class="language-csharp">// Perfect.
double AverageAge {
    get {
        return people.Average (p =&gt; p.Age);
    }
}


// Wrong.
double AverageAge
{
    get {
        return people.Average(p =&gt; p.Age);
    }
}
</code></pre>
<p>Notice how  <code>get</code> keeps its brace on the same line.</p>
<p>For very small properties, you can compress things:</p>
<pre><code class="language-csharp">// Preferred.
int Property {
    get { return value; }
    set { x = value; }
}

// Acceptable.
int Property {
    get {
        return value;
    }
    set {
        x = value;
    }
}
</code></pre>
<p>Empty methods should have the body of code using two lines, in consistency with the rest:</p>
<pre><code class="language-csharp">// Good.
void EmptyMethod()
{
}

// These are wrong.
void EmptyMethod() {}

void EmptyMethod()
{}
</code></pre>
<p>Generic method type parameter constraints are on separate lines, one line per type parameter, indented once:</p>
<pre><code class="language-csharp">static bool TryParse&lt;TEnum&gt;(string value, out TEnum result)
    where TEnum : struct
{
    ...
}
</code></pre>
<p>If statements with else clauses are formatted like this:</p>
<p>good:</p>
<pre><code class="language-csharp">if (dingus) {
        ...
} else {
        ...
}
</code></pre>
<p>bad:</p>
<pre><code class="language-csharp">if (dingus)
{
        ...
}
else
{
        ...
}
</code></pre>
<p>bad:</p>
<pre><code class="language-csharp">if (dingus) {
        ...
}
else {
        ...
}
</code></pre>
<p>Namespaces, types, and methods all put braces on their own line:</p>
<pre><code class="language-csharp">// Correct.
namespace MyApp
{

    class FluxCapacitor
    {
        ...
    }
}

// Wrong - opening braces are not on their own lines.
namespace MyApp {
    class FluxCapacitor {
        ...
    }
}
</code></pre>
<p>To summarize:</p>
<table>
<thead>
<tr>
<th>Statement</th>
<th>Brace position</th>
</tr>
</thead>
<tbody>
<tr>
<td>Namespace</td>
<td>new line</td>
</tr>
<tr>
<td>Type</td>
<td>new line</td>
</tr>
<tr>
<td>Methods</td>
<td>new line</td>
</tr>
<tr>
<td>Constructors</td>
<td>new line</td>
</tr>
<tr>
<td>Destructors</td>
<td>new line</td>
</tr>
<tr>
<td>Properties</td>
<td>same line</td>
</tr>
<tr>
<td>Control blocks (if, for...)</td>
<td>same line</td>
</tr>
<tr>
<td>Anonymous types and methods</td>
<td>same line</td>
</tr>
</tbody>
</table>
<h3 id="long-argument-lists">Long Argument Lists</h3>
<p>When your argument list grows too long, split your method invocation across multiple lines, with the first argument on a new line after the opening parenthesis of the method invocation, the closing parenthesis of the invocation on its own line at the same indentation level as the line with the opening parenthesis. This style works especially well for methods with named parameters.</p>
<pre><code class="language-csharp">// Lovely.
Console.WriteLine(
    &quot;Connect to {0} via {1} with extra data: {2} {3}&quot;,
    database.Address,
    database.ConnectionMethod.Description,
    data.FirstPart,
    data.SecondPart
);
</code></pre>
<p>It's also acceptable to put multiple arguments on a single line when they belong together:</p>
<pre><code class="language-csharp">// Acceptable.
Console.WriteLine(
    &quot;Connect to {0} via {1} with extra data: {2} {3}&quot;,
    database.Address,
    database.ConnectionMethod.Description,
    data.FirstPart, data.SecondPart
);
</code></pre>
<p>When chaining method calls, each method call in the chain should be on a separate line indented once:</p>
<pre><code class="language-csharp">void M() {
    IEnumerable&lt;int&gt; items = Enumerable.Range(0, 100)
        .Select(e =&gt; e * 2);
}
</code></pre>
<p>Use single spaces in expressions liberally:</p>
<p>good:</p>
<pre><code class="language-csharp">// Good.
if (a + 5 &gt; method(blah() + 4))

// Bad.
if (a+5&gt;method(blah()+4))
</code></pre>
<h3 id="casing">Casing</h3>
<p>Argument names should use the camel casing for identifiers, like this:</p>
<p>good:</p>
<pre><code class="language-csharp">// Good.
void Method(string myArgument)

// Bad.
void Method(string lpstrArgument)
void Method(string my_string)
</code></pre>
<h3 id="instance-fields">Instance Fields</h3>
<p>Don't use  <code>m_</code> or <code>_</code> as prefixes for instance fields. Just use normal parameter naming conventions:</p>
<pre><code class="language-csharp">// Perfect.
class Person
{
    string name;
}

// Wrong.
class Person
{
    string m_name;
}
</code></pre>
<p>Don't write <code>private</code> for private members, as this is the default visibility in C#:</p>
<pre><code class="language-csharp">// Perfect.
class Person
{
    string name;
}

// Wrong.
class Person
{
    private string name;
}
</code></pre>
<p>An exception to this rule is serializable classes. In this case, if we desire to have our serialized data be compatible with Microsoft's, we must use the same field name.</p>
<h3 id="this"><code>this</code></h3>
<p>The use of "this." as a prefix in code is discouraged, it is mostly redundant. In general, since internal variables are lowercase and anything that becomes public starts with an uppercase letter, there is no ambiguity between what the "Foo" and "foo" are. The first is a public property or field, the second is internal property or field.</p>
<p>Good:</p>
<pre><code class="language-csharp">class Foo
{
    int bar;

    void Update(int newValue)
    {
        bar = newValue;
    }

    void Clear()
    {
        Update();
    }
}
</code></pre>
<p>Bad:</p>
<pre><code class="language-csharp">class Foo
{
    int bar;

    void Update(int newValue)
    {
        this.bar = newValue;
    }

    void Clear()
    {
        this.Update();
    }
}
</code></pre>
<p>An exception is made for <code>this</code> when the parameter name is the same as an instance variable, this happens sometimes in constructors or if naming is difficult:</p>
<p>Good:</p>
<pre><code class="language-csharp">class Message
{
    char text;

    public Message(string text)
    {
        this.text = text;
    }
}
</code></pre>
<h2 id="comments">Comments</h2>
<h3 id="simple-comments">Simple Comments</h3>
<p>Comments begin with <code>//</code> followed by a single space, use sentence casing, and exhibit proper spelling and grammar.</p>
<pre><code class="language-csharp">// Great:
// Verify that the client and server states are consistent.

// Bad - missing space:
//Verify that the client and server states are consistent.

// Bad - not a sentence:
// verify client server states
</code></pre>
<p>If your comment just paraphrases code, remove it:</p>
<pre><code class="language-csharp">// Bad
// Makes the window key and orders it front.
window.MakeKeyAndOrderFront ();
</code></pre>
<h3 id="multiline-comments">Multiline comments</h3>
<p>Long comments tend to grow from smaller ones, so it's simpler to always use <code>//</code> than to switch to <code>/* ... */</code> when a comment becomes "long".</p>
<pre><code class="language-csharp">// Good:

// Sartorial leggings ennui before they sold out banjo, lo-fi Truffaut
// Shoreditch sustainable Godard skateboard next level iPhone. Locavore tousled
// meh fingerstache DIY church-key keytar, Vice pug quinoa seitan. Blog photo
// booth Pinterest letterpress kogi leggings aesthetic irony.


// Bad:

/*
 * Sartorial leggings ennui before they sold out banjo, lo-fi Truffaut
 * Shoreditch sustainable Godard skateboard next level iPhone. Locavore tousled
 * meh fingerstache DIY church-key keytar, Vice pug quinoa seitan. Blog photo
 * booth Pinterest letterpress kogi leggings aesthetic irony.
 */
</code></pre>
<h3 id="commenting-out-code">Commenting Out Code</h3>
<p>The only recommended use of <code>/* ... */</code>-style comments is for commenting out code. Please do not comment out multiple lines of code with <code>//</code>.</p>
<pre><code class="language-csharp">// Good:

/*
for (int i = 0; i &lt; int.MaxValue; i++)
    Console.WriteLine (i);
*/

// Bad:

// for (int i = 0; i &lt; int.MaxValue; i++)
//    Console.WriteLine (i);
</code></pre>
<p>You should avoid commenting out code anyway, preferring version control or other methods.</p>
<h2 id="naming">Naming</h2>
<h3 id="constants">Constants</h3>
<p>Write constants in <code>CamelCase</code>, not <code>UPPERCASE</code>.</p>
<pre><code class="language-csharp">// Perfect.
const int LeftMargin = 10;

// No need to shout.
const int LEFT_MARGIN = 10;
</code></pre>
<h2 id="lambdas">Lambdas</h2>
<p>Lambdas are written with a single space before and after the <code>=&gt;</code>:</p>
<pre><code class="language-csharp">// Great.
Func&lt;int, int&gt; square = i =&gt; i * i;

// Terrible.
Func&lt;int, int&gt; square = i=&gt;i * i;
</code></pre>
<p>If your lambda takes a single argument, omit the parentheses around the argument list:</p>
<pre><code class="language-csharp">// Great!
var admins = Users.Select (user =&gt; user.IsAdministrator);

// Silly.
var admins = Users.Select ((user) =&gt; user.IsAdministrator);
</code></pre>
<p>Whenever possible, omit types from lambda argument lists, and use simple names:</p>
<pre><code class="language-csharp">// Great:
list.OnScroll += (sender, e) =&gt; {
    ...
};

// Passé:
list.OnScroll += (object sender, EventArgs e) =&gt; {
    ...
};

// No! Parameter name is needlessly complex:
sqlDatabaseAdaptors.Select (sqlDatabaseAdaptor =&gt; sqlDatabaseAdaptor.Id);

// Much better. We have enough context from the larger identifier to know what 'adaptor' is:
sqlDatabaseAdaptors.Select (adaptor =&gt; adaptor.Id);
</code></pre>
<p>When the body of a lambda is a simple statement or expression, don't use a block:</p>
<pre><code class="language-csharp">// Excellent!
var averageSalary = employees.Average (employee =&gt; employee.Salary);

// Inconceivable!
var averageSalary = employees.Average (employee =&gt; { return employee.Salary; });
</code></pre>
<p>When the body of the lambda is a block, put the opening brace on the same line as the <code>=&gt;</code>, indent the body of the block,
and close the block at the same level of indentation as the line containing the opening brace:</p>
<pre><code class="language-csharp">// Ideal:
people.ForEach (person =&gt; {
    person.BrushTeeth ();
    person.CallMom ();
    person.RegisterToVote ();
});

// No! Improperly positioned opening brace:
people.ForEach (person =&gt;
{
    person.BrushTeeth ();
    person.CallMom ();
    person.RegisterToVote ();
});

// No! Improperly positioned closing brace:
people.ForEach (person =&gt; {
    person.BrushTeeth ();
    person.CallMom ();
    person.RegisterToVote ();
    }
);

// No! Bad indentation:
people.ForEach (person =&gt; { person.BrushTeeth ();
                            person.CallMom ();
                            person.RegisterToVote ();
                          });
</code></pre>
<p>Always prefer lambdas, <code>Func&lt;&gt;</code>, and <code>Action&lt;&gt;</code> types to <code>delegate</code>. The only recommended use of <code>delegate</code> is when the body of your anonymous method doesn't reference any of its arguments:</p>
<pre><code class="language-csharp">thing.EventWithSenderAndEventArgs += delegate {
    Console.WriteLine (&quot;EventWithSenderAndEventArgs raised.&quot;);
};
</code></pre>
<p>It is acceptable to use single-character argument names in lambdas if the receiver is an <code>IEnumerable</code> and is named in such a way as to make the lambda argument obvious, and the lambda argument name is the first character of the receiver's identifier:</p>
<pre><code class="language-csharp">// Acceptable:
var averageSalary = employees.Average (e =&gt; e.Salary);

// Acceptable:
var averageSalary = employees.Average (employee =&gt; employee.Salary);

// Wrong - parameter name doesn't correspond to collection name:
var averageSalary = employees.Average (x =&gt; x.Salary);
</code></pre>
<h2 id="credits">Credits</h2>
<p>This guide was adapted from the <a href="http://www.mono-project.com/Coding_Guidelines">Mono coding guidelines</a> with inspiration from thoughtbot's excellent <a href="https://github.com/thoughtbot/guides">guide for programming in style</a> and <a href="http://llvm.org/docs/CodingStandards.html">The LLVM Coding Standards</a>.</p>

  <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://d-k-ivanov.github.io/">Main site</a>
      </p><p>Copyright &copy; 2016-2020 Dmitry Ivanov. <script type="text/javascript"> (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)}; m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)}) (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym"); ym(40819844, "init", { clickmap:true, trackLinks:true, accurateTrackBounce:true }); </script> <noscript><div><img src="https://mc.yandex.ru/watch/40819844" style="position:absolute; left:-9999px;" alt="" /></div></noscript></p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>