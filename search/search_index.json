{
    "docs": [
        {
            "location": "/",
            "text": "About me\n\n\n\n\nDmitry Ivanov\n\n\nGitHub repo\n\n\nFacebook\n\n\nVK.com\n\n\nLinkedIn\n\n\n\n\n\n\nUseful links\n\n\n\n\nRob van der Woude's Scripting Page\n\n\nVbsEdit\n - VBS scripts \n\n\nMorgan's Library\n - Dan Morgan's Oracle Library\n\n\nAdminer\n - simple database management php console\n\n\nGlobal DNS record check\n - Site to get responce from many DNS servers around the world\n\n\n\n\n\n\nUnsorted\n\n\nJoining all similarly prefixed files\n\n\nFor example, \"_tar.gz.1of2\" and \"_tar.gz.2of2\".\n\n\n# Unix\ncat \"FileName_tar.gz.1of3\" \"FileName_tar.gz.2of3\" \"FileName_tar.gz.3of3\" > \"FileName.tar.gz\"\n# Windows\ncopy /b \"FileName_tar.gz.1of3\"+\"FileName_tar.gz.2of3\"+\"FileName_tar.gz.3of3\" \"FileName.tar.gz\"\n\n\n\n\nTMUX\n\n\ntmux list-sessions\ntmux attach -t 2\nsudo tmux -2 -S /tmp/tmux-<UID>/default",
            "title": "Home"
        },
        {
            "location": "/#about-me",
            "text": "Dmitry Ivanov  GitHub repo  Facebook  VK.com  LinkedIn",
            "title": "About me"
        },
        {
            "location": "/#useful-links",
            "text": "Rob van der Woude's Scripting Page  VbsEdit  - VBS scripts   Morgan's Library  - Dan Morgan's Oracle Library  Adminer  - simple database management php console  Global DNS record check  - Site to get responce from many DNS servers around the world",
            "title": "Useful links"
        },
        {
            "location": "/#unsorted",
            "text": "",
            "title": "Unsorted"
        },
        {
            "location": "/#joining-all-similarly-prefixed-files",
            "text": "For example, \"_tar.gz.1of2\" and \"_tar.gz.2of2\".  # Unix\ncat \"FileName_tar.gz.1of3\" \"FileName_tar.gz.2of3\" \"FileName_tar.gz.3of3\" > \"FileName.tar.gz\"\n# Windows\ncopy /b \"FileName_tar.gz.1of3\"+\"FileName_tar.gz.2of3\"+\"FileName_tar.gz.3of3\" \"FileName.tar.gz\"",
            "title": "Joining all similarly prefixed files"
        },
        {
            "location": "/#tmux",
            "text": "tmux list-sessions\ntmux attach -t 2\nsudo tmux -2 -S /tmp/tmux-<UID>/default",
            "title": "TMUX"
        },
        {
            "location": "/Admin/Windows_Administrative_Tools/",
            "text": "Use domain credentials from non domain worksation\n\n\nrunas /netonly /user:DOMAIN\\username \"<program>\"\n# DNS Management\n#runas /netonly /user:username@domain \"%SystemRoot%\\system32\\mmc.exe %SystemRoot%\\system32\\dnsmgmt.msc\"\n# AD Users and Computers\n#runas /netonly /user:username@domain \"%SystemRoot%\\system32\\mmc.exe %SystemRoot%\\system32\\dsa.msc\"",
            "title": "Windows Administrative Tools"
        },
        {
            "location": "/Admin/Windows_Administrative_Tools/#use-domain-credentials-from-non-domain-worksation",
            "text": "runas /netonly /user:DOMAIN\\username \"<program>\"\n# DNS Management\n#runas /netonly /user:username@domain \"%SystemRoot%\\system32\\mmc.exe %SystemRoot%\\system32\\dnsmgmt.msc\"\n# AD Users and Computers\n#runas /netonly /user:username@domain \"%SystemRoot%\\system32\\mmc.exe %SystemRoot%\\system32\\dsa.msc\"",
            "title": "Use domain credentials from non domain worksation"
        },
        {
            "location": "/Admin/xFreeRDP/",
            "text": "XfreeRDP\n\n\nxfreerdp [+clipboard]/w:<WIDTH> /h:<HEIGHT> /drive:<cuatom_drive_name>,<path_to_attach> /v:<ip>:<port> /u:<user_name>\nxfreerdp +clipboard /w:1600 /h:900 /v:10.15.0.10:3389 /u:Administrator\nxfreerdp +clipboard /w:1800 /h:1000 /u:Adminitatrator /drive:hmc,/home/4T/IT/IBM/HMC/7.9_sp3 /v:10.15.0.10",
            "title": "xFreeRDP"
        },
        {
            "location": "/Admin/xFreeRDP/#xfreerdp",
            "text": "xfreerdp [+clipboard]/w:<WIDTH> /h:<HEIGHT> /drive:<cuatom_drive_name>,<path_to_attach> /v:<ip>:<port> /u:<user_name>\nxfreerdp +clipboard /w:1600 /h:900 /v:10.15.0.10:3389 /u:Administrator\nxfreerdp +clipboard /w:1800 /h:1000 /u:Adminitatrator /drive:hmc,/home/4T/IT/IBM/HMC/7.9_sp3 /v:10.15.0.10",
            "title": "XfreeRDP"
        },
        {
            "location": "/Databases/MariaDB/Backup_and_Restore/",
            "text": "Dump\n\n\nmysqldump db_name > backup-file.sql\n\n\n\n\nRestore\n\n\nmysql db_name < backup-file.sql",
            "title": "Backup and Restore"
        },
        {
            "location": "/Databases/MariaDB/Backup_and_Restore/#dump",
            "text": "mysqldump db_name > backup-file.sql",
            "title": "Dump"
        },
        {
            "location": "/Databases/MariaDB/Backup_and_Restore/#restore",
            "text": "mysql db_name < backup-file.sql",
            "title": "Restore"
        },
        {
            "location": "/Databases/MariaDB/Installation/",
            "text": "MariaDB server 5.5\n\n\nyum install mariadb-server\nvim /etc/my.cnf\n---\n[mysqld]\ncharacter-set-server=utf8\n---\n\nsystemctl start mariadb\nsystemctl enable mariadb \n\nmysql_secure_installation\n\n\n\n\n\nMariaDB server 10.1\n\n\nyum install centos-release-scl\nyum --enablerepo=centos-sclo-rh install rh-mariadb101-mariadb-server \nscl enable rh-mariadb101 bash \n\nvim /etc/profile.d/rh-mariadb101.sh \n---\n#!/bin/bash\n\nsource /opt/rh/rh-mariadb101/enable\nexport X_SCLS=\"`scl enable rh-mariadb101 'echo $X_SCLS'`\"\n---\n\nvim /etc/opt/rh/rh-mariadb101/my.cnf.d/mariadb-server.cnf \n---\n[mysqld]\ncharacter-set-server=utf8 \n---\n\nsystemctl start rh-mariadb101-mariadb\nsystemctl enable rh-mariadb101-mariadb \n\nmysql_secure_installation",
            "title": "Installation"
        },
        {
            "location": "/Databases/MariaDB/Installation/#mariadb-server-55",
            "text": "yum install mariadb-server\nvim /etc/my.cnf\n---\n[mysqld]\ncharacter-set-server=utf8\n---\n\nsystemctl start mariadb\nsystemctl enable mariadb \n\nmysql_secure_installation",
            "title": "MariaDB server 5.5"
        },
        {
            "location": "/Databases/MariaDB/Installation/#mariadb-server-101",
            "text": "yum install centos-release-scl\nyum --enablerepo=centos-sclo-rh install rh-mariadb101-mariadb-server \nscl enable rh-mariadb101 bash \n\nvim /etc/profile.d/rh-mariadb101.sh \n---\n#!/bin/bash\n\nsource /opt/rh/rh-mariadb101/enable\nexport X_SCLS=\"`scl enable rh-mariadb101 'echo $X_SCLS'`\"\n---\n\nvim /etc/opt/rh/rh-mariadb101/my.cnf.d/mariadb-server.cnf \n---\n[mysqld]\ncharacter-set-server=utf8 \n---\n\nsystemctl start rh-mariadb101-mariadb\nsystemctl enable rh-mariadb101-mariadb \n\nmysql_secure_installation",
            "title": "MariaDB server 10.1"
        },
        {
            "location": "/Databases/MongoDB/Backup_and_restore/",
            "text": "Backup\n\n\n# Gzipped archive\nmongodump --host \"ip_address_or_replicaset:port\" --db dataBaseName --gzip --archive=/path/to/archive/file.agz\n# BSON Folder\nmongodump --host \"ip_address_or_replicaset:port\" --db dataBaseName --out /path/to/backup/folder\n# With oplog\nmongodump --host \"ip_address_or_replicaset:port\" --oplog --gzip --archive=/path/to/archive/file.agz\nmongodump --host \"ip_address_or_replicaset:port\" --oplog --out /path/to/backup/folder\n\n\n\n\nRestore\n\n\n# Gzipped archive\nmongorestore --host \"ip_address_or_replicaset:port\" --db dataBaseName --drop --gzip --archive=/path/to/archive/file.agz\n# BSON Folder\nmongorestore --host \"ip_address_or_replicaset:port\" --db dataBaseName --drop /path/to/backup/folder\n# With oplog\nmongorestore --host \"ip_address_or_replicaset:port\" --oplogReplay --drop --gzip --archive=/path/to/archive/file.agz\nmongorestore --host \"ip_address_or_replicaset:port\" --oplogReplay --drop /path/to/backup/folder",
            "title": "Backup and restore"
        },
        {
            "location": "/Databases/MongoDB/Backup_and_restore/#backup",
            "text": "# Gzipped archive\nmongodump --host \"ip_address_or_replicaset:port\" --db dataBaseName --gzip --archive=/path/to/archive/file.agz\n# BSON Folder\nmongodump --host \"ip_address_or_replicaset:port\" --db dataBaseName --out /path/to/backup/folder\n# With oplog\nmongodump --host \"ip_address_or_replicaset:port\" --oplog --gzip --archive=/path/to/archive/file.agz\nmongodump --host \"ip_address_or_replicaset:port\" --oplog --out /path/to/backup/folder",
            "title": "Backup"
        },
        {
            "location": "/Databases/MongoDB/Backup_and_restore/#restore",
            "text": "# Gzipped archive\nmongorestore --host \"ip_address_or_replicaset:port\" --db dataBaseName --drop --gzip --archive=/path/to/archive/file.agz\n# BSON Folder\nmongorestore --host \"ip_address_or_replicaset:port\" --db dataBaseName --drop /path/to/backup/folder\n# With oplog\nmongorestore --host \"ip_address_or_replicaset:port\" --oplogReplay --drop --gzip --archive=/path/to/archive/file.agz\nmongorestore --host \"ip_address_or_replicaset:port\" --oplogReplay --drop /path/to/backup/folder",
            "title": "Restore"
        },
        {
            "location": "/Databases/MongoDB/Queries/",
            "text": "Find by _id\n\n\ndb.ticket.find({ \"field_name_with_id\" : ObjectId(\"--_id--\") });",
            "title": "Queries"
        },
        {
            "location": "/Databases/MongoDB/Queries/#find-by-_id",
            "text": "db.ticket.find({ \"field_name_with_id\" : ObjectId(\"--_id--\") });",
            "title": "Find by _id"
        },
        {
            "location": "/Databases/MongoDB/Quick_Reference/",
            "text": "Quick reference\n\n\nhelp\n\ndb.help()\n\nshow dbs\nshow databases\nuse <db>\n\nshow collections\ndb.<collection>.help()\n\nshow users\nshow roles\nshow profile\n\ndb.collection.find()\ndb.collection.insert()\ndb.collection.update()\ndb.collection.save()\ndb.collection.remove()\ndb.collection.drop()\ndb.collection.createIndex()\ndb.getSiblingDB()\n\n\n\n\n\nDump to JSON\n\n\nmongo --host <db_server> <db_name> -u <username> -p <password> << EOF > out.json\ndb.File.files.find().pretty()\nEOF\n\n\n\n\nConnect\n\n\nmongo --host <db_server> <db_name> -u <username> -p <password>",
            "title": "Quick Reference"
        },
        {
            "location": "/Databases/MongoDB/Quick_Reference/#quick-reference",
            "text": "help\n\ndb.help()\n\nshow dbs\nshow databases\nuse <db>\n\nshow collections\ndb.<collection>.help()\n\nshow users\nshow roles\nshow profile\n\ndb.collection.find()\ndb.collection.insert()\ndb.collection.update()\ndb.collection.save()\ndb.collection.remove()\ndb.collection.drop()\ndb.collection.createIndex()\ndb.getSiblingDB()",
            "title": "Quick reference"
        },
        {
            "location": "/Databases/MongoDB/Quick_Reference/#dump-to-json",
            "text": "mongo --host <db_server> <db_name> -u <username> -p <password> << EOF > out.json\ndb.File.files.find().pretty()\nEOF",
            "title": "Dump to JSON"
        },
        {
            "location": "/Databases/MongoDB/Quick_Reference/#connect",
            "text": "mongo --host <db_server> <db_name> -u <username> -p <password>",
            "title": "Connect"
        },
        {
            "location": "/Databases/MySQL/Replication/",
            "text": "Replication\n\n\n# On Master:\nvim /etc/mysql/my.cnf:\n   server-id   = 2\n   log_bin     = /var/lib/mysql-binlog/mysql-bin.log\n\n# SQL on master:\nmysql> grant replication slave on *.* to replica@'%' identified by '<password>';\nmysql> flush privileges;\nmysql> exit\n\n# On Slave:\nvim /etc/mysql/my.cnf:\n   server-id   = 3\n   log_bin     = /var/lib/mysql-binlog/mysql-bin.log\n\n# SQL on Slave\nmysql> change master to \n      -> master_host='<master_server>',\n      -> master_user='replica', \n      -> master_password='<password>',\n      -> master_log_file='<bin_log>', \n      -> master_log_pos=<bin_log_position>;",
            "title": "Replication"
        },
        {
            "location": "/Databases/MySQL/Replication/#replication",
            "text": "# On Master:\nvim /etc/mysql/my.cnf:\n   server-id   = 2\n   log_bin     = /var/lib/mysql-binlog/mysql-bin.log\n\n# SQL on master:\nmysql> grant replication slave on *.* to replica@'%' identified by '<password>';\nmysql> flush privileges;\nmysql> exit\n\n# On Slave:\nvim /etc/mysql/my.cnf:\n   server-id   = 3\n   log_bin     = /var/lib/mysql-binlog/mysql-bin.log\n\n# SQL on Slave\nmysql> change master to \n      -> master_host='<master_server>',\n      -> master_user='replica', \n      -> master_password='<password>',\n      -> master_log_file='<bin_log>', \n      -> master_log_pos=<bin_log_position>;",
            "title": "Replication"
        },
        {
            "location": "/Databases/Oracle/Blocking_sessions/",
            "text": "Find all locking sessions\n\n\nSELECT * FROM v$lock;\n\n\n\n\nView all blocking sessions ver.1\n\n\nSELECT s.blocking_session, s.sid, s.serial#, s.seconds_in_wait FROM v$session s WHERE blocking_session IS NOT NULL;\n\n\n\n\nView all blocking sessions ver.2\n\n\nSELECT s1.username || '@' || s1.machine\n    || ' ( SID=' || s1.sid || ' )  is blocking '\n    || s2.username || '@' || s2.machine || ' ( SID=' || s2.sid || ' ) ' AS blocking_status\n    FROM v$lock l1, v$session s1, v$lock l2, v$session s2\n    WHERE s1.sid=l1.sid AND s2.sid=l2.sid\n    AND l1.BLOCK=1 AND l2.request > 0\n    AND l1.id1 = l2.id1\n    AND l1.id2 = l2.id2;\n\n\n\n\nView SID and ID of blocking sessions\n\n\nSELECT sid, id1 FROM v$lock WHERE TYPE='TM';\n\n\n\n\nView the name of blocking session\n\n\nSELECT object_name FROM dba_objects WHERE object_id=101482;\n\n\n\n\nKill session: \" ALTER SYSTEM KILL SESSION 'SID,ID' \"\n\n\nALTER SYSTEM KILL SESSION '1621,24543';\n\n\n\n\nView all active sessions\n\n\nSELECT s.inst_id,\n       s.sid,\n       s.serial#,\n       p.spid,\n       s.username,\n       s.program\nFROM   gv$session s\n       JOIN gv$process p ON p.addr = s.paddr AND p.inst_id = s.inst_id\nWHERE  s.type != 'BACKGROUND';",
            "title": "Blocking sessions"
        },
        {
            "location": "/Databases/Oracle/Blocking_sessions/#find-all-locking-sessions",
            "text": "SELECT * FROM v$lock;",
            "title": "Find all locking sessions"
        },
        {
            "location": "/Databases/Oracle/Blocking_sessions/#view-all-blocking-sessions-ver1",
            "text": "SELECT s.blocking_session, s.sid, s.serial#, s.seconds_in_wait FROM v$session s WHERE blocking_session IS NOT NULL;",
            "title": "View all blocking sessions ver.1"
        },
        {
            "location": "/Databases/Oracle/Blocking_sessions/#view-all-blocking-sessions-ver2",
            "text": "SELECT s1.username || '@' || s1.machine\n    || ' ( SID=' || s1.sid || ' )  is blocking '\n    || s2.username || '@' || s2.machine || ' ( SID=' || s2.sid || ' ) ' AS blocking_status\n    FROM v$lock l1, v$session s1, v$lock l2, v$session s2\n    WHERE s1.sid=l1.sid AND s2.sid=l2.sid\n    AND l1.BLOCK=1 AND l2.request > 0\n    AND l1.id1 = l2.id1\n    AND l1.id2 = l2.id2;",
            "title": "View all blocking sessions ver.2"
        },
        {
            "location": "/Databases/Oracle/Blocking_sessions/#view-sid-and-id-of-blocking-sessions",
            "text": "SELECT sid, id1 FROM v$lock WHERE TYPE='TM';",
            "title": "View SID and ID of blocking sessions"
        },
        {
            "location": "/Databases/Oracle/Blocking_sessions/#view-the-name-of-blocking-session",
            "text": "SELECT object_name FROM dba_objects WHERE object_id=101482;",
            "title": "View the name of blocking session"
        },
        {
            "location": "/Databases/Oracle/Blocking_sessions/#kill-session-alter-system-kill-session-sidid",
            "text": "ALTER SYSTEM KILL SESSION '1621,24543';",
            "title": "Kill session: \" ALTER SYSTEM KILL SESSION 'SID,ID' \""
        },
        {
            "location": "/Databases/Oracle/Blocking_sessions/#view-all-active-sessions",
            "text": "SELECT s.inst_id,\n       s.sid,\n       s.serial#,\n       p.spid,\n       s.username,\n       s.program\nFROM   gv$session s\n       JOIN gv$process p ON p.addr = s.paddr AND p.inst_id = s.inst_id\nWHERE  s.type != 'BACKGROUND';",
            "title": "View all active sessions"
        },
        {
            "location": "/Databases/Oracle/CentOS_7_Installation/",
            "text": "GUI\n\n\nyum groups install \"GNOME Desktop\"\nstartx\n\n\n\n\nDatabase pre-requirements\n\n\n# Dependencies\nyum install binutils compat-libcap1 gcc gcc-c++ glibc glibc.i686 glibc-devel glibc.i686 ksh libaio libaio.i686 libaio-devel libaio-devel.i686 libgcc libgcc.i686 libstdc++ libstdc++l7.i686 libstdc++-devel libstdc++-devel.i686 compat-libstdc++-33 compat-libstdc++-33.i686 libXi libXi.i686 libXtst libXtst.i686 make sysstat \n\n# Kernel\nMEMTOTAL=$(free -b | sed -n '2p' | awk '{print $2}')\nSHMMAX=$(expr $MEMTOTAL / 2)\nPAGESIZE=$(getconf PAGE_SIZE)\n\ncat >> /etc/sysctl.conf << EOF\nfs.aio-max-nr = 1048576\nfs.file-max = 6815744\nkernel.shmmax = $SHMMAX\nkernel.shmall = `expr \\( $SHMMAX / $PAGESIZE \\) \\* \\( 4096 / 16 \\)`\nkernel.shmmni = 4096\nkernel.sem = 250 32000 100 128\nnet.ipv4.ip_local_port_range = 9000 65500\nnet.core.rmem_default = 262144\nnet.core.rmem_max = 4194304\nnet.core.wmem_default = 262144\nnet.core.wmem_max = 1048576\nEOF\n\nsysctl -p \n\n# Users and groups\ni=54321; for group in oinstall dba backupdba oper dgdba kmdba; do\ngroupadd -g $i $group; i=`expr $i + 1`\ndone\n\nuseradd -u 1200 -g oinstall -G dba,oper,backupdba,dgdba,kmdba -d /home/oracle oracle \npasswd oracle \n\n# Folders\nmkdir -p /u01/app/oracle \nchown -R oracle:oinstall /u01/app \nchmod -R 775 /u01 \n\nvim /etc/pam.d/login \n# Insert after \"session required pam_namespace.so\":\nsession    required     pam_limits.so\n\nvim /etc/security/limits.conf \n# Add to the end of file:\n\noracle  soft  nproc   2047\noracle  hard  nproc   16384\noracle  soft  nofile  1024\noracle  hard  nofile  65536\noracle  soft  stack   10240\noracle  hard  stack   32768\n\nsu - oracle\nvim ~/.bash_profile \n# Add to the end\numask 022\nexport ORACLE_BASE=/u01/app/oracle \n\n\n\n\nDatabase software installation\n\n\n# Upload installation software to /tmp:\nscp linuxamd64_12102_database_se2_1of2.zip oracle@db_server:/tmp/\nscp linuxamd64_12102_database_se2_2of2.zip oracle@db_server:/tmp/\n\n# Login to DB server with X-Forwarding enabled:\nssh -Y oracle@db_server\n\n# Unpack archives:\nunzip linuxamd64_12102_database_se2_1of2.zip\nunzip linuxamd64_12102_database_se2_2of2.zip\n\n# Run Oracle universal installer\ncd database/\n./runInstaller \n\n\n\n\nJust follow installation steps in GUI:\n\n\n\n\nStep 01. Enter your \nE-Mail\n and Oracle Enterproise support \npassword\n, if you have one\n\n\nStep 02. \n(.)\n Install database software only (we'll install database later)\n\n\nStep 03. Select parovriate type of installation. In simple case choose \n\"Single instance database installation\"\n\n\nStep 04. Choose prefered language. But \nEnglish\n is recommended in all cases.\n\n\nStep 05. Select edidtion. It depends of distribution package. In this case \nStandard Edition Two\n\n\nStep 06. Choose path for oracle home directory. In our case everything will filled up by default.\n\n\nStep 07. Choose path for oracle inventory. In our case everything will filled up by default.\n\n\nStep 08. Choose oracle grroups. In our case everything will filled up by default. \n\n\nStep 09. On this step you'll face swap error in most cases. Just ignore it. In any other errors look at oracle forum. \nDO NOT IGNORE ANY ERRORS EXCEPT OF SWAP\n\n\nStep 10. Install oracle database software\n\n\nStep 11. On this step installater demand you to execute 2 spripts from root user. Just run them.\n\n\nStep 12. Finish\n\n\n\n\nvim ~/.bash_profile \n\n# Add to the end of file: \n\nexport ORACLE_HOME=/u01/app/oracle/product/12.1.0/dbhome_1\nexport PATH=$PATH:$ORACLE_HOME/bin\n\n\n\n\nNet listener\n\n\nJust run \nnetca\n from oracle user and follow steps of configuration wizard\n\n\n# Login to DB server with X-Forwarding enabled:\nssh -Y oracle@db_server\n\n# Run Network listener configuration wizard:\nnetca\n\n\n\n\nDatabase\n\n\n# Login to DB server with X-Forwarding enabled:\nssh -Y oracle@db_server\n\n# Run Database configuration wizard:\ndbca\n\n\n\n\n\nFollow installation steps for fat installation:\n\n\n\n\nStep 01. Choose \n(.) Create database\n\n\nStep 02. \n(.)\n Create a database with default configuration\n\n Global Database name: input what name you like\n\n Storage type: \nFile System\n (if you don't have ASM)\n\n Database character set: \nAL32UTF8 - Unicode UTF-8 Universal character set\n\n\n Choose password for sysdba account.\n\n Uncheck \n[]Create As Container Database**\n\n\nStep 03. Look for any errors\n\n\nStep 04. Next\n\n\nStep 05. Finish\n\n\n\n\nvim /etc/oratab \n\n#Set last synbol from \"N\" to \"Y\"\n<database_SID>:/u01/app/oracle/product/12.1.0/dbhome_1:Y\n\nvim ~/.bash_profile \n# Add to the end of file:\n\nexport ORACLE_SID=<database_SID>\n\n\n\n\n\nAutostart\n\n\n\n\nOracle environemnt:\n\n\n\n\nvim /etc/sysconfig/<SID>.oracledb\n\n# Contents\nORACLE_BASE=/u01/app/oracle\nORACLE_HOME=/u01/app/oracle/product/12.1.0/dbhome_1\nORACLE_SID=<your_SID>\n\n\n\n\n\n\nNet listner service:\n\n\n\n\nvim /usr/lib/systemd/system/<SID>@lsnrctl.service \n\n# Contents\n[Unit]\nDescription=Oracle Net Listener\nAfter=network.target\n\n[Service]\nType=forking\nEnvironmentFile=/etc/sysconfig/<SID>.oracledb\nExecStart=/u01/app/oracle/product/12.1.0/dbhome_1/bin/lsnrctl start\nExecStop=/u01/app/oracle/product/12.1.0/dbhome_1/bin/lsnrctl stop\nUser=oracle\n\n[Install]\nWantedBy=multi-user.target\n\n\n\n\n\n\nDatabase service:\n\n\n\n\nvim /usr/lib/systemd/system/<SID>@oracledb.service \n\n# Contents\n[Unit]\nDescription=Oracle Database service\nAfter=network.target lsnrctl.service\n\n[Service]\nType=forking\nEnvironmentFile=/etc/sysconfig/<SID>.oracledb\nExecStart=/u01/app/oracle/product/12.1.0/dbhome_1/bin/dbstart /u01/app/oracle/product/12.1.0/dbhome_1\nExecStop=/u01/app/oracle/product/12.1.0/dbhome_1/bin/dbshut /u01/app/oracle/product/12.1.0/dbhome_1\nUser=oracle\n\n[Install]\nWantedBy=multi-user.target\n\n\n\n\n\n\nSystemd reload and enable:\n\n\n\n\nsystemctl daemon-reload \nsystemctl enable <SID>@lsnrctl \nsystemctl enable <SID>@oracledb",
            "title": "CentOS 7 Installation"
        },
        {
            "location": "/Databases/Oracle/CentOS_7_Installation/#gui",
            "text": "yum groups install \"GNOME Desktop\"\nstartx",
            "title": "GUI"
        },
        {
            "location": "/Databases/Oracle/CentOS_7_Installation/#database-pre-requirements",
            "text": "# Dependencies\nyum install binutils compat-libcap1 gcc gcc-c++ glibc glibc.i686 glibc-devel glibc.i686 ksh libaio libaio.i686 libaio-devel libaio-devel.i686 libgcc libgcc.i686 libstdc++ libstdc++l7.i686 libstdc++-devel libstdc++-devel.i686 compat-libstdc++-33 compat-libstdc++-33.i686 libXi libXi.i686 libXtst libXtst.i686 make sysstat \n\n# Kernel\nMEMTOTAL=$(free -b | sed -n '2p' | awk '{print $2}')\nSHMMAX=$(expr $MEMTOTAL / 2)\nPAGESIZE=$(getconf PAGE_SIZE)\n\ncat >> /etc/sysctl.conf << EOF\nfs.aio-max-nr = 1048576\nfs.file-max = 6815744\nkernel.shmmax = $SHMMAX\nkernel.shmall = `expr \\( $SHMMAX / $PAGESIZE \\) \\* \\( 4096 / 16 \\)`\nkernel.shmmni = 4096\nkernel.sem = 250 32000 100 128\nnet.ipv4.ip_local_port_range = 9000 65500\nnet.core.rmem_default = 262144\nnet.core.rmem_max = 4194304\nnet.core.wmem_default = 262144\nnet.core.wmem_max = 1048576\nEOF\n\nsysctl -p \n\n# Users and groups\ni=54321; for group in oinstall dba backupdba oper dgdba kmdba; do\ngroupadd -g $i $group; i=`expr $i + 1`\ndone\n\nuseradd -u 1200 -g oinstall -G dba,oper,backupdba,dgdba,kmdba -d /home/oracle oracle \npasswd oracle \n\n# Folders\nmkdir -p /u01/app/oracle \nchown -R oracle:oinstall /u01/app \nchmod -R 775 /u01 \n\nvim /etc/pam.d/login \n# Insert after \"session required pam_namespace.so\":\nsession    required     pam_limits.so\n\nvim /etc/security/limits.conf \n# Add to the end of file:\n\noracle  soft  nproc   2047\noracle  hard  nproc   16384\noracle  soft  nofile  1024\noracle  hard  nofile  65536\noracle  soft  stack   10240\noracle  hard  stack   32768\n\nsu - oracle\nvim ~/.bash_profile \n# Add to the end\numask 022\nexport ORACLE_BASE=/u01/app/oracle",
            "title": "Database pre-requirements"
        },
        {
            "location": "/Databases/Oracle/CentOS_7_Installation/#database-software-installation",
            "text": "# Upload installation software to /tmp:\nscp linuxamd64_12102_database_se2_1of2.zip oracle@db_server:/tmp/\nscp linuxamd64_12102_database_se2_2of2.zip oracle@db_server:/tmp/\n\n# Login to DB server with X-Forwarding enabled:\nssh -Y oracle@db_server\n\n# Unpack archives:\nunzip linuxamd64_12102_database_se2_1of2.zip\nunzip linuxamd64_12102_database_se2_2of2.zip\n\n# Run Oracle universal installer\ncd database/\n./runInstaller   Just follow installation steps in GUI:   Step 01. Enter your  E-Mail  and Oracle Enterproise support  password , if you have one  Step 02.  (.)  Install database software only (we'll install database later)  Step 03. Select parovriate type of installation. In simple case choose  \"Single instance database installation\"  Step 04. Choose prefered language. But  English  is recommended in all cases.  Step 05. Select edidtion. It depends of distribution package. In this case  Standard Edition Two  Step 06. Choose path for oracle home directory. In our case everything will filled up by default.  Step 07. Choose path for oracle inventory. In our case everything will filled up by default.  Step 08. Choose oracle grroups. In our case everything will filled up by default.   Step 09. On this step you'll face swap error in most cases. Just ignore it. In any other errors look at oracle forum.  DO NOT IGNORE ANY ERRORS EXCEPT OF SWAP  Step 10. Install oracle database software  Step 11. On this step installater demand you to execute 2 spripts from root user. Just run them.  Step 12. Finish   vim ~/.bash_profile \n\n# Add to the end of file: \n\nexport ORACLE_HOME=/u01/app/oracle/product/12.1.0/dbhome_1\nexport PATH=$PATH:$ORACLE_HOME/bin",
            "title": "Database software installation"
        },
        {
            "location": "/Databases/Oracle/CentOS_7_Installation/#net-listener",
            "text": "Just run  netca  from oracle user and follow steps of configuration wizard  # Login to DB server with X-Forwarding enabled:\nssh -Y oracle@db_server\n\n# Run Network listener configuration wizard:\nnetca",
            "title": "Net listener"
        },
        {
            "location": "/Databases/Oracle/CentOS_7_Installation/#database",
            "text": "# Login to DB server with X-Forwarding enabled:\nssh -Y oracle@db_server\n\n# Run Database configuration wizard:\ndbca  Follow installation steps for fat installation:   Step 01. Choose  (.) Create database  Step 02.  (.)  Create a database with default configuration  Global Database name: input what name you like  Storage type:  File System  (if you don't have ASM)  Database character set:  AL32UTF8 - Unicode UTF-8 Universal character set   Choose password for sysdba account.  Uncheck  []Create As Container Database**  Step 03. Look for any errors  Step 04. Next  Step 05. Finish   vim /etc/oratab \n\n#Set last synbol from \"N\" to \"Y\"\n<database_SID>:/u01/app/oracle/product/12.1.0/dbhome_1:Y\n\nvim ~/.bash_profile \n# Add to the end of file:\n\nexport ORACLE_SID=<database_SID>",
            "title": "Database"
        },
        {
            "location": "/Databases/Oracle/CentOS_7_Installation/#autostart",
            "text": "Oracle environemnt:   vim /etc/sysconfig/<SID>.oracledb\n\n# Contents\nORACLE_BASE=/u01/app/oracle\nORACLE_HOME=/u01/app/oracle/product/12.1.0/dbhome_1\nORACLE_SID=<your_SID>   Net listner service:   vim /usr/lib/systemd/system/<SID>@lsnrctl.service \n\n# Contents\n[Unit]\nDescription=Oracle Net Listener\nAfter=network.target\n\n[Service]\nType=forking\nEnvironmentFile=/etc/sysconfig/<SID>.oracledb\nExecStart=/u01/app/oracle/product/12.1.0/dbhome_1/bin/lsnrctl start\nExecStop=/u01/app/oracle/product/12.1.0/dbhome_1/bin/lsnrctl stop\nUser=oracle\n\n[Install]\nWantedBy=multi-user.target   Database service:   vim /usr/lib/systemd/system/<SID>@oracledb.service \n\n# Contents\n[Unit]\nDescription=Oracle Database service\nAfter=network.target lsnrctl.service\n\n[Service]\nType=forking\nEnvironmentFile=/etc/sysconfig/<SID>.oracledb\nExecStart=/u01/app/oracle/product/12.1.0/dbhome_1/bin/dbstart /u01/app/oracle/product/12.1.0/dbhome_1\nExecStop=/u01/app/oracle/product/12.1.0/dbhome_1/bin/dbshut /u01/app/oracle/product/12.1.0/dbhome_1\nUser=oracle\n\n[Install]\nWantedBy=multi-user.target   Systemd reload and enable:   systemctl daemon-reload \nsystemctl enable <SID>@lsnrctl \nsystemctl enable <SID>@oracledb",
            "title": "Autostart"
        },
        {
            "location": "/Databases/Oracle/Common/",
            "text": "Show tables\n\n\nSELECT owner, table_name FROM dba_tables;\nSELECT owner, table_name FROM all_tables;\nSELECT table_name FROM user_tables;\n\n\n\n\nShow filterd tables\n\n\nSELECT table_name FROM user_tables WHERE table_name LIKE '%<any_pattern>%';\n# Example: SELECT table_name FROM user_tables WHERE table_name LIKE '%BLACK_LIST%';\n\n\n\n\nLogin to database\n\n\n# First of all you can just use clean 'sqlplus' and it request user and password\nsqlplus <username>/<password>@<oracle_database_hostname>\n\n\n\n\nRun SQL script\n\n\n# Unix\n@/path/to/sql_script.sql\nSTART /path/to/sql_script.sql\n# Windows\n@c:\\path\\to\\sql_script.sql\nSTART c:\\path\\to\\sql_script.sql\n\n\n\n\nShow table information\n\n\nDESCRIBE <table_name>",
            "title": "Common"
        },
        {
            "location": "/Databases/Oracle/Common/#show-tables",
            "text": "SELECT owner, table_name FROM dba_tables;\nSELECT owner, table_name FROM all_tables;\nSELECT table_name FROM user_tables;",
            "title": "Show tables"
        },
        {
            "location": "/Databases/Oracle/Common/#show-filterd-tables",
            "text": "SELECT table_name FROM user_tables WHERE table_name LIKE '%<any_pattern>%';\n# Example: SELECT table_name FROM user_tables WHERE table_name LIKE '%BLACK_LIST%';",
            "title": "Show filterd tables"
        },
        {
            "location": "/Databases/Oracle/Common/#login-to-database",
            "text": "# First of all you can just use clean 'sqlplus' and it request user and password\nsqlplus <username>/<password>@<oracle_database_hostname>",
            "title": "Login to database"
        },
        {
            "location": "/Databases/Oracle/Common/#run-sql-script",
            "text": "# Unix\n@/path/to/sql_script.sql\nSTART /path/to/sql_script.sql\n# Windows\n@c:\\path\\to\\sql_script.sql\nSTART c:\\path\\to\\sql_script.sql",
            "title": "Run SQL script"
        },
        {
            "location": "/Databases/Oracle/Common/#show-table-information",
            "text": "DESCRIBE <table_name>",
            "title": "Show table information"
        },
        {
            "location": "/Databases/Oracle/Dump/",
            "text": "Fast oracle database dump creation\n\n\nThis way of making dump isn't safe, but convenient within clean or dev environment.\n\n\n# Export\nexpdp / full=Y dumpfile=<DBNAME>.dmp logfile=expdp<DBNAME>.log\nexpdp 'DBNAME'/DBPASSWORD@SID dumpfile=<dumpfile>.dmp nologfile=Y\n\n# Import \nimpdp / full=Y dumpfile=<DBNAME>.dmp logfile=impdp<DBNAME>.log \nimpdp 'DBNAME'/DBPASSWORD@SID dumpfile=<dumpfile>.dmp nologfile=Y",
            "title": "Dump"
        },
        {
            "location": "/Databases/Oracle/Dump/#fast-oracle-database-dump-creation",
            "text": "This way of making dump isn't safe, but convenient within clean or dev environment.  # Export\nexpdp / full=Y dumpfile=<DBNAME>.dmp logfile=expdp<DBNAME>.log\nexpdp 'DBNAME'/DBPASSWORD@SID dumpfile=<dumpfile>.dmp nologfile=Y\n\n# Import \nimpdp / full=Y dumpfile=<DBNAME>.dmp logfile=impdp<DBNAME>.log \nimpdp 'DBNAME'/DBPASSWORD@SID dumpfile=<dumpfile>.dmp nologfile=Y",
            "title": "Fast oracle database dump creation"
        },
        {
            "location": "/Databases/Oracle/Memory/",
            "text": "ORA-00845: MEMORY_TARGET not supported\n\n\nNot enough of shared memory\n\n\numount tmpfs\nmount -t tmpfs shmfs -o size=1024m /dev/shm",
            "title": "Memory"
        },
        {
            "location": "/Databases/Oracle/Memory/#ora-00845-memory_target-not-supported",
            "text": "Not enough of shared memory  umount tmpfs\nmount -t tmpfs shmfs -o size=1024m /dev/shm",
            "title": "ORA-00845: MEMORY_TARGET not supported"
        },
        {
            "location": "/Databases/Oracle/OJDBC/",
            "text": "BUG: 9632480\n\n\nOJDBC 12.1.0.2 - BUG: ORA-01000: maximum open cursors exceeded\n\n\nWe need:\n\n\n\n\nojdbc7.jar\n\n\np19632480_121020_Generic.zip\n\n\nJRE\n\n\n\n\n\n\nWe need to update OracleDatabaseMetaData.class in our ojdbc7.jar archive\n\n\n\n\nunzip p19632480_121020_Generic.zip\n\n\n\n\nGet folder \n./p19632480_121020_Generic/19632480/files/jdbc/lib/ojdbc7.jar\n from archvive and place it to \nojdbc7.jar\n file location\n\n\nMake sure that your JAVA_HOME is exported\n\n\nChange working directory to ojdbc7.jar location and run:\n\n\n$JAVA_HOME/jar -uf ojdbc7.jar",
            "title": "OJDBC"
        },
        {
            "location": "/Databases/Oracle/OJDBC/#bug-9632480",
            "text": "OJDBC 12.1.0.2 - BUG: ORA-01000: maximum open cursors exceeded  We need:   ojdbc7.jar  p19632480_121020_Generic.zip  JRE    We need to update OracleDatabaseMetaData.class in our ojdbc7.jar archive   unzip p19632480_121020_Generic.zip  Get folder  ./p19632480_121020_Generic/19632480/files/jdbc/lib/ojdbc7.jar  from archvive and place it to  ojdbc7.jar  file location  Make sure that your JAVA_HOME is exported  Change working directory to ojdbc7.jar location and run:  $JAVA_HOME/jar -uf ojdbc7.jar",
            "title": "BUG: 9632480"
        },
        {
            "location": "/Databases/Oracle/Tablespace/",
            "text": "Create\n\n\nCREATE TABLESPACE tablespace_name DATAFILE 'tablespace_name.ora' SIZE 20M AUTOEXTEND ON;\n### You need this line only for Oracle 12 \nALTER SESSION SET \"_ORACLE_SCRIPT\"=true;\nCREATE USER tablespace_username IDENTIFIED BY tablespace_username_password DEFAULT TABLESPACE tablespace_name;\nGRANT ALL PRIVILEGES TO tablespabe+username ;",
            "title": "Tablespace"
        },
        {
            "location": "/Databases/Oracle/Tablespace/#create",
            "text": "CREATE TABLESPACE tablespace_name DATAFILE 'tablespace_name.ora' SIZE 20M AUTOEXTEND ON;\n### You need this line only for Oracle 12 \nALTER SESSION SET \"_ORACLE_SCRIPT\"=true;\nCREATE USER tablespace_username IDENTIFIED BY tablespace_username_password DEFAULT TABLESPACE tablespace_name;\nGRANT ALL PRIVILEGES TO tablespabe+username ;",
            "title": "Create"
        },
        {
            "location": "/Databases/Oracle/Useful_Queries/",
            "text": "View tablespaces by user\n\n\nselect distinct p.tablespace_name from dba_tablespaces p, dba_xml_tables x, dba_users u, all_all_tables t where t.table_name=x.table_name and t.tablespace_name=p.tablespace_name and x.owner=u.username;\n\n\n\n\nView all tablespaces: run by sysdba\n\n\nselect * from dba_tablespaces;\n\n\n\n\nView charset\n\n\nSELECT value$ FROM sys.props$ WHERE name = 'NLS_CHARACTERSET' ;\n\n\n\n\nGet status of instances\n\n\nselect instance_name, status, database_status from v$instance; \nselect status from v$instance;\nselect logins from v$instance;\n\n\n\n\nMount and open DB\n\n\nALTER DATABASE Mount;\nALTER DATABASE OPEN;\n\n\n\n\nBackup via RMAN\n\n\nrun {\nshutdown immediate;\nstartup mount;\nbackup database;\nalter database open;\n}\n\n\n\n\nEnabling archivelog\n\n\nSHUTDOWN;\nSTARTUP MOUNT EXCLUSIVE;\nALTER DATABASE ARCHIVELOG;\nALTER DATABASE OPEN;\nSELECT log_mode FROM v$database;\n\n\n\n\nOpen cursors\n\n\nselect * from v$parameter where name = 'open_cursors';\nselect value from v$parameter where name = 'open_cursors';\nalter system set open_cursors=4000 scope=both;\n\n-- Top list\nselect a.value, s.username, s.sid, s.serial# from v$sesstat a, v$statname b, v$session s where a.statistic# = b.statistic#  and s.sid=a.sid and b.name = 'opened cursors current' and s.username is not null order by value desc;\nselect * from ( select ss.value, sn.name, ss.sid from v$sesstat ss, v$statname sn where ss.statistic# = sn.statistic# and sn.name like '%opened cursors current%' order by value desc) where rownum < 11 ;\n\nselect USERNAME, OSUSER, PROCESS, MACHINE, PROGRAM, EVENT, STATE from v$session where sid in (select SID from ( select ss.value, sn.name, ss.sid from v$sesstat ss, v$statname sn where ss.statistic# = sn.statistic# and sn.name like '%opened cursors current%' order by value desc));\nselect SID,USERNAME, OSUSER, PROCESS, MACHINE, PROGRAM, EVENT, STATE from v$session where sid in (select SID from ( select ss.value, sn.name, ss.sid from v$sesstat ss, v$statname sn where ss.statistic# = sn.statistic# and sn.name like '%opened cursors current%' order by value desc) where rownum < 20);\n\nselect user_name, status, osuser, machine, a.sql_text \n  from v$session b, v$open_cursor a \n  where a.sid = b.sid and MACHINE='SERVER_NAME'; \n\nselect * \n  from v$session b, v$open_cursor a \n  where a.sid = b.sid and MACHINE='SERVER_NAME';\n\nselect a.value, s.username, s.sid, s.serial# from v$sesstat a, v$statname b, v$session s where b.name = 'opened cursors current' order by value desc;",
            "title": "Useful Queries"
        },
        {
            "location": "/Databases/Oracle/Useful_Queries/#view-tablespaces-by-user",
            "text": "select distinct p.tablespace_name from dba_tablespaces p, dba_xml_tables x, dba_users u, all_all_tables t where t.table_name=x.table_name and t.tablespace_name=p.tablespace_name and x.owner=u.username;",
            "title": "View tablespaces by user"
        },
        {
            "location": "/Databases/Oracle/Useful_Queries/#view-all-tablespaces-run-by-sysdba",
            "text": "select * from dba_tablespaces;",
            "title": "View all tablespaces: run by sysdba"
        },
        {
            "location": "/Databases/Oracle/Useful_Queries/#view-charset",
            "text": "SELECT value$ FROM sys.props$ WHERE name = 'NLS_CHARACTERSET' ;",
            "title": "View charset"
        },
        {
            "location": "/Databases/Oracle/Useful_Queries/#get-status-of-instances",
            "text": "select instance_name, status, database_status from v$instance; \nselect status from v$instance;\nselect logins from v$instance;",
            "title": "Get status of instances"
        },
        {
            "location": "/Databases/Oracle/Useful_Queries/#mount-and-open-db",
            "text": "ALTER DATABASE Mount;\nALTER DATABASE OPEN;",
            "title": "Mount and open DB"
        },
        {
            "location": "/Databases/Oracle/Useful_Queries/#backup-via-rman",
            "text": "run {\nshutdown immediate;\nstartup mount;\nbackup database;\nalter database open;\n}",
            "title": "Backup via RMAN"
        },
        {
            "location": "/Databases/Oracle/Useful_Queries/#enabling-archivelog",
            "text": "SHUTDOWN;\nSTARTUP MOUNT EXCLUSIVE;\nALTER DATABASE ARCHIVELOG;\nALTER DATABASE OPEN;\nSELECT log_mode FROM v$database;",
            "title": "Enabling archivelog"
        },
        {
            "location": "/Databases/Oracle/Useful_Queries/#open-cursors",
            "text": "select * from v$parameter where name = 'open_cursors';\nselect value from v$parameter where name = 'open_cursors';\nalter system set open_cursors=4000 scope=both;\n\n-- Top list\nselect a.value, s.username, s.sid, s.serial# from v$sesstat a, v$statname b, v$session s where a.statistic# = b.statistic#  and s.sid=a.sid and b.name = 'opened cursors current' and s.username is not null order by value desc;\nselect * from ( select ss.value, sn.name, ss.sid from v$sesstat ss, v$statname sn where ss.statistic# = sn.statistic# and sn.name like '%opened cursors current%' order by value desc) where rownum < 11 ;\n\nselect USERNAME, OSUSER, PROCESS, MACHINE, PROGRAM, EVENT, STATE from v$session where sid in (select SID from ( select ss.value, sn.name, ss.sid from v$sesstat ss, v$statname sn where ss.statistic# = sn.statistic# and sn.name like '%opened cursors current%' order by value desc));\nselect SID,USERNAME, OSUSER, PROCESS, MACHINE, PROGRAM, EVENT, STATE from v$session where sid in (select SID from ( select ss.value, sn.name, ss.sid from v$sesstat ss, v$statname sn where ss.statistic# = sn.statistic# and sn.name like '%opened cursors current%' order by value desc) where rownum < 20);\n\nselect user_name, status, osuser, machine, a.sql_text \n  from v$session b, v$open_cursor a \n  where a.sid = b.sid and MACHINE='SERVER_NAME'; \n\nselect * \n  from v$session b, v$open_cursor a \n  where a.sid = b.sid and MACHINE='SERVER_NAME';\n\nselect a.value, s.username, s.sid, s.serial# from v$sesstat a, v$statname b, v$session s where b.name = 'opened cursors current' order by value desc;",
            "title": "Open cursors"
        },
        {
            "location": "/Dev/Android/Adb/",
            "text": "Upload file to android device\n\n\nadb push <path_to>/<file> <remote_path_to>/<file>\n# adb push ~/dev/armenianalphabet/armenianalphabet.apk /mnt/sdcard/Download/armenianalphabet.apk\n\n\n\n\nDownload file from android device\n\n\nadb pull <path_to_remote>/<file> <path_to_local>/<file>\n# adb pull /mnt/sdcard/Download/armenianalphabet.apk ~/tmp/armenianalphabet.apk",
            "title": "Adb"
        },
        {
            "location": "/Dev/Android/Adb/#upload-file-to-android-device",
            "text": "adb push <path_to>/<file> <remote_path_to>/<file>\n# adb push ~/dev/armenianalphabet/armenianalphabet.apk /mnt/sdcard/Download/armenianalphabet.apk",
            "title": "Upload file to android device"
        },
        {
            "location": "/Dev/Android/Adb/#download-file-from-android-device",
            "text": "adb pull <path_to_remote>/<file> <path_to_local>/<file>\n# adb pull /mnt/sdcard/Download/armenianalphabet.apk ~/tmp/armenianalphabet.apk",
            "title": "Download file from android device"
        },
        {
            "location": "/Dev/Android/Android_Studio/",
            "text": "libGL error: unable to load driver: i965_dri.so\n\n\n# Arch Linux\nmv ~/Android/Sdk/tools/lib64/libstdc++/libstdc++.so.6{,.bak}\nmv ~/Android/Sdk/tools/lib64/libstdc++/libstdc++.so.6.0.18{,.bak}\nln -s /usr/lib/libstdc++.so  ~/Android/Sdk/tools/lib64/libstdc++/",
            "title": "Android Studio"
        },
        {
            "location": "/Dev/Android/Android_Studio/#libgl-error-unable-to-load-driver-i965_driso",
            "text": "# Arch Linux\nmv ~/Android/Sdk/tools/lib64/libstdc++/libstdc++.so.6{,.bak}\nmv ~/Android/Sdk/tools/lib64/libstdc++/libstdc++.so.6.0.18{,.bak}\nln -s /usr/lib/libstdc++.so  ~/Android/Sdk/tools/lib64/libstdc++/",
            "title": "libGL error: unable to load driver: i965_dri.so"
        },
        {
            "location": "/Dev/Android/Apk/",
            "text": "Install release signed apk\n\n\nIf you trying to install release apk on device which was used to debug, you need to uninstall previous build because application signature is changed. \n\n\n~/Android/Sdk/platform-tools/adb uninstall <full_application_name>\n# ~/Android/Sdk/platform-tools/adb uninstall com.google.market",
            "title": "Apk"
        },
        {
            "location": "/Dev/Android/Apk/#install-release-signed-apk",
            "text": "If you trying to install release apk on device which was used to debug, you need to uninstall previous build because application signature is changed.   ~/Android/Sdk/platform-tools/adb uninstall <full_application_name>\n# ~/Android/Sdk/platform-tools/adb uninstall com.google.market",
            "title": "Install release signed apk"
        },
        {
            "location": "/Dev/Bash/Collect_bash_history/",
            "text": "Collect .bash_history from a bunch of servers.\n\n\nip_base_file\n - just a list of IP address. And you have to have same password on all servers.\n\n\n#!/bin/bash\n#\n#  Script to collect bash history from remote servers\n#\necho \"Usage: ./collect.sh <ip_base_file>\"\n\nread -n 1 -p \"Do you want to collect bash_history? (y/[a]): \" AMSURE\n[ \"$AMSURE\" = \"y\" ] || exit\necho \"\" 1>&2\n\nnow=$(date +\"%m_%d_%Y\")\nmkdir ./$now\n## Provide BASE64 encoded password here\n## echo \"MEGA-SECURE-PASSWORD\" | base64 -i\nPASS=`echo \"TUVHQS1TRUNVUkUtUEFTU1dPUkQK\" | base64 -di`\nawk '{print $1}' < ./\"$1\" | while read ip; do\n\nexpect -c \"\n    set timeout 1\n    spawn scp  root@$ip:~/.bash_history ./\"$now\"/\"$ip\"_history.txt\n    expect yes/no { send yes\\r ; exp_continue }\n    expect password: { send $PASS\\r }\n    expect 100%\n    sleep 1\n    exit\n\"\ndone",
            "title": "Collect bash history"
        },
        {
            "location": "/Dev/Bash/Collect_bash_history/#collect-bash_history-from-a-bunch-of-servers",
            "text": "ip_base_file  - just a list of IP address. And you have to have same password on all servers.  #!/bin/bash\n#\n#  Script to collect bash history from remote servers\n#\necho \"Usage: ./collect.sh <ip_base_file>\"\n\nread -n 1 -p \"Do you want to collect bash_history? (y/[a]): \" AMSURE\n[ \"$AMSURE\" = \"y\" ] || exit\necho \"\" 1>&2\n\nnow=$(date +\"%m_%d_%Y\")\nmkdir ./$now\n## Provide BASE64 encoded password here\n## echo \"MEGA-SECURE-PASSWORD\" | base64 -i\nPASS=`echo \"TUVHQS1TRUNVUkUtUEFTU1dPUkQK\" | base64 -di`\nawk '{print $1}' < ./\"$1\" | while read ip; do\n\nexpect -c \"\n    set timeout 1\n    spawn scp  root@$ip:~/.bash_history ./\"$now\"/\"$ip\"_history.txt\n    expect yes/no { send yes\\r ; exp_continue }\n    expect password: { send $PASS\\r }\n    expect 100%\n    sleep 1\n    exit\n\"\ndone",
            "title": "Collect .bash_history from a bunch of servers."
        },
        {
            "location": "/Dev/Bash/Convert-CP1251-to-UTF8/",
            "text": "Convert windows-1251 to utf-8\n\n\n#!/usr/bin/bash\n\n# Recursive file convertion windows-1251 --> utf-8\n# Place this file in the root of your site, add execute permission and run\n# Converts *.php, *.html, *.css, *.js files.\n# To add file type by extension, e.g. *.cgi, add '-o -name \"*.cgi\"' to the find command\n\nfind ./ -name \"*.cfg\"  -type f |\nwhile read file\ndo\n  echo \" $file\"\n  mv $file $file.icv\n  iconv -f WINDOWS-1251 -t UTF-8 $file.icv > $file\n  rm -f $file.icv\ndone",
            "title": "Convert CP1251 to UTF8"
        },
        {
            "location": "/Dev/Bash/Convert-CP1251-to-UTF8/#convert-windows-1251-to-utf-8",
            "text": "#!/usr/bin/bash\n\n# Recursive file convertion windows-1251 --> utf-8\n# Place this file in the root of your site, add execute permission and run\n# Converts *.php, *.html, *.css, *.js files.\n# To add file type by extension, e.g. *.cgi, add '-o -name \"*.cgi\"' to the find command\n\nfind ./ -name \"*.cfg\"  -type f |\nwhile read file\ndo\n  echo \" $file\"\n  mv $file $file.icv\n  iconv -f WINDOWS-1251 -t UTF-8 $file.icv > $file\n  rm -f $file.icv\ndone",
            "title": "Convert windows-1251 to utf-8"
        },
        {
            "location": "/Dev/Bash/Gentoo_Functions/",
            "text": "# Copyright 1999-2014 Gentoo Foundation\n# Distributed under the terms of the GNU General Public License v2\n\n#\n# All functions in this file should be written in POSIX sh. Please do\n# not use bashisms.\n#\n\nRC_GOT_FUNCTIONS=\"yes\"\n\n#\n#    hard set the indent used for e-commands.\n#    num defaults to 0\n# This is a private function.\n#\n_esetdent()\n{\n  local i=\"$1\"\n  [ -z \"$i\" ] || [ \"$i\" -lt 0 ] && i=0\n  RC_INDENTATION=$(printf \"%${i}s\" '')\n}\n\n#\n#    increase the indent used for e-commands.\n#\neindent()\n{\n  local i=\"$1\"\n  [ -n \"$i\" ] && [ \"$i\" -gt 0 ] || i=$RC_DEFAULT_INDENT\n  _esetdent $(( ${#RC_INDENTATION} + i ))\n}\n\n#\n#    decrease the indent used for e-commands.\n#\neoutdent()\n{\n  local i=\"$1\"\n  [ -n \"$i\" ] && [ \"$i\" -gt 0 ] || i=$RC_DEFAULT_INDENT\n  _esetdent $(( ${#RC_INDENTATION} - i ))\n}\n\n#\n# this function was lifted from OpenRC. It returns 0 if the argument  or\n# the value of the argument is \"yes\", \"true\", \"on\", or \"1\" or 1\n# otherwise.\n#\nyesno()\n{\n  [ -z \"$1\" ] && return 1\n\n  case \"$1\" in\n    [Yy][Ee][Ss]|[Tt][Rr][Uu][Ee]|[Oo][Nn]|1) return 0;;\n    [Nn][Oo]|[Ff][Aa][Ll][Ss][Ee]|[Oo][Ff][Ff]|0) return 1;;\n  esac\n\n  local value=\n  eval value=\\$${1}\n  case \"$value\" in\n    [Yy][Ee][Ss]|[Tt][Rr][Uu][Ee]|[Oo][Nn]|1) return 0;;\n    [Nn][Oo]|[Ff][Aa][Ll][Ss][Ee]|[Oo][Ff][Ff]|0) return 1;;\n    *) vewarn \"\\$$1 is not set properly\"; return 1;;\n  esac\n}\n\n#\n#    use the system logger to log a message\n#\nesyslog()\n{\n  local pri=\n  local tag=\n\n  if [ -n \"$EINFO_LOG\" ] && command -v logger > /dev/null 2>&1; then\n    pri=\"$1\"\n    tag=\"$2\"\n\n    shift 2\n    [ -z \"$*\" ] && return 0\n\n    logger -p \"${pri}\" -t \"${tag}\" -- \"$*\"\n  fi\n\n  return 0\n}\n\n#\n#    show an informative message (without a newline)\n#\neinfon()\n{\n  if yesno \"${EINFO_QUIET}\"; then\n    return 0\n  fi\n  if ! yesno \"${RC_ENDCOL}\" && [ \"${LAST_E_CMD}\" = \"ebegin\" ]; then\n    printf \"\\n\"\n  fi\n  printf \" ${GOOD}*${NORMAL} ${RC_INDENTATION}$*\"\n  LAST_E_CMD=\"einfon\"\n  return 0\n}\n\n#\n#    show an informative message (with a newline)\n#\neinfo()\n{\n  einfon \"$*\\n\"\n  LAST_E_CMD=\"einfo\"\n  return 0\n}\n\n#\n#    show a warning message (without a newline) and log it\n#\newarnn()\n{\n  if yesno \"${EINFO_QUIET}\"; then\n    return 0\n  else\n    if ! yesno \"${RC_ENDCOL}\" && [ \"${LAST_E_CMD}\" = \"ebegin\" ]; then\n      printf \"\\n\" >&2\n    fi\n    printf \" ${WARN}*${NORMAL} ${RC_INDENTATION}$*\" >&2\n  fi\n\n  local name=\"${0##*/}\"\n  # Log warnings to system log\n  esyslog \"daemon.warning\" \"${name}\" \"$*\"\n\n  LAST_E_CMD=\"ewarnn\"\n  return 0\n}\n\n#\n#    show a warning message (with a newline) and log it\n#\newarn()\n{\n  if yesno \"${EINFO_QUIET}\"; then\n    return 0\n  else\n    if ! yesno \"${RC_ENDCOL}\" && [ \"${LAST_E_CMD}\" = \"ebegin\" ]; then\n      printf \"\\n\" >&2\n    fi\n    printf \" ${WARN}*${NORMAL} ${RC_INDENTATION}$*\\n\" >&2\n  fi\n\n  local name=\"${0##*/}\"\n  # Log warnings to system log\n  esyslog \"daemon.warning\" \"${name}\" \"$*\"\n\n  LAST_E_CMD=\"ewarn\"\n  return 0\n}\n\n#\n#    show an error message (without a newline) and log it\n#\neerrorn()\n{\n  if yesno \"${EERROR_QUIET}\"; then\n    return 1\n  else\n    if ! yesno \"${RC_ENDCOL}\" && [ \"${LAST_E_CMD}\" = \"ebegin\" ]; then\n      printf \"\\n\" >&2\n    fi\n    printf \" ${BAD}*${NORMAL} ${RC_INDENTATION}$*\" >&2\n  fi\n\n  local name=\"${0##*/}\"\n  # Log errors to system log\n  esyslog \"daemon.err\" \"rc-scripts\" \"$*\"\n\n  LAST_E_CMD=\"eerrorn\"\n  return 1\n}\n\n#\n#    show an error message (with a newline) and log it\n#\neerror()\n{\n  if yesno \"${EERROR_QUIET}\"; then\n    return 1\n  else\n    if ! yesno \"${RC_ENDCOL}\" && [ \"${LAST_E_CMD}\" = \"ebegin\" ]; then\n      printf \"\\n\" >&2\n    fi\n    printf \" ${BAD}*${NORMAL} ${RC_INDENTATION}$*\\n\" >&2\n  fi\n\n  local name=\"${0##*/}\"\n  # Log errors to system log\n  esyslog \"daemon.err\" \"rc-scripts\" \"$*\"\n\n  LAST_E_CMD=\"eerror\"\n  return 1\n}\n\n#\n#    show a message indicating the start of a process\n#\nebegin()\n{\n  local msg=\"$*\"\n  if yesno \"${EINFO_QUIET}\"; then\n    return 0\n  fi\n\n  msg=\"${msg} ...\"\n  einfon \"${msg}\"\n  if yesno \"${RC_ENDCOL}\"; then\n    printf \"\\n\"\n  fi\n\n  LAST_E_LEN=\"$(( 3 + ${#RC_INDENTATION} + ${#msg} ))\"\n  LAST_E_CMD=\"ebegin\"\n  return 0\n}\n\n#\n#    indicate the completion of process, called from eend/ewend\n#    if error, show errstr via efunc\n#\n#    This function is private to functions.sh.  Do not call it from a\n#    script.\n#\n_eend()\n{\nhen\n  ENDCOL='\\033[A\\033['$(( COLS - 8 ))'C'\nelse\n  ENDCOL=''\nfi\n\n# Setup the colors so our messages all look pretty\nif yesno \"${RC_NOCOLOR}\"; then\n  unset GOOD WARN BAD NORMAL HILITE BRACKET\nelif (command -v tput && tput colors) >/dev/null 2>&1; then\n  GOOD=\"$(tput sgr0)$(tput bold)$(tput setaf 2)\"\n  WARN=\"$(tput sgr0)$(tput bold)$(tput setaf 3)\"\n  BAD=\"$(tput sgr0)$(tput bold)$(tput setaf 1)\"\n  HILITE=\"$(tput sgr0)$(tput bold)$(tput setaf 6)\"\n  BRACKET=\"$(tput sgr0)$(tput bold)$(tput setaf 4)\"\n  NORMAL=\"$(tput sgr0)\"\nelse\n  GOOD=$(printf '\\033[32;01m')\n  WARN=$(printf '\\033[33;01m')\n  BAD=$(printf '\\033[31;01m')\n  HILITE=$(printf '\\033[36;01m')\n  BRACKET=$(printf '\\033[34;01m')\n  NORMAL=$(printf '\\033[0m')\nfi\n\n# vim:ts=4\nshift\n\n  _eend \"${retval}\" eerror \"$*\"\n\n  LAST_E_CMD=\"eend\"\n  return ${retval}\n}\n\n#\n#    indicate the completion of process\n#    if error, show errstr via ewarn\n#\newend()\n{\n  local retval=\"${1:-0}\"\n  [ $# -eq 0 ] || shift\n\n  _eend \"${retval}\" ewarn \"$*\"\n\n  LAST_E_CMD=\"ewend\"\n  return ${retval}\n}\n\n# v-e-commands honor EINFO_VERBOSE which defaults to no.\n# The condition is negated so the return value will be zero.\nveinfo()\n{\n  yesno \"${EINFO_VERBOSE}\" && einfo \"$@\"\n}\n\nveinfon()\n{\n  yesno \"${EINFO_VERBOSE}\" && einfon \"$@\"\n}\n\nvewarn()\n{\n  yesno \"${EINFO_VERBOSE}\" && ewarn \"$@\"\n}\n\nveerror()\n{\n  yesno \"${EINFO_VERBOSE}\" && eerror \"$@\"\n}\n\nvebegin()\n{\n  yesno \"${EINFO_VERBOSE}\" && ebegin \"$@\"\n}\n\nveend()\n{\n  yesno \"${EINFO_VERBOSE}\" && { eend \"$@\"; return $?; }\n  return ${1:-0}\n}\n\nvewend()\n{\n  yesno \"${EINFO_VERBOSE}\" && { ewend \"$@\"; return $?; }\n  return ${1:-0}\n}\n\nveindent()\n{\n  yesno \"${EINFO_VERBOSE}\" && eindent\n}\n\nveoutdent()\n{\n  yesno \"${EINFO_VERBOSE}\" && eoutdent\n}\n\n#\n#    prints the current libdir {lib,lib32,lib64}\n#\nget_libdir()\n{\n  if [ -n \"${CONF_LIBDIR_OVERRIDE}\" ] ; then\n    CONF_LIBDIR=\"${CONF_LIBDIR_OVERRIDE}\"\n  elif command -v portageq > /dev/null 2>&1; then\n    CONF_LIBDIR=\"$(portageq envvar CONF_LIBDIR)\"\n  fi\n  printf \"${CONF_LIBDIR:=lib}\\n\"\n}\n\n#\n#   return 0 if gentoo=param was passed to the kernel\n#\n#   EXAMPLE:  if get_bootparam \"nodevfs\" ; then ....\n#\nget_bootparam()\n{\n  local x copt params retval=1\n\n  [ ! -r /proc/cmdline ] && return 1\n\n  read copts < /proc/cmdline\n  for copt in $copts ; do\n    if [ \"${copt%=*}\" = \"gentoo\" ] ; then\n      params=$(gawk -v PARAMS=\"${copt##*=}\" '\n        BEGIN {\n          split(PARAMS, nodes, \",\")\n          for (x in nodes)\n            print nodes[x]\n        }')\n\n      # Parse gentoo option\n      for x in ${params} ; do\n        if [ \"${x}\" = \"$1\" ] ; then\n#         echo \"YES\"\n          retval=0\n        fi\n      done\n    fi\n  done\n\n  return ${retval}\n}\n\n#\n#   return 0 if any of the files/dirs are newer than\n#   the reference file\n#\n#   EXAMPLE: if is_older_than a.out *.o ; then ...\nis_older_than()\n{\n  local x=\n  local ref=\"$1\"\n  [ $# -eq 0 ] || shift\n\n  for x in \"$@\" ; do\n    [ \"${x}\" -nt \"${ref}\" ] && return 0\n    [ -d \"${x}\" ] && is_older_than \"${ref}\" \"${x}\"/* && return 0\n  done\n\n  return 1\n}\n\n# This is the main script, please add all functions above this point!\n\n# Dont output to stdout?\nEINFO_QUIET=\"${EINFO_QUIET:-no}\"\nEINFO_VERBOSE=\"${EINFO_VERBOSE:-no}\"\n\n# Should we use color?\nRC_NOCOLOR=\"${RC_NOCOLOR:-no}\"\n# Can the terminal handle endcols?\nRC_ENDCOL=\"yes\"\n\n# Default values for e-message indentation and dots\nRC_INDENTATION=''\nRC_DEFAULT_INDENT=2\nRC_DOT_PATTERN=''\n\n# Cache the CONSOLETYPE - this is important as backgrounded shells don't\n# have a TTY. rc unsets it at the end of running so it shouldn't hang\n# around\nif [ -z \"${CONSOLETYPE}\" ] ; then\n  CONSOLETYPE=\"$(consoletype stdout 2>/dev/null )\"; export CONSOLETYPE\nfi\nif [ \"${CONSOLETYPE}\" = \"serial\" ] ; then\n  RC_NOCOLOR=\"yes\"\n  RC_ENDCOL=\"no\"\nfi\n\nfor arg in \"$@\" ; do\n  case \"${arg}\" in\n    # Lastly check if the user disabled it with --nocolor argument\n    --nocolor|-nc)\n      RC_NOCOLOR=\"yes\"\n      ;;\n  esac\ndone\n\n# Setup COLS and ENDCOL so eend can line up the [ ok ]\nCOLS=\"${COLUMNS:-0}\"            # bash's internal COLUMNS variable\n[ \"$COLS\" -eq 0 ] && \\\n        COLS=\"$(set -- $(stty size 2>/dev/null) ; printf \"$2\\n\")\"\n[ -z \"$COLS\" ] && COLS=80\n[ \"$COLS\" -gt 0 ] || COLS=80  # width of [ ok ] == 7\n\nif yesno \"${RC_ENDCOL}\"; then\n  ENDCOL='\\033[A\\033['$(( COLS - 8 ))'C'\nelse\n  ENDCOL=''\nfi\n\n# Setup the colors so our messages all look pretty\nif yesno \"${RC_NOCOLOR}\"; then\n  unset GOOD WARN BAD NORMAL HILITE BRACKET\nelif (command -v tput && tput colors) >/dev/null 2>&1; then\n  GOOD=\"$(tput sgr0)$(tput bold)$(tput setaf 2)\"\n  WARN=\"$(tput sgr0)$(tput bold)$(tput setaf 3)\"\n  BAD=\"$(tput sgr0)$(tput bold)$(tput setaf 1)\"\n  HILITE=\"$(tput sgr0)$(tput bold)$(tput setaf 6)\"\n  BRACKET=\"$(tput sgr0)$(tput bold)$(tput setaf 4)\"\n  NORMAL=\"$(tput sgr0)\"\nelse\n  GOOD=$(printf '\\033[32;01m')\n  WARN=$(printf '\\033[33;01m')\n  BAD=$(printf '\\033[31;01m')\n  HILITE=$(printf '\\033[36;01m')\n  BRACKET=$(printf '\\033[34;01m')\n  NORMAL=$(printf '\\033[0m')\nfi\n\n# vim:ts=4",
            "title": "Gentoo Functions"
        },
        {
            "location": "/Dev/Brainfuck/Sample1/",
            "text": "Print \"2 + 2 = 4\"**\n\n\n# Increase a[1] to 50 and print ASCII value \"2\"  \n# 1.    ++++++++++[>+++++<-]>.< \n# Increase a[2] to 32 and print ASCII value \" \"  \n# 2.    ++++++++[>>++++<<-]>>.<<\n# Increase a[3] to 43 and print ASCII value \"+\"  \n# 3.    ++++++++++[>>>++++<<<-]>>>+++.<<<\n# Print from a[2] ASCII value \" \"  \n# 4.    >>.<<\n# Print from a[1] ASCII value \"2\"  \n# 5.    >.<\n# Print from a[2] ASCII value \" \"  \n# 6.    >>.<<\n# Increase a[4] to 61 and print ASCII value \"=\"  \n# 7.    ++++++++++[>>>>++++++<<<<-]>>>>+.<<<<\n# Print from a[2] ASCII value \" \"  \n# 8.    >>.<<\n# Increase a[5] to 52 and print ASCII value \"4\"  \n# 9.    ++++++++++[>>>>>+++++<<<<<-]>>>>>++.<<<<<\n\n++++++++++[>+++++<-]>.<\n++++++++[>>++++<<-]>>.<<\n++++++++++[>>>++++<<<-]>>>+++.<<<\n>>.<<\n>.<\n>>.<<\n++++++++++[>>>>++++++<<<<-]>>>>+.<<<<\n>>.<<\n++++++++++[>>>>>+++++<<<<<-]>>>>>++.<<<<<",
            "title": "Sample1"
        },
        {
            "location": "/Dev/Brainfuck/Sample1/#print-2-2-4",
            "text": "# Increase a[1] to 50 and print ASCII value \"2\"  \n# 1.    ++++++++++[>+++++<-]>.< \n# Increase a[2] to 32 and print ASCII value \" \"  \n# 2.    ++++++++[>>++++<<-]>>.<<\n# Increase a[3] to 43 and print ASCII value \"+\"  \n# 3.    ++++++++++[>>>++++<<<-]>>>+++.<<<\n# Print from a[2] ASCII value \" \"  \n# 4.    >>.<<\n# Print from a[1] ASCII value \"2\"  \n# 5.    >.<\n# Print from a[2] ASCII value \" \"  \n# 6.    >>.<<\n# Increase a[4] to 61 and print ASCII value \"=\"  \n# 7.    ++++++++++[>>>>++++++<<<<-]>>>>+.<<<<\n# Print from a[2] ASCII value \" \"  \n# 8.    >>.<<\n# Increase a[5] to 52 and print ASCII value \"4\"  \n# 9.    ++++++++++[>>>>>+++++<<<<<-]>>>>>++.<<<<<\n\n++++++++++[>+++++<-]>.<\n++++++++[>>++++<<-]>>.<<\n++++++++++[>>>++++<<<-]>>>+++.<<<\n>>.<<\n>.<\n>>.<<\n++++++++++[>>>>++++++<<<<-]>>>>+.<<<<\n>>.<<\n++++++++++[>>>>>+++++<<<<<-]>>>>>++.<<<<<",
            "title": "Print \"2 + 2 = 4\"**"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/",
            "text": "Overview C++11/14/17\n\n\nMany of these descriptions and examples come from various resources (see \nAcknowledgements\n section), summarized in my own words.\n\n\nC++17 includes the following new language features:\n\n\n\n\ntemplate argument deduction for class templates\n\n\ndeclaring non-type template parameters with auto\n\n\nfolding expressions\n\n\nnew rules for auto deduction from braced-init-list\n\n\nconstexpr lambda\n\n\ninline variables\n\n\nnested namespaces\n\n\nstructured bindings\n\n\nselection statements with initializer\n\n\nconstexpr if\n\n\n\n\nC++17 includes the following new library features:\n\n\n\n\nstd::variant\n\n\nstd::optional\n\n\nstd::any\n\n\nstd::string_view\n\n\nstd::invoke\n\n\nstd::apply\n\n\nsplicing for maps and sets\n\n\n\n\nC++14 includes the following new language features:\n\n\n\n\nbinary literals\n\n\ngeneric lambda expressions\n\n\nlambda capture initializers\n\n\nreturn type deduction\n\n\ndecltype(auto)\n\n\nrelaxing constraints on constexpr functions\n\n\n\n\nC++14 includes the following new library features:\n\n\n\n\nuser-defined literals for standard library types\n\n\ncompile-time integer sequences\n\n\n\n\nC++11 includes the following new language features:\n\n\n\n\nmove semantics\n\n\nvariadic templates\n\n\nrvalue references\n\n\ninitializer lists\n\n\nstatic assertions\n\n\nauto\n\n\nlambda expressions\n\n\ndecltype\n\n\ntemplate aliases\n\n\nnullptr\n\n\nstrongly-typed enums\n\n\nattributes\n\n\nconstexpr\n\n\ndelegating constructors\n\n\nuser-defined literals\n\n\nexplicit virtual overrides\n\n\ndefault functions\n\n\ndeleted functions\n\n\nrange-based for loops\n\n\nspecial member functions for move semantics\n\n\n\n\nC++11 includes the following new library features:\n\n\n\n\nstd::move\n\n\nstd::forward\n\n\nstd::to_string\n\n\ntype traits\n\n\nsmart pointers\n\n\nstd::chrono\n\n\ntuples\n\n\nstd::tie\n\n\nstd::array\n\n\nunordered containers\n\n\nmemory model\n\n\n\n\nC++17 Language Features\n\n\nTemplate argument deduction for class templates\n\n\nAutomatic template argument deduction much like how it's done for functions, but now including class constructors.\n\n\ntemplate <typename T = float>\nstruct MyContainer {\n  T val;\n  MyContainer() : val() {}\n  MyContainer(T val) : val(val) {}\n  // ...\n};\nMyContainer c1{ 1 }; // OK MyContainer<int>\nMyContainer c2; // OK MyContainer<float>\n\n\n\n\nDeclaring non-type template parameters with auto\n\n\nFollowing the deduction rules of \nauto\n, while respecting the non-type template parameter list of allowable types[*], template arguments can be deduced from the types of its arguments:\n\n\n// Explicitly pass type `int` as template argument.\nauto seq = std::integer_sequence<int, 0, 1, 2>();\n// Type is deduced to be `int`.\nauto seq2 = my_integer_sequence<0, 1, 2>();\n\n\n\n\n* - For example, you cannot use a \ndouble\n as a template parameter type, which also makes this an invalid deduction using \nauto\n.\n\n\nFolding expressions\n\n\nA fold expression performs a fold of a template parameter pack over a binary operator.\n\n An expression of the form \n(... op e)\n or \n(e op ...)\n, where \nop\n is a fold-operator and \ne\n is an unexpanded parameter pack, are called \nunary folds\n.\n\n An expression of the form \n(e1 op1 ... op2 e2)\n, where \nop1\n and \nop2\n are fold-operators, is called a \nbinary fold\n. Either \ne1\n or \ne2\n are unexpanded parameter packs, but not both.\n\n\ntemplate<typename... Args>\nbool logicalAnd(Args... args) {\n    // Binary folding.\n    return (true && ... && args);\n}\nbool b = true;\nbool& b2 = b;\nlogicalAnd(b, b2, true); // == true\n\n\n\n\ntemplate<typename... Args>\nauto sum(Args... args) {\n    // Unary folding.\n    return (... + args);\n}\nsum(1.0, 2.0f, 3); // == 6.0\n\n\n\n\nNew rules for auto deduction from braced-init-list\n\n\nChanges to \nauto\n deduction when used with the uniform initialization syntax. Previously, \nauto x{ 3 };\n deduces a \nstd::initializer_list<int>\n, which now deduces to \nint\n.\n\n\nauto x1{ 1, 2, 3 }; // error: not a single element\nauto x2 = { 1, 2, 3 }; // decltype(x2) is std::initializer_list<int>\nauto x3{ 3 }; // decltype(x3) is int\nauto x4{ 3.0 }; // decltype(x4) is double\n\n\n\n\nconstexpr lambda\n\n\nCompile-time lambdas using \nconstexpr\n.\n\n\nauto identity = [] (int n) constexpr { return n; };\nstatic_assert(identity(123) == 123);\n\n\n\n\nconstexpr auto add = [] (int x, int y) {\n  auto L = [=] { return x; };\n  auto R = [=] { return y; };\n  return [=] { return L() + R(); };\n};\n\nstatic_assert(add(1, 2)() == 3);\n\n\n\n\nconstexpr int addOne(int n) {\n  return [n] { return n + 1; }();\n}\n\nstatic_assert(addOne(1) == 2);\n\n\n\n\nInline variables\n\n\nThe inline specifier can be applied to variables as well as to functions. A variable declared inline has the same semantics as a function declared inline.\n\n\n// Disassembly example using compiler explorer.\nstruct S { int x; };\ninline S x1 = S{321}; // mov esi, dword ptr [x1]\n                      // x1: .long 321\n\nS x2 = S{123};        // mov eax, dword ptr [.L_ZZ4mainE2x2]\n                      // mov dword ptr [rbp - 8], eax\n                      // .L_ZZ4mainE2x2: .long 123\n\n\n\n\nNested namespaces\n\n\nUsing the namespace resolution operator to create nested namespace definitions.\n\n\nnamespace A {\n  namespace B {\n    namespace C {\n      int i;\n    }\n  }\n}\n// vs.\nnamespace A::B::C {\n  int i;\n}\n\n\n\n\nStructured bindings\n\n\nA proposal for de-structuring initialization, that would allow writing \nauto {x, y, z} = expr;\n where the type of \nexpr\n was a tuple-like object, whose elements would be bound to the variables \nx\n, \ny\n, and \nz\n (which this construct declares). \nTuple-like objects\n include \nstd::tuple\n, \nstd::pair\n, \nstd::array\n, and aggregate structures.\n\n\nusing Coordinate = std::pair<int, int>;\nCoordinate origin() {\n  return Coordinate{0, 0};\n}\n\nconst auto [ x, y ] = origin();\nx; // == 0\ny; // == 0\n\n\n\n\nSelection statements with initializer\n\n\nNew versions of the \nif\n and \nswitch\n statements which simplify common code patterns and help users keep scopes tight.\n\n\n{\n  std::lock_guard<std::mutex> lk(mx);\n  if (v.empty()) v.push_back(val);\n}\n// vs.\nif (std::lock_guard<std::mutex> lk(mx); v.empty()) {\n  v.push_back(val);\n}\n\n\n\n\nFoo gadget(args);\nswitch (auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n// vs.\nswitch (Foo gadget(args); auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n\n\n\n\nconstexpr if\n\n\nWrite code that is instantiated depending on a compile-time condition.\n\n\ntemplate <typename T>\nconstexpr bool isIntegral() {\n  if constexpr (std::is_integral<T>::value) {\n    return true;\n  } else {\n    return false;\n  }\n}\nstatic_assert(isIntegral<int>() == true);\nstatic_assert(isIntegral<char>() == true);\nstatic_assert(isIntegral<double>() == false);\nstruct S {};\nstatic_assert(isIntegral<S>() == false);\n\n\n\n\nC++17 Library Features\n\n\nstd::variant\n\n\nThe class template \nstd::variant\n represents a type-safe \nunion\n. An instance of \nstd::variant\n at any given time holds a value of one of its alternative types (it's also possible for it to be valueless).\n\n\nstd::variant<int, double> v{ 12 };\nstd::get<int>(v); // == 12\nstd::get<0>(v); // == 12\nv = 12.0;\nstd::get<double>(v); // == 12.0\nstd::get<1>(v); // == 12.0\n\n\n\n\nstd::optional\n\n\nThe class template \nstd::optional\n manages an optional contained value, i.e. a value that may or may not be present. A common use case for optional is the return value of a function that may fail.\n\n\nstd::optional<std::string> create(bool b) {\n  if (b) {\n    return \"Godzilla\";\n  } else {\n    return {};\n  }\n}\n\ncreate(false).value_or(\"empty\"); // == \"empty\"\ncreate(true).value(); // == \"Godzilla\"\n// optional-returning factory functions are usable as conditions of while and if\nif (auto str = create(true)) {\n  // ...\n}\n\n\n\n\nstd::any\n\n\nA type-safe container for single values of any type.\n\n\nstd::any x{ 5 };\nx.has_value() // == true\nstd::any_cast<int>(x) // == 5\nstd::any_cast<int&>(x) = 10;\nstd::any_cast<int>(x) // == 10\n\n\n\n\nstd::string_view\n\n\nA non-owning reference to a string. Useful for providing an abstraction on top of strings (e.g. for parsing).\n\n\n// Regular strings.\nstd::string_view cppstr{ \"foo\" };\n// Wide strings.\nstd::wstring_view wcstr_v{ L\"baz\" };\n// Character arrays.\nchar array[3] = {'b', 'a', 'r'};\nstd::string_view array_v(array, sizeof array);\n\n\n\n\nstd::string str{ \"   trim me\" };\nstd::string_view v{ str };\nv.remove_prefix(std::min(v.find_first_not_of(\" \"), v.size()));\nstr; //  == \"   trim me\"\nv; // == \"trim me\"\n\n\n\n\nstd::invoke\n\n\nInvoke a \nCallable\n object with parameters. Examples of \nCallable\n objects are \nstd::function\n or \nstd::bind\n where an object can be called similarly to a regular function.\n\n\ntemplate <typename Callable>\nclass Proxy {\n    Callable c;\npublic:\n    Proxy(Callable c): c(c) {}\n    template <class... Args>\n    decltype(auto) operator()(Args&&... args) {\n        // ...\n        return std::invoke(c, std::forward<Args>(args)...);\n    }\n};\nauto add = [] (int x, int y) {\n  return x + y;\n};\nProxy<decltype(add)> p{ add };\np(1, 2); // == 3\n\n\n\n\nstd::apply\n\n\nInvoke a \nCallable\n object with a tuple of arguments.\n\n\nauto add = [] (int x, int y) {\n  return x + y;\n};\nstd::apply(add, std::make_tuple( 1, 2 )); // == 3\n\n\n\n\nSplicing for maps and sets\n\n\nMoving nodes and merging containers without the overhead of expensive copies, moves, or heap allocations/deallocations.\n\n\nMoving elements from one map to another:\n\n\nstd::map<int, string> src{ { 1, \"one\" }, { 2, \"two\" }, { 3, \"buckle my shoe\" } };\nstd::map<int, string> dst{ { 3, \"three\" } };\ndst.insert(src.extract(src.find(1))); // Cheap remove and insert of { 1, \"one\" } from `src` to `dst`.\ndst.insert(src.extract(2)); // Cheap remove and insert of { 2, \"two\" } from `src` to `dst`.\n// dst == { { 1, \"one\" }, { 2, \"two\" }, { 3, \"three\" } };\n\n\n\n\nInserting an entire set:\n\n\nstd::set<int> src{1, 3, 5};\nstd::set<int> dst{2, 4, 5};\ndst.merge(src);\n// src == { 5 }\n// dst == { 1, 2, 3, 4, 5 }\n\n\n\n\nInserting elements which outlive the container:\n\n\nauto elementFactory() {\n  std::set<...> s;\n  s.emplace(...);\n  return s.extract(s.begin());\n}\ns2.insert(elementFactory());\n\n\n\n\nChanging the key of a map element:\n\n\nstd::map<int, string> m{ { 1, \"one\" }, { 2, \"two\" }, { 3, \"three\" } };\nauto e = m.extract(2);\ne.key() = 4;\nm.insert(std::move(e));\n// m == { { 1, \"one\" }, { 3, \"three\" }, { 4, \"two\" } }\n\n\n\n\nC++14 Language Features\n\n\nBinary literals\n\n\nBinary literals provide a convenient way to represent a base-2 number.\nIt is possible to separate digits with \n'\n.\n\n\n0b110 // == 6\n0b1111'1111 // == 255\n\n\n\n\nGeneric lambda expressions\n\n\nC++14 now allows the \nauto\n type-specifier in the parameter list, enabling polymorphic lambdas.\n\n\nauto identity = [](auto x) { return x; };\nint three = identity(3); // == 3\nstd::string foo = identity(\"foo\"); // == \"foo\"\n\n\n\n\nLambda capture initializers\n\n\nThis allows creating lambda captures initialized with arbitrary expressions. The name given to the captured value does not need to be related to any variables in the enclosing scopes and introduces a new name inside the lambda body. The initializing expression is evaluated when the lambda is \ncreated\n (not when it is \ninvoked\n).\n\n\nint factory(int i) { return i * 10; }\nauto f = [x = factory(2)] { return x; }; // returns 20\n\nauto generator = [x = 0] () mutable {\n  // this would no compile without 'mutable' as we are modifying x on each call\n  return x++;\n};\nauto a = generator(); // == 0\nauto b = generator(); // == 1\nauto c = generator(); // == 2\n\n\n\n\nBecause it is now possible to \nmove\n (or \nforward\n) values into a lambda that could previously be only captured by copy or reference we can now capture move-only types in a lambda by value. Note that in the below example the \np\n in the capture-list of \ntask2\n on the left-hand-side of \n=\n is a new variable private to the lambda body and does not refer to the original \np\n.\n\n\nauto p = std::make_unique<int>(1);\n\nauto task1 = [=] { *p = 5; }; // ERROR: std::unique_ptr cannot be copied\n// vs.\nauto task2 = [p = std::move(p)] { *p = 5; }; // OK: p is move-constructed into the closure object\n// the original p is empty after task2 is created\n\n\n\n\nUsing this reference-captures can have different names than the referenced variable.\n\n\nauto x = 1;\nauto f = [&r = x, x = x * 10] {\n  ++r;\n  return r + x;\n};\nf(); // sets x to 2 and returns 12\n\n\n\n\nReturn type deduction\n\n\nUsing an \nauto\n return type in C++14, the compiler will attempt to deduce the type for you. With lambdas, you can now deduce its return type using \nauto\n, which makes returning a deduced reference or rvalue reference possible.\n\n\n// Deduce return type as `int`.\nauto f(int i) {\n return i;\n}\n\n\n\n\ntemplate <typename T>\nauto& f(T& t) {\n  return t;\n}\n\n// Returns a reference to a deduced type.\nauto g = [](auto& x) -> auto& { return f(x); };\nint y = 123;\nint& z = g(y); // reference to `y`\n\n\n\n\ndecltype(auto)\n\n\nThe \ndecltype(auto)\n type-specifier also deduces a type like \nauto\n does. However, it deduces return types while keeping their references or \"const-ness\", while \nauto\n will not.\n\n\nconst int x = 0;\nauto x1 = x; // int\ndecltype(auto) x2 = x; // const int\nint y = 0;\nint& y1 = y;\nauto y2 = y; // int\ndecltype(auto) y3 = y; // int&\nint&& z = 0;\nauto z1 = std::move(z); // int\ndecltype(auto) z2 = std::move(z); // int&&\n\n\n\n\n// Note: Especially useful for generic code!\n\n// Return type is `int`.\nauto f(const int& i) {\n return i;\n}\n\n// Return type is `const int&`.\ndecltype(auto) g(const int& i) {\n return i;\n}\n\nint x = 123;\nstatic_assert(std::is_same<const int&, decltype(f(x))>::value == 0);\nstatic_assert(std::is_same<int, decltype(f(x))>::value == 1);\nstatic_assert(std::is_same<const int&, decltype(g(x))>::value == 1);\n\n\n\n\nRelaxing constraints on constexpr functions\n\n\nIn C++11, \nconstexpr\n function bodies could only contain a very limited set of syntax, including (but not limited to): \ntypedef\ns, \nusing\ns, and a single \nreturn\n statement. In C++14, the set of allowable syntax expands greatly to include the most common syntax such as \nif\n statements, multiple \nreturn\ns, loops, etc.\n\n\nconstexpr int factorial(int n) {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\nfactorial(5); // == 120\n\n\n\n\nC++14 Library Features\n\n\nUser-defined literals for standard library types\n\n\nNew user-defined literals for standard library types, including new built-in literals for \nchrono\n and \nbasic_string\n. These can be \nconstexpr\n meaning they can be used at compile-time. Some uses for these literals include compile-time integer parsing, binary literals, and imaginary number literals.\n\n\nusing namespace std::chrono_literals;\nauto day = 24h;\nday.count(); // == 24\nstd::chrono::duration_cast<std::chrono::minutes>(day).count(); // == 1440\n\n\n\n\nCompile-time integer sequences\n\n\nThe class template \nstd::integer_sequence\n represents a compile-time sequence of integers. There are a few helpers built on top:\n\n \nstd::make_integer_sequence<T, N...>\n - creates a sequence of \n0, ..., N - 1\n with type \nT\n.\n\n \nstd::index_sequence_for<T...>\n - converts a template parameter pack into an integer sequence.\n\n\nConvert an array into a tuple:\n\n\ntemplate<typename Array, std::size_t... I>\ndecltype(auto) a2t_impl(const Array& a, std::integer_sequence<std::size_t, I...>) {\n  return std::make_tuple(a[I]...);\n}\n\ntemplate<typename T, std::size_t N, typename Indices = std::make_index_sequence<N>>\ndecltype(auto) a2t(const std::array<T, N>& a) {\n  return a2t_impl(a, Indices());\n}\n\n\n\n\nC++11 Language Features\n\n\nMove semantics\n\n\nMove semantics is mostly about performance optimization: the ability to move an object without the expensive overhead of copying. The difference between a copy and a move is that a copy leaves the source unchanged, and a move will leave the source either unchanged or radically different -- depending on what the source is. For plain old data, a move is the same as a copy.\n\n\nTo move an object means to transfer ownership of some resource it manages to another object. You could think of this as changing pointers held by the source object to be moved, or now held, by the destination object; the resource remains in its location in memory. Such an inexpensive transfer of resources is extremely useful when the source is an \nrvalue\n, where the potentially dangerous side-effect of changing the source after the move is redundant since the source is a temporary object that won't be accessible later.\n\n\nMoves also make it possible to transfer objects such as \nstd::unique_ptr\ns, \nsmart pointers\n that are designed to hold a pointer to a unique object, from one scope to another.\n\n\nSee the sections on: \nrvalue references\n, \ndefining move special member functions\n, \nstd::move\n, \nstd::forward\n.\n\n\nRvalue references\n\n\nC++11 introduces a new reference termed the \nrvalue reference\n. An rvalue reference to \nA\n is created with the syntax \nA&&\n. This enables two major features: move semantics; and \nperfect forwarding\n, the ability to pass arguments while maintaining information about them as lvalues/rvalues in a generic way.\n\n\nauto\n type deduction with lvalues and rvalues:\n\n\nint x = 0; // `x` is an lvalue of type `int`\nint& xl = x; // `xl` is an lvalue of type `int&`\nint&& xr = x; // compiler error -- `x` is an lvalue\nint&& xr2 = 0; // `xr2` is an lvalue of type `int&&`\nauto& al = x; // `al` is an lvalue of type `int&`\nauto&& al2 = x; // `al2` is an lvalue of type `int&`\nauto&& ar = 0; // `ar` is an lvalue of type `int&&`\n\n\n\n\nSee also: \nstd::move\n, \nstd::forward\n.\n\n\nVariadic templates\n\n\nThe \n...\n syntax creates a \nparameter pack\n or expands one. A template \nparameter pack\n is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A template with at least one parameter pack is called a \nvariadic template\n.\n\n\ntemplate <typename... T>\nstruct arity {\n  constexpr static int value = sizeof...(T);\n};\nstatic_assert(arity<>::value == 0);\nstatic_assert(arity<char, short, int>::value == 3);\n\n\n\n\nInitializer lists\n\n\nA lightweight array-like container of elements created using a \"braced list\" syntax. For example, \n{ 1, 2, 3 }\n creates a sequences of integers, that has type \nstd::initializer_list<int>\n. Useful as a replacement to passing a vector of objects to a function.\n\n\nint sum(const std::initializer_list<int>& list) {\n  int total = 0;\n  for (auto& e : list) {\n    total += e;\n  }\n\n  return total;\n}\n\nauto list = { 1, 2, 3 };\nf(list); // == 6\nf({ 1, 2, 3 }); // == 6\nf({}); // == 0\n\n\n\n\nStatic assertions\n\n\nAssertions that are evaluated at compile-time.\n\n\nconstexpr int x = 0;\nconstexpr int y = 1;\nstatic_assert(x == y, \"x != y\");\n\n\n\n\nauto\n\n\nauto\n-typed variables are deduced by the compiler according to the type of their initializer.\n\n\nauto a = 3.14; // double\nauto b = 1; // int\nauto& c = b; // int&\nauto d = { 0 }; // std::initializer_list<int>\nauto&& e = 1; // int&&\nauto&& f = b; // int&\nauto g = new auto(123); // int*\nconst auto h = 1; // const int\nauto i = 1, j = 2, k = 3; // int, int, int\nauto l = 1, m = true, n = 1.61; // error -- `l` deduced to be int, `m` is bool\nauto o; // error -- `o` requires initializer\n\n\n\n\nExtremely useful for readability, especially for complicated types:\n\n\nstd::vector<int> v = ...;\nstd::vector<int>::const_iterator cit = v.cbegin();\n// vs.\nauto cit = v.cbegin();\n\n\n\n\nFunctions can also deduce the return type using \nauto\n. In C++11, a return type must be specified either explicitly, or using \ndecltype\n like so:\n\n\ntemplate <typename X, typename Y>\nauto add(X x, Y y) -> decltype(x + y) {\n  return x + y;\n}\nadd(1, 2); // == 3\nadd(1, 2.0); // == 3.0\nadd(1.5, 1.5); // == 3.0\n\n\n\n\nThe trailing return type in the above example is the \ndeclared type\n (see section on \ndecltype\n) of the expression \nx + y\n. For example, if \nx\n is an integer and \ny\n is a double, \ndecltype(x + y)\n is a double. Therefore, the above function will deduce the type depending on what type the expression \nx + y\n yields. Notice that the trailing return type has access to its parameters, and \nthis\n when appropriate.\n\n\nLambda expressions\n\n\nA \nlambda\n is an unnamed function object capable of capturing variables in scope. It features: a \ncapture list\n; an optional set of parameters with an optional trailing return type; and a body. Examples of capture lists:\n\n \n[]\n - captures nothing.\n\n \n[=]\n - capture local objects (local variables, parameters) in scope by value.\n\n \n[&]\n - capture local objects (local variables, parameters) in scope by reference.\n\n \n[this]\n - capture \nthis\n pointer by value.\n* \n[a, &b]\n - capture objects \na\n by value, \nb\n by reference.\n\n\nint x = 1;\n\nauto getX = [=]{ return x; };\ngetX(); // == 1\n\nauto addX = [=](int y) { return x + y; };\naddX(1); // == 2\n\nauto getXRef = [&]() -> int& { return x; };\ngetXRef(); // int& to `x`\n\n\n\n\nBy default value-captures cannot be modified inside the lambda because the compiler-generated method is marked as \nconst\n. The \nmutable\n keyword allows modifying captured variables. The keyword is placed after the parameter-list (which must be present even if it is empty).\n\n\nint x = 1;\n\nauto f1 = [&x] { x = 2; }; // OK: x is a reference and modifies the original\n\nauto f2 = [x] { x = 2; }; // ERROR: the lambda can only perform const-operations on the captured value\n// vs.\nauto f3 = [x] () mutable { x = 2; }; // OK: the lambda can perform any operations on the captured value\n\n\n\n\ndecltype\n\n\ndecltype\n is an operator which returns the \ndeclared type\n of an expression passed to it. Examples of \ndecltype\n:\n\n\nint a = 1; // `a` is declared as type `int`\ndecltype(a) b = a; // `decltype(a)` is `int`\nconst int& c = a; // `c` is declared as type `const int&`\ndecltype(c) d = a; // `decltype(c)` is `const int&`\ndecltype(123) e = 123; // `decltype(123)` is `int`\nint&& f = 1; // `f` is declared as type `int&&`\ndecltype(f) g = 1; // `decltype(f) is `int&&`\ndecltype((a)) h = x; // `decltype((a))` is int&\n\n\n\n\ntemplate <typename X, typename Y>\nauto add(X x, Y y) -> decltype(x + y) {\n  return x + y;\n}\nadd(1, 2.0); // `decltype(x + y)` => `decltype(3.0)` => `double`\n\n\n\n\nTemplate aliases\n\n\nSemantically similar to using a \ntypedef\n however, template aliases with \nusing\n are easier to read and are compatible with templates.\n\n\ntemplate <typename T>\nusing Vec = std::vector<T>;\nVec<int> v{}; // std::vector<int>\n\nusing String = std::string;\nString s{\"foo\"};\n\n\n\n\nnullptr\n\n\nC++11 introduces a new null pointer type designed to replace C's \nNULL\n macro. \nnullptr\n itself is of type \nstd::nullptr_t\n and can be implicitly converted into pointer types, and unlike \nNULL\n, not convertible to integral types except \nbool\n.\n\n\nvoid foo(int);\nvoid foo(char*);\nfoo(NULL); // error -- ambiguous\nfoo(nullptr); // calls foo(char*)\n\n\n\n\nStrongly-typed enums\n\n\nType-safe enums that solve a variety of problems with C-style enums including: implicit conversions, inability to specify the underlying type, scope pollution.\n\n\n// Specifying underlying type as `unsigned int`\nenum class Color : unsigned int { Red = 0xff0000, Green = 0xff00, Blue = 0xff };\n// `Red`/`Green` in `Alert` don't conflict with `Color`\nenum class Alert : bool { Red, Green };\nColor c = Color::Red;\n\n\n\n\nAttributes\n\n\nAttributes provide a universal syntax over \n__attribute__(...)\n, \n__declspec\n, etc.\n\n\n// `noreturn` attribute indicates `f` doesn't return.\n[[ noreturn ]] void f() {\n  throw \"error\";\n}\n\n\n\n\nconstexpr\n\n\nConstant expressions are expressions evaluated by the compiler at compile-time. Only non-complex computations can be carried out in a constant expression. Use the \nconstexpr\n specifier to indicate the variable, function, etc. is a constant expression.\n\n\nconstexpr int square(int x) {\n  return x * x;\n}\n\nint square2(int x) {\n  return x * x;\n}\n\nint a = square(2);  // mov DWORD PTR [rbp-4], 4\n\nint b = square2(2); // mov edi, 2\n                    // call square2(int)\n                    // mov DWORD PTR [rbp-8], eax\n\n\n\n\nconstexpr\n values are those that the compiler can evaluate at compile-time:\n\n\nconst int x = 123;\nconstexpr const int& y = x; // error -- constexpr variable `y` must be initialized by a constant expression\n\n\n\n\nConstant expressions with classes:\n\n\nstruct Complex {\n  constexpr Complex(double r, double i) : re(r), im(i) { }\n  constexpr double real() { return re; }\n  constexpr double imag() { return im; }\n\nprivate:\n  double re;\n  double im;\n};\n\nconstexpr Complex I(0, 1);\n\n\n\n\nDelegating constructors\n\n\nConstructors can now call other constructors in the same class using an initializer list.\n\n\nstruct Foo {\n  int foo;\n  Foo(int foo) : foo(foo) {}\n  Foo() : Foo(0) {}\n};\n\nFoo foo{};\nfoo.foo; // == 0\n\n\n\n\nUser-defined literals\n\n\nUser-defined literals allow you to extend the language and add your own syntax. To create a literal, define a \nT operator \"\" X(...) { ... }\n function that returns a type \nT\n, with a name \nX\n. Note that the name of this function defines the name of the literal. Any literal names not starting with an underscore are reserved and won't be invoked. There are rules on what parameters a user-defined literal function should accept, according to what type the literal is called on.\n\n\nConverting Celsius to Fahrenheit:\n\n\n// `unsigned long long` parameter required for integer literal.\nlong long operator \"\" _celsius(unsigned long long tempCelsius) {\n  return std::llround(tempCelsius * 1.8 + 32);\n}\n24_celsius; // == 75\n\n\n\n\nString to integer conversion:\n\n\n// `const char*` and `std::size_t` required as parameters.\nint operator \"\" _int(const char* str, std::size_t) {\n  return std::stoi(str);\n}\n\n\"123\"_int; // == 123, with type `int`\n\n\n\n\nExplicit virtual overrides\n\n\nSpecifies that a virtual function overrides another virtual function. If the virtual function does not override a parent's virtual function, throws a compiler error.\n\n\nstruct A {\n  virtual void foo();\n  void bar();\n};\n\nstruct B : A {\n  void foo() override; // correct -- B::foo overrides A::foo\n  void bar() override; // error -- A::bar is not virtual\n  void baz() override; // error -- B::baz does not override A::baz\n};\n\n\n\n\nDefault functions\n\n\nA more elegant, efficient way to provide a default implementation of a function, such as a constructor.\n\n\nstruct A {\n  A() = default;\n  A(int x) : x(x) {}\n  int x{ 1 };\n};\nA a{}; // a.x == 1\nA a2{ 123 }; // a.x == 123\n\n\n\n\nWith inheritance:\n\n\nstruct B {\n  B() : x(1);\n  int x;\n};\n\nstruct C : B {\n  // Calls B::B\n  C() = default;\n};\n\nC c{}; // c.x == 1\n\n\n\n\nDeleted functions\n\n\nA more elegant, efficient way to provide a deleted implementation of a function. Useful for preventing copies on objects.\n\n\nclass A {\n  int x;\n\npublic:\n  A(int x) : x(x) {};\n  A(const A&) = delete;\n  A& operator=(const A&) = delete;\n};\n\nA x{ 123 };\nA y = x; // error -- call to deleted copy constructor\ny = x; // error -- operator= deleted\n\n\n\n\nRange-based for loops\n\n\nSyntactic sugar for iterating over a container's elements.\n\n\nstd::array<int, 5> a{ 1, 2, 3, 4, 5 };\nfor (int& x : a) x *= 2;\n// a == { 2, 4, 6, 8, 10 }\n\n\n\n\nNote the difference when using \nint\n as opposed to \nint&\n:\n\n\nstd::array<int, 5> a{ 1, 2, 3, 4, 5 };\nfor (int x : a) x *= 2;\n// a == { 1, 2, 3, 4, 5 }\n\n\n\n\nSpecial member functions for move semantics\n\n\nThe copy constructor and copy assignment operator are called when copies are made, and with C++11's introduction of move semantics, there is now a move constructor and move assignment operator for moves.\n\n\nstruct A {\n  std::string s;\n  A() : s(\"test\") {}\n  A(const A& o) : s(o.s) {}\n  A(A&& o) : s(std::move(o.s)) {}\n  A& operator=(A&& o) {\n   s = std::move(o.s);\n   return *this;\n  }\n};\n\nA f(A a) {\n  return a;\n}\n\nA a1 = f(A{}); // move-constructed from rvalue temporary\nA a2 = std::move(a1); // move-constructed using std::move\nA a3 = A{};\na2 = std::move(a3); // move-assignment using std::move\na1 = f(A{}); // move-assignment from rvalue temporary\n\n\n\n\nC++11 Library Features\n\n\nstd::move\n\n\nstd::move\n indicates that the object passed to it may be moved, or in other words, moved from one object to another without a copy. The object passed in should not be used after the move in certain situations.\n\n\nA definition of \nstd::move\n (performing a move is nothing more than casting to an rvalue):\n\n\ntemplate <typename T>\ntypename remove_reference<T>::type&& move(T&& arg) {\n  return static_cast<typename remove_reference<T>::type&&>(arg);\n}\n\n\n\n\nTransferring \nstd::unique_ptr\ns:\n\n\nstd::unique_ptr<int> p1{ new int };\nstd::unique_ptr<int> p2 = p1; // error -- cannot copy unique pointers\nstd::unique_ptr<int> p3 = std::move(p1); // move `p1` into `p2`\n                                         // now unsafe to dereference object held by `p1`\n\n\n\n\nstd::forward\n\n\nReturns the arguments passed to it as-is, either as an lvalue or rvalue references, and includes cv-qualification. Useful for generic code that need a reference (either lvalue or rvalue) when appropriate, e.g factories. Forwarding gets its power from \ntemplate argument deduction\n:\n\n \nT& &\n becomes \nT&\n\n\n \nT& &&\n becomes \nT&\n\n\n \nT&& &\n becomes \nT&\n\n\n \nT&& &&\n becomes \nT&&\n\n\nA definition of \nstd::forward\n:\n\n\ntemplate <typename T>\nT&& forward(typename remove_reference<T>::type& arg) {\n  return static_cast<T&&>(arg);\n}\n\n\n\n\nAn example of a function \nwrapper\n which just forwards other \nA\n objects to a new \nA\n object's copy or move constructor:\n\n\nstruct A {\n  A() = default;\n  A(const A& o) { std::cout << \"copied\" << std::endl; }\n  A(A&& o) { std::cout << \"moved\" << std::endl; }\n};\n\ntemplate <typename T>\nA wrapper(T&& arg) {\n  return A{ std::forward<T>(arg) };\n}\n\nwrapper(A{}); // moved\nA a{};\nwrapper(a); // copied\nwrapper(std::move(a)); // moved\n\n\n\n\nstd::to_string\n\n\nConverts a numeric argument to a \nstd::string\n.\n\n\nstd::to_string(1.2); // == \"1.2\"\nstd::to_string(123); // == \"123\"\n\n\n\n\nType traits\n\n\nType traits defines a compile-time template-based interface to query or modify the properties of types.\n\n\nstatic_assert(std::is_integral<int>::value == 1);\nstatic_assert(std::is_same<int, int>::value == 1);\nstatic_assert(std::is_same<std::conditional<true, int, double>::type, int>::value == 1);\n\n\n\n\nSmart pointers\n\n\nC++11 introduces new smart(er) pointers: \nstd::unique_ptr\n, \nstd::shared_ptr\n, \nstd::weak_ptr\n. \nstd::auto_ptr\n now becomes deprecated and then eventually removed in C++17. \nstd::unique_ptr\n is a non-copyable, movable smart pointer that properly manages arrays and STL containers.\n\n\nstd::unique_ptr<Foo> p1(new Foo);  // `p1` owns `Foo`\nif (p1) p1->bar();\n\n{\n  std::unique_ptr<Foo> p2(std::move(p1));  // Now `p2` owns `Foo`\n  f(*p2);\n\n  p1 = std::move(p2);  // Ownership returns to `p1` -- `p2` gets destroyed\n}\n\nif (p1) p1->bar();\n// `Foo` instance is destroyed when `p1` goes out of scope\n\n\n\n\nstd::chrono\n\n\nThe chrono library contains a set of utility functions and types that deal with \ndurations\n, \nclocks\n, and \ntime points\n. One use case of this library is benchmarking code:\n\n\nstd::chrono::time_point<std::chrono::system_clock> start, end;\nstart = std::chrono::system_clock::now();\n// Some computations...\nend = std::chrono::system_clock::now();\n\nstd::chrono::duration<double> elapsed_seconds = end-start;\n\nelapsed_seconds.count(); // t number of seconds, represented as a `double`\n\n\n\n\nTuples\n\n\nTuples are a fixed-size collection of heterogeneous values. Access the elements of a \nstd::tuple\n by unpacking using \nstd::tie\n, or using \nstd::get\n.\n\n\n// `playerProfile` has type `std::tuple<int, std::string, std::string>`.\nauto playerProfile = std::make_tuple(51, \"Frans Nielsen\", \"NYI\");\nstd::get<0>(playerProfile); // 51\nstd::get<1>(playerProfile); // \"Frans Nielsen\"\nstd::get<2>(playerProfile); // \"NYI\"\n\n\n\n\nstd::tie\n\n\nCreates a tuple of lvalue references. Useful for unpacking \nstd::pair\n and \nstd::tuple\n objects. Use \nstd::ignore\n as a placeholder for ignored values. In C++17, structured bindings should be used instead.\n\n\n// With tuples...\nstd::string playerName;\nstd::tie(std::ignore, playerName, std::ignore) = std::make_tuple(91, \"John Tavares\", \"NYI\");\n\n// With pairs...\nstd::string yes, no;\nstd::tie(yes, no) = std::make_pair(\"yes\", \"no\");\n\n\n\n\nstd::array\n\n\nstd::array\n is a container built on top of a C-style array. Supports common container operations such as sorting.\n\n\nstd::array<int, 3> a = {2, 1, 3};\nstd::sort(a.begin(), a.end()); // a == { 1, 2, 3 }\nfor (int& x : a) x *= 2; // a == { 2, 4, 6 }\n\n\n\n\nUnordered containers\n\n\nThese containers maintain average constant-time complexity for search, insert, and remove operations. In order to achieve constant-time complexity, sacrifices order for speed by hashing elements into buckets. There are four unordered containers:\n\n \nunordered_set\n\n\n \nunordered_multiset\n\n\n \nunordered_map\n\n\n \nunordered_multimap\n\n\nMemory model\n\n\nC++11 introduces a memory model for C++, which means library support for threading and atomic operations. Some of these operations include (but aren't limited to) atomic loads/stores, compare-and-swap, atomic flags, promises, futures, locks, and condition variables.\n\n\nAcknowledgements\n\n\n\n\ncppreference\n - especially useful for finding examples and documentation of new library features.\n\n\nC++ Rvalue References Explained\n - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.\n\n\nclang\n and \ngcc\n's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.\n\n\nCompiler explorer\n\n\nScott Meyers' Effective Modern C++\n - highly recommended book!\n\n\nJason Turner's C++ Weekly\n - nice collection of C++-related videos.\n\n\nWhat can I do with a moved-from object?\n\n\nWhat are some uses of decltype(auto)?\n\n\nAnd many more SO posts I'm forgetting...\n\n\n\n\nAuthor\n\n\nAnthony Calandra\n\n\nContent Contributors\n\n\nThose who have added new content will be listed here in no particular order.\n\n \nthukydides\n - mentioned binary digit separators.\n\n \nmknejp\n - lambda capture initializers and \nmutable\n keyword.\n\n\nLicense\n\n\nMIT",
            "title": "Modern Cpp Features"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#overview-c111417",
            "text": "Many of these descriptions and examples come from various resources (see  Acknowledgements  section), summarized in my own words.  C++17 includes the following new language features:   template argument deduction for class templates  declaring non-type template parameters with auto  folding expressions  new rules for auto deduction from braced-init-list  constexpr lambda  inline variables  nested namespaces  structured bindings  selection statements with initializer  constexpr if   C++17 includes the following new library features:   std::variant  std::optional  std::any  std::string_view  std::invoke  std::apply  splicing for maps and sets   C++14 includes the following new language features:   binary literals  generic lambda expressions  lambda capture initializers  return type deduction  decltype(auto)  relaxing constraints on constexpr functions   C++14 includes the following new library features:   user-defined literals for standard library types  compile-time integer sequences   C++11 includes the following new language features:   move semantics  variadic templates  rvalue references  initializer lists  static assertions  auto  lambda expressions  decltype  template aliases  nullptr  strongly-typed enums  attributes  constexpr  delegating constructors  user-defined literals  explicit virtual overrides  default functions  deleted functions  range-based for loops  special member functions for move semantics   C++11 includes the following new library features:   std::move  std::forward  std::to_string  type traits  smart pointers  std::chrono  tuples  std::tie  std::array  unordered containers  memory model",
            "title": "Overview C++11/14/17"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#c17-language-features",
            "text": "",
            "title": "C++17 Language Features"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#template-argument-deduction-for-class-templates",
            "text": "Automatic template argument deduction much like how it's done for functions, but now including class constructors.  template <typename T = float>\nstruct MyContainer {\n  T val;\n  MyContainer() : val() {}\n  MyContainer(T val) : val(val) {}\n  // ...\n};\nMyContainer c1{ 1 }; // OK MyContainer<int>\nMyContainer c2; // OK MyContainer<float>",
            "title": "Template argument deduction for class templates"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#declaring-non-type-template-parameters-with-auto",
            "text": "Following the deduction rules of  auto , while respecting the non-type template parameter list of allowable types[*], template arguments can be deduced from the types of its arguments:  // Explicitly pass type `int` as template argument.\nauto seq = std::integer_sequence<int, 0, 1, 2>();\n// Type is deduced to be `int`.\nauto seq2 = my_integer_sequence<0, 1, 2>();  * - For example, you cannot use a  double  as a template parameter type, which also makes this an invalid deduction using  auto .",
            "title": "Declaring non-type template parameters with auto"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#folding-expressions",
            "text": "A fold expression performs a fold of a template parameter pack over a binary operator.  An expression of the form  (... op e)  or  (e op ...) , where  op  is a fold-operator and  e  is an unexpanded parameter pack, are called  unary folds .  An expression of the form  (e1 op1 ... op2 e2) , where  op1  and  op2  are fold-operators, is called a  binary fold . Either  e1  or  e2  are unexpanded parameter packs, but not both.  template<typename... Args>\nbool logicalAnd(Args... args) {\n    // Binary folding.\n    return (true && ... && args);\n}\nbool b = true;\nbool& b2 = b;\nlogicalAnd(b, b2, true); // == true  template<typename... Args>\nauto sum(Args... args) {\n    // Unary folding.\n    return (... + args);\n}\nsum(1.0, 2.0f, 3); // == 6.0",
            "title": "Folding expressions"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#new-rules-for-auto-deduction-from-braced-init-list",
            "text": "Changes to  auto  deduction when used with the uniform initialization syntax. Previously,  auto x{ 3 };  deduces a  std::initializer_list<int> , which now deduces to  int .  auto x1{ 1, 2, 3 }; // error: not a single element\nauto x2 = { 1, 2, 3 }; // decltype(x2) is std::initializer_list<int>\nauto x3{ 3 }; // decltype(x3) is int\nauto x4{ 3.0 }; // decltype(x4) is double",
            "title": "New rules for auto deduction from braced-init-list"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#constexpr-lambda",
            "text": "Compile-time lambdas using  constexpr .  auto identity = [] (int n) constexpr { return n; };\nstatic_assert(identity(123) == 123);  constexpr auto add = [] (int x, int y) {\n  auto L = [=] { return x; };\n  auto R = [=] { return y; };\n  return [=] { return L() + R(); };\n};\n\nstatic_assert(add(1, 2)() == 3);  constexpr int addOne(int n) {\n  return [n] { return n + 1; }();\n}\n\nstatic_assert(addOne(1) == 2);",
            "title": "constexpr lambda"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#inline-variables",
            "text": "The inline specifier can be applied to variables as well as to functions. A variable declared inline has the same semantics as a function declared inline.  // Disassembly example using compiler explorer.\nstruct S { int x; };\ninline S x1 = S{321}; // mov esi, dword ptr [x1]\n                      // x1: .long 321\n\nS x2 = S{123};        // mov eax, dword ptr [.L_ZZ4mainE2x2]\n                      // mov dword ptr [rbp - 8], eax\n                      // .L_ZZ4mainE2x2: .long 123",
            "title": "Inline variables"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#nested-namespaces",
            "text": "Using the namespace resolution operator to create nested namespace definitions.  namespace A {\n  namespace B {\n    namespace C {\n      int i;\n    }\n  }\n}\n// vs.\nnamespace A::B::C {\n  int i;\n}",
            "title": "Nested namespaces"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#structured-bindings",
            "text": "A proposal for de-structuring initialization, that would allow writing  auto {x, y, z} = expr;  where the type of  expr  was a tuple-like object, whose elements would be bound to the variables  x ,  y , and  z  (which this construct declares).  Tuple-like objects  include  std::tuple ,  std::pair ,  std::array , and aggregate structures.  using Coordinate = std::pair<int, int>;\nCoordinate origin() {\n  return Coordinate{0, 0};\n}\n\nconst auto [ x, y ] = origin();\nx; // == 0\ny; // == 0",
            "title": "Structured bindings"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#selection-statements-with-initializer",
            "text": "New versions of the  if  and  switch  statements which simplify common code patterns and help users keep scopes tight.  {\n  std::lock_guard<std::mutex> lk(mx);\n  if (v.empty()) v.push_back(val);\n}\n// vs.\nif (std::lock_guard<std::mutex> lk(mx); v.empty()) {\n  v.push_back(val);\n}  Foo gadget(args);\nswitch (auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n// vs.\nswitch (Foo gadget(args); auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}",
            "title": "Selection statements with initializer"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#constexpr-if",
            "text": "Write code that is instantiated depending on a compile-time condition.  template <typename T>\nconstexpr bool isIntegral() {\n  if constexpr (std::is_integral<T>::value) {\n    return true;\n  } else {\n    return false;\n  }\n}\nstatic_assert(isIntegral<int>() == true);\nstatic_assert(isIntegral<char>() == true);\nstatic_assert(isIntegral<double>() == false);\nstruct S {};\nstatic_assert(isIntegral<S>() == false);",
            "title": "constexpr if"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#c17-library-features",
            "text": "",
            "title": "C++17 Library Features"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#stdvariant",
            "text": "The class template  std::variant  represents a type-safe  union . An instance of  std::variant  at any given time holds a value of one of its alternative types (it's also possible for it to be valueless).  std::variant<int, double> v{ 12 };\nstd::get<int>(v); // == 12\nstd::get<0>(v); // == 12\nv = 12.0;\nstd::get<double>(v); // == 12.0\nstd::get<1>(v); // == 12.0",
            "title": "std::variant"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#stdoptional",
            "text": "The class template  std::optional  manages an optional contained value, i.e. a value that may or may not be present. A common use case for optional is the return value of a function that may fail.  std::optional<std::string> create(bool b) {\n  if (b) {\n    return \"Godzilla\";\n  } else {\n    return {};\n  }\n}\n\ncreate(false).value_or(\"empty\"); // == \"empty\"\ncreate(true).value(); // == \"Godzilla\"\n// optional-returning factory functions are usable as conditions of while and if\nif (auto str = create(true)) {\n  // ...\n}",
            "title": "std::optional"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#stdany",
            "text": "A type-safe container for single values of any type.  std::any x{ 5 };\nx.has_value() // == true\nstd::any_cast<int>(x) // == 5\nstd::any_cast<int&>(x) = 10;\nstd::any_cast<int>(x) // == 10",
            "title": "std::any"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#stdstring_view",
            "text": "A non-owning reference to a string. Useful for providing an abstraction on top of strings (e.g. for parsing).  // Regular strings.\nstd::string_view cppstr{ \"foo\" };\n// Wide strings.\nstd::wstring_view wcstr_v{ L\"baz\" };\n// Character arrays.\nchar array[3] = {'b', 'a', 'r'};\nstd::string_view array_v(array, sizeof array);  std::string str{ \"   trim me\" };\nstd::string_view v{ str };\nv.remove_prefix(std::min(v.find_first_not_of(\" \"), v.size()));\nstr; //  == \"   trim me\"\nv; // == \"trim me\"",
            "title": "std::string_view"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#stdinvoke",
            "text": "Invoke a  Callable  object with parameters. Examples of  Callable  objects are  std::function  or  std::bind  where an object can be called similarly to a regular function.  template <typename Callable>\nclass Proxy {\n    Callable c;\npublic:\n    Proxy(Callable c): c(c) {}\n    template <class... Args>\n    decltype(auto) operator()(Args&&... args) {\n        // ...\n        return std::invoke(c, std::forward<Args>(args)...);\n    }\n};\nauto add = [] (int x, int y) {\n  return x + y;\n};\nProxy<decltype(add)> p{ add };\np(1, 2); // == 3",
            "title": "std::invoke"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#stdapply",
            "text": "Invoke a  Callable  object with a tuple of arguments.  auto add = [] (int x, int y) {\n  return x + y;\n};\nstd::apply(add, std::make_tuple( 1, 2 )); // == 3",
            "title": "std::apply"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#splicing-for-maps-and-sets",
            "text": "Moving nodes and merging containers without the overhead of expensive copies, moves, or heap allocations/deallocations.  Moving elements from one map to another:  std::map<int, string> src{ { 1, \"one\" }, { 2, \"two\" }, { 3, \"buckle my shoe\" } };\nstd::map<int, string> dst{ { 3, \"three\" } };\ndst.insert(src.extract(src.find(1))); // Cheap remove and insert of { 1, \"one\" } from `src` to `dst`.\ndst.insert(src.extract(2)); // Cheap remove and insert of { 2, \"two\" } from `src` to `dst`.\n// dst == { { 1, \"one\" }, { 2, \"two\" }, { 3, \"three\" } };  Inserting an entire set:  std::set<int> src{1, 3, 5};\nstd::set<int> dst{2, 4, 5};\ndst.merge(src);\n// src == { 5 }\n// dst == { 1, 2, 3, 4, 5 }  Inserting elements which outlive the container:  auto elementFactory() {\n  std::set<...> s;\n  s.emplace(...);\n  return s.extract(s.begin());\n}\ns2.insert(elementFactory());  Changing the key of a map element:  std::map<int, string> m{ { 1, \"one\" }, { 2, \"two\" }, { 3, \"three\" } };\nauto e = m.extract(2);\ne.key() = 4;\nm.insert(std::move(e));\n// m == { { 1, \"one\" }, { 3, \"three\" }, { 4, \"two\" } }",
            "title": "Splicing for maps and sets"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#c14-language-features",
            "text": "",
            "title": "C++14 Language Features"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#binary-literals",
            "text": "Binary literals provide a convenient way to represent a base-2 number.\nIt is possible to separate digits with  ' .  0b110 // == 6\n0b1111'1111 // == 255",
            "title": "Binary literals"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#generic-lambda-expressions",
            "text": "C++14 now allows the  auto  type-specifier in the parameter list, enabling polymorphic lambdas.  auto identity = [](auto x) { return x; };\nint three = identity(3); // == 3\nstd::string foo = identity(\"foo\"); // == \"foo\"",
            "title": "Generic lambda expressions"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#lambda-capture-initializers",
            "text": "This allows creating lambda captures initialized with arbitrary expressions. The name given to the captured value does not need to be related to any variables in the enclosing scopes and introduces a new name inside the lambda body. The initializing expression is evaluated when the lambda is  created  (not when it is  invoked ).  int factory(int i) { return i * 10; }\nauto f = [x = factory(2)] { return x; }; // returns 20\n\nauto generator = [x = 0] () mutable {\n  // this would no compile without 'mutable' as we are modifying x on each call\n  return x++;\n};\nauto a = generator(); // == 0\nauto b = generator(); // == 1\nauto c = generator(); // == 2  Because it is now possible to  move  (or  forward ) values into a lambda that could previously be only captured by copy or reference we can now capture move-only types in a lambda by value. Note that in the below example the  p  in the capture-list of  task2  on the left-hand-side of  =  is a new variable private to the lambda body and does not refer to the original  p .  auto p = std::make_unique<int>(1);\n\nauto task1 = [=] { *p = 5; }; // ERROR: std::unique_ptr cannot be copied\n// vs.\nauto task2 = [p = std::move(p)] { *p = 5; }; // OK: p is move-constructed into the closure object\n// the original p is empty after task2 is created  Using this reference-captures can have different names than the referenced variable.  auto x = 1;\nauto f = [&r = x, x = x * 10] {\n  ++r;\n  return r + x;\n};\nf(); // sets x to 2 and returns 12",
            "title": "Lambda capture initializers"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#return-type-deduction",
            "text": "Using an  auto  return type in C++14, the compiler will attempt to deduce the type for you. With lambdas, you can now deduce its return type using  auto , which makes returning a deduced reference or rvalue reference possible.  // Deduce return type as `int`.\nauto f(int i) {\n return i;\n}  template <typename T>\nauto& f(T& t) {\n  return t;\n}\n\n// Returns a reference to a deduced type.\nauto g = [](auto& x) -> auto& { return f(x); };\nint y = 123;\nint& z = g(y); // reference to `y`",
            "title": "Return type deduction"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#decltypeauto",
            "text": "The  decltype(auto)  type-specifier also deduces a type like  auto  does. However, it deduces return types while keeping their references or \"const-ness\", while  auto  will not.  const int x = 0;\nauto x1 = x; // int\ndecltype(auto) x2 = x; // const int\nint y = 0;\nint& y1 = y;\nauto y2 = y; // int\ndecltype(auto) y3 = y; // int&\nint&& z = 0;\nauto z1 = std::move(z); // int\ndecltype(auto) z2 = std::move(z); // int&&  // Note: Especially useful for generic code!\n\n// Return type is `int`.\nauto f(const int& i) {\n return i;\n}\n\n// Return type is `const int&`.\ndecltype(auto) g(const int& i) {\n return i;\n}\n\nint x = 123;\nstatic_assert(std::is_same<const int&, decltype(f(x))>::value == 0);\nstatic_assert(std::is_same<int, decltype(f(x))>::value == 1);\nstatic_assert(std::is_same<const int&, decltype(g(x))>::value == 1);",
            "title": "decltype(auto)"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#relaxing-constraints-on-constexpr-functions",
            "text": "In C++11,  constexpr  function bodies could only contain a very limited set of syntax, including (but not limited to):  typedef s,  using s, and a single  return  statement. In C++14, the set of allowable syntax expands greatly to include the most common syntax such as  if  statements, multiple  return s, loops, etc.  constexpr int factorial(int n) {\n  if (n <= 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\nfactorial(5); // == 120",
            "title": "Relaxing constraints on constexpr functions"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#c14-library-features",
            "text": "",
            "title": "C++14 Library Features"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#user-defined-literals-for-standard-library-types",
            "text": "New user-defined literals for standard library types, including new built-in literals for  chrono  and  basic_string . These can be  constexpr  meaning they can be used at compile-time. Some uses for these literals include compile-time integer parsing, binary literals, and imaginary number literals.  using namespace std::chrono_literals;\nauto day = 24h;\nday.count(); // == 24\nstd::chrono::duration_cast<std::chrono::minutes>(day).count(); // == 1440",
            "title": "User-defined literals for standard library types"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#compile-time-integer-sequences",
            "text": "The class template  std::integer_sequence  represents a compile-time sequence of integers. There are a few helpers built on top:   std::make_integer_sequence<T, N...>  - creates a sequence of  0, ..., N - 1  with type  T .   std::index_sequence_for<T...>  - converts a template parameter pack into an integer sequence.  Convert an array into a tuple:  template<typename Array, std::size_t... I>\ndecltype(auto) a2t_impl(const Array& a, std::integer_sequence<std::size_t, I...>) {\n  return std::make_tuple(a[I]...);\n}\n\ntemplate<typename T, std::size_t N, typename Indices = std::make_index_sequence<N>>\ndecltype(auto) a2t(const std::array<T, N>& a) {\n  return a2t_impl(a, Indices());\n}",
            "title": "Compile-time integer sequences"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#c11-language-features",
            "text": "",
            "title": "C++11 Language Features"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#move-semantics",
            "text": "Move semantics is mostly about performance optimization: the ability to move an object without the expensive overhead of copying. The difference between a copy and a move is that a copy leaves the source unchanged, and a move will leave the source either unchanged or radically different -- depending on what the source is. For plain old data, a move is the same as a copy.  To move an object means to transfer ownership of some resource it manages to another object. You could think of this as changing pointers held by the source object to be moved, or now held, by the destination object; the resource remains in its location in memory. Such an inexpensive transfer of resources is extremely useful when the source is an  rvalue , where the potentially dangerous side-effect of changing the source after the move is redundant since the source is a temporary object that won't be accessible later.  Moves also make it possible to transfer objects such as  std::unique_ptr s,  smart pointers  that are designed to hold a pointer to a unique object, from one scope to another.  See the sections on:  rvalue references ,  defining move special member functions ,  std::move ,  std::forward .",
            "title": "Move semantics"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#rvalue-references",
            "text": "C++11 introduces a new reference termed the  rvalue reference . An rvalue reference to  A  is created with the syntax  A&& . This enables two major features: move semantics; and  perfect forwarding , the ability to pass arguments while maintaining information about them as lvalues/rvalues in a generic way.  auto  type deduction with lvalues and rvalues:  int x = 0; // `x` is an lvalue of type `int`\nint& xl = x; // `xl` is an lvalue of type `int&`\nint&& xr = x; // compiler error -- `x` is an lvalue\nint&& xr2 = 0; // `xr2` is an lvalue of type `int&&`\nauto& al = x; // `al` is an lvalue of type `int&`\nauto&& al2 = x; // `al2` is an lvalue of type `int&`\nauto&& ar = 0; // `ar` is an lvalue of type `int&&`  See also:  std::move ,  std::forward .",
            "title": "Rvalue references"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#variadic-templates",
            "text": "The  ...  syntax creates a  parameter pack  or expands one. A template  parameter pack  is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A template with at least one parameter pack is called a  variadic template .  template <typename... T>\nstruct arity {\n  constexpr static int value = sizeof...(T);\n};\nstatic_assert(arity<>::value == 0);\nstatic_assert(arity<char, short, int>::value == 3);",
            "title": "Variadic templates"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#initializer-lists",
            "text": "A lightweight array-like container of elements created using a \"braced list\" syntax. For example,  { 1, 2, 3 }  creates a sequences of integers, that has type  std::initializer_list<int> . Useful as a replacement to passing a vector of objects to a function.  int sum(const std::initializer_list<int>& list) {\n  int total = 0;\n  for (auto& e : list) {\n    total += e;\n  }\n\n  return total;\n}\n\nauto list = { 1, 2, 3 };\nf(list); // == 6\nf({ 1, 2, 3 }); // == 6\nf({}); // == 0",
            "title": "Initializer lists"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#static-assertions",
            "text": "Assertions that are evaluated at compile-time.  constexpr int x = 0;\nconstexpr int y = 1;\nstatic_assert(x == y, \"x != y\");",
            "title": "Static assertions"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#auto",
            "text": "auto -typed variables are deduced by the compiler according to the type of their initializer.  auto a = 3.14; // double\nauto b = 1; // int\nauto& c = b; // int&\nauto d = { 0 }; // std::initializer_list<int>\nauto&& e = 1; // int&&\nauto&& f = b; // int&\nauto g = new auto(123); // int*\nconst auto h = 1; // const int\nauto i = 1, j = 2, k = 3; // int, int, int\nauto l = 1, m = true, n = 1.61; // error -- `l` deduced to be int, `m` is bool\nauto o; // error -- `o` requires initializer  Extremely useful for readability, especially for complicated types:  std::vector<int> v = ...;\nstd::vector<int>::const_iterator cit = v.cbegin();\n// vs.\nauto cit = v.cbegin();  Functions can also deduce the return type using  auto . In C++11, a return type must be specified either explicitly, or using  decltype  like so:  template <typename X, typename Y>\nauto add(X x, Y y) -> decltype(x + y) {\n  return x + y;\n}\nadd(1, 2); // == 3\nadd(1, 2.0); // == 3.0\nadd(1.5, 1.5); // == 3.0  The trailing return type in the above example is the  declared type  (see section on  decltype ) of the expression  x + y . For example, if  x  is an integer and  y  is a double,  decltype(x + y)  is a double. Therefore, the above function will deduce the type depending on what type the expression  x + y  yields. Notice that the trailing return type has access to its parameters, and  this  when appropriate.",
            "title": "auto"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#lambda-expressions",
            "text": "A  lambda  is an unnamed function object capable of capturing variables in scope. It features: a  capture list ; an optional set of parameters with an optional trailing return type; and a body. Examples of capture lists:   []  - captures nothing.   [=]  - capture local objects (local variables, parameters) in scope by value.   [&]  - capture local objects (local variables, parameters) in scope by reference.   [this]  - capture  this  pointer by value.\n*  [a, &b]  - capture objects  a  by value,  b  by reference.  int x = 1;\n\nauto getX = [=]{ return x; };\ngetX(); // == 1\n\nauto addX = [=](int y) { return x + y; };\naddX(1); // == 2\n\nauto getXRef = [&]() -> int& { return x; };\ngetXRef(); // int& to `x`  By default value-captures cannot be modified inside the lambda because the compiler-generated method is marked as  const . The  mutable  keyword allows modifying captured variables. The keyword is placed after the parameter-list (which must be present even if it is empty).  int x = 1;\n\nauto f1 = [&x] { x = 2; }; // OK: x is a reference and modifies the original\n\nauto f2 = [x] { x = 2; }; // ERROR: the lambda can only perform const-operations on the captured value\n// vs.\nauto f3 = [x] () mutable { x = 2; }; // OK: the lambda can perform any operations on the captured value",
            "title": "Lambda expressions"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#decltype",
            "text": "decltype  is an operator which returns the  declared type  of an expression passed to it. Examples of  decltype :  int a = 1; // `a` is declared as type `int`\ndecltype(a) b = a; // `decltype(a)` is `int`\nconst int& c = a; // `c` is declared as type `const int&`\ndecltype(c) d = a; // `decltype(c)` is `const int&`\ndecltype(123) e = 123; // `decltype(123)` is `int`\nint&& f = 1; // `f` is declared as type `int&&`\ndecltype(f) g = 1; // `decltype(f) is `int&&`\ndecltype((a)) h = x; // `decltype((a))` is int&  template <typename X, typename Y>\nauto add(X x, Y y) -> decltype(x + y) {\n  return x + y;\n}\nadd(1, 2.0); // `decltype(x + y)` => `decltype(3.0)` => `double`",
            "title": "decltype"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#template-aliases",
            "text": "Semantically similar to using a  typedef  however, template aliases with  using  are easier to read and are compatible with templates.  template <typename T>\nusing Vec = std::vector<T>;\nVec<int> v{}; // std::vector<int>\n\nusing String = std::string;\nString s{\"foo\"};",
            "title": "Template aliases"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#nullptr",
            "text": "C++11 introduces a new null pointer type designed to replace C's  NULL  macro.  nullptr  itself is of type  std::nullptr_t  and can be implicitly converted into pointer types, and unlike  NULL , not convertible to integral types except  bool .  void foo(int);\nvoid foo(char*);\nfoo(NULL); // error -- ambiguous\nfoo(nullptr); // calls foo(char*)",
            "title": "nullptr"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#strongly-typed-enums",
            "text": "Type-safe enums that solve a variety of problems with C-style enums including: implicit conversions, inability to specify the underlying type, scope pollution.  // Specifying underlying type as `unsigned int`\nenum class Color : unsigned int { Red = 0xff0000, Green = 0xff00, Blue = 0xff };\n// `Red`/`Green` in `Alert` don't conflict with `Color`\nenum class Alert : bool { Red, Green };\nColor c = Color::Red;",
            "title": "Strongly-typed enums"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#attributes",
            "text": "Attributes provide a universal syntax over  __attribute__(...) ,  __declspec , etc.  // `noreturn` attribute indicates `f` doesn't return.\n[[ noreturn ]] void f() {\n  throw \"error\";\n}",
            "title": "Attributes"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#constexpr",
            "text": "Constant expressions are expressions evaluated by the compiler at compile-time. Only non-complex computations can be carried out in a constant expression. Use the  constexpr  specifier to indicate the variable, function, etc. is a constant expression.  constexpr int square(int x) {\n  return x * x;\n}\n\nint square2(int x) {\n  return x * x;\n}\n\nint a = square(2);  // mov DWORD PTR [rbp-4], 4\n\nint b = square2(2); // mov edi, 2\n                    // call square2(int)\n                    // mov DWORD PTR [rbp-8], eax  constexpr  values are those that the compiler can evaluate at compile-time:  const int x = 123;\nconstexpr const int& y = x; // error -- constexpr variable `y` must be initialized by a constant expression  Constant expressions with classes:  struct Complex {\n  constexpr Complex(double r, double i) : re(r), im(i) { }\n  constexpr double real() { return re; }\n  constexpr double imag() { return im; }\n\nprivate:\n  double re;\n  double im;\n};\n\nconstexpr Complex I(0, 1);",
            "title": "constexpr"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#delegating-constructors",
            "text": "Constructors can now call other constructors in the same class using an initializer list.  struct Foo {\n  int foo;\n  Foo(int foo) : foo(foo) {}\n  Foo() : Foo(0) {}\n};\n\nFoo foo{};\nfoo.foo; // == 0",
            "title": "Delegating constructors"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#user-defined-literals",
            "text": "User-defined literals allow you to extend the language and add your own syntax. To create a literal, define a  T operator \"\" X(...) { ... }  function that returns a type  T , with a name  X . Note that the name of this function defines the name of the literal. Any literal names not starting with an underscore are reserved and won't be invoked. There are rules on what parameters a user-defined literal function should accept, according to what type the literal is called on.  Converting Celsius to Fahrenheit:  // `unsigned long long` parameter required for integer literal.\nlong long operator \"\" _celsius(unsigned long long tempCelsius) {\n  return std::llround(tempCelsius * 1.8 + 32);\n}\n24_celsius; // == 75  String to integer conversion:  // `const char*` and `std::size_t` required as parameters.\nint operator \"\" _int(const char* str, std::size_t) {\n  return std::stoi(str);\n}\n\n\"123\"_int; // == 123, with type `int`",
            "title": "User-defined literals"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#explicit-virtual-overrides",
            "text": "Specifies that a virtual function overrides another virtual function. If the virtual function does not override a parent's virtual function, throws a compiler error.  struct A {\n  virtual void foo();\n  void bar();\n};\n\nstruct B : A {\n  void foo() override; // correct -- B::foo overrides A::foo\n  void bar() override; // error -- A::bar is not virtual\n  void baz() override; // error -- B::baz does not override A::baz\n};",
            "title": "Explicit virtual overrides"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#default-functions",
            "text": "A more elegant, efficient way to provide a default implementation of a function, such as a constructor.  struct A {\n  A() = default;\n  A(int x) : x(x) {}\n  int x{ 1 };\n};\nA a{}; // a.x == 1\nA a2{ 123 }; // a.x == 123  With inheritance:  struct B {\n  B() : x(1);\n  int x;\n};\n\nstruct C : B {\n  // Calls B::B\n  C() = default;\n};\n\nC c{}; // c.x == 1",
            "title": "Default functions"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#deleted-functions",
            "text": "A more elegant, efficient way to provide a deleted implementation of a function. Useful for preventing copies on objects.  class A {\n  int x;\n\npublic:\n  A(int x) : x(x) {};\n  A(const A&) = delete;\n  A& operator=(const A&) = delete;\n};\n\nA x{ 123 };\nA y = x; // error -- call to deleted copy constructor\ny = x; // error -- operator= deleted",
            "title": "Deleted functions"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#range-based-for-loops",
            "text": "Syntactic sugar for iterating over a container's elements.  std::array<int, 5> a{ 1, 2, 3, 4, 5 };\nfor (int& x : a) x *= 2;\n// a == { 2, 4, 6, 8, 10 }  Note the difference when using  int  as opposed to  int& :  std::array<int, 5> a{ 1, 2, 3, 4, 5 };\nfor (int x : a) x *= 2;\n// a == { 1, 2, 3, 4, 5 }",
            "title": "Range-based for loops"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#special-member-functions-for-move-semantics",
            "text": "The copy constructor and copy assignment operator are called when copies are made, and with C++11's introduction of move semantics, there is now a move constructor and move assignment operator for moves.  struct A {\n  std::string s;\n  A() : s(\"test\") {}\n  A(const A& o) : s(o.s) {}\n  A(A&& o) : s(std::move(o.s)) {}\n  A& operator=(A&& o) {\n   s = std::move(o.s);\n   return *this;\n  }\n};\n\nA f(A a) {\n  return a;\n}\n\nA a1 = f(A{}); // move-constructed from rvalue temporary\nA a2 = std::move(a1); // move-constructed using std::move\nA a3 = A{};\na2 = std::move(a3); // move-assignment using std::move\na1 = f(A{}); // move-assignment from rvalue temporary",
            "title": "Special member functions for move semantics"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#c11-library-features",
            "text": "",
            "title": "C++11 Library Features"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#stdmove",
            "text": "std::move  indicates that the object passed to it may be moved, or in other words, moved from one object to another without a copy. The object passed in should not be used after the move in certain situations.  A definition of  std::move  (performing a move is nothing more than casting to an rvalue):  template <typename T>\ntypename remove_reference<T>::type&& move(T&& arg) {\n  return static_cast<typename remove_reference<T>::type&&>(arg);\n}  Transferring  std::unique_ptr s:  std::unique_ptr<int> p1{ new int };\nstd::unique_ptr<int> p2 = p1; // error -- cannot copy unique pointers\nstd::unique_ptr<int> p3 = std::move(p1); // move `p1` into `p2`\n                                         // now unsafe to dereference object held by `p1`",
            "title": "std::move"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#stdforward",
            "text": "Returns the arguments passed to it as-is, either as an lvalue or rvalue references, and includes cv-qualification. Useful for generic code that need a reference (either lvalue or rvalue) when appropriate, e.g factories. Forwarding gets its power from  template argument deduction :   T& &  becomes  T&    T& &&  becomes  T&    T&& &  becomes  T&    T&& &&  becomes  T&&  A definition of  std::forward :  template <typename T>\nT&& forward(typename remove_reference<T>::type& arg) {\n  return static_cast<T&&>(arg);\n}  An example of a function  wrapper  which just forwards other  A  objects to a new  A  object's copy or move constructor:  struct A {\n  A() = default;\n  A(const A& o) { std::cout << \"copied\" << std::endl; }\n  A(A&& o) { std::cout << \"moved\" << std::endl; }\n};\n\ntemplate <typename T>\nA wrapper(T&& arg) {\n  return A{ std::forward<T>(arg) };\n}\n\nwrapper(A{}); // moved\nA a{};\nwrapper(a); // copied\nwrapper(std::move(a)); // moved",
            "title": "std::forward"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#stdto_string",
            "text": "Converts a numeric argument to a  std::string .  std::to_string(1.2); // == \"1.2\"\nstd::to_string(123); // == \"123\"",
            "title": "std::to_string"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#type-traits",
            "text": "Type traits defines a compile-time template-based interface to query or modify the properties of types.  static_assert(std::is_integral<int>::value == 1);\nstatic_assert(std::is_same<int, int>::value == 1);\nstatic_assert(std::is_same<std::conditional<true, int, double>::type, int>::value == 1);",
            "title": "Type traits"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#smart-pointers",
            "text": "C++11 introduces new smart(er) pointers:  std::unique_ptr ,  std::shared_ptr ,  std::weak_ptr .  std::auto_ptr  now becomes deprecated and then eventually removed in C++17.  std::unique_ptr  is a non-copyable, movable smart pointer that properly manages arrays and STL containers.  std::unique_ptr<Foo> p1(new Foo);  // `p1` owns `Foo`\nif (p1) p1->bar();\n\n{\n  std::unique_ptr<Foo> p2(std::move(p1));  // Now `p2` owns `Foo`\n  f(*p2);\n\n  p1 = std::move(p2);  // Ownership returns to `p1` -- `p2` gets destroyed\n}\n\nif (p1) p1->bar();\n// `Foo` instance is destroyed when `p1` goes out of scope",
            "title": "Smart pointers"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#stdchrono",
            "text": "The chrono library contains a set of utility functions and types that deal with  durations ,  clocks , and  time points . One use case of this library is benchmarking code:  std::chrono::time_point<std::chrono::system_clock> start, end;\nstart = std::chrono::system_clock::now();\n// Some computations...\nend = std::chrono::system_clock::now();\n\nstd::chrono::duration<double> elapsed_seconds = end-start;\n\nelapsed_seconds.count(); // t number of seconds, represented as a `double`",
            "title": "std::chrono"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#tuples",
            "text": "Tuples are a fixed-size collection of heterogeneous values. Access the elements of a  std::tuple  by unpacking using  std::tie , or using  std::get .  // `playerProfile` has type `std::tuple<int, std::string, std::string>`.\nauto playerProfile = std::make_tuple(51, \"Frans Nielsen\", \"NYI\");\nstd::get<0>(playerProfile); // 51\nstd::get<1>(playerProfile); // \"Frans Nielsen\"\nstd::get<2>(playerProfile); // \"NYI\"",
            "title": "Tuples"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#stdtie",
            "text": "Creates a tuple of lvalue references. Useful for unpacking  std::pair  and  std::tuple  objects. Use  std::ignore  as a placeholder for ignored values. In C++17, structured bindings should be used instead.  // With tuples...\nstd::string playerName;\nstd::tie(std::ignore, playerName, std::ignore) = std::make_tuple(91, \"John Tavares\", \"NYI\");\n\n// With pairs...\nstd::string yes, no;\nstd::tie(yes, no) = std::make_pair(\"yes\", \"no\");",
            "title": "std::tie"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#stdarray",
            "text": "std::array  is a container built on top of a C-style array. Supports common container operations such as sorting.  std::array<int, 3> a = {2, 1, 3};\nstd::sort(a.begin(), a.end()); // a == { 1, 2, 3 }\nfor (int& x : a) x *= 2; // a == { 2, 4, 6 }",
            "title": "std::array"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#unordered-containers",
            "text": "These containers maintain average constant-time complexity for search, insert, and remove operations. In order to achieve constant-time complexity, sacrifices order for speed by hashing elements into buckets. There are four unordered containers:   unordered_set    unordered_multiset    unordered_map    unordered_multimap",
            "title": "Unordered containers"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#memory-model",
            "text": "C++11 introduces a memory model for C++, which means library support for threading and atomic operations. Some of these operations include (but aren't limited to) atomic loads/stores, compare-and-swap, atomic flags, promises, futures, locks, and condition variables.",
            "title": "Memory model"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#acknowledgements",
            "text": "cppreference  - especially useful for finding examples and documentation of new library features.  C++ Rvalue References Explained  - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.  clang  and  gcc 's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.  Compiler explorer  Scott Meyers' Effective Modern C++  - highly recommended book!  Jason Turner's C++ Weekly  - nice collection of C++-related videos.  What can I do with a moved-from object?  What are some uses of decltype(auto)?  And many more SO posts I'm forgetting...",
            "title": "Acknowledgements"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#author",
            "text": "Anthony Calandra",
            "title": "Author"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#content-contributors",
            "text": "Those who have added new content will be listed here in no particular order.   thukydides  - mentioned binary digit separators.   mknejp  - lambda capture initializers and  mutable  keyword.",
            "title": "Content Contributors"
        },
        {
            "location": "/Dev/C_and_Cpp/Modern_Cpp_Features/#license",
            "text": "MIT",
            "title": "License"
        },
        {
            "location": "/Dev/C_and_Cpp/Rand/",
            "text": "Random number\n\n\nReturning rand() % N does not uniformly give a number in the range [0, N) unless N divides the length of the interval into which rand() returns (i.e. is a power of 2). Furthermore, one has no idea whether the moduli of rand() are independent: it's possible that they go 0, 1, 2, ..., which is uniform but not very random. The only assumption it seems reasonable to make is that rand() puts out a Poisson distribution: any two nonoverlapping subintervals of the same size are equally likely and independent. For a finite set of values, this implies a uniform distribution and also ensures that the values of rand() are nicely scattered.\n\n\nThis means that the only correct way of changing the range of rand() is to divide it into boxes; for example, if RAND_MAX == 11 and you want a range of 1..6, you should assign {0,1} to 1, {2,3} to 2, and so on. These are disjoint, equally-sized intervals and thus are uniformly and independently distributed.\n\n\nThe suggestion to use floating-point division is mathematically plausible but suffers from rounding issues in principle. Perhaps double is high-enough precision to make it work; perhaps not. I don't know and I don't want to have to figure it out; in any case, the answer is system-dependent.\n\n\nThe correct way is to use integer arithmetic. That is, you want something like the following:\n\n\n#include <stdlib.h> // For random(), RAND_MAX\n\n// Assumes 0 <= max <= RAND_MAX\n// Returns in the closed interval [0, max]\nlong random_at_most(long max) {\n  unsigned long\n    // max <= RAND_MAX < ULONG_MAX, so this is okay.\n    num_bins = (unsigned long) max + 1,\n    num_rand = (unsigned long) RAND_MAX + 1,\n    bin_size = num_rand / num_bins,\n    defect   = num_rand % num_bins;\n\n  long x;\n  do {\n   x = random();\n  }\n  // This is carefully written not to overflow\n  while (num_rand - defect <= (unsigned long)x);\n\n  // Truncated division is intentional\n  return x/bin_size;\n}\n\n\n\n\nThe loop is necessary to get a perfectly uniform distribution. For example, if you are given random numbers from 0 to 2 and you want only ones from 0 to 1, you just keep pulling until you don't get a 2; it's not hard to check that this gives 0 or 1 with equal probability. This method is also described in the link that nos gave in their answer, though coded differently. I'm using random() rather than rand() as it has a better distribution (as noted by the man page for rand()).\n\n\nIf you want to get random values outside the default range [0, RAND_MAX], then you have to do something tricky. Perhaps the most expedient is to define a function random_extended() that pulls n bits (using random_at_most()) and returns in [0, 2\nn), and then apply random_at_most() with random_extended() in place of random() (and 2\nn - 1 in place of RAND_MAX) to pull a random value less than 2**n, assuming you have a numerical type that can hold such a value. Finally, of course, you can get values in [min, max] using min + random_at_most(max - min), including negative values.",
            "title": "Rand"
        },
        {
            "location": "/Dev/C_and_Cpp/Rand/#random-number",
            "text": "Returning rand() % N does not uniformly give a number in the range [0, N) unless N divides the length of the interval into which rand() returns (i.e. is a power of 2). Furthermore, one has no idea whether the moduli of rand() are independent: it's possible that they go 0, 1, 2, ..., which is uniform but not very random. The only assumption it seems reasonable to make is that rand() puts out a Poisson distribution: any two nonoverlapping subintervals of the same size are equally likely and independent. For a finite set of values, this implies a uniform distribution and also ensures that the values of rand() are nicely scattered.  This means that the only correct way of changing the range of rand() is to divide it into boxes; for example, if RAND_MAX == 11 and you want a range of 1..6, you should assign {0,1} to 1, {2,3} to 2, and so on. These are disjoint, equally-sized intervals and thus are uniformly and independently distributed.  The suggestion to use floating-point division is mathematically plausible but suffers from rounding issues in principle. Perhaps double is high-enough precision to make it work; perhaps not. I don't know and I don't want to have to figure it out; in any case, the answer is system-dependent.  The correct way is to use integer arithmetic. That is, you want something like the following:  #include <stdlib.h> // For random(), RAND_MAX\n\n// Assumes 0 <= max <= RAND_MAX\n// Returns in the closed interval [0, max]\nlong random_at_most(long max) {\n  unsigned long\n    // max <= RAND_MAX < ULONG_MAX, so this is okay.\n    num_bins = (unsigned long) max + 1,\n    num_rand = (unsigned long) RAND_MAX + 1,\n    bin_size = num_rand / num_bins,\n    defect   = num_rand % num_bins;\n\n  long x;\n  do {\n   x = random();\n  }\n  // This is carefully written not to overflow\n  while (num_rand - defect <= (unsigned long)x);\n\n  // Truncated division is intentional\n  return x/bin_size;\n}  The loop is necessary to get a perfectly uniform distribution. For example, if you are given random numbers from 0 to 2 and you want only ones from 0 to 1, you just keep pulling until you don't get a 2; it's not hard to check that this gives 0 or 1 with equal probability. This method is also described in the link that nos gave in their answer, though coded differently. I'm using random() rather than rand() as it has a better distribution (as noted by the man page for rand()).  If you want to get random values outside the default range [0, RAND_MAX], then you have to do something tricky. Perhaps the most expedient is to define a function random_extended() that pulls n bits (using random_at_most()) and returns in [0, 2 n), and then apply random_at_most() with random_extended() in place of random() (and 2 n - 1 in place of RAND_MAX) to pull a random value less than 2**n, assuming you have a numerical type that can hold such a value. Finally, of course, you can get values in [min, max] using min + random_at_most(max - min), including negative values.",
            "title": "Random number"
        },
        {
            "location": "/Dev/Cmd/ping_whole_subnet/",
            "text": "Ping subnet\n\n\nFOR /L %i IN (1,1,254) DO ping -n 1 192.168.10.%i | FIND /i \"Reply\">>c:\\ipaddresses.txt",
            "title": "Ping whole subnet"
        },
        {
            "location": "/Dev/Cmd/ping_whole_subnet/#ping-subnet",
            "text": "FOR /L %i IN (1,1,254) DO ping -n 1 192.168.10.%i | FIND /i \"Reply\">>c:\\ipaddresses.txt",
            "title": "Ping subnet"
        },
        {
            "location": "/Dev/Cuda/Make/",
            "text": "Dealing with: libGL.so,libGLU.so,libX11.so not found\n\n\n# If you face this warnings:\n# >>> WARNING - libGL.so not found, refer to CUDA Getting Started Guide for how to find and install them. <<<\n# >>> WARNING - libGLU.so not found, refer to CUDA Getting Started Guide for how to find and install them. <<<\n# >>> WARNING - libX11.so not found, refer to CUDA Getting Started Guide for how to find and install them. <<<\n# You sould pass apropriate lib path to GLPATH environment variable\n\nGLPATH=/usr/lib make\nGLPATH=/usr/lib32 make\nGLPATH=/usr/lib64 make",
            "title": "Make"
        },
        {
            "location": "/Dev/Cuda/Make/#dealing-with-libglsolibglusolibx11so-not-found",
            "text": "# If you face this warnings:\n# >>> WARNING - libGL.so not found, refer to CUDA Getting Started Guide for how to find and install them. <<<\n# >>> WARNING - libGLU.so not found, refer to CUDA Getting Started Guide for how to find and install them. <<<\n# >>> WARNING - libX11.so not found, refer to CUDA Getting Started Guide for how to find and install them. <<<\n# You sould pass apropriate lib path to GLPATH environment variable\n\nGLPATH=/usr/lib make\nGLPATH=/usr/lib32 make\nGLPATH=/usr/lib64 make",
            "title": "Dealing with: libGL.so,libGLU.so,libX11.so not found"
        },
        {
            "location": "/Dev/Debug/10_Commands/",
            "text": "Ten Commands Every Linux Developer Should Know\n\n\nThis article presents a list of commands you should be able to find on any Linux installation. These are tools to help you improve your code and be more productive. The list comes from my own experience as a programmer and includes tools I've come to rely on repeatedly. Some tools help create code, some help debug code and some help reverse engineer code that's been dumped in your lap.\n\n\nctags\n\n\nThose of you addicted to integrated development environments (IDEs) probably never heard of this tool, or if you did you probably think it's obsolete. But a tags-aware editor is a productive programming tool.\nTagging your code allows editors like vi and Emacs to treat your code like hypertext (Figure 1). Each object in your code becomes hyperlinked to its definition. For example, if you are browsing code in vi and want to know where the variable foo was defined, type :ta foo. If your cursor is pointing to the variable, simply use Ctrl-right bracket.\n\n\nThe good news for the vi-impaired is ctags is not only for C and vi anymore. The GNU version of ctags produces tags that can be used with Emacs and many other editors that recognize tag files. In addition, ctags recognizes many languages other than C and C++, including Perl and Python, and even hardware design languages, such as Verilog. It even can produce a human-readable cross-reference that can be useful for understanding code and performing metrics. Even if you're not interested in using ctags in your editor, you might want to check out the human-readable cross-reference by typing:\n\n\n  ctags -x *.c*.\n\n\n\n\nWhat I like about this tool is that you get useful information whether you input one file or one hundred files, unlike many IDEs that aren't useful unless they can see your entire application. It's not a program checker, so garbage in, garbage out (GIGO) rules apply.\n\n\nstrace\n\n\nstrace lets you decipher what's going on when you have no debugger nor the source code. One of my pet peeves is a program that doesn't start and doesn't tell you why. Perhaps a required file is missing or has the wrong permissions. strace can tell you what the program is doing right up to the point where it exits. It can tell you what system calls the program is using and whether they pass or fail. It even can follow forks.\n\n\nstrace often gives me answers much more quickly than a debugger, especially if the code is unfamiliar. On occasion, I have to debug code on a live system with no debugger. A quick run with strace sometimes can avoid patching the system or littering my code with printfs. Here is a trivial example of me as an unprivileged user trying to delete a protected file:\n\n\nstrace -o strace.out rm -f /etc/yp.conf\n\n\n\n\nThe output shows where things went wrong:\n\n\nlstat64(\"/etc/yp.conf\", {st_mode=S_IFREG|0644,st_size=361, ...}) = 0\naccess(\"/etc/yp.conf\", W_OK) = -1 EACCES(Permission denied)\nunlink(\"/etc/yp.conf\") = -1 EACCES (Permission denied)\n\n\n\n\nstrace also lets you attach to processes for just-in-time debugging. Suppose a process seems to be spending a lot of time doing nothing. A quick way to find out what is going on is to type:\n\n\nstrace -c -p mypid\n\n\n\n\nAfter a second or two, press Ctrl-C and you might see a dump something like this:\n\n\n% time    seconds  usecs/call     calls    errors  syscall\n------ ----------- ----------- --------- --------- ----------------\n 91.31    0.480456        3457       139           poll\n  6.66    0.035025         361        97           write\n  0.91    0.004794          16       304           futex\n  0.52    0.002741          14       203           read\n  0.31    0.001652           3       533           gettimeofday\n  0.26    0.001361           4       374           ioctl\n  0.01    0.000075           8        10           brk\n  0.01    0.000064          64         1           clone\n  0.00    0.000026          26         1           stat64\n  0.00    0.000007           7         1           uname\n  0.00    0.000005           5         1           sched_get_priority_max\n  0.00    0.000002           2         1           sched_get_priority_min\n------ ----------- ----------- --------- --------- ----------------\n100.00    0.526208                  1665           total\n\n\n\n\nIn this case, it's spending most of its time in the poll system call\u2014probably waiting on a socket.\n\n\nfuser\n\n\nThe name is a mnemonic for file user and tells what processes have opened a given file. It also can send a signal to all those processes for you. Suppose you want to delete a file but can't because some program has it open and won't close it. Instead of rebooting, type fuser -k myfile. This sends a SIGTERM to every process that has myfile opened.\nPerhaps you need to kill a process that forked itself all over the place, intentionally or otherwise. An unenlightened programmer might type something like ps | grep myprogram. This inevitably would be followed by several cut-and-paste operations with the mouse. An easier way is to type fuser -k ./myprogram, where myprogram is the pathname of the executable. fuser typically is located in /sbin, which generally is reserved for system administrative tools. You can add /usr/sbin and /sbin to the end of your $PATH.\n\n\nps\n\n\nps is used to find process status, but many people don't realize it also can be a powerful debugging tool. To get at these features, use the -o option, which lets you access many details of your processes, including CPU usage, virtual memory usage, current state and much more. Many of these options are defined in the POSIX standard, so they work across platforms.\nTo look at your running commands by pid and process state, type ps -e -o pid,state,cmd. The output looks like this:\n\n\n4576 S /opt/OpenOffice.org1.1.0/program/soffice.bin -writer\n4618 D dd if /dev/cdrom of /dev/null\n4619 S bash\n4645 R ps -e -o pid,state,cmd\n\n\n\n\nHere you can see my dd command is in an uninterruptible sleep (state D). Basically, it is blocking while waiting for /dev/cdrom. My OpenOffice.org writer is sleeping (state S) while I type my example, and my ps command is running (state R).\nFor an idea of how a running program is performing, type:\n\n\nps -o start,time,etime -p mypid\n\n\n\n\nThis shows the basic output from the time command, discussed later, except you don't have to wait until your program is finished.\nMost of the information that ps produces is available from the \n/proc\n filesystem, but if you are writing a script, using ps is more portable. You never know when a minor kernel rev will break all of your scripts that are mining the \n/proc\n filesystem. Use ps instead.\n\n\ntime\n\n\nThe time command is useful for understanding your code's performance. The most basic output consists of real, user and system time. Intuitively, real time is the amount of time between when the code started and when it exited. User time and system time are the amount of time spent executing application code versus kernel code, respectively.\nTwo flavors of the time command are available. The shell has a built-in version that tells you only scheduler information. A version in /usr/bin includes more information and allows you to format the output. You easily can override the built-in time command by preceding it with a backslash, as in the examples that follow.\nA basic knowledge of the Linux scheduler is helpful in interpreting the output, but this tool also is helpful for learning how the scheduler works. For example, the real time of a process typically is larger than the sum of the user and system time. Time spent blocking in a system call does not count against the process, because the scheduler is free to schedule other processes during this time. The following sleep command takes one second to execute but takes no measurable system or user time:\n\n\n\\time -p sleep 1\nreal 1.03\nuser 0.00\nsys 0.00\n\n\n\n\nThe next example shows how a task can spend all of its time in user space. Here, Perl calls the log() function in a loop, which requires nothing from the kernel:\n\n\n\\time perl -e 'log(2.0) foreach(0..0x100000)'\nreal 0.40\nuser 0.20\nsys 0.00\n\n\n\n\nThis example shows a process using a lot of memory:\n\n\n\\time perl -e '$x = 'a' x 0x1000000'\n\n0.06user 0.12system 0:00.22elapsed 81%CPU (0avgtext+0avgdata 0maxresident)k\n0inputs+0outputs (309major+8235minor)pagefaults\n0swaps\n\n\n\n\nThe useful information here is listed as pagefaults. Although the GNU time command advertises a lot of information, the 2.4 series of the Linux kernel stores only major and minor page-fault information. A major page fault is one that requires I/O; a minor page fault does not.\n\n\nnm\n\n\nThis command allows you to retrieve information on symbol names inside an object file or executable file. By default, the output gives you a symbol name and its virtual address. What good is that? Suppose you are compiling code and the compiler complains that you have an unresolved symbol _foo. You search all of your source code and cannot find anywhere where you use this symbol. Perhaps it got pulled in from some template or a macro buried in one of the dozens of include files that compiled along with your code. The command:\n\n\nnm -guA *.o | grep foo\n\n\n\n\nshows all the modules that refer to foo. If you want to find out what library defines foo, simply use:\n\n\nnm -gA /usr/lib/* | grep foo\n\n\n\n\nThe nm command also understands how to demangle C++ names, which can be handy when mixing C and C++. For example, forgetting to declare a C function with extern\"C\" produces a link time error something like this:\n\n\nundefined reference to `cfunc(char*)'\n\n\n\n\nIn a large project with poorly defined headers, you might have a hard time tracking down the offending module. In this case, you can look for all the unresolved symbols in each object file with demangling turned on as follows:\n\n\nnm -guC *.o\nextern-c.o:cfunc\nno-extern-c.o:cfunc(char*)\n\n\n\n\nThe first module is correct; the second is not.\n\n\nstrings\n\n\nThis command looks for ASCII strings embedded in binary files. It can be used for good or for evil. The good uses include trying to figure out what library is producing that cryptic string on stdout every once in a while, for example:\nstrings -f /usr/lib/lib* | grep \"cryptic message\"\nOn the evil side, the character strings can be used to probe your format strings looking for clues and vulnerabilities. This is why you should never put passwords and logins in your programs. It might be wise to examine your own programs with this tool and see what a clever programmer can see. The version of strings that comes with the GNU binutils has many useful options.\n\n\nod, xxd\n\n\nThese two commands do basically the same thing, but each offers slightly different features. od is used to convert a binary file to whatever format you like. When dealing with programs that generate raw binary files, od can be indispensable. Although the name stands for octal dump, it can dump data in decimal and hexadecimal as well. od dumps integers, IEEE floats or plain bytes. When looking at multibyte integers or floats, the host byte order affects the output.\nxxd also dumps binary files but does not try to interpret them as integers or floats, so the host byte order does not affect the output, which can be confusing or helpful depending on the file. Let's create a four-byte file on an Intel machine:\n\n\n$ echo -n abcd > foo.bin\n$ od -tx4 foo.bin\n0000000 64636261\n0000004\n\n$ xxd -g4 foo.bin\n0000000: 61626364         abcd\n\n\n\n\nThe output of od is a byte-swapped 32-bit integer, and the output of xxd is a group of four bytes in the same byte order as they appear in the file. If you're looking for the string abcd, xxd is the command for you. But, if you're looking for the 32-bit number 0x64636261, od is the right command.\nxxd also knows a few cool tricks that od doesn't, including the ability to format the output in binary and to translate a binary file into a C array. Suppose you have a binary file that you want to encode inside an array in your C program. One way to do this is by creating a text file as follows:\n\n\n$ xxd -i foo.bin\n\nunsigned char foo_bin[] = {\n  0x61, 0x62, 0x63, 0x64\n};\n\nunsigned int foo_bin_len = 4;\n\n\n\n\nfile\n\n\nUNIX and Linux have never enforced any policy of filename extensions. Naming conventions have evolved, but they are guidelines, not policies. If you want to name your digital picture image00.exe, go ahead. Your Linux photo application gladly accepts the file no matter what the name is, although it may be hard to remember.\nThe file command can help when you have to retrieve a file from a brain-dead Web browser, which mangles the name\u2014say a file that should have been named foo.bar.hello.world.tar.gz comes out as foo.bar. The file command can help like this:\n\n\n$ file foo.bar\n\nfoo.bar: gzip compressed data, was \"foo.bar.hello.world.tar\", from Unix\n\n\n\n\nPerhaps you received a distribution with a bin directory full of dozens of files, some of which are executables and some are scripts. Suppose you want to pick out all the shell scripts. Try this:\n\n\n$ file /usr/sbin/*  | grep script\n\n/usr/sbin/makewhatis:  a /bin/bash script text executable\n\n/usr/sbin/xconv.pl:    a /usr/bin/perl script text executable\n\n\n\n\nThe file command identifies all the files in the bin directory, and the grep command filters out everything not a script. Here are some more examples:\n\n\nfile core.4867\n\ncore.4867: ELF 32-bit LSB core file Intel 80386, version 1 (SYSV), SVR4-style, from 'abort'\n\nfile /boot/initrd-2.4.20-6.img\n\n/boot/initrd-2.4.20-6.img: gzip compressed data, from Unix, max compression\n\nfile -z /boot/initrd-2.4.20-6.img\n\n/boot/initrd-2.4.20-6.img: Linux rev 1.0 ext2\nfilesystem data (gzip compressed data, from Unix, max compression)\n\n\n\n\nJust as you shouldn't judge a book by its cover, you shouldn't assume the contents of a file based on its name.\n\n\nobjdump\n\n\nThis is a more advanced tool and is not for the faint of heart. It's sort of a data-mining tool for object files. A treasure trove of information is encoded inside your object code, and this tool lets you see it. One useful thing this tool can do is dump assembly code mixed with source lines, something gcc -S doesn't do for some reason. Your object code must be compiled with debug (-g) for this to work:\n\n\nobjdump --demangle --source myobject.o\n\n\n\n\nobjdump also can help extract binary data from a core file for postmortem debug when you don't have access to a debugger. A complete example is too long for this article, but you need the virtual address from nm or obdump -t. Then, you can dump the file offsets for each virtual address with objdump -x. Finally, objdump is able to read from non-ELF file formats that gdb and other tools can't touch.\nThis article is not intended as a definitive reference but as a starting point to help you become more productive. Each one of these commands is well documented in the Linux man and info pages. Consult them for more information and more ideas.",
            "title": "10 Commands"
        },
        {
            "location": "/Dev/Debug/10_Commands/#ten-commands-every-linux-developer-should-know",
            "text": "This article presents a list of commands you should be able to find on any Linux installation. These are tools to help you improve your code and be more productive. The list comes from my own experience as a programmer and includes tools I've come to rely on repeatedly. Some tools help create code, some help debug code and some help reverse engineer code that's been dumped in your lap.",
            "title": "Ten Commands Every Linux Developer Should Know"
        },
        {
            "location": "/Dev/Debug/10_Commands/#ctags",
            "text": "Those of you addicted to integrated development environments (IDEs) probably never heard of this tool, or if you did you probably think it's obsolete. But a tags-aware editor is a productive programming tool.\nTagging your code allows editors like vi and Emacs to treat your code like hypertext (Figure 1). Each object in your code becomes hyperlinked to its definition. For example, if you are browsing code in vi and want to know where the variable foo was defined, type :ta foo. If your cursor is pointing to the variable, simply use Ctrl-right bracket.  The good news for the vi-impaired is ctags is not only for C and vi anymore. The GNU version of ctags produces tags that can be used with Emacs and many other editors that recognize tag files. In addition, ctags recognizes many languages other than C and C++, including Perl and Python, and even hardware design languages, such as Verilog. It even can produce a human-readable cross-reference that can be useful for understanding code and performing metrics. Even if you're not interested in using ctags in your editor, you might want to check out the human-readable cross-reference by typing:    ctags -x *.c*.  What I like about this tool is that you get useful information whether you input one file or one hundred files, unlike many IDEs that aren't useful unless they can see your entire application. It's not a program checker, so garbage in, garbage out (GIGO) rules apply.",
            "title": "ctags"
        },
        {
            "location": "/Dev/Debug/10_Commands/#strace",
            "text": "strace lets you decipher what's going on when you have no debugger nor the source code. One of my pet peeves is a program that doesn't start and doesn't tell you why. Perhaps a required file is missing or has the wrong permissions. strace can tell you what the program is doing right up to the point where it exits. It can tell you what system calls the program is using and whether they pass or fail. It even can follow forks.  strace often gives me answers much more quickly than a debugger, especially if the code is unfamiliar. On occasion, I have to debug code on a live system with no debugger. A quick run with strace sometimes can avoid patching the system or littering my code with printfs. Here is a trivial example of me as an unprivileged user trying to delete a protected file:  strace -o strace.out rm -f /etc/yp.conf  The output shows where things went wrong:  lstat64(\"/etc/yp.conf\", {st_mode=S_IFREG|0644,st_size=361, ...}) = 0\naccess(\"/etc/yp.conf\", W_OK) = -1 EACCES(Permission denied)\nunlink(\"/etc/yp.conf\") = -1 EACCES (Permission denied)  strace also lets you attach to processes for just-in-time debugging. Suppose a process seems to be spending a lot of time doing nothing. A quick way to find out what is going on is to type:  strace -c -p mypid  After a second or two, press Ctrl-C and you might see a dump something like this:  % time    seconds  usecs/call     calls    errors  syscall\n------ ----------- ----------- --------- --------- ----------------\n 91.31    0.480456        3457       139           poll\n  6.66    0.035025         361        97           write\n  0.91    0.004794          16       304           futex\n  0.52    0.002741          14       203           read\n  0.31    0.001652           3       533           gettimeofday\n  0.26    0.001361           4       374           ioctl\n  0.01    0.000075           8        10           brk\n  0.01    0.000064          64         1           clone\n  0.00    0.000026          26         1           stat64\n  0.00    0.000007           7         1           uname\n  0.00    0.000005           5         1           sched_get_priority_max\n  0.00    0.000002           2         1           sched_get_priority_min\n------ ----------- ----------- --------- --------- ----------------\n100.00    0.526208                  1665           total  In this case, it's spending most of its time in the poll system call\u2014probably waiting on a socket.",
            "title": "strace"
        },
        {
            "location": "/Dev/Debug/10_Commands/#fuser",
            "text": "The name is a mnemonic for file user and tells what processes have opened a given file. It also can send a signal to all those processes for you. Suppose you want to delete a file but can't because some program has it open and won't close it. Instead of rebooting, type fuser -k myfile. This sends a SIGTERM to every process that has myfile opened.\nPerhaps you need to kill a process that forked itself all over the place, intentionally or otherwise. An unenlightened programmer might type something like ps | grep myprogram. This inevitably would be followed by several cut-and-paste operations with the mouse. An easier way is to type fuser -k ./myprogram, where myprogram is the pathname of the executable. fuser typically is located in /sbin, which generally is reserved for system administrative tools. You can add /usr/sbin and /sbin to the end of your $PATH.",
            "title": "fuser"
        },
        {
            "location": "/Dev/Debug/10_Commands/#ps",
            "text": "ps is used to find process status, but many people don't realize it also can be a powerful debugging tool. To get at these features, use the -o option, which lets you access many details of your processes, including CPU usage, virtual memory usage, current state and much more. Many of these options are defined in the POSIX standard, so they work across platforms.\nTo look at your running commands by pid and process state, type ps -e -o pid,state,cmd. The output looks like this:  4576 S /opt/OpenOffice.org1.1.0/program/soffice.bin -writer\n4618 D dd if /dev/cdrom of /dev/null\n4619 S bash\n4645 R ps -e -o pid,state,cmd  Here you can see my dd command is in an uninterruptible sleep (state D). Basically, it is blocking while waiting for /dev/cdrom. My OpenOffice.org writer is sleeping (state S) while I type my example, and my ps command is running (state R).\nFor an idea of how a running program is performing, type:  ps -o start,time,etime -p mypid  This shows the basic output from the time command, discussed later, except you don't have to wait until your program is finished.\nMost of the information that ps produces is available from the  /proc  filesystem, but if you are writing a script, using ps is more portable. You never know when a minor kernel rev will break all of your scripts that are mining the  /proc  filesystem. Use ps instead.",
            "title": "ps"
        },
        {
            "location": "/Dev/Debug/10_Commands/#time",
            "text": "The time command is useful for understanding your code's performance. The most basic output consists of real, user and system time. Intuitively, real time is the amount of time between when the code started and when it exited. User time and system time are the amount of time spent executing application code versus kernel code, respectively.\nTwo flavors of the time command are available. The shell has a built-in version that tells you only scheduler information. A version in /usr/bin includes more information and allows you to format the output. You easily can override the built-in time command by preceding it with a backslash, as in the examples that follow.\nA basic knowledge of the Linux scheduler is helpful in interpreting the output, but this tool also is helpful for learning how the scheduler works. For example, the real time of a process typically is larger than the sum of the user and system time. Time spent blocking in a system call does not count against the process, because the scheduler is free to schedule other processes during this time. The following sleep command takes one second to execute but takes no measurable system or user time:  \\time -p sleep 1\nreal 1.03\nuser 0.00\nsys 0.00  The next example shows how a task can spend all of its time in user space. Here, Perl calls the log() function in a loop, which requires nothing from the kernel:  \\time perl -e 'log(2.0) foreach(0..0x100000)'\nreal 0.40\nuser 0.20\nsys 0.00  This example shows a process using a lot of memory:  \\time perl -e '$x = 'a' x 0x1000000'\n\n0.06user 0.12system 0:00.22elapsed 81%CPU (0avgtext+0avgdata 0maxresident)k\n0inputs+0outputs (309major+8235minor)pagefaults\n0swaps  The useful information here is listed as pagefaults. Although the GNU time command advertises a lot of information, the 2.4 series of the Linux kernel stores only major and minor page-fault information. A major page fault is one that requires I/O; a minor page fault does not.",
            "title": "time"
        },
        {
            "location": "/Dev/Debug/10_Commands/#nm",
            "text": "This command allows you to retrieve information on symbol names inside an object file or executable file. By default, the output gives you a symbol name and its virtual address. What good is that? Suppose you are compiling code and the compiler complains that you have an unresolved symbol _foo. You search all of your source code and cannot find anywhere where you use this symbol. Perhaps it got pulled in from some template or a macro buried in one of the dozens of include files that compiled along with your code. The command:  nm -guA *.o | grep foo  shows all the modules that refer to foo. If you want to find out what library defines foo, simply use:  nm -gA /usr/lib/* | grep foo  The nm command also understands how to demangle C++ names, which can be handy when mixing C and C++. For example, forgetting to declare a C function with extern\"C\" produces a link time error something like this:  undefined reference to `cfunc(char*)'  In a large project with poorly defined headers, you might have a hard time tracking down the offending module. In this case, you can look for all the unresolved symbols in each object file with demangling turned on as follows:  nm -guC *.o\nextern-c.o:cfunc\nno-extern-c.o:cfunc(char*)  The first module is correct; the second is not.",
            "title": "nm"
        },
        {
            "location": "/Dev/Debug/10_Commands/#strings",
            "text": "This command looks for ASCII strings embedded in binary files. It can be used for good or for evil. The good uses include trying to figure out what library is producing that cryptic string on stdout every once in a while, for example:\nstrings -f /usr/lib/lib* | grep \"cryptic message\"\nOn the evil side, the character strings can be used to probe your format strings looking for clues and vulnerabilities. This is why you should never put passwords and logins in your programs. It might be wise to examine your own programs with this tool and see what a clever programmer can see. The version of strings that comes with the GNU binutils has many useful options.",
            "title": "strings"
        },
        {
            "location": "/Dev/Debug/10_Commands/#od-xxd",
            "text": "These two commands do basically the same thing, but each offers slightly different features. od is used to convert a binary file to whatever format you like. When dealing with programs that generate raw binary files, od can be indispensable. Although the name stands for octal dump, it can dump data in decimal and hexadecimal as well. od dumps integers, IEEE floats or plain bytes. When looking at multibyte integers or floats, the host byte order affects the output.\nxxd also dumps binary files but does not try to interpret them as integers or floats, so the host byte order does not affect the output, which can be confusing or helpful depending on the file. Let's create a four-byte file on an Intel machine:  $ echo -n abcd > foo.bin\n$ od -tx4 foo.bin\n0000000 64636261\n0000004\n\n$ xxd -g4 foo.bin\n0000000: 61626364         abcd  The output of od is a byte-swapped 32-bit integer, and the output of xxd is a group of four bytes in the same byte order as they appear in the file. If you're looking for the string abcd, xxd is the command for you. But, if you're looking for the 32-bit number 0x64636261, od is the right command.\nxxd also knows a few cool tricks that od doesn't, including the ability to format the output in binary and to translate a binary file into a C array. Suppose you have a binary file that you want to encode inside an array in your C program. One way to do this is by creating a text file as follows:  $ xxd -i foo.bin\n\nunsigned char foo_bin[] = {\n  0x61, 0x62, 0x63, 0x64\n};\n\nunsigned int foo_bin_len = 4;",
            "title": "od, xxd"
        },
        {
            "location": "/Dev/Debug/10_Commands/#file",
            "text": "UNIX and Linux have never enforced any policy of filename extensions. Naming conventions have evolved, but they are guidelines, not policies. If you want to name your digital picture image00.exe, go ahead. Your Linux photo application gladly accepts the file no matter what the name is, although it may be hard to remember.\nThe file command can help when you have to retrieve a file from a brain-dead Web browser, which mangles the name\u2014say a file that should have been named foo.bar.hello.world.tar.gz comes out as foo.bar. The file command can help like this:  $ file foo.bar\n\nfoo.bar: gzip compressed data, was \"foo.bar.hello.world.tar\", from Unix  Perhaps you received a distribution with a bin directory full of dozens of files, some of which are executables and some are scripts. Suppose you want to pick out all the shell scripts. Try this:  $ file /usr/sbin/*  | grep script\n\n/usr/sbin/makewhatis:  a /bin/bash script text executable\n\n/usr/sbin/xconv.pl:    a /usr/bin/perl script text executable  The file command identifies all the files in the bin directory, and the grep command filters out everything not a script. Here are some more examples:  file core.4867\n\ncore.4867: ELF 32-bit LSB core file Intel 80386, version 1 (SYSV), SVR4-style, from 'abort'\n\nfile /boot/initrd-2.4.20-6.img\n\n/boot/initrd-2.4.20-6.img: gzip compressed data, from Unix, max compression\n\nfile -z /boot/initrd-2.4.20-6.img\n\n/boot/initrd-2.4.20-6.img: Linux rev 1.0 ext2\nfilesystem data (gzip compressed data, from Unix, max compression)  Just as you shouldn't judge a book by its cover, you shouldn't assume the contents of a file based on its name.",
            "title": "file"
        },
        {
            "location": "/Dev/Debug/10_Commands/#objdump",
            "text": "This is a more advanced tool and is not for the faint of heart. It's sort of a data-mining tool for object files. A treasure trove of information is encoded inside your object code, and this tool lets you see it. One useful thing this tool can do is dump assembly code mixed with source lines, something gcc -S doesn't do for some reason. Your object code must be compiled with debug (-g) for this to work:  objdump --demangle --source myobject.o  objdump also can help extract binary data from a core file for postmortem debug when you don't have access to a debugger. A complete example is too long for this article, but you need the virtual address from nm or obdump -t. Then, you can dump the file offsets for each virtual address with objdump -x. Finally, objdump is able to read from non-ELF file formats that gdb and other tools can't touch.\nThis article is not intended as a definitive reference but as a starting point to help you become more productive. Each one of these commands is well documented in the Linux man and info pages. Consult them for more information and more ideas.",
            "title": "objdump"
        },
        {
            "location": "/Dev/Debug/Core_Dumps/",
            "text": "Setup core dumps\n\n\n# Set core pattern to get files named like: core-bash-sig11-user0-group0-pid28808-time1481235929\necho \"core-%e-sig%s-user%u-group%g-pid%p-time%t\" > /proc/sys/kernel/core_pattern\n\n# Set limits for all users:\nvim /etc/security/limits.d/core.conf\n# --- contents ---\n*       hard        core        unlimited\n*       soft        core        unlimited\n# ----------------\n\n# (Optional) Enable DefaultCoreLimits for all systemd services:\nvim /etc/systemd/system.conf\n# Uncoment DefaultLimitCORE and set it to infinity:\nDefaultLimitCORE=infinity\n# Reload systemd\nsystemctl daemon-reexec\n\n# (Optional) Update only that service that you intersted in:\nvim /etc/systemd/system/service-you-intersted-in.service\n# --- Add following in [Service] section ---\nLimitCORE=infinity\n# ------------------------------------------\n# Restart your service:\nsystemctl stop service-you-intersted-in\nsystemctl start service-you-intersted-in\n\n# And don't forget to disable core dumping when you don't need dumps any more",
            "title": "Core Dumps"
        },
        {
            "location": "/Dev/Debug/Core_Dumps/#setup-core-dumps",
            "text": "# Set core pattern to get files named like: core-bash-sig11-user0-group0-pid28808-time1481235929\necho \"core-%e-sig%s-user%u-group%g-pid%p-time%t\" > /proc/sys/kernel/core_pattern\n\n# Set limits for all users:\nvim /etc/security/limits.d/core.conf\n# --- contents ---\n*       hard        core        unlimited\n*       soft        core        unlimited\n# ----------------\n\n# (Optional) Enable DefaultCoreLimits for all systemd services:\nvim /etc/systemd/system.conf\n# Uncoment DefaultLimitCORE and set it to infinity:\nDefaultLimitCORE=infinity\n# Reload systemd\nsystemctl daemon-reexec\n\n# (Optional) Update only that service that you intersted in:\nvim /etc/systemd/system/service-you-intersted-in.service\n# --- Add following in [Service] section ---\nLimitCORE=infinity\n# ------------------------------------------\n# Restart your service:\nsystemctl stop service-you-intersted-in\nsystemctl start service-you-intersted-in\n\n# And don't forget to disable core dumping when you don't need dumps any more",
            "title": "Setup core dumps"
        },
        {
            "location": "/Dev/Debug/GDB/",
            "text": "Analyse core dumps\n\n\n# run debugger with exe-you-intersted-in\ngdb <executable>\n\n# load core core dump\n(gdb) core <core_dump_file>\n\n# use common gdb commands like:\nbacktrace",
            "title": "GDB"
        },
        {
            "location": "/Dev/Debug/GDB/#analyse-core-dumps",
            "text": "# run debugger with exe-you-intersted-in\ngdb <executable>\n\n# load core core dump\n(gdb) core <core_dump_file>\n\n# use common gdb commands like:\nbacktrace",
            "title": "Analyse core dumps"
        },
        {
            "location": "/Dev/Hardware/GPU/",
            "text": "How to calc max resolution to MB\n\n\nA graphics card actually requires relatively little memory to function as a simple framebuffer (2D graphics) device:\n\n\nFor example - the framebuffer requirements for 1920x1080 in 32 bit colour would be:\n\n\n    1920 x 1080 = 2073600 pixels\n    2073600 x 32 = 66355200 bits\n    66355200 / 8 = 8294400 bytes\n    8294400 / 1024 = 8100 kilobytes\n    8100 / 1024 = 7.91015625 megabytes\n\n\n\n\nSo even at that high resolution an 8MB card would be able to display an image.\n\n\nYou can double, or even triple that amount if you are using double or triple buffering (display one image while rendering another then switch to that new image while you render a third, etc).\n\n\nAll the rest of the memory is used when the card is working with 3D graphics to store internal copies (and transformed copies) of textures for rendering. The more memory you have the more and higher resolution textures the card can hold internally, so it won't need to be repeatedly sent the same textures over and over again by the gaming engine.\n\n\nSo basically the more memory you have the better it will be for 3D gaming.\n\n\nUHD 8K\n\n\n7680 \u00d7 4320 = 33177600 px\n33177600 x 48 = 1592524800 bits\n1592524800 / 8 = 199065600 byte\n199065600 / 1024 = 194400 KB\n194400 / 1024 = 189,84375 MB",
            "title": "GPU"
        },
        {
            "location": "/Dev/Hardware/GPU/#how-to-calc-max-resolution-to-mb",
            "text": "A graphics card actually requires relatively little memory to function as a simple framebuffer (2D graphics) device:  For example - the framebuffer requirements for 1920x1080 in 32 bit colour would be:      1920 x 1080 = 2073600 pixels\n    2073600 x 32 = 66355200 bits\n    66355200 / 8 = 8294400 bytes\n    8294400 / 1024 = 8100 kilobytes\n    8100 / 1024 = 7.91015625 megabytes  So even at that high resolution an 8MB card would be able to display an image.  You can double, or even triple that amount if you are using double or triple buffering (display one image while rendering another then switch to that new image while you render a third, etc).  All the rest of the memory is used when the card is working with 3D graphics to store internal copies (and transformed copies) of textures for rendering. The more memory you have the more and higher resolution textures the card can hold internally, so it won't need to be repeatedly sent the same textures over and over again by the gaming engine.  So basically the more memory you have the better it will be for 3D gaming.",
            "title": "How to calc max resolution to MB"
        },
        {
            "location": "/Dev/Hardware/GPU/#uhd-8k",
            "text": "7680 \u00d7 4320 = 33177600 px\n33177600 x 48 = 1592524800 bits\n1592524800 / 8 = 199065600 byte\n199065600 / 1024 = 194400 KB\n194400 / 1024 = 189,84375 MB",
            "title": "UHD 8K"
        },
        {
            "location": "/Dev/Hardware/IP_Packet_Example/",
            "text": "IP Packet Example\n\n\n    0x0000:  0050 5684 0731 0013 19ff 1343 0800 4500  .PV..1.....C..E.\n    0x0010:  0034 448b 4000 7f06 8d9a 0a0a 0a83 0a0a  .4D.@...........\n    0x0020:  0b08 d7ec 0050 57bb 1851 0000 0000 8002  .....PW..Q......\n    0x0030:  2000 dd28 0000 0204 05b4 0103 0308 0101  ...(............\n    0x0040:  0402\n\n0x0000:\n0050 5684 0731 - Destination MAC-address 00:50:56:84:07:31\n0013 19ff 1343 - Source MAC-address 00:13:19:ff:13:43\n0800 - Type (0x0800 - IP)\n4500 - IP version, IHL (IP Header Length), Type of service\n0x0010:\n0034 - Packet Length 52\n448b - Packet ID 17547\n4000 - Flag DF (Don't fragment) \u0438 Fregment Offset\n7f06 - TTL and protocol (127 \u0438 6)\n8d9a - Header checksum\n0a0a 0a83 - Source IP 10.10.10.131\n0x0020 - '0000':\n0a0a 0b08 - Destination IP 10.10.11.8\nd7ec - Source port 55276\n0050 - Destination port 80\n57bb 1851 - Queue number 1471879249\n0000 0000 - Answer number ACK, \u0442\u0443\u0442 0\n8002 - \u0422\u0421\u0420 Header Length, message type (here: SYN)\n0x0030:\n2000 - Window 8192\ndd28 - CheckSUM\n0000 - Urgent pointer\n0204 - TCP Options: MSS (max segment size option)\n05b4 - TCP Options: MSS (max segment size = 1460)\n0103 - TCP Options: nop\n0308 - TCP Options: Window Scale 8\n0101 - TCP Options: nop, nop\n0x0040:\n0402 - TCP Options: SackOK",
            "title": "IP Packet Example"
        },
        {
            "location": "/Dev/Hardware/IP_Packet_Example/#ip-packet-example",
            "text": "0x0000:  0050 5684 0731 0013 19ff 1343 0800 4500  .PV..1.....C..E.\n    0x0010:  0034 448b 4000 7f06 8d9a 0a0a 0a83 0a0a  .4D.@...........\n    0x0020:  0b08 d7ec 0050 57bb 1851 0000 0000 8002  .....PW..Q......\n    0x0030:  2000 dd28 0000 0204 05b4 0103 0308 0101  ...(............\n    0x0040:  0402\n\n0x0000:\n0050 5684 0731 - Destination MAC-address 00:50:56:84:07:31\n0013 19ff 1343 - Source MAC-address 00:13:19:ff:13:43\n0800 - Type (0x0800 - IP)\n4500 - IP version, IHL (IP Header Length), Type of service\n0x0010:\n0034 - Packet Length 52\n448b - Packet ID 17547\n4000 - Flag DF (Don't fragment) \u0438 Fregment Offset\n7f06 - TTL and protocol (127 \u0438 6)\n8d9a - Header checksum\n0a0a 0a83 - Source IP 10.10.10.131\n0x0020 - '0000':\n0a0a 0b08 - Destination IP 10.10.11.8\nd7ec - Source port 55276\n0050 - Destination port 80\n57bb 1851 - Queue number 1471879249\n0000 0000 - Answer number ACK, \u0442\u0443\u0442 0\n8002 - \u0422\u0421\u0420 Header Length, message type (here: SYN)\n0x0030:\n2000 - Window 8192\ndd28 - CheckSUM\n0000 - Urgent pointer\n0204 - TCP Options: MSS (max segment size option)\n05b4 - TCP Options: MSS (max segment size = 1460)\n0103 - TCP Options: nop\n0308 - TCP Options: Window Scale 8\n0101 - TCP Options: nop, nop\n0x0040:\n0402 - TCP Options: SackOK",
            "title": "IP Packet Example"
        },
        {
            "location": "/Dev/Hardware/Latency_Numbers/",
            "text": "Latency Numbers Every Programmer Should Know\n\n\n\n\nLatency Numbers Every Programmer Should Know\n\n\n\n\n# From Jonas Bon\u00e9r\nLatency Comparison Numbers\n--------------------------\nL1 cache reference                           0.5 ns\nBranch mispredict                            5   ns\nL2 cache reference                           7   ns                      14x L1 cache\nMutex lock/unlock                           25   ns\nMain memory reference                      100   ns                      20x L2 cache, 200x L1 cache\nCompress 1K bytes with Zippy             3,000   ns        3 us\nSend 1K bytes over 1 Gbps network       10,000   ns       10 us\nRead 4K randomly from SSD*             150,000   ns      150 us          ~1GB/sec SSD\nRead 1 MB sequentially from memory     250,000   ns      250 us\nRound trip within same datacenter      500,000   ns      500 us\nRead 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory\nDisk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip\nRead 1 MB sequentially from disk    20,000,000   ns   20,000 us   20 ms  80x memory, 20X SSD\nSend packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms\n\nNotes\n-----\n1 ns = 10^-9 seconds\n1 us = 10^-6 seconds = 1,000 ns\n1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns",
            "title": "Latency Numbers"
        },
        {
            "location": "/Dev/Hardware/Latency_Numbers/#latency-numbers-every-programmer-should-know",
            "text": "Latency Numbers Every Programmer Should Know   # From Jonas Bon\u00e9r\nLatency Comparison Numbers\n--------------------------\nL1 cache reference                           0.5 ns\nBranch mispredict                            5   ns\nL2 cache reference                           7   ns                      14x L1 cache\nMutex lock/unlock                           25   ns\nMain memory reference                      100   ns                      20x L2 cache, 200x L1 cache\nCompress 1K bytes with Zippy             3,000   ns        3 us\nSend 1K bytes over 1 Gbps network       10,000   ns       10 us\nRead 4K randomly from SSD*             150,000   ns      150 us          ~1GB/sec SSD\nRead 1 MB sequentially from memory     250,000   ns      250 us\nRound trip within same datacenter      500,000   ns      500 us\nRead 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory\nDisk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip\nRead 1 MB sequentially from disk    20,000,000   ns   20,000 us   20 ms  80x memory, 20X SSD\nSend packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms\n\nNotes\n-----\n1 ns = 10^-9 seconds\n1 us = 10^-6 seconds = 1,000 ns\n1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns",
            "title": "Latency Numbers Every Programmer Should Know"
        },
        {
            "location": "/Dev/Hardware/Networks/",
            "text": "RFC1878\n\n\nFull Table\n\n\n   The following table lists the variable length subnets from 1 to 32,\n   the CIDR [3] representation form (/xx) and the Decmial equivalents.\n   (M = Million, K=Thousand, A,B,C= traditional class values)\n\n   Mask value:                             # of\n   Hex            CIDR   Decimal           addresses  Classfull\n   80.00.00.00    /1     128.0.0.0         2048 M     128 A\n   C0.00.00.00    /2     192.0.0.0         1024 M      64 A\n   E0.00.00.00    /3     224.0.0.0          512 M      32 A\n   F0.00.00.00    /4     240.0.0.0          256 M      16 A\n   F8.00.00.00    /5     248.0.0.0          128 M       8 A\n   FC.00.00.00    /6     252.0.0.0           64 M       4 A\n   FE.00.00.00    /7     254.0.0.0           32 M       2 A\n   FF.00.00.00    /8     255.0.0.0           16 M       1 A\n   FF.80.00.00    /9     255.128.0.0          8 M     128 B\n   FF.C0.00.00   /10     255.192.0.0          4 M      64 B\n   FF.E0.00.00   /11     255.224.0.0          2 M      32 B\n   FF.F0.00.00   /12     255.240.0.0       1024 K      16 B\n   FF.F8.00.00   /13     255.248.0.0        512 K       8 B\n   FF.FC.00.00   /14     255.252.0.0        256 K       4 B\n   FF.FE.00.00   /15     255.254.0.0        128 K       2 B\n   FF.FF.00.00   /16     255.255.0.0         64 K       1 B\n   FF.FF.80.00   /17     255.255.128.0       32 K     128 C\n   FF.FF.C0.00   /18     255.255.192.0       16 K      64 C\n   FF.FF.E0.00   /19     255.255.224.0        8 K      32 C\n   FF.FF.F0.00   /20     255.255.240.0        4 K      16 C\n   FF.FF.F8.00   /21     255.255.248.0        2 K       8 C\n   FF.FF.FC.00   /22     255.255.252.0        1 K       4 C\n   FF.FF.FE.00   /23     255.255.254.0      512         2 C\n   FF.FF.FF.00   /24     255.255.255.0      256         1 C\n   FF.FF.FF.80   /25     255.255.255.128    128       1/2 C\n   FF.FF.FF.C0   /26     255.255.255.192     64       1/4 C\n   FF.FF.FF.E0   /27     255.255.255.224     32       1/8 C\n   FF.FF.FF.F0   /28     255.255.255.240     16      1/16 C\n   FF.FF.FF.F8   /29     255.255.255.248      8      1/32 C\n   FF.FF.FF.FC   /30     255.255.255.252      4      1/64 C\n   FF.FF.FF.FE   /31     255.255.255.254      2     1/128 C\n   FF.FF.FF.FF   /32     255.255.255.255   This is a single host route\n\n\n\n\nSubnets and Networks\n\n\n\n\nThe number of available network and host addresses are derived from the number of bits used for subnet masking.  The tables below depict the number of subnetting bits and the resulting network, broadcast address, and host addresses.  Please note that all-zeros and all-ones subnets are included in Tables 1-1 and 1-2 per the current, standards- based practice for using all definable subnets.\n\n\n\n\nTable 1-1 Class B\n\n\nSubnet Mask     # of nets    Net. Addr.  Host Addr Range  Brodcast Addr.\nBits of Subnet  hosts/subnet\n\n255.255.128.0   2 nets        N.N.0.0     N.N.0-127.N      N.N.127.255\n1 bit subnet    32766         N.N.128.0   N.N.128-254.N    N.N.254.255\n\n255.255.192.0   4 nets        N.N.0.0     N.N.0-63.N       N.N.63.255\n2 bit subnet    16382         N.N.64.0    N.N.64-127.N     N.N.127.255\n                              N.N.128.0   N.N.128-191.N    N.N.191.255\n                              N.N.192.0   N.N.192-254.N    N.N.254.255\n\n255.255.224.0   8 nets        N.N.0.0     N.N.0-31.N       N.N.31.255\n3 bit subnet    8190          N.N.32.0    N.N.32-63.N      N.N.63.255\n                              N.N.64.0    N.N.64-95.N      N.N.95.255\n                              N.N.96.0    N.N.96-127.N     N.N.127.255\n                              N.N.128.0   N.N.128-159.N    N.N.159.255\n                              N.N.160.0   N.N.160-191.N    N.N.191.255\n                              N.N.192.0   N.N.192-223.N    N.N.223.255\n                              N.N.224.0   N.N.224-254.N    N.N.254.255\n\n255.255.240.0   16 nets       N.N.0.0     N.N.0-15.N       N.N.15.255\n4 bit subnet    4094          N.N.16.0    N.N.16-31.N      N.N.31.255\n                              N.N.32.0    N.N.32-47.N      N.N.47.255\n                              N.N.48.0    N.N.48-63.N      N.N.63.255\n                              N.N.64.0    N.N.64-79.N      N.N.79.255\n                              N.N.80.0    N.N.80-95.N      N.N.95.255\n                              N.N.96.0    N.N.96-111.N     N.N.111.255\n                              N.N.112.0   N.N.112-127.N    N.N.127.255\n                              N.N.128.0   N.N.128-143.N    N.N.143.255\n                              N.N.144.0   N.N.144-159.N    N.N.159.255\n                              N.N.160.0   N.N.160-175.N    N.N.175.255\n                              N.N.176.0   N.N.176-191.N    N.N.191.255\n                              N.N.192.0   N.N.192-207.N    N.N.207.255\n                              N.N.208.0   N.N.208-223.N    N.N.223.255\n                              N.N.224.0   N.N.224-239.N    N.N.239.255\n                              N.N.240.0   N.N.240-254.N    N.N.254.255\n\n255.255.248.0   32 nets       N.N.0.0     N.N.0-7.N        N.N.7.255\n5 bit subnet    2046          N.N.8.0     N.N.8-15.N       N.N.15.255\n                              N.N.16.0    N.N.16-23.N      N.N.23.255\n                              N.N.24.0    N.N.24-31.N      N.N.31.255\n                              N.N.32.0    N.N.32-39.N      N.N.39.255\n                              N.N.40.0    N.N.40-47.N      N.N.47.255\n                              N.N.48.0    N.N.48-55.N      N.N.55.255\n                              N.N.56.0    N.N.56-63.N      N.N.63.255\n                              N.N.64.0    N.N.64-71.N      N.N.71.255\n                              N.N.72.0    N.N.72-79.N      N.N.79.255\n                              N.N.80.0    N.N.80-87.N      N.N.87.255\n                              N.N.88.0    N.N.88-95.N      N.N.95.255\n                              N.N.96.0    N.N.96-103.N     N.N.103.255\n                              N.N.104.0   N.N.104-111.N    N.N.111.255\n                              N.N.112.0   N.N.112-119.N    N.N.119.255\n                              N.N.120.0   N.N.120-127.N    N.N.127.255\n                              N.N.128.0   N.N.128-135.N    N.N.135.255\n                              N.N.136.0   N.N.136-143.N    N.N.143.255\n                              N.N.144.0   N.N.144-151.N    N.N.151.255\n                              N.N.152.0   N.N.152-159.N    N.N.159.255\n                              N.N.160.0   N.N.160-167.N    N.N.167.255\n                              N.N.168.0   N.N.168-175.N    N.N.175.255\n                              N.N.176.0   N.N.176-183.N    N.N.183.255\n                              N.N.184.0   N.N.184-191.N    N.N.191.255\n                              N.N.192.0   N.N.192-199.N    N.N.199.255\n                              N.N.200.0   N.N.200-207.N    N.N.207.255\n                              N.N.208.0   N.N.208-215.N    N.N.215.255\n                              N.N.216.0   N.N.216-223.N    N.N.223.255\n                              N.N.224.0   N.N.224-231.N    N.N.231.255\n                              N.N.232.0   N.N.232-239.N    N.N.239.255\n                              N.N.240.0   N.N.240-247.N    N.N.247.255\n                              N.N.248.0   N.N.248-254.N    N.N.254.255\n\n255.255.252.0   64 nets       N.N.0.0     N.N.0-3.N        N.N.3.255\n6 bit subnet    1022          N.N.4.0     N.N.4-7.N        N.N.7.255\n                              N.N.8.0     N.N.8-11.N       N.N.11.255\n                              N.N.12.0    N.N.12-15.N      N.N.15.255\n                              N.N.240.0   N.N.240-243.N    N.N.243.255\n                              N.N.244.0   N.N.244-247.N    N.N.247.255\n                              N.N.248.0   N.N.248-251.N    N.N.251.255\n                              N.N.252.0   N.N.252-254.N    N.N.254.255\n\n\n255.255.254.0   128 nets      N.N.0.0     N.N.0-1.N        N.N.1.255\n7 bit subnet    510           N.N.2.0     N.N.2-3.N        N.N.3.255\n                              N.N.4.0     N.N.4-5.N        N.N.5.255\n                              N.N.250.0   N.N.250-251.N    N.N.251.255\n                              N.N.252.0   N.N.252-253.N    N.N.253.255\n                              N.N.254.0   N.N.254.N        N.N.254.255\n\n255.255.255.0   255 nets      N.N.0.0     N.N.0.N          N.N.0.255\n8 bit subnet    253           N.N.1.0     N.N.1.N          N.N.1.255\n                              N.N.252.0   N.N.252.N        N.N.252.255\n                              N.N.253.0   N.N.253.N        N.N.253.255\n                              N.N.254.0   N.N.254.N        N.N.254.255\n\n\n\n\nTable 1-2 Class C\n\n\nSubnet Mask     # of nets    Net. Addr.  Host Addr Range  Brodcast Addr.\nBits of Subnet  hosts/subnet\n\n255.255.255.128 2 nets       N.N.N.0     N.N.N.1-126      N.N.N.127\n1 bit Class C   126          N.N.N.128   N.N.N.129-254    N.N.N.255\n9 bit Class B\n\n\n\n255.255.255.192 4 nets       N.N.N.0     N.N.N.1-62       N.N.N.63\n2 bit Class C   62           N.N.N.64    N.N.N.65-126     N.N.N.127\n10 bit Class B               N.N.N.128   N.N.N.129-190    N.N.N.191\n                             N.N.N.192   N.N.N.193-254    N.N.N.255\n\n255.255.255.224 8 nets       N.N.N.0     N.N.N.1-30       N.N.N.31\n3 bit Class C   30           N.N.N.32    N.N.N.33-62      N.N.N.63\n11 bit Class B               N.N.N.64    N.N.N.65-94      N.N.N.95\n                             N.N.N.96    N.N.N.97-126     N.N.N.127\n                             N.N.N.128   N.N.N.129-158    N.N.N.159\n                             N.N.N.160   N.N.N.161-190    N.N.N.191\n                             N.N.N.192   N.N.N.193-222    N.N.N.223\n                             N.N.N.224   N.N.N.225-254    N.N.N.255\n\n255.255.255.240 16 nets      N.N.N.0     N.N.N.1-14       N.N.N.15\n4 bit Class C   14           N.N.N.16    N.N.N.17-30      N.N.N.31\n12 bit Class B               N.N.N.32    N.N.N.33-46      N.N.N.47\n                             N.N.N.48    N.N.N.49-62      N.N.N.63\n                             N.N.N.64    N.N.N.65-78      N.N.N.79\n                             N.N.N.80    N.N.N.81-94      N.N.N.95\n                             N.N.N.96    N.N.N.97-110     N.N.N.111\n                             N.N.N.112   N.N.N.113-126    N.N.N.127\n                             N.N.N.128   N.N.N.129-142    N.N.N.143\n                             N.N.N.144   N.N.N.145-158    N.N.N.159\n                             N.N.N.160   N.N.N.161-174    N.N.N.175\n                             N.N.N.176   N.N.N.177-190    N.N.N.191\n                             N.N.N.192   N.N.N.193-206    N.N.N.207\n                             N.N.N.208   N.N.N.209-222    N.N.N.223\n                             N.N.N.224   N.N.N.225-238    N.N.N.239\n                             N.N.N.240   N.N.N.241-254    N.N.N.255\n\n255.255.255.248 32 nets      N.N.N.0     N.N.N.1-6        N.N.N.7\n5 bit Class C   6            N.N.N.8     N.N.N.9-14       N.N.N.15\n13 bit Class B               N.N.N.16    N.N.N.17-22      N.N.N.23\n                             N.N.N.24    N.N.N.25-30      N.N.N.31\n                             N.N.N.32    N.N.N.33-38      N.N.N.39\n                             N.N.N.40    N.N.N.41-46      N.N.N.47\n                             N.N.N.48    N.N.N.49-54      N.N.N.55\n                             N.N.N.56    N.N.N.57-62      N.N.N.63\n                             N.N.N.64    N.N.N.65-70      N.N.N.71\n                             N.N.N.72    N.N.N.73-78      N.N.N.79\n                             N.N.N.80    N.N.N.81-86      N.N.N.87\n                             N.N.N.88    N.N.N.89-94      N.N.N.95\n                             N.N.N.96    N.N.N.97-102     N.N.N.103\n                             N.N.N.104   N.N.N.105-110    N.N.N.111\n                             N.N.N.112   N.N.N.113-118    N.N.N.119\n                             N.N.N.120   N.N.N.121-126    N.N.N.127\n                             N.N.N.128   N.N.N.129-134    N.N.N.135\n                             N.N.N.136   N.N.N.137-142    N.N.N.143\n                             N.N.N.144   N.N.N.145-150    N.N.N.151\n                             N.N.N.152   N.N.N.153-158    N.N.N.159\n                             N.N.N.160   N.N.N.161-166    N.N.N.167\n                             N.N.N.168   N.N.N.169-174    N.N.N.175\n                             N.N.N.176   N.N.N.177-182    N.N.N.183\n                             N.N.N.184   N.N.N.185-190    N.N.N.191\n                             N.N.N.192   N.N.N.193-198    N.N.N.199\n                             N.N.N.200   N.N.N.201-206    N.N.N.207\n                             N.N.N.208   N.N.N.209-214    N.N.N.215\n                             N.N.N.216   N.N.N.217-222    N.N.N.223\n                             N.N.N.224   N.N.N.225-230    N.N.N.231\n                             N.N.N.232   N.N.N.233-238    N.N.N.239\n                             N.N.N.240   N.N.N.241-246    N.N.N.247\n                             N.N.N.248   N.N.N.249-254    N.N.N.255\n\n255.255.255.252 64 nets      N.N.N.0     N.N.N.1-2        N.N.N.3\n6 bit Class C   2            N.N.N.4     N.N.N.5-6        N.N.N.7\n14 bit Class B               N.N.N.8     N.N.N.9-10       N.N.N.11\n                             N.N.N.244   N.N.N.245-246    N.N.N.247\n                             N.N.N.248   N.N.N.249-250    N.N.N.251\n                             N.N.N.252   N.N.N.253-254    N.N.N.255\n\n\n\n\n\n\nFor the sake of completeness within this memo, tables 2-1 and 2-2 illistrate some options for subnet/host partions within selected block sizes using calculations which exclude all-zeros and all-ones subnets.  Many vendors only support subnetting based upon this premise.  This practice is obsolete!  Modern software will be able to utilize all definable networks.\n\n\n\n\nTable 2-1 from a /16 block\n\n\n# bits          Mask            Effective Subnets       Effective Hosts\n========        =====           =================       ===============\n2               255.255.192.0   2                       16382\n3               255.255.224.0   6                       8190\n4               255.255.240.0   14                      4094\n5               255.255.248.0   30                      2046\n6               255.255.252.0   62                      1022\n7               255.255.254.0   126                     510\n8               255.255.255.0   254                     254\n9               255.255.255.128 510                     126\n10              255.255.255.192 1022                    62\n11              255.255.255.224 2046                    30\n12              255.255.255.240 4094                    14\n13              255.255.255.248 8190                    6\n14              255.255.255.252 16382                   2\n\n\n\n\nTable 2-2 from a /24 block\n\n\n# bits          Mask            Effective Subnets       Effective Hosts\n========        =====           =================       ===============\n2               255.255.255.192 2                       62\n3               255.255.255.224 6                       30\n4               255.255.255.240 14                      14\n5               255.255.255.248 30                      6\n6               255.255.255.252 62                      2\n\n*Subnet all zeroes and all ones excluded. (Obsolete)\n*Host all zeroes and all ones excluded.   (Obsolete)",
            "title": "Networks"
        },
        {
            "location": "/Dev/Hardware/Networks/#rfc1878",
            "text": "",
            "title": "RFC1878"
        },
        {
            "location": "/Dev/Hardware/Networks/#full-table",
            "text": "The following table lists the variable length subnets from 1 to 32,\n   the CIDR [3] representation form (/xx) and the Decmial equivalents.\n   (M = Million, K=Thousand, A,B,C= traditional class values)\n\n   Mask value:                             # of\n   Hex            CIDR   Decimal           addresses  Classfull\n   80.00.00.00    /1     128.0.0.0         2048 M     128 A\n   C0.00.00.00    /2     192.0.0.0         1024 M      64 A\n   E0.00.00.00    /3     224.0.0.0          512 M      32 A\n   F0.00.00.00    /4     240.0.0.0          256 M      16 A\n   F8.00.00.00    /5     248.0.0.0          128 M       8 A\n   FC.00.00.00    /6     252.0.0.0           64 M       4 A\n   FE.00.00.00    /7     254.0.0.0           32 M       2 A\n   FF.00.00.00    /8     255.0.0.0           16 M       1 A\n   FF.80.00.00    /9     255.128.0.0          8 M     128 B\n   FF.C0.00.00   /10     255.192.0.0          4 M      64 B\n   FF.E0.00.00   /11     255.224.0.0          2 M      32 B\n   FF.F0.00.00   /12     255.240.0.0       1024 K      16 B\n   FF.F8.00.00   /13     255.248.0.0        512 K       8 B\n   FF.FC.00.00   /14     255.252.0.0        256 K       4 B\n   FF.FE.00.00   /15     255.254.0.0        128 K       2 B\n   FF.FF.00.00   /16     255.255.0.0         64 K       1 B\n   FF.FF.80.00   /17     255.255.128.0       32 K     128 C\n   FF.FF.C0.00   /18     255.255.192.0       16 K      64 C\n   FF.FF.E0.00   /19     255.255.224.0        8 K      32 C\n   FF.FF.F0.00   /20     255.255.240.0        4 K      16 C\n   FF.FF.F8.00   /21     255.255.248.0        2 K       8 C\n   FF.FF.FC.00   /22     255.255.252.0        1 K       4 C\n   FF.FF.FE.00   /23     255.255.254.0      512         2 C\n   FF.FF.FF.00   /24     255.255.255.0      256         1 C\n   FF.FF.FF.80   /25     255.255.255.128    128       1/2 C\n   FF.FF.FF.C0   /26     255.255.255.192     64       1/4 C\n   FF.FF.FF.E0   /27     255.255.255.224     32       1/8 C\n   FF.FF.FF.F0   /28     255.255.255.240     16      1/16 C\n   FF.FF.FF.F8   /29     255.255.255.248      8      1/32 C\n   FF.FF.FF.FC   /30     255.255.255.252      4      1/64 C\n   FF.FF.FF.FE   /31     255.255.255.254      2     1/128 C\n   FF.FF.FF.FF   /32     255.255.255.255   This is a single host route",
            "title": "Full Table"
        },
        {
            "location": "/Dev/Hardware/Networks/#subnets-and-networks",
            "text": "The number of available network and host addresses are derived from the number of bits used for subnet masking.  The tables below depict the number of subnetting bits and the resulting network, broadcast address, and host addresses.  Please note that all-zeros and all-ones subnets are included in Tables 1-1 and 1-2 per the current, standards- based practice for using all definable subnets.",
            "title": "Subnets and Networks"
        },
        {
            "location": "/Dev/Hardware/Networks/#table-1-1-class-b",
            "text": "Subnet Mask     # of nets    Net. Addr.  Host Addr Range  Brodcast Addr.\nBits of Subnet  hosts/subnet\n\n255.255.128.0   2 nets        N.N.0.0     N.N.0-127.N      N.N.127.255\n1 bit subnet    32766         N.N.128.0   N.N.128-254.N    N.N.254.255\n\n255.255.192.0   4 nets        N.N.0.0     N.N.0-63.N       N.N.63.255\n2 bit subnet    16382         N.N.64.0    N.N.64-127.N     N.N.127.255\n                              N.N.128.0   N.N.128-191.N    N.N.191.255\n                              N.N.192.0   N.N.192-254.N    N.N.254.255\n\n255.255.224.0   8 nets        N.N.0.0     N.N.0-31.N       N.N.31.255\n3 bit subnet    8190          N.N.32.0    N.N.32-63.N      N.N.63.255\n                              N.N.64.0    N.N.64-95.N      N.N.95.255\n                              N.N.96.0    N.N.96-127.N     N.N.127.255\n                              N.N.128.0   N.N.128-159.N    N.N.159.255\n                              N.N.160.0   N.N.160-191.N    N.N.191.255\n                              N.N.192.0   N.N.192-223.N    N.N.223.255\n                              N.N.224.0   N.N.224-254.N    N.N.254.255\n\n255.255.240.0   16 nets       N.N.0.0     N.N.0-15.N       N.N.15.255\n4 bit subnet    4094          N.N.16.0    N.N.16-31.N      N.N.31.255\n                              N.N.32.0    N.N.32-47.N      N.N.47.255\n                              N.N.48.0    N.N.48-63.N      N.N.63.255\n                              N.N.64.0    N.N.64-79.N      N.N.79.255\n                              N.N.80.0    N.N.80-95.N      N.N.95.255\n                              N.N.96.0    N.N.96-111.N     N.N.111.255\n                              N.N.112.0   N.N.112-127.N    N.N.127.255\n                              N.N.128.0   N.N.128-143.N    N.N.143.255\n                              N.N.144.0   N.N.144-159.N    N.N.159.255\n                              N.N.160.0   N.N.160-175.N    N.N.175.255\n                              N.N.176.0   N.N.176-191.N    N.N.191.255\n                              N.N.192.0   N.N.192-207.N    N.N.207.255\n                              N.N.208.0   N.N.208-223.N    N.N.223.255\n                              N.N.224.0   N.N.224-239.N    N.N.239.255\n                              N.N.240.0   N.N.240-254.N    N.N.254.255\n\n255.255.248.0   32 nets       N.N.0.0     N.N.0-7.N        N.N.7.255\n5 bit subnet    2046          N.N.8.0     N.N.8-15.N       N.N.15.255\n                              N.N.16.0    N.N.16-23.N      N.N.23.255\n                              N.N.24.0    N.N.24-31.N      N.N.31.255\n                              N.N.32.0    N.N.32-39.N      N.N.39.255\n                              N.N.40.0    N.N.40-47.N      N.N.47.255\n                              N.N.48.0    N.N.48-55.N      N.N.55.255\n                              N.N.56.0    N.N.56-63.N      N.N.63.255\n                              N.N.64.0    N.N.64-71.N      N.N.71.255\n                              N.N.72.0    N.N.72-79.N      N.N.79.255\n                              N.N.80.0    N.N.80-87.N      N.N.87.255\n                              N.N.88.0    N.N.88-95.N      N.N.95.255\n                              N.N.96.0    N.N.96-103.N     N.N.103.255\n                              N.N.104.0   N.N.104-111.N    N.N.111.255\n                              N.N.112.0   N.N.112-119.N    N.N.119.255\n                              N.N.120.0   N.N.120-127.N    N.N.127.255\n                              N.N.128.0   N.N.128-135.N    N.N.135.255\n                              N.N.136.0   N.N.136-143.N    N.N.143.255\n                              N.N.144.0   N.N.144-151.N    N.N.151.255\n                              N.N.152.0   N.N.152-159.N    N.N.159.255\n                              N.N.160.0   N.N.160-167.N    N.N.167.255\n                              N.N.168.0   N.N.168-175.N    N.N.175.255\n                              N.N.176.0   N.N.176-183.N    N.N.183.255\n                              N.N.184.0   N.N.184-191.N    N.N.191.255\n                              N.N.192.0   N.N.192-199.N    N.N.199.255\n                              N.N.200.0   N.N.200-207.N    N.N.207.255\n                              N.N.208.0   N.N.208-215.N    N.N.215.255\n                              N.N.216.0   N.N.216-223.N    N.N.223.255\n                              N.N.224.0   N.N.224-231.N    N.N.231.255\n                              N.N.232.0   N.N.232-239.N    N.N.239.255\n                              N.N.240.0   N.N.240-247.N    N.N.247.255\n                              N.N.248.0   N.N.248-254.N    N.N.254.255\n\n255.255.252.0   64 nets       N.N.0.0     N.N.0-3.N        N.N.3.255\n6 bit subnet    1022          N.N.4.0     N.N.4-7.N        N.N.7.255\n                              N.N.8.0     N.N.8-11.N       N.N.11.255\n                              N.N.12.0    N.N.12-15.N      N.N.15.255\n                              N.N.240.0   N.N.240-243.N    N.N.243.255\n                              N.N.244.0   N.N.244-247.N    N.N.247.255\n                              N.N.248.0   N.N.248-251.N    N.N.251.255\n                              N.N.252.0   N.N.252-254.N    N.N.254.255\n\n\n255.255.254.0   128 nets      N.N.0.0     N.N.0-1.N        N.N.1.255\n7 bit subnet    510           N.N.2.0     N.N.2-3.N        N.N.3.255\n                              N.N.4.0     N.N.4-5.N        N.N.5.255\n                              N.N.250.0   N.N.250-251.N    N.N.251.255\n                              N.N.252.0   N.N.252-253.N    N.N.253.255\n                              N.N.254.0   N.N.254.N        N.N.254.255\n\n255.255.255.0   255 nets      N.N.0.0     N.N.0.N          N.N.0.255\n8 bit subnet    253           N.N.1.0     N.N.1.N          N.N.1.255\n                              N.N.252.0   N.N.252.N        N.N.252.255\n                              N.N.253.0   N.N.253.N        N.N.253.255\n                              N.N.254.0   N.N.254.N        N.N.254.255",
            "title": "Table 1-1 Class B"
        },
        {
            "location": "/Dev/Hardware/Networks/#table-1-2-class-c",
            "text": "Subnet Mask     # of nets    Net. Addr.  Host Addr Range  Brodcast Addr.\nBits of Subnet  hosts/subnet\n\n255.255.255.128 2 nets       N.N.N.0     N.N.N.1-126      N.N.N.127\n1 bit Class C   126          N.N.N.128   N.N.N.129-254    N.N.N.255\n9 bit Class B\n\n\n\n255.255.255.192 4 nets       N.N.N.0     N.N.N.1-62       N.N.N.63\n2 bit Class C   62           N.N.N.64    N.N.N.65-126     N.N.N.127\n10 bit Class B               N.N.N.128   N.N.N.129-190    N.N.N.191\n                             N.N.N.192   N.N.N.193-254    N.N.N.255\n\n255.255.255.224 8 nets       N.N.N.0     N.N.N.1-30       N.N.N.31\n3 bit Class C   30           N.N.N.32    N.N.N.33-62      N.N.N.63\n11 bit Class B               N.N.N.64    N.N.N.65-94      N.N.N.95\n                             N.N.N.96    N.N.N.97-126     N.N.N.127\n                             N.N.N.128   N.N.N.129-158    N.N.N.159\n                             N.N.N.160   N.N.N.161-190    N.N.N.191\n                             N.N.N.192   N.N.N.193-222    N.N.N.223\n                             N.N.N.224   N.N.N.225-254    N.N.N.255\n\n255.255.255.240 16 nets      N.N.N.0     N.N.N.1-14       N.N.N.15\n4 bit Class C   14           N.N.N.16    N.N.N.17-30      N.N.N.31\n12 bit Class B               N.N.N.32    N.N.N.33-46      N.N.N.47\n                             N.N.N.48    N.N.N.49-62      N.N.N.63\n                             N.N.N.64    N.N.N.65-78      N.N.N.79\n                             N.N.N.80    N.N.N.81-94      N.N.N.95\n                             N.N.N.96    N.N.N.97-110     N.N.N.111\n                             N.N.N.112   N.N.N.113-126    N.N.N.127\n                             N.N.N.128   N.N.N.129-142    N.N.N.143\n                             N.N.N.144   N.N.N.145-158    N.N.N.159\n                             N.N.N.160   N.N.N.161-174    N.N.N.175\n                             N.N.N.176   N.N.N.177-190    N.N.N.191\n                             N.N.N.192   N.N.N.193-206    N.N.N.207\n                             N.N.N.208   N.N.N.209-222    N.N.N.223\n                             N.N.N.224   N.N.N.225-238    N.N.N.239\n                             N.N.N.240   N.N.N.241-254    N.N.N.255\n\n255.255.255.248 32 nets      N.N.N.0     N.N.N.1-6        N.N.N.7\n5 bit Class C   6            N.N.N.8     N.N.N.9-14       N.N.N.15\n13 bit Class B               N.N.N.16    N.N.N.17-22      N.N.N.23\n                             N.N.N.24    N.N.N.25-30      N.N.N.31\n                             N.N.N.32    N.N.N.33-38      N.N.N.39\n                             N.N.N.40    N.N.N.41-46      N.N.N.47\n                             N.N.N.48    N.N.N.49-54      N.N.N.55\n                             N.N.N.56    N.N.N.57-62      N.N.N.63\n                             N.N.N.64    N.N.N.65-70      N.N.N.71\n                             N.N.N.72    N.N.N.73-78      N.N.N.79\n                             N.N.N.80    N.N.N.81-86      N.N.N.87\n                             N.N.N.88    N.N.N.89-94      N.N.N.95\n                             N.N.N.96    N.N.N.97-102     N.N.N.103\n                             N.N.N.104   N.N.N.105-110    N.N.N.111\n                             N.N.N.112   N.N.N.113-118    N.N.N.119\n                             N.N.N.120   N.N.N.121-126    N.N.N.127\n                             N.N.N.128   N.N.N.129-134    N.N.N.135\n                             N.N.N.136   N.N.N.137-142    N.N.N.143\n                             N.N.N.144   N.N.N.145-150    N.N.N.151\n                             N.N.N.152   N.N.N.153-158    N.N.N.159\n                             N.N.N.160   N.N.N.161-166    N.N.N.167\n                             N.N.N.168   N.N.N.169-174    N.N.N.175\n                             N.N.N.176   N.N.N.177-182    N.N.N.183\n                             N.N.N.184   N.N.N.185-190    N.N.N.191\n                             N.N.N.192   N.N.N.193-198    N.N.N.199\n                             N.N.N.200   N.N.N.201-206    N.N.N.207\n                             N.N.N.208   N.N.N.209-214    N.N.N.215\n                             N.N.N.216   N.N.N.217-222    N.N.N.223\n                             N.N.N.224   N.N.N.225-230    N.N.N.231\n                             N.N.N.232   N.N.N.233-238    N.N.N.239\n                             N.N.N.240   N.N.N.241-246    N.N.N.247\n                             N.N.N.248   N.N.N.249-254    N.N.N.255\n\n255.255.255.252 64 nets      N.N.N.0     N.N.N.1-2        N.N.N.3\n6 bit Class C   2            N.N.N.4     N.N.N.5-6        N.N.N.7\n14 bit Class B               N.N.N.8     N.N.N.9-10       N.N.N.11\n                             N.N.N.244   N.N.N.245-246    N.N.N.247\n                             N.N.N.248   N.N.N.249-250    N.N.N.251\n                             N.N.N.252   N.N.N.253-254    N.N.N.255   For the sake of completeness within this memo, tables 2-1 and 2-2 illistrate some options for subnet/host partions within selected block sizes using calculations which exclude all-zeros and all-ones subnets.  Many vendors only support subnetting based upon this premise.  This practice is obsolete!  Modern software will be able to utilize all definable networks.",
            "title": "Table 1-2 Class C"
        },
        {
            "location": "/Dev/Hardware/Networks/#table-2-1-from-a-16-block",
            "text": "# bits          Mask            Effective Subnets       Effective Hosts\n========        =====           =================       ===============\n2               255.255.192.0   2                       16382\n3               255.255.224.0   6                       8190\n4               255.255.240.0   14                      4094\n5               255.255.248.0   30                      2046\n6               255.255.252.0   62                      1022\n7               255.255.254.0   126                     510\n8               255.255.255.0   254                     254\n9               255.255.255.128 510                     126\n10              255.255.255.192 1022                    62\n11              255.255.255.224 2046                    30\n12              255.255.255.240 4094                    14\n13              255.255.255.248 8190                    6\n14              255.255.255.252 16382                   2",
            "title": "Table 2-1 from a /16 block"
        },
        {
            "location": "/Dev/Hardware/Networks/#table-2-2-from-a-24-block",
            "text": "# bits          Mask            Effective Subnets       Effective Hosts\n========        =====           =================       ===============\n2               255.255.255.192 2                       62\n3               255.255.255.224 6                       30\n4               255.255.255.240 14                      14\n5               255.255.255.248 30                      6\n6               255.255.255.252 62                      2\n\n*Subnet all zeroes and all ones excluded. (Obsolete)\n*Host all zeroes and all ones excluded.   (Obsolete)",
            "title": "Table 2-2 from a /24 block"
        },
        {
            "location": "/Dev/Java/Environment/",
            "text": "Windows variables\n\n\nJAVA_HOME         : C:\\Program Files\\Java\\jdkx.x.x_xxx\nJDK_HOME          : %JAVA_HOME%\nJRE_HOME          : %JAVA_HOME%\\jre\nCLASSPATH         : .;%JAVA_HOME%\\lib;%JAVA_HOME%\\jre\\lib\nPATH              : <all_your_recors>;%JAVA_HOME%\\bin\n# Optional\nJAVA_TOOL_OPTIONS : -Dfile.encoding=\"UTF-8\"\n\n\n\n\nUnix variables\n\n\n# If you install JRE only:\nJAVA_HOME=/path/to/jre\nJRE_HOME=$JAVA_HOME\nCLASSPATH=.;$JAVA_HOME/lib\nPATH=$PATH;$JAVA_HOME/bin\n\n# If you install JDK:\nJAVA_HOME=/path/to/jdk\nJDK_HOME=$JAVA_HOME\nJRE_HOME=$JAVA_HOME/jre\nCLASSPATH=.;$JAVA_HOME/lib;$JAVA_HOME/jre/lib\nPATH=$PATH;$JAVA_HOME/bin",
            "title": "Environment"
        },
        {
            "location": "/Dev/Java/Environment/#windows-variables",
            "text": "JAVA_HOME         : C:\\Program Files\\Java\\jdkx.x.x_xxx\nJDK_HOME          : %JAVA_HOME%\nJRE_HOME          : %JAVA_HOME%\\jre\nCLASSPATH         : .;%JAVA_HOME%\\lib;%JAVA_HOME%\\jre\\lib\nPATH              : <all_your_recors>;%JAVA_HOME%\\bin\n# Optional\nJAVA_TOOL_OPTIONS : -Dfile.encoding=\"UTF-8\"",
            "title": "Windows variables"
        },
        {
            "location": "/Dev/Java/Environment/#unix-variables",
            "text": "# If you install JRE only:\nJAVA_HOME=/path/to/jre\nJRE_HOME=$JAVA_HOME\nCLASSPATH=.;$JAVA_HOME/lib\nPATH=$PATH;$JAVA_HOME/bin\n\n# If you install JDK:\nJAVA_HOME=/path/to/jdk\nJDK_HOME=$JAVA_HOME\nJRE_HOME=$JAVA_HOME/jre\nCLASSPATH=.;$JAVA_HOME/lib;$JAVA_HOME/jre/lib\nPATH=$PATH;$JAVA_HOME/bin",
            "title": "Unix variables"
        },
        {
            "location": "/Dev/Java/Runtime_customization/",
            "text": "Java custom user and system preferencies path\n\n\n# From user which will start particular hava application\n\nmkdir -p <new_system_prefs>\nmkdir -p <new_user_prefs>\nchmod -R 755 <new_system_prefs>\nchmod -R 755 <new_user_prefs> \n\nexport JAVA_OPTS=\"-Djava.util.prefs.systemRoot=<new_system_prefs> -Djava.util.prefs.userRoot=<new_user_prefs>\"\n\n# start application",
            "title": "Runtime customization"
        },
        {
            "location": "/Dev/Java/Runtime_customization/#java-custom-user-and-system-preferencies-path",
            "text": "# From user which will start particular hava application\n\nmkdir -p <new_system_prefs>\nmkdir -p <new_user_prefs>\nchmod -R 755 <new_system_prefs>\nchmod -R 755 <new_user_prefs> \n\nexport JAVA_OPTS=\"-Djava.util.prefs.systemRoot=<new_system_prefs> -Djava.util.prefs.userRoot=<new_user_prefs>\"\n\n# start application",
            "title": "Java custom user and system preferencies path"
        },
        {
            "location": "/Dev/Libraries/Linux/",
            "text": "Add global library path\n\n\necho '/path/to/library/dir' >> /etc/ld.so.conf.d/<your-custom-name>.conf\nldconfig",
            "title": "Linux"
        },
        {
            "location": "/Dev/Libraries/Linux/#add-global-library-path",
            "text": "echo '/path/to/library/dir' >> /etc/ld.so.conf.d/<your-custom-name>.conf\nldconfig",
            "title": "Add global library path"
        },
        {
            "location": "/Dev/MPI/HelloWorld/",
            "text": "Hello World\n\n\n\n\nC\n\n\n\n\n#include <stdio.h>\n#include <mpi.h>\n\nmain(int argc, char **argv)\n{\n   int node;\n   char hostname[256];\n\n   MPI_Init(&argc,&argv);\n   MPI_Comm_rank(MPI_COMM_WORLD, &node);\n\n   gethostname(hostname,255);\n   printf(\"Hello World from process %d on %s\\n\",node, hostname);\n\n   MPI_Finalize();\n\n   return 0;\n}\n\n\n\n\n\n\nRUN\n\n\n\n\n#!/bin/bash\n#$ -l mem=1G\n#$ -l h_rt=0:15:00\n#$ -pe mpi-fill 8\n#$ -cwd\n\necho -n \"Start at $(date +%Y-%m-%d-%H-%M-%S)\"\nmpirun ./helloworld\necho -n \"Finish at $(date +%Y-%m-%d-%H-%M-%S)\"",
            "title": "HelloWorld"
        },
        {
            "location": "/Dev/MPI/HelloWorld/#hello-world",
            "text": "C   #include <stdio.h>\n#include <mpi.h>\n\nmain(int argc, char **argv)\n{\n   int node;\n   char hostname[256];\n\n   MPI_Init(&argc,&argv);\n   MPI_Comm_rank(MPI_COMM_WORLD, &node);\n\n   gethostname(hostname,255);\n   printf(\"Hello World from process %d on %s\\n\",node, hostname);\n\n   MPI_Finalize();\n\n   return 0;\n}   RUN   #!/bin/bash\n#$ -l mem=1G\n#$ -l h_rt=0:15:00\n#$ -pe mpi-fill 8\n#$ -cwd\n\necho -n \"Start at $(date +%Y-%m-%d-%H-%M-%S)\"\nmpirun ./helloworld\necho -n \"Finish at $(date +%Y-%m-%d-%H-%M-%S)\"",
            "title": "Hello World"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/",
            "text": "MPI_Abort\n\n\nMPI_Abort(3)                          MPI                         MPI_Abort(3)\n\n\n\nNAME\n       MPI_Abort -  Terminates MPI execution environment\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Abort( MPI_Comm comm, int errorcode )\n\nINPUT PARAMETERS\n       comm   - communicator of tasks to abort\n       errorcode\n              - error code to return to invoking environment\n\n\nNOTES\n       Terminates all MPI processes associated with the communicator comm ; in\n       most systems (all to date), terminates all processes.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       abort.c\n\n\n\n                                  12/13/2001                      MPI_Abort(3)\n\n\n\n\nMPI_Address\n\n\nMPI_Address(3)                        MPI                       MPI_Address(3)\n\n\n\nNAME\n       MPI_Address -  Gets the address of a location in memory\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Address( void *location, MPI_Aint *address)\n\nINPUT PARAMETERS\n       location\n              - location in caller memory (choice)\n\n\nOUTPUT PARAMETER\n       address\n              - address of location (integer)\n\n\nNOTE\n       This  routine  is  provided for both the Fortran and C programmers.  On\n       many systems, the address returned by this routine will be the same  as\n       produced by the C & operator, but this is not required in C and may not\n       be true of systems with word- rather than byte-oriented instructions or\n       systems with segmented address spaces.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       address.c\n\n\n\n                                  11/14/2001                    MPI_Address(3)\n\n\n\n\nMPI_Allgather\n\n\nMPI_Allgather(3)                      MPI                     MPI_Allgather(3)\n\n\n\nNAME\n       MPI_Allgather  -   Gathers data from all tasks and distribute it to all\n       tasks\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Allgather ( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                           void *recvbuf, int recvcount, MPI_Datatype recvtype,\n                          MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              - number of elements received from any process (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES\n       The MPI standard (1.0 and 1.1) says that\n\n       The jth block of data sent from each proess is received by  every  pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This is misleading; a better description is\n\n       The  block  of data sent from the jth process is received by every pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This text was suggested by Rajeev Thakur.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler  may  be  changed  with  MPI_Errhandler_set  ;  the\n       predefined error handler MPI_ERRORS_RETURN may be used to  cause  error\n       values  to  be  returned.  Note that MPI does not guarentee that an MPI\n       program can continue past an error.\n\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       allgather.c\n\n\n\n                                   10/1/2004                  MPI_Allgather(3)\n\n\n\n\nMPI_Allgatherv\n\n\nMPI_Allgatherv(3)                     MPI                    MPI_Allgatherv(3)\n\n\n\nNAME\n       MPI_Allgatherv -  Gathers data from all tasks and deliver it to all\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Allgatherv ( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                            void *recvbuf, int *recvcounts, int *displs,\n                           MPI_Datatype recvtype, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcounts\n              -  integer array (of length group size) containing the number of\n              elements that are received from each process\n       displs - integer array (of length group size). Entry  i  specifies  the\n              displacement (relative to recvbuf ) at which to place the incom-\n              ing data from process i\n\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES\n       The MPI standard (1.0 and 1.1) says that\n\n       The jth block of data sent from each proess is received by  every  pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This is misleading; a better description is\n\n       The  block  of data sent from the jth process is received by every pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This text was suggested by Rajeev Thakur.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       allgatherv.c\n\n\n\n                                  11/14/2001                 MPI_Allgatherv(3)\n\n\n\n\nMPI_Allreduce\n\n\nMPI_Allreduce(3)                      MPI                     MPI_Allreduce(3)\n\n\n\nNAME\n       MPI_Allreduce  -  Combines values from all processes and distribute the\n       result back to all processes\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Allreduce ( void *sendbuf, void *recvbuf, int count,\n                          MPI_Datatype datatype, MPI_Op op, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - data type of elements of send buffer (handle)\n       op     - operation (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - starting address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The  reduction functions ( MPI_Op ) do not return an error value.  As a\n       result, if the functions detect an error, all they  can  do  is  either\n       call  MPI_Abort  or silently skip the problem.  Thus, if you change the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The  reason  for  this is the performance problems in ensuring that all\n       collective routines return the same error value.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_OP\n              - Invalid operation.  MPI operations (objects of type  MPI_Op  )\n              must either be one of the predefined operations (e.g., MPI_SUM )\n              or created with MPI_Op_create .\n\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       allreduce.c\n\n\n\n                                  11/14/2001                  MPI_Allreduce(3)\n\n\n\n\nMPI_Alltoall\n\n\nMPI_Alltoall(3)                       MPI                      MPI_Alltoall(3)\n\n\n\nNAME\n       MPI_Alltoall -  Sends data from all to all processes\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Alltoall( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                         void *recvbuf, int recvcnt, MPI_Datatype recvtype,\n                        MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements to send to each process (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              - number of elements received from any process (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\nLOCATION\n       alltoall.c\n\n\n\n                                  11/14/2001                   MPI_Alltoall(3)\n\n\n\n\nMPI_Alltoallv\n\n\nMPI_Alltoallv(3)                      MPI                     MPI_Alltoallv(3)\n\n\n\nNAME\n       MPI_Alltoallv -  Sends data from all to all processes, with a displace-\n       ment\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Alltoallv (\n               void *sendbuf,\n               int *sendcnts,\n               int *sdispls,\n               MPI_Datatype sendtype,\n               void *recvbuf,\n               int *recvcnts,\n               int *rdispls,\n               MPI_Datatype recvtype,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcounts\n              - integer array equal to the group size specifying the number of\n              elements to send to each processor\n       sdispls\n              -  integer  array  (of length group size). Entry j specifies the\n              displacement (relative to sendbuf  from which to take the outgo-\n              ing data destined for process j\n\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcounts\n              -  integer  array equal to the group size specifying the maximum\n              number of elements that can be received from each processor\n       rdispls\n              - integer array (of length group size). Entry  i  specifies  the\n              displacement  (relative to recvbuf  at which to place the incom-\n              ing data from process i\n\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       alltoallv.c\n\n\n\n                                  11/14/2001                  MPI_Alltoallv(3)\n\n\n\n\nMPI_Attr_delete\n\n\nMPI_Attr_delete(3)                    MPI                   MPI_Attr_delete(3)\n\n\n\nNAME\n       MPI_Attr_delete -  Deletes attribute value associated with a key\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Attr_delete ( MPI_Comm comm, int keyval )\n\nINPUT PARAMETERS\n       comm   - communicator to which attribute is attached (handle)\n       keyval - The key value of the deleted attribute (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              keys.\n\nLOCATION\n       attr_delval.c\n\n\n\n                                  11/14/2001                MPI_Attr_delete(3)\n\n\n\n\nMPI_Attr_get\n\n\nMPI_Attr_get(3)                       MPI                      MPI_Attr_get(3)\n\n\n\nNAME\n       MPI_Attr_get -  Retrieves attribute value by key\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Attr_get (\n               MPI_Comm comm,\n               int keyval,\n               void *attr_value,\n               int *flag )\n\nINPUT PARAMETERS\n       comm   - communicator to which attribute is attached (handle)\n       keyval - key value (integer)\n\n\nOUTPUT PARAMETERS\n       attr_value\n              - attribute value, unless flag = false\n       flag   -  true  if  an  attribute  value  was  extracted;   false if no\n              attribute is associated with the key\n\n\nNOTES\n       Attributes must be extracted  from  the  same  language  as  they  were\n       inserted  in  with  MPI_ATTR_PUT  .   The notes for C and Fortran below\n       explain why.\n\n\nNOTES FOR C\n       Even though the attr_value arguement is declared as  void  *  ,  it  is\n       really  the  address of a void pointer.  See the rationale in the stan-\n       dard for more details.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       The  attr_value  in  Fortran  is  a pointer to a Fortran integer, not a\n       pointer to a void * .\n\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_OTHER\n              - Other error; the error code associated with this  error  indi-\n              cates an attempt to use an invalue keyval.\n\nLOCATION\n       attr_getval.c\n\n\n\n                                  11/14/2001                   MPI_Attr_get(3)\n\n\n\n\nMPI_Attr_put\n\n\nMPI_Attr_put(3)                       MPI                      MPI_Attr_put(3)\n\n\n\nNAME\n       MPI_Attr_put -  Stores attribute value associated with a key\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Attr_put ( MPI_Comm comm, int keyval, void *attr_value )\n\nINPUT PARAMETERS\n       comm   - communicator to which attribute will be attached (handle)\n       keyval - key value, as returned by MPI_KEYVAL_CREATE (integer)\n       attribute_val\n              - attribute value\n\n\nNOTES\n       Values of the permanent attributes MPI_TAG_UB , MPI_HOST , MPI_IO , and\n       MPI_WTIME_IS_GLOBAL may not be changed.\n\n       The type of the attribute value depends on  whether  C  or  Fortran  is\n       being  used.  In C, an attribute value is a pointer ( void * ); in For-\n       tran, it is a single integer ( not a  pointer,  since  Fortran  has  no\n       pointers  and  there are systems for which a pointer does not fit in an\n       integer (e.g., any > 32 bit address system that uses 64 bits  for  For-\n       tran DOUBLE PRECISION ).\n\n       If an attribute is already present, the delete function (specified when\n       the corresponding keyval was created) will be called.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_OTHER\n              -  Other  error; the error code associated with this error indi-\n              cates an attempt to use an invalue keyval.\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              keys.\n\n\nSEE ALSO\n       MPI_Attr_get, MPI_Keyval_create, MPI_Attr_delete\n\nLOCATION\n       attr_putval.c\n\n\n\n                                  11/14/2001                   MPI_Attr_put(3)\n\n\n\n\nMPI_Barrier\n\n\nMPI_Barrier(3)                        MPI                       MPI_Barrier(3)\n\n\n\nNAME\n       MPI_Barrier -  Blocks until all process have reached this routine.\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Barrier (\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n\n\nNOTES\n       Blocks  the  caller  until  all  group members have called it; the call\n       returns at any process only after all group members  have  entered  the\n       call.\n\n\nALGORITHM\n       If the underlying device cannot do better, a tree-like or combine algo-\n       rithm is used to broadcast a message wto all members of the  communica-\n       tor.   We  can  modifiy  this  to  use  \"blocks\"  at  a later time (see\n       MPI_Bcast ).\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       barrier.c\n\n\n\n                                  11/14/2001                    MPI_Barrier(3)\n\n\n\n\nMPI_Bcast\n\n\nMPI_Bcast(3)                          MPI                         MPI_Bcast(3)\n\n\n\nNAME\n       MPI_Bcast  -  Broadcasts a message from the process with rank \"root\" to\n       all other processes of the group.\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Bcast ( void *buffer, int count, MPI_Datatype datatype, int root,\n                      MPI_Comm comm )\n\nINPUT/OUTPUT PARAMETERS\n       buffer - starting address of buffer (choice)\n       count  - number of entries in buffer (integer)\n       datatype\n              - data type of buffer (handle)\n       root   - rank of broadcast root (integer)\n       comm   - communicator (handle)\n\n\nALGORITHM\n       If the underlying device does not take  responsibility,  this  function\n       uses  a  tree-like algorithm to broadcast the message to blocks of pro-\n       cesses.  A linear algorithm is then used to broadcast the message  from\n       the    first   process   in   a   block   to   all   other   processes.\n       MPIR_BCAST_BLOCK_SIZE determines the size of blocks.  If this is set to\n       1, then this function is equivalent to using a pure tree algorithm.  If\n       it is set to the size of the group or greater,  it  is  a  pure  linear\n       algorithm.   The  value  should be adjusted to determine the most effi-\n       cient value on different machines.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_ROOT\n              - Invalid root.  The root must be specified as  a  rank  in  the\n              communicator.   Ranks  must  be between zero and the size of the\n              communicator minus one.\n\nLOCATION\n       bcast.c\n\n\n\n                                  11/14/2001                      MPI_Bcast(3)\n\n\n\n\nMPI_Bsend_init\n\n\nMPI_Bsend_init(3)                     MPI                    MPI_Bsend_init(3)\n\n\n\nNAME\n       MPI_Bsend_init -  Builds a handle for a buffered send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Bsend_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                          int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n\nLOCATION\n       bsend_init.c\n\n\n\n                                  12/13/2001                 MPI_Bsend_init(3)\n\n\n\n\nMPI_Bsend\n\n\nMPI_Bsend(3)                          MPI                         MPI_Bsend(3)\n\n\n\nNAME\n       MPI_Bsend -  Basic send with user-specified buffering\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Bsend(\n               void *buf,\n               int count,\n               MPI_Datatype datatype,\n               int dest,\n               int tag,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES\n       This  send is provided as a convenience function; it allows the user to\n       send messages without worring about where they  are  buffered  (because\n       the user must have provided buffer space with MPI_Buffer_attach ).\n\n       In deciding how much buffer space to allocate, remember that the buffer\n       space is not available for reuse by subsequent MPI_Bsend s  unless  you\n       are certain that the message has been received (not just that it should\n       have been received).  For example, this code does not  allocate  enough\n       buffer space\n       MPI_Buffer_attach( b, n*sizeof(double) + MPI_BSEND_OVERHEAD );\n       for (i=0; i<m; i++) {\n       MPI_Bsend( buf, n, MPI_DOUBLE, ... );\n       }\n\n       because only enough buffer space is provided for a single send, and the\n       loop may start a second MPI_Bsend before the first is done  making  use\n       of the buffer.\n\n       In C, you can force the messages to be delivered by\n       MPI_Buffer_detach( &b, &n );\n       MPI_Buffer_attach( b, n );\n\n       (The  MPI_Buffer_detach  will  not complete until all buffered messages\n       are delivered.)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n\n\nSEE ALSO\n       MPI_Buffer_attach, MPI_Ibsend, MPI_Bsend_init\n\nLOCATION\n       bsend.c\n\n\n\n                                  11/14/2001                      MPI_Bsend(3)\n\n\n\n\nMPI_Buffer_attach\n\n\nMPI_Buffer_attach(3)                  MPI                 MPI_Buffer_attach(3)\n\n\n\nNAME\n       MPI_Buffer_attach -  Attaches a user-defined buffer for sending\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Buffer_attach( void *buffer, int size )\n\nINPUT PARAMETERS\n       buffer - initial buffer address (choice)\n       size   - buffer size, in bytes (integer)\n\n\nNOTES\n       The size given should be the sum of the sizes of all outstanding Bsends\n       that you intend to have, plus a few hundred bytes for each  Bsend  that\n       you  do.   For  the  purposes  of  calculating  size,  you  should  use\n       MPI_Pack_size .\n\n       In other words, in the code\n       MPI_Buffer_attach( buffer, size );\n       MPI_Bsend( ..., count=20, datatype=type1,  ... );\n       .\n       .\n       .\n       MPI_Bsend( ..., count=40, datatype=type2, ... );\n\n       the value of size in the MPI_Buffer_attach call should be greater  than\n       the value computed by\n       MPI_Pack_size( 20, type1, comm, &s1 );\n       MPI_Pack_size( 40, type2, comm, &s2 );\n       size = s1 + s2 + 2 * MPI_BSEND_OVERHEAD;\n\n       The  MPI_BSEND_OVERHEAD  gives  the maximum amount of space that may be\n       used in the buffer for use by the BSEND routines in using  the  buffer.\n       This value is in mpi.h (for C) and mpif.h (for Fortran).\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_INTERN\n              - An internal error has been detected.  This is  fatal.   Please\n              send a bug report to mpi-bugs@mcs.anl.gov .\n\n\n\nSEE ALSO\n       MPI_Buffer_detach, MPI_Bsend\n\nLOCATION\n       bufattach.c\n\n\n\n                                  11/14/2001              MPI_Buffer_attach(3)\n\n\n\n\nMPI_Buffer_detach\n\n\nMPI_Buffer_detach(3)                  MPI                 MPI_Buffer_detach(3)\n\n\n\nNAME\n       MPI_Buffer_detach  -   Removes an existing buffer (for use in MPI_Bsend\n       etc)\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Buffer_detach(\n               void *bufferptr,\n               int *size )\n\nOUTPUT PARAMETERS\n       buffer - initial buffer address (choice)\n       size   - buffer size, in bytes (integer)\n\n\nNOTES\n       The reason that MPI_Buffer_detach returns the address and size  of  the\n       buffer  being  detached  is  to  allow  nested libraries to replace and\n       restore the buffer.  For example, consider\n\n       int size, mysize, idummy;\n       void *ptr, *myptr, *dummy;\n       MPI_Buffer_detach( &ptr, &size );\n       MPI_Buffer_attach( myptr, mysize );\n       .\n       .\n       .\n       .\n       .\n       .\n       library code ...\n       .\n       .\n       .\n       MPI_Buffer_detach( &dummy, &idummy );\n       MPI_Buffer_attach( ptr, size );\n\n\n       This is much like the action of the Unix signal  routine  and  has  the\n       same  strengths (it is simple) and weaknesses (it only works for nested\n       usages).\n\n       Note that for this approach  to  work,  MPI_Buffer_detach  must  return\n       MPI_SUCCESS  even  when there is no buffer to detach.  In that case, it\n       returns a size of zero.  The MPI  1.1  standard  for  MPI_BUFFER_DETACH\n       contains the text\n\n       The statements made in this section describe the behavior of MPI for\n       buffered-mode sends. When no buffer is currently associated, MPI behaves\n       as if a zero-sized buffer is associated with the process.\n\n\n       This  could  be  read  as  applying only to the various Bsend routines.\n       This  implementation  takes  the  position   that   this   applies   to\n       MPI_BUFFER_DETACH as well.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       The Fortran binding for this routine  is  different.   Because  Fortran\n       does  not  have  pointers, it is impossible to provide a way to use the\n       output of this routine to exchange buffers.  In  this  case,  only  the\n       size field is set.\n\n\nNOTES FOR C\n       Even though the bufferptr argument is declared as void * , it is really\n       the address of a void pointer.  See the rationale in the  standard  for\n       more details.\n\nLOCATION\n       buffree.c\n\n\n\n                                  11/14/2001              MPI_Buffer_detach(3)\n\n\n\n\nMPI_Cancel\n\n\nMPI_Cancel(3)                         MPI                        MPI_Cancel(3)\n\n\n\nNAME\n       MPI_Cancel -  Cancels a communication request\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cancel( MPI_Request *request )\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTE\n       Cancel  has  only  been implemented for receive requests; it is a no-op\n       for send requests.  The primary expected use of MPI_Cancel is in multi-\n       buffering  schemes,  where  speculative  MPI_Irecvs are made.  When the\n       computation completes, some of these receive requests may remain; using\n       MPI_Cancel allows the user to cancel these unsatisfied requests.\n\n       Cancelling  a  send  operation  is  much  more difficult, in large part\n       because the send will usually  be  at  least  partially  complete  (the\n       information  on  the tag, size, and source are usually sent immediately\n       to the destination).  As of version 1.2.0, MPICH supports cancelling of\n       sends.   Users are advised that cancelling a send, while a local opera-\n       tion (as defined by the MPI standard), is likely to be expensive  (usu-\n       ally generating one or more internal messages).\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNULL HANDLES\n       The MPI 1.1 specification, in the section on opaque objects, explicitly\n\nDISALLOWS FREEING A NULL COMMUNICATOR. THE TEXT FROM THE STANDARD IS\n       A null handle argument is an erroneous IN argument in MPI calls, unless an\n       exception is explicitly stated in the text that defines the function. Such\n       exception is allowed for handles to request objects in Wait and Test calls\n       (sections Communication Completion and Multiple Completions ). Otherwise, a\n       null handle can only be passed to a function that allocates a new object and\n       returns a reference to it in the handle.\n\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cancel.c\n\n\n\n                                  11/14/2001                     MPI_Cancel(3)\n\n\n\n\nMPI_Cart_coords\n\n\nMPI_Cart_coords(3)                    MPI                   MPI_Cart_coords(3)\n\n\n\nNAME\n       MPI_Cart_coords  -   Determines  process  coords  in cartesian topology\n       given rank in group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cart_coords ( MPI_Comm comm, int rank, int maxdims, int *coords )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       rank   - rank of a process within group of comm (integer)\n       maxdims\n              - length of vector coords in the calling program (integer)\n\n\nOUTPUT PARAMETER\n       coords - integer array (of size ndims ) containing the Cartesian  coor-\n              dinates of specified process (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_DIMS\n              - Illegal dimension argument.  A dimension argument is  null  or\n              its length is less than or equal to zero.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       cart_coords.c\n\n\n\n                                   3/28/2002                MPI_Cart_coords(3)\n\n\n\n\nMPI_Cart_create\n\n\nMPI_Cart_create(3)                    MPI                   MPI_Cart_create(3)\n\n\n\nNAME\n       MPI_Cart_create  -  Makes a new communicator to which topology informa-\n       tion has been attached\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cart_create ( MPI_Comm comm_old, int ndims, int *dims, int *periods,\n                            int reorder, MPI_Comm *comm_cart )\n\nINPUT PARAMETERS\n       comm_old\n              - input communicator (handle)\n       ndims  - number of dimensions of cartesian grid (integer)\n       dims   - integer array of size ndims specifying the number of processes\n              in each dimension\n       periods\n              -  logical  array  of  size ndims specifying whether the grid is\n              periodic (true) or not (false) in each dimension\n       reorder\n              - ranking may be reordered (true) or not (false) (logical)\n\n\nOUTPUT PARAMETER\n       comm_cart\n              - communicator with new cartesian topology (handle)\n\n\nALGORITHM\n       We ignore reorder info currently.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_DIMS\n              - Illegal dimension argument.  A dimension argument is  null  or\n              its length is less than or equal to zero.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_create.c\n\n\n\n                                  11/14/2001                MPI_Cart_create(3)\n\n\n\n\nMPI_Cartdim_get\n\n\nMPI_Cartdim_get(3)                    MPI                   MPI_Cartdim_get(3)\n\n\n\nNAME\n       MPI_Cartdim_get  -  Retrieves Cartesian topology information associated\n       with a  communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cartdim_get ( MPI_Comm comm, int *ndims )\n\nINPUT PARAMETER\n       comm   - communicator with cartesian structure (handle)\n\n\nOUTPUT PARAMETER\n       ndims  - number of dimensions of the cartesian structure (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cartdim_get.c\n\n\n\n                                  11/14/2001                MPI_Cartdim_get(3)\n\n\n\n\nMPI_Cart_get\n\n\nMPI_Cart_get(3)                       MPI                      MPI_Cart_get(3)\n\n\n\nNAME\n       MPI_Cart_get  -   Retrieves  Cartesian  topology information associated\n       with a  communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cart_get (\n               MPI_Comm comm,\n               int maxdims,\n               int *dims,\n               int *periods,\n               int *coords )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       maxdims\n              - length of vectors dims , periods , and coords in  the  calling\n              program (integer)\n\n\nOUTPUT PARAMETERS\n       dims   -  number  of  processes  for each cartesian dimension (array of\n              integer)\n       periods\n              - periodicity (true/false) for each cartesian  dimension  (array\n              of logical)\n       coords -  coordinates  of calling process in cartesian structure (array\n              of integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_get.c\n\n\n\n                                  11/14/2001                   MPI_Cart_get(3)\n\n\n\n\nMPI_Cart_map\n\n\nMPI_Cart_map(3)                       MPI                      MPI_Cart_map(3)\n\n\n\nNAME\n       MPI_Cart_map -  Maps process to Cartesian topology information\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cart_map (\n               MPI_Comm comm_old,\n               int ndims,\n               int *dims,\n               int *periods,\n               int *newrank)\n\nINPUT PARAMETERS\n       comm   - input communicator (handle)\n       ndims  - number of dimensions of Cartesian structure (integer)\n       dims   - integer array of size ndims specifying the number of processes\n              in each coordinate direction\n       periods\n              - logical array of size ndims specifying the periodicity  speci-\n              fication in each coordinate direction\n\n\nOUTPUT PARAMETER\n       newrank\n              -  reordered rank of the calling process; MPI_UNDEFINED if call-\n              ing process does not belong to grid (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_DIMS\n              -  Illegal  dimension argument.  A dimension argument is null or\n              its length is less than or equal to zero.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_map.c\n\n\n\n                                   3/28/2002                   MPI_Cart_map(3)\n\n\n\n\nMPI_Cart_rank\n\n\nMPI_Cart_rank(3)                      MPI                     MPI_Cart_rank(3)\n\n\n\nNAME\n       MPI_Cart_rank  -   Determines process rank in communicator given Carte-\n       sian location\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cart_rank (\n               MPI_Comm comm,\n               int *coords,\n               int *rank )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       coords - integer array (of size ndims ) specifying the cartesian  coor-\n              dinates of a process\n\n\nOUTPUT PARAMETER\n       rank   - rank of specified process (integer)\n\n\nNOTES\n       Out-of-range  coordinates  are  erroneous  for non-periodic dimensions.\n       Versions of MPICH before 1.2.2 returned MPI_PROC_NULL for the  rank  in\n       this case.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_rank.c\n\n\n\n                                  11/14/2001                  MPI_Cart_rank(3)\n\n\n\n\nMPI_Cart_shift\n\n\nMPI_Cart_shift(3)                     MPI                    MPI_Cart_shift(3)\n\n\n\nNAME\n       MPI_Cart_shift  -   Returns  the  shifted source and destination ranks,\n       given a  shift direction and amount\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cart_shift ( MPI_Comm comm, int direction, int displ,\n                           int *source, int *dest )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       direction\n              - coordinate dimension of shift (integer)\n       disp   - displacement (> 0: upwards shift, < 0: downwards shift) (inte-\n              ger)\n\n\nOUTPUT PARAMETERS\n       rank_source\n              - rank of source process (integer)\n       rank_dest\n              - rank of destination process (integer)\n\n\nNOTES\n       The  direction  argument  is  in the range [0,n-1] for an n-dimensional\n       Cartesian mesh.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_shift.c\n\n\n\n                                  11/14/2001                 MPI_Cart_shift(3)\n\n\n\n\nMPI_Cart_sub\n\n\nMPI_Cart_sub(3)                       MPI                      MPI_Cart_sub(3)\n\n\n\nNAME\n       MPI_Cart_sub  -   Partitions  a communicator into subgroups which  form\n       lower-dimensional cartesian subgrids\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cart_sub ( MPI_Comm comm, int *remain_dims, MPI_Comm *comm_new )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       remain_dims\n              - the i th entry of  remain_dims  specifies  whether  the  i  th\n              dimension  is  kept  in the subgrid (true) or is dropped (false)\n              (logical vector)\n\n\nOUTPUT PARAMETER\n       newcomm\n              - communicator containing the subgrid that includes the  calling\n              process (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_sub.c\n\n\n\n                                  11/14/2001                   MPI_Cart_sub(3)\n\n\n\n\nMPI_Comm_compare\n\n\nMPI_Comm_compare(3)                   MPI                  MPI_Comm_compare(3)\n\n\n\nNAME\n       MPI_Comm_compare -  Compares two communicators\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_compare (\n               MPI_Comm  comm1,\n               MPI_Comm  comm2,\n               int *result)\n\nINPUT PARAMETERS\n       comm1  - comm1 (handle)\n       comm2  - comm2 (handle)\n\n\nOUTPUT PARAMETER\n       result -  integer which is MPI_IDENT if the contexts and groups are the\n              same, MPI_CONGRUENT if different contexts but identical  groups,\n              MPI_SIMILAR  if  different  contexts  but  similar  groups,  and\n              MPI_UNEQUAL otherwise\n\n\nUSING 'MPI_COMM_NULL' WITH 'MPI_COMM_COMPARE'\n       It is an error  to  use  MPI_COMM_NULL  as  one  of  the  arguments  to\n       MPI_Comm_compare .  The relevant sections of the MPI standard are\n\n       .   (2.4.1  Opaque  Objects)  A null handle argument is an erroneous IN\n       argument in MPI calls, unless an exception is explicitly stated in  the\n       text that defines the function.\n\n       .   (5.4.1. Communicator Accessors) <no text in MPI_COMM_COMPARE allow-\n       ing a null handle>\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       commcompare.c\n\n\n\n                                  11/14/2001               MPI_Comm_compare(3)\n\n\n\n\nMPI_Comm_create\n\n\nMPI_Comm_create(3)                    MPI                   MPI_Comm_create(3)\n\n\n\nNAME\n       MPI_Comm_create -  Creates a new communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_create ( MPI_Comm comm, MPI_Group group, MPI_Comm *comm_out )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n       group  - group, which is a subset of the group of comm (handle)\n\n\nOUTPUT PARAMETER\n       comm_out\n              - new communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Comm_free\n\nLOCATION\n       comm_create.c\n\n\n\n                                  11/14/2001                MPI_Comm_create(3)\n\n\n\n\nMPI_Comm_dup\n\n\nMPI_Comm_dup(3)                       MPI                      MPI_Comm_dup(3)\n\n\n\nNAME\n       MPI_Comm_dup -  Duplicates an existing communicator with all its cached\n       information\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_dup (\n               MPI_Comm comm,\n               MPI_Comm *comm_out )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       newcomm\n              - A new communicator over the same group as comm but with a  new\n              context. See notes.  (handle)\n\n\nNOTES\n       This routine is used to create a new communicator that has a new commu-\n       nication context but contains the same group of processes as the  input\n       communicator.  Since all MPI communication is performed within a commu-\n       nicator (specifies as the group of processes plus  the  context),  this\n       routine  provides an effective way to create a private communicator for\n       use by a software module or library.  In particular, no library routine\n       should  use MPI_COMM_WORLD as the communicator; instead, a duplicate of\n       a user-specified communicator should always be used.  For more informa-\n       tion, see Using MPI, 2nd edition.\n\n       Because  this routine essentially produces a copy of a communicator, it\n       also copies any attributes that have been defined on the input communi-\n       cator, using the attribute copy function specified by the copy_function\n       argument to MPI_Keyval_create .  This is particularly  useful  for  (a)\n       attributes that describe some property of the group associated with the\n       communicator, such as its interconnection topology and  (b)  communica-\n       tors  that  are  given back to the user; the attibutes in this case can\n       track subsequent MPI_Comm_dup operations on this communicator.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Comm_free, MPI_Keyval_create, MPI_Attr_set, MPI_Attr_delete\n\n\nLOCATION\n       comm_dup.c\n\n\n\n                                  11/14/2001                   MPI_Comm_dup(3)\n\n\n\n\nMPI_Comm_free\n\n\nMPI_Comm_free(3)                      MPI                     MPI_Comm_free(3)\n\n\n\nNAME\n       MPI_Comm_free -  Marks the communicator object for deallocation\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_free ( MPI_Comm *commp )\n\nINPUT PARAMETER\n       comm   - communicator to be destroyed (handle)\n\n\nNULL HANDLES\n       The MPI 1.1 specification, in the section on opaque objects, explicitly\n\nDISALLOWS FREEING A NULL COMMUNICATOR. THE TEXT FROM THE STANDARD IS\n       A null handle argument is an erroneous IN argument in MPI calls, unless an\n       exception is explicitly stated in the text that defines the function. Such\n       exception is allowed for handles to request objects in Wait and Test calls\n       (sections Communication Completion and Multiple Completions ). Otherwise, a\n       null handle can only be passed to a function that allocates a new object and\n       returns a reference to it in the handle.\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_free.c\n\n\n\n                                  10/31/2002                  MPI_Comm_free(3)\n\n\n\n\nMPI_Comm_group\n\n\nMPI_Comm_group(3)                     MPI                    MPI_Comm_group(3)\n\n\n\nNAME\n       MPI_Comm_group -  Accesses the group associated with given communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_group (\n               MPI_Comm comm,\n               MPI_Group *group )\n\nINPUT PARAMETER\n       comm   - Communicator\n\n\nOUTPUT PARAMETER\n       group  - Group in communicator\n\n\nUSING 'MPI_COMM_NULL' WITH 'MPI_COMM_GROUP'\n       It is an error  to  use  MPI_COMM_NULL  as  one  of  the  arguments  to\n       MPI_Comm_group .  The relevant sections of the MPI standard are\n\n       .   (2.4.1  Opaque  Objects)  A null handle argument is an erroneous IN\n       argument in MPI calls, unless an exception is explicitly stated in  the\n       text that defines the function.\n\n       .   (5.3.2.  Group  Constructors) <no text in MPI_COMM_GROUP allowing a\n       null handle>\n\n       Previous versions of MPICH allow MPI_COMM_NULL in  this  function.   In\n       the interests of promoting portability of applications, we have changed\n       the behavior of MPI_Comm_group to detect  this  violation  of  the  MPI\n       standard.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       comm_group.c\n\n\n\n                                  11/14/2001                 MPI_Comm_group(3)\n\n\n\n\nMPI_Comm_rank\n\n\nMPI_Comm_rank(3)                      MPI                     MPI_Comm_rank(3)\n\n\n\nNAME\n       MPI_Comm_rank -  Determines the rank of the calling process in the com-\n       municator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_rank ( MPI_Comm comm, int *rank )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       rank   - rank of the calling process in group of comm (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       comm_rank.c\n\n\n\n                                  11/14/2001                  MPI_Comm_rank(3)\n\n\n\n\nMPI_Comm_remote_group\n\n\nMPI_Comm_remote_group(3)              MPI             MPI_Comm_remote_group(3)\n\n\n\nNAME\n       MPI_Comm_remote_group -  Accesses the remote group associated with  the\n       given inter-communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_remote_group ( MPI_Comm comm, MPI_Group *group )\n\nINPUT PARAMETER\n       comm   - Communicator (must be intercommunicator)\n\n\nOUTPUT PARAMETER\n       group  - remote group of communicator\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       comm_rgroup.c\n\n\n\n                                  11/14/2001          MPI_Comm_remote_group(3)\n\n\n\n\nMPI_Comm_remote_size\n\n\nMPI_Comm_remote_size(3)               MPI              MPI_Comm_remote_size(3)\n\n\n\nNAME\n       MPI_Comm_remote_size  -  Determines the size of the remote group  asso-\n       ciated with an inter-communictor\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_remote_size ( MPI_Comm comm, int *size )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       size   - number of processes in the group of comm (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_rsize.c\n\n\n\n                                  11/14/2001           MPI_Comm_remote_size(3)\n\n\n\n\nMPI_Comm_size\n\n\nMPI_Comm_size(3)                      MPI                     MPI_Comm_size(3)\n\n\n\nNAME\n       MPI_Comm_size  -   Determines  the  size of the group associated with a\n       communictor\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_size ( MPI_Comm comm, int *size )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       size   - number of processes in the group of comm (integer)\n\n\nNOTES\n       MPI_COMM_NULL is not considered a valid argument to this function.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_size.c\n\n\n\n                                  11/14/2001                  MPI_Comm_size(3)\n\n\n\n\nMPI_Comm_split\n\n\nMPI_Comm_split(3)                     MPI                    MPI_Comm_split(3)\n\n\n\nNAME\n       MPI_Comm_split -  Creates new communicators based on colors and keys\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_split ( MPI_Comm comm, int color, int key, MPI_Comm *comm_out )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n       color  - control of subset assignment (nonnegative integer).  Processes\n              with the same color are in the same new communicator\n       key    - control of rank assigment (integer)\n\n\nOUTPUT PARAMETER\n       newcomm\n              - new communicator (handle)\n\n\nNOTES\n       The color must be non-negative or MPI_UNDEFINED .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nALGORITHM\n       The current algorithm used has quite a few (read: a lot of) inefficien-\n       cies that can be removed.  Here is what we do for now\n\n       1) A table is built of colors, and keys (has a next field also).\n       2) The tables of all processes are merged using\n       MPI_Allreduce\n       .\n       3) Two contexts are allocated for all the comms to be created.  These\n       same two contexts can be used for all created communicators since\n       the communicators will not overlap.\n       4) If the local process has a color of\n       MPI_UNDEFINED\n       , it can return\n       a\n       NULL\n       comm.\n       5) The table entries that match the local process color are sorted\n       by key/rank.\n       6) A group is created from the sorted list and a communicator is created\n       with this group and the previously allocated contexts.\n\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Comm_free\n\nLOCATION\n       comm_split.c\n\n\n\n                                   8/29/2002                 MPI_Comm_split(3)\n\n\n\n\nMPI_Comm_test_inter\n\n\nMPI_Comm_test_inter(3)                MPI               MPI_Comm_test_inter(3)\n\n\n\nNAME\n       MPI_Comm_test_inter -  Tests to see if a comm is an inter-communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_test_inter ( MPI_Comm comm, int *flag )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       flag   - (logical)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_testic.c\n\n\n\n                                  11/14/2001            MPI_Comm_test_inter(3)\n\n\n\n\nMPI_Dims_create\n\n\nMPI_Dims_create(3)                    MPI                   MPI_Dims_create(3)\n\n\n\nNAME\n       MPI_Dims_create -  Creates a division of processors in a cartesian grid\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Dims_create(\n               int nnodes,\n               int ndims,\n               int *dims)\n\nINPUT PARAMETERS\n       nnodes - number of nodes in a grid (integer)\n       ndims  - number of cartesian dimensions (integer)\n\n\nIN/OUT PARAMETER\n       dims   - integer array of size ndims specifying the number of nodes  in\n              each dimension\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       dims_create.c\n\n\n\n                                   4/24/2002                MPI_Dims_create(3)\n\n\n\n\nMPI_Errhandler_create\n\n\nMPI_Errhandler_create(3)              MPI             MPI_Errhandler_create(3)\n\n\n\nNAME\n       MPI_Errhandler_create -  Creates an MPI-style errorhandler\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Errhandler_create(\n               MPI_Handler_function *function,\n               MPI_Errhandler       *errhandler)\n\nINPUT PARAMETER\n       function\n              - user defined error handling procedure\n\n\nOUTPUT PARAMETER\n       errhandler\n              - MPI error handler (handle)\n\n\nNOTES\n       The  MPI  Standard  states  that  an implementation may make the output\n       value (errhandler) simply the address of the  function.   However,  the\n       action  of  MPI_Errhandler_free  makes  this  impossible,  since  it is\n       required to set the value of the argument to MPI_ERRHANDLER_NULL .   In\n       addition,  the actual error handler must remain until all communicators\n       that use it are freed.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       errcreate.c\n\n\n\n                                  11/14/2001          MPI_Errhandler_create(3)\n\n\n\n\nMPI_Errhandler_free\n\n\nMPI_Errhandler_free(3)                MPI               MPI_Errhandler_free(3)\n\n\n\nNAME\n       MPI_Errhandler_free -  Frees an MPI-style errorhandler\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Errhandler_free( MPI_Errhandler *errhandler )\n\nINPUT PARAMETER\n       errhandler\n              -  MPI  error  handler  (handle).  Set to MPI_ERRHANDLER_NULL on\n              exit.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       errfree.c\n\n\n\n                                  11/14/2001            MPI_Errhandler_free(3)\n\n\n\n\nMPI_Errhandler_get\n\n\nMPI_Errhandler_get(3)                 MPI                MPI_Errhandler_get(3)\n\n\n\nNAME\n       MPI_Errhandler_get -  Gets the error handler for a communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Errhandler_get( MPI_Comm comm, MPI_Errhandler *errhandler )\n\nINPUT PARAMETER\n       comm   - communicator to get the error handler from (handle)\n\n\nOUTPUT PARAMETER\n       errhandler\n              - MPI error handler currently associated with communicator (han-\n              dle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTE ON IMPLEMENTATION\n       The  MPI Standard was unclear on whether this routine required the user\n       to call MPI_Errhandler_free once for each call made to this routine  in\n       order  to  free  the  error  handler.  After some debate, the MPI Forum\n       added an explicit statement that users are required to call MPI_Errhan-\n       dler_free  when the return value from this routine is no longer needed.\n       This behavior is similar to the other MPI routines for getting objects;\n       for  example, MPI_Comm_group requires that the user call MPI_Group_free\n       when the group returned by MPI_Comm_group is no longer needed.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       errget.c\n\n\n\n                                  11/14/2001             MPI_Errhandler_get(3)\n\n\n\n\nMPI_Errhandler_set\n\n\nMPI_Errhandler_set(3)                 MPI                MPI_Errhandler_set(3)\n\n\n\nNAME\n       MPI_Errhandler_set -  Sets the error handler for a communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Errhandler_set( MPI_Comm comm, MPI_Errhandler errhandler )\n\nINPUT PARAMETERS\n       comm   - communicator to set the error handler for (handle)\n       errhandler\n              - new MPI error handler for communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       errset.c\n\n\n\n                                  11/14/2001             MPI_Errhandler_set(3)\n\n\n\n\nMPI_Error_class\n\n\nMPI_Error_class(3)                    MPI                   MPI_Error_class(3)\n\n\n\nNAME\n       MPI_Error_class -  Converts an error code into an error class\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Error_class(\n               int errorcode,\n               int *errorclass)\n\nINPUT PARAMETER\n       errorcode\n              - Error code returned by an MPI routine\n\n\nOUTPUT PARAMETER\n       errorclass\n              - Error class associated with errorcode\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       errclass.c\n\n\n\n                                  11/14/2001                MPI_Error_class(3)\n\n\n\n\nMPI_Error_string\n\n\nMPI_Error_string(3)                   MPI                  MPI_Error_string(3)\n\n\n\nNAME\n       MPI_Error_string -  Return a string for a given error code\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Error_string( int errorcode, char *string, int *resultlen )\n\nINPUT PARAMETERS\n       errorcode\n              - Error code returned by an MPI routine or an MPI error class\n\n\nOUTPUT PARAMETER\n       string - Text that corresponds to the errorcode\n       resultlen\n              - Length of string\n\n              Notes:  Error codes are the values return by MPI routines (in C)\n              or in the ierr argument (in Fortran).  These  can  be  converted\n              into error classes with the routine MPI_Error_class .\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       errorstring.c\n\n\n\n                                  11/14/2001               MPI_Error_string(3)\n\n\n\n\nMPI_Finalize\n\n\nMPI_Finalize(3)                       MPI                      MPI_Finalize(3)\n\n\n\nNAME\n       MPI_Finalize -  Terminates MPI execution environment\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Finalize()\n\nNOTES\n       All  processes  must  call  this routine before exiting.  The number of\n       processes running after this routine is called is undefined; it is best\n       not  to perform much more than a return rc after calling MPI_Finalize .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       finalize.c\n\n\n\n                                   4/9/2002                    MPI_Finalize(3)\n\n\n\n\nMPI_Gather\n\n\nMPI_Gather(3)                         MPI                        MPI_Gather(3)\n\n\n\nNAME\n       MPI_Gather -  Gathers together values from a group of processes\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Gather ( void *sendbuf, int sendcnt, MPI_Datatype sendtype,\n                       void *recvbuf, int recvcount, MPI_Datatype recvtype,\n                       int root, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              -  number  of elements for any single receive (integer, signifi-\n              cant only at root)\n       recvtype\n              - data type of recv buffer elements (significant only  at  root)\n              (handle)\n       root   - rank of receiving process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice, significant only at root )\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\nLOCATION\n       gather.c\n\n\n\n                                  11/14/2001                     MPI_Gather(3)\n\n\n\n\nMPI_Gatherv\n\n\nMPI_Gatherv(3)                        MPI                       MPI_Gatherv(3)\n\n\n\nNAME\n       MPI_Gatherv -  Gathers into specified locations from all processes in a\n       group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Gatherv ( void *sendbuf, int sendcnt, MPI_Datatype sendtype,\n                         void *recvbuf, int *recvcnts, int *displs,\n                        MPI_Datatype recvtype,\n                         int root, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcounts\n              - integer array (of length group size) containing the number  of\n              elements  that  are received from each process (significant only\n              at root )\n       displs - integer array (of length group size). Entry  i  specifies  the\n              displacement relative to recvbuf  at which to place the incoming\n              data from process i (significant only at root)\n       recvtype\n              - data type of recv buffer elements (significant only at root  )\n              (handle)\n       root   - rank of receiving process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice, significant only at root )\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       gatherv.c\n\n\n\n                                   2/19/2002                    MPI_Gatherv(3)\n\n\n\n\nMPI_Get_count\n\n\nMPI_Get_count(3)                      MPI                     MPI_Get_count(3)\n\n\n\nNAME\n       MPI_Get_count -  Gets the number of \"top level\" elements\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Get_count(\n               MPI_Status *status,\n               MPI_Datatype datatype,\n               int *count )\n\nINPUT PARAMETERS\n       status - return status of receive operation (Status)\n       datatype\n              - datatype of each receive buffer element (handle)\n\n\nOUTPUT PARAMETER\n       count  -  number  of  received elements (integer) Notes: If the size of\n              the datatype is zero, this routine will return a count of  zero.\n              If  the amount of data in status is not an exact multiple of the\n              size of datatype (so that count would not be integral), a  count\n              of MPI_UNDEFINED is returned instead.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       getcount.c\n\n\n\n                                  11/14/2001                  MPI_Get_count(3)\n\n\n\n\nMPI_Get_elements\n\n\nMPI_Get_elements(3)                   MPI                  MPI_Get_elements(3)\n\n\n\nNAME\n       MPI_Get_elements -  Returns the number of basic elements in a datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Get_elements ( MPI_Status *status, MPI_Datatype datatype,\n                             int *elements )\n\nINPUT PARAMETERS\n       status - return status of receive operation (Status)\n       datatype\n              - datatype used by receive operation (handle)\n\n\nOUTPUT PARAMETER\n       count  - number of received basic elements (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\n\nLOCATION\n       getelements.c\n\n\n\n                                  11/14/2001               MPI_Get_elements(3)\n\n\n\n\nMPI_Get_processor_name\n\n\nMPI_Get_processor_name(3)             MPI            MPI_Get_processor_name(3)\n\n\n\nNAME\n       MPI_Get_processor_name -  Gets the name of the processor\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Get_processor_name(\n               char *name,\n               int *resultlen)\n\nOUTPUT PARAMETERS\n       name   -  A  unique  specifier  for  the actual (as opposed to virtual)\n              node. This must be an array of  size  at  least  MPI_MAX_PROCES-\n              SOR_NAME .\n\n       resultlen\n              - Length (in characters) of the name\n\n\nNOTES\n       The  name  returned should identify a particular piece of hardware; the\n       exact format is implementation defined.  This name may or  may  not  be\n       the same as might be returned by gethostname , uname , or sysinfo .\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       getpname.c\n\n\n\n                                  11/14/2001         MPI_Get_processor_name(3)\n\n\n\n\nMPI_Get_version\n\n\nMPI_Get_version(3)                    MPI                   MPI_Get_version(3)\n\n\n\nNAME\n       MPI_Get_version -  Gets the version of MPI\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Get_version(\n               int *version,\n               int *subversion )\n\nOUTPUT PARAMETERS\n       version\n              - Major version of MPI (1 or 2)\n       subversion\n              - Minor version of MPI.\n\n\nNOTES\n       The  defined  values  MPI_VERSION  and  MPI_SUBVERSION contain the same\n       information.  This routine allows you to check that the library matches\n       the version specified in the mpi.h and mpif.h files.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       getversion.c\n\n\n\n                                  11/14/2001                MPI_Get_version(3)\n\n\n\n\n\nMPI_Graph_create\n\n\nMPI_Graph_create(3)                   MPI                  MPI_Graph_create(3)\n\n\n\nNAME\n       MPI_Graph_create -  Makes a new communicator to which topology informa-\n       tion has been attached\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Graph_create ( MPI_Comm comm_old, int nnodes, int *index, int *edges,\n                             int reorder, MPI_Comm *comm_graph )\n\nINPUT PARAMETERS\n       comm_old\n              - input communicator without topology (handle)\n       nnodes - number of nodes in graph (integer)\n       index  - array of integers describing node degrees (see below)\n       edges  - array of integers describing graph edges (see below)\n       reorder\n              - ranking may be reordered (true) or not (false) (logical)\n\n\nOUTPUT PARAMETER\n       comm_graph\n              - communicator with graph topology added (handle)\n\n\nALGORITHM\n       We ignore the reorder info currently.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graphcreate.c\n\n\n\n                                   1/4/2002                MPI_Graph_create(3)\n\n\n\n\nMPI_Graphdims_get\n\n\nMPI_Graphdims_get(3)                  MPI                 MPI_Graphdims_get(3)\n\n\n\nNAME\n       MPI_Graphdims_get  -   Retrieves  graph topology information associated\n       with a  communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Graphdims_get ( MPI_Comm comm, int *nnodes, int *nedges )\n\nINPUT PARAMETERS\n       comm   - communicator for group with graph structure (handle)\n\n\nOUTPUT PARAMETER\n       nnodes - number of nodes in graph (integer)\n       nedges - number of edges in graph (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graphdimsget.c\n\n\n\n                                  11/14/2001              MPI_Graphdims_get(3)\n\n\n\n\nMPI_Graph_get\n\n\nMPI_Graph_get(3)                      MPI                     MPI_Graph_get(3)\n\n\n\nNAME\n       MPI_Graph_get -  Retrieves graph topology information associated with a\n       communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Graph_get ( MPI_Comm comm, int maxindex, int maxedges,\n                          int *index, int *edges )\n\nINPUT PARAMETERS\n       comm   - communicator with graph structure (handle)\n       maxindex\n              - length of vector index in the calling program  (integer)\n       maxedges\n              - length of vector edges in the calling program  (integer)\n\n\nOUTPUT PARAMETER\n       index  - array of integers containing the graph structure (for  details\n              see the definition of MPI_GRAPH_CREATE )\n       edges  - array of integers containing the graph structure\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graph_get.c\n\n\n\n                                   1/4/2002                   MPI_Graph_get(3)\n\n\n\n\nMPI_Graph_map\n\n\nMPI_Graph_map(3)                      MPI                     MPI_Graph_map(3)\n\n\n\nNAME\n       MPI_Graph_map -  Maps process to graph topology information\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Graph_map ( MPI_Comm comm_old, int nnodes, int *index, int *edges,\n                          int *newrank )\n\nINPUT PARAMETERS\n       comm   - input communicator (handle)\n       nnodes - number of graph nodes (integer)\n       index  -   integer   array   specifying   the   graph   structure,  see\n              MPI_GRAPH_CREATE\n\n       edges  - integer array specifying the graph structure\n\n\nOUTPUT PARAMETER\n       newrank\n              - reordered rank of the calling process;  MPI_UNDEFINED  if  the\n              calling process does not belong to graph (integer)\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graph_map.c\n\n\n\n                                   1/4/2002                   MPI_Graph_map(3)\n\n\n\n\nMPI_Graph_neighbors_count\n\n\nMPI_Graph_neighbors_count(3)          MPI         MPI_Graph_neighbors_count(3)\n\n\n\nNAME\n       MPI_Graph_neighbors_count  -  Returns the number of neighbors of a node\n       associated with a graph topology\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Graph_neighbors_count ( MPI_Comm comm, int rank, int *nneighbors )\n\nINPUT PARAMETERS\n       comm   - communicator with graph topology (handle)\n       rank   - rank of process in group of comm (integer)\n\n\nOUTPUT PARAMETER\n       nneighbors\n              - number of neighbors of specified process (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       graphnbrcnt.c\n\n\n\n                                  11/14/2001      MPI_Graph_neighbors_count(3)\n\n\n\n\nMPI_Graph_neighbors\n\n\nMPI_Graph_neighbors(3)                MPI               MPI_Graph_neighbors(3)\n\n\n\nNAME\n       MPI_Graph_neighbors -  Returns the neighbors of a node associated  with\n       a graph topology\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Graph_neighbors ( MPI_Comm comm, int rank, int maxneighbors,\n                               int *neighbors )\n\nINPUT PARAMETERS\n       comm   - communicator with graph topology (handle)\n       rank   - rank of process in group of comm (integer)\n       maxneighbors\n              - size of array neighbors (integer)\n\n\nOUTPUT PARAMETERS\n       neighbors\n              - ranks of processes that are  neighbors  to  specified  process\n              (array of integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       graph_nbr.c\n\n\n\n                                  11/14/2001            MPI_Graph_neighbors(3)\n\n\n\n\nMPI_Group_compare\n\n\nMPI_Group_compare(3)                  MPI                 MPI_Group_compare(3)\n\n\n\nNAME\n       MPI_Group_compare -  Compares two groups\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_compare ( MPI_Group group1, MPI_Group group2, int *result )\n\nINPUT PARAMETERS\n       group1 - group1 (handle)\n       group2 - group2 (handle)\n\n\nOUTPUT PARAMETER\n       result - integer which is MPI_IDENT if the order and members of the two\n              groups are the same, MPI_SIMILAR if only  the  members  are  the\n              same, and MPI_UNEQUAL otherwise\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       groupcompare.c\n\n\n\n                                  11/14/2001              MPI_Group_compare(3)\n\n\n\n\nMPI_Group_difference\n\n\nMPI_Group_difference(3)               MPI              MPI_Group_difference(3)\n\n\n\nNAME\n       MPI_Group_difference -  Makes a group from the difference of two groups\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_difference ( MPI_Group group1, MPI_Group group2,\n                                MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group1 - first group (handle)\n       group2 - second group (handle)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - difference group (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_diff.c\n\n\n\n                                  11/14/2001           MPI_Group_difference(3)\n\n\n\n\nMPI_Group_excl\n\n\nMPI_Group_excl(3)                     MPI                    MPI_Group_excl(3)\n\n\n\nNAME\n       MPI_Group_excl  -  Produces a group by reordering an existing group and\n       taking only unlisted members\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_excl ( MPI_Group group, int n, int *ranks, MPI_Group *newgroup )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of elements in array ranks (integer)\n       ranks  - array of integer ranks in group not to appear in newgroup\n\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, preserving the order defined  by\n              group (handle)\n\n\nNOTE\n       Currently,  each  of  the  ranks to exclude must be a valid rank in the\n       group and all elements must be distinct or the function  is  erroneous.\n       This restriction is per the draft.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_excl.c\n\n\n\n                                  11/14/2001                 MPI_Group_excl(3)\n\n\n\n\nMPI_Group_free\n\n\nMPI_Group_free(3)                     MPI                    MPI_Group_free(3)\n\n\n\nNAME\n       MPI_Group_free -  Frees a group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_free ( MPI_Group *group )\n       Input Parameter\n       group  - group (handle)\n\n\nNOTES\n       On output, group is set to MPI_GROUP_NULL .\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              groups.\n\nLOCATION\n       group_free.c\n\n\n\n                                  11/14/2001                 MPI_Group_free(3)\n\n\n\n\nMPI_Group_incl\n\n\nMPI_Group_incl(3)                     MPI                    MPI_Group_incl(3)\n\n\n\nNAME\n       MPI_Group_incl  -  Produces a group by reordering an existing group and\n       taking only listed members\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_incl ( MPI_Group group, int n, int *ranks, MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of elements in array ranks  (and  size  of  newgroup  )\n              (integer)\n       ranks  -  ranks  of  processes in group to appear in newgroup (array of\n              integers)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, in the order defined by ranks\n\n              (handle)\n\n\nNOTE\n       This implementation does not currently check to see that  the  list  of\n       ranks to ensure that there are no duplicates.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_incl.c\n\n\n\n                                  11/14/2001                 MPI_Group_incl(3)\n\n\n\n\nMPI_Group_intersection\n\n\nMPI_Group_intersection(3)             MPI            MPI_Group_intersection(3)\n\n\n\nNAME\n       MPI_Group_intersection  -   Produces a group as the intersection of two\n       existing groups\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_intersection ( MPI_Group group1, MPI_Group group2,\n                                  MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group1 - first group (handle)\n       group2 - second group (handle)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - intersection group (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_inter.c\n\n\n\n                                  11/14/2001         MPI_Group_intersection(3)\n\n\n\n\nMPI_Group_range_excl\n\n\nMPI_Group_range_excl(3)               MPI              MPI_Group_range_excl(3)\n\n\n\nNAME\n       MPI_Group_range_excl  -   Produces  a group by excluding ranges of pro-\n       cesses from an existing group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_range_excl ( MPI_Group group, int n, int ranges[][3],\n                                MPI_Group *newgroup )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of elements in array ranks (integer)\n       ranges - a one-dimensional array of integer triplets of the form (first\n              rank,  last rank, stride), indicating the ranks in group of pro-\n              cesses to be excluded from the output group newgroup .\n\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, preserving the  order  in  group\n              (handle)\n\n\nNOTE\n       Currently,  each  of  the  ranks to exclude must be a valid rank in the\n       group and all elements must be distinct or the function  is  erroneous.\n       This restriction is per the draft.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_rexcl.c\n\n\n\n                                  11/14/2001           MPI_Group_range_excl(3)\n\n\n\n\nMPI_Group_range_incl\n\n\nMPI_Group_range_incl(3)               MPI              MPI_Group_range_incl(3)\n\n\n\nNAME\n       MPI_Group_range_incl  -  Creates a new group from ranges of ranks in an\n       existing group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_range_incl ( MPI_Group group, int n, int ranges[][3],\n                                MPI_Group *newgroup )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of triplets in array ranges (integer)\n       ranges - a one-dimensional array  of  integer  triplets,  of  the  form\n              (first  rank,  last  rank,  stride) indicating ranks in group or\n              processes to be included in newgroup\n\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, in the order defined  by  ranges\n              (handle)\n\n\nNOTE\n       This  implementation  does  not currently check to see that the list of\n       ranges to include are valid ranks in the group.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_rincl.c\n\n\n\n                                  11/14/2001           MPI_Group_range_incl(3)\n\n\n\n\nMPI_Group_rank\n\n\nMPI_Group_rank(3)                     MPI                    MPI_Group_rank(3)\n\n\n\nNAME\n       MPI_Group_rank -  Returns the rank of this process in the given group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_rank ( MPI_Group group, int *rank )\n\nINPUT PARAMETERS\n       group  - group (handle)\n\n\nOUTPUT PARAMETER\n       rank   -  rank of the calling process in group, or MPI_UNDEFINED if the\n              process is not a member (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       group_rank.c\n\n\n\n                                  11/14/2001                 MPI_Group_rank(3)\n\n\n\n\nMPI_Group_size\n\n\nMPI_Group_size(3)                     MPI                    MPI_Group_size(3)\n\n\n\nNAME\n       MPI_Group_size -  Returns the size of a group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_size ( MPI_Group group, int *size )\n\nINPUT PARAMETERS\n       group  - group (handle) Output Parameter:\n       size   - number of processes in the group (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       group_size.c\n\n\n\n                                  11/14/2001                 MPI_Group_size(3)\n\n\n\n\nMPI_Group_translate_ranks\n\n\nMPI_Group_translate_ranks(3)          MPI         MPI_Group_translate_ranks(3)\n\n\n\nNAME\n       MPI_Group_translate_ranks  -   Translates the ranks of processes in one\n       group to  those in another group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_translate_ranks ( MPI_Group group_a, int n, int *ranks_a,\n                                    MPI_Group group_b, int *ranks_b )\n\nINPUT PARAMETERS\n       group1 - group1 (handle)\n       n      - number of ranks in ranks1 and ranks2 arrays (integer)\n       ranks1 - array of zero or more valid ranks in group1\n\n       group2 - group2 (handle)\n\n\nOUTPUT PARAMETER\n       ranks2 - array of corresponding ranks in group2, MPI_UNDEFINED when  no\n              correspondence exists.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       group_tranks.c\n\n\n\n                                  11/14/2001      MPI_Group_translate_ranks(3)\n\n\n\n\nMPI_Group_union\n\n\nMPI_Group_union(3)                    MPI                   MPI_Group_union(3)\n\n\n\nNAME\n       MPI_Group_union -  Produces a group by combining two groups\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_union ( MPI_Group group1, MPI_Group group2,\n                            MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group1 - first group (handle)\n       group2 - second group (handle)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - union group (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_union.c\n\n\n\n                                  11/14/2001                MPI_Group_union(3)\n\n\n\n\nMPI_Ibsend\n\n\nMPI_Ibsend(3)                         MPI                        MPI_Ibsend(3)\n\n\n\nNAME\n       MPI_Ibsend -  Starts a nonblocking buffered send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Ibsend( void *buf, int count, MPI_Datatype datatype, int dest, int tag,\n                      MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\n\nLOCATION\n       ibsend.c\n\n\n\n                                  11/14/2001                     MPI_Ibsend(3)\n\n\n\n\nMPI_Initialized\n\n\nMPI_Initialized(3)                    MPI                   MPI_Initialized(3)\n\n\n\nNAME\n       MPI_Initialized -  Indicates whether MPI_Init has been called.\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Initialized( int *flag )\n\nOUTPUT PARAMETER\n       flag   -  Flag is true if MPI_Init has been called and false otherwise.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       initialize.c\n\n\n\n                                  11/14/2001                MPI_Initialized(3)\n\n\n\n\nMPI_Init\n\n\nMPI_Init(3)                           MPI                          MPI_Init(3)\n\n\n\nNAME\n       MPI_Init -  Initialize the MPI execution environment\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Init(int *argc, char ***argv)\n\nINPUT PARAMETERS\n       argc   - Pointer to the number of arguments\n       argv   - Pointer to the argument vector\n\n\nCOMMAND LINE ARGUMENTS\n       MPI specifies no command-line arguments but does allow an MPI implemen-\n       tation to make use of them.\n\n       -mpiqueue\n              - print out the state of the message queues when MPI_FINALIZE is\n              called.   All  processors print; the output may be hard to deci-\n              pher.  This is intended as a debugging aid.\n\n       -mpiversion\n              - print out the version of the implementation  (  not  of  MPI),\n              including the arguments that were used with configure.\n\n       -mpinice nn\n              -  Increments the nice value by nn (lowering the priority of the\n              program by nn ).  nn must be positive (except  for  root).   Not\n              all systems support this argument; those that do not will ignore\n              it.\n\n       -mpedbg\n              - Start a debugger in an xterm  window  if  there  is  an  error\n              (either detected by MPI or a normally fatal signal).  This works\n              only if MPICH was configured with -mpedbg .  CURRENTLY DISABLED.\n              If  you  have  TotalView, -mpichtv or mpirun -tv will give you a\n              better environment anyway.\n\n       -mpimem\n              - If MPICH was built with -DMPIR_DEBUG_MEM  ,  this  checks  all\n              malloc  and  free  operations  (internal  to MPICH) for signs of\n              injury to the memory allocation areas.\n\n       -mpidb options\n              - Activate various debugging options.  Some require  that  MPICH\n              have  been  built  with special options.  These are intended for\n              debugging MPICH, not for debugging user programs.  The available\n              options include:\n              mem     - Enable dynamic memory tracing of internal MPI objects\n              memall  - Generate output of all memory allocation/deallocation\n              ptr     - Enable tracing of internal MPI pointer conversions\n              rank n  - Limit subsequent -mpidb options to on the process with\n              the specified rank in MPI_COMM_WORLD.  A rank of -1\n              selects all of MPI_COMM_WORLD.\n              ref     - Trace use of internal MPI objects\n              reffile filename - Trace use of internal MPI objects with output\n              to the indicated file\n              trace   - Trace routine calls\n\n\n\nNOTES\n       Note  that  the  Fortran  binding  for  this routine has only the error\n       return argument ( MPI_INIT(ierror) )\n\n       Because the Fortran and C versions of MPI_Init are different, there  is\n       a  restriction  on  who can call MPI_Init .  The version (Fortran or C)\n       must match the main program.  That is, if the main  program  is  in  C,\n       then  the C version of MPI_Init must be called.  If the main program is\n       in Fortran, the Fortran version must be called.\n\n       On exit from this routine, all processes will have a copy of the  argu-\n       ment  list.   This  is  not  required  by  the MPI standard, and truely\n       portable codes should not rely on it.  This is provided as a service by\n       this implementation (an MPI implementation is allowed to distribute the\n       command line arguments but is not required to).\n\n       Command line arguments are not provided to Fortran programs.  More pre-\n       cisely,  non-standard  Fortran  routines  such as getarg and iargc have\n       undefined behavior in MPI and in this implementation.\n\n       The MPI standard does not say what a program can do before an  MPI_INIT\n       or  after an MPI_FINALIZE .  In the MPICH implementation, you should do\n       as little as possible.  In particular, avoid anything that changes  the\n       external  state of the program, such as opening files, reading standard\n       input or writing to standard output.\n\n\nSIGNALS USED\n       The MPI standard requires that all signals  used  be  documented.   The\n       MPICH  implementation  itself uses no signals, but some of the software\n       that MPICH relies on may use some signals.  The list below  is  partial\n       and  should  be  independantly checked if you (and any package that you\n       use) depend on particular signals.\n\n\nIBM POE/MPL FOR SP2\n       SIGHUP, SIGINT, SIGQUIT, SIGFPE, SIGSEGV,  SIGPIPE,  SIGALRM,  SIGTERM,\n       SIGIO\n\n\n-MPEDBG SWITCH\n       SIGQUIT, SIGILL, SIGFPE, SIGBUS, SIGSEGV, SIGSYS\n\n\nMEIKO CS2\n       SIGUSR2\n\n\nCH_P4 DEVICE\n       SIGUSR1\n\n       The ch_p4 device also catches SIGINT, SIGFPE, SIGBUS, and SIGSEGV; this\n       helps the p4 device (and MPICH) more gracefully abort a failed program.\n\n\nINTEL PARAGON (CH_NX AND NX DEVICE)\n       SIGUSR2\n\n\nSHARED MEMORY (CH_SHMEM DEVICE)\n       SIGCHLD\n\n       Note  that  if  you are using software that needs the same signals, you\n       may find that there is no way to use that software with the MPI  imple-\n       mentation.   The  signals  that cause the most trouble for applications\n       include SIGIO , SIGALRM , and SIGPIPE .  For example, using  SIGIO  and\n       SIGPIPE may prevent X11 routines from working.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_OTHER\n              - This error class is associated with an error code  that  indi-\n              cates  that  an attempt was made to call MPI_INIT a second time.\n              MPI_INIT may only be called once in a program.\n\nLOCATION\n       init.c\n\n\n\n                                   4/8/2002                        MPI_Init(3)\n\n\n\n\nmpi_init_thread\n\n\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\" />\n<title>404 Not Found</title>\n</head>\n\n<body>\n<p><strong>HTTP 404 - Not Found</strong><p />\n\nThe requested URL was not found on this server.\n</body>\n</html>\n\n\n\n\nMPI_Intercomm_create\n\n\nMPI_Intercomm_create(3)               MPI              MPI_Intercomm_create(3)\n\n\n\nNAME\n       MPI_Intercomm_create  -  Creates an intercommuncator from two intracom-\n       municators\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Intercomm_create ( MPI_Comm local_comm, int local_leader,\n                                MPI_Comm peer_comm, int remote_leader, int tag,\n                                MPI_Comm *comm_out )\n\nINPUT PARAMTERS\n       local_comm\n              - Local (intra)communicator\n       local_leader\n              - Rank in local_comm of leader (often 0)\n       peer_comm\n              - Remote communicator\n       remote_leader\n              - Rank in peer_comm of remote leader (often 0)\n       tag    - Message tag to use in constructing intercommunicator; if  mul-\n              tiple MPI_Intercomm_creates are being made, they should use dif-\n              ferent tags (more precisely, ensure that the  local  and  remote\n              leaders  are  using different tags for each MPI_intercomm_create\n              ).\n\n\nOUTPUT PARAMETER\n       comm_out\n              - Created intercommunicator\n\n\nNOTES\n       The MPI 1.1 Standard contains two mutually exclusive  comments  on  the\n       input intracommunicators.  One says that their repective groups must be\n       disjoint; the other that the leaders can be the  same  process.   After\n       some  discussion  by the MPI Forum, it has been decided that the groups\n       must be disjoint.  Note that the reason given for this in the  standard\n       is  not  the  reason  for  this choice; rather, the other operations on\n       intercommunicators (like MPI_Intercomm_merge ) do not make sense if the\n       groups are not disjoint.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nALGORITHM\n       1) Allocate a send context, an inter\n              - coll context, and an intra-coll context\n       2) Send send_context and lrank_to_grank list from local comm group\n              - if I'm the local_leader.\n       3) If I'm the local leader, then wait on the posted sends and receives\n              - to complete.  Post the receive for the remote  group  informa-\n              tion and wait for it to complete.\n       4) Broadcast information received from the remote leader.\n              - . 5) Create the inter_communicator from the information we now\n              have.\n       An inter\n              - communicator ends up with three levels of communicators.   The\n              inter-communicator  returned  to the user, a \"collective\" inter-\n              communicator that can be used for  safe  communications  between\n              local  & remote groups, and a collective intra-communicator that\n              can be used to allocate new contexts during the  merge  and  dup\n              operations.\n\n              For the resulting inter-communicator, comm_out\n\n\n              comm_out                       = inter-communicator\n              comm_out->comm_coll            = \"collective\" inter-communicator\n              comm_out->comm_coll->comm_coll = safe collective intra-communicator\n\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Intercomm_merge, MPI_Comm_free, MPI_Comm_remote_group,\n       MPI_Comm_remote_size\n\nLOCATION\n       ic_create.c\n\n\n\n                                  11/14/2001           MPI_Intercomm_create(3)\n\n\n\n\nMPI_Intercomm_merge\n\n\nMPI_Intercomm_merge(3)                MPI               MPI_Intercomm_merge(3)\n\n\n\nNAME\n       MPI_Intercomm_merge  -  Creates an intracommuncator from an intercommu-\n       nicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Intercomm_merge ( MPI_Comm comm, int high, MPI_Comm *comm_out )\n\nINPUT PARAMETERS\n       comm   - Intercommunicator\n       high   - Used to order the groups of the two intracommunicators  within\n              comm when creating the new communicator.\n\n\nOUTPUT PARAMETER\n       comm_out\n              - Created intracommunicator\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nALGORITHM\n       1) Allocate two contexts\n       2) Local and remote group leaders swap high values\n       3) Determine the high value.\n       4) Merge the two groups and make the intra-communicator\n\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Intercomm_create, MPI_Comm_free\n\nLOCATION\n       ic_merge.c\n\n\n\n                                  11/14/2001            MPI_Intercomm_merge(3)\n\n\n\n\nMPI_Iprobe\n\n\nMPI_Iprobe(3)                         MPI                        MPI_Iprobe(3)\n\n\n\nNAME\n       MPI_Iprobe -  Nonblocking test for a message\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Iprobe( int source, int tag, MPI_Comm comm, int *flag,\n                      MPI_Status *status )\n\nINPUT PARAMETERS\n       source - source rank, or MPI_ANY_SOURCE (integer)\n       tag    - tag value or MPI_ANY_TAG (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       flag   - (logical)\n       status - status object (Status)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       iprobe.c\n\n\n\n                                   12/7/2004                     MPI_Iprobe(3)\n\n\n\n\nMPI_Irecv\n\n\nMPI_Irecv(3)                          MPI                         MPI_Irecv(3)\n\n\n\nNAME\n       MPI_Irecv -  Begins a nonblocking receive\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Irecv( void *buf, int count, MPI_Datatype datatype, int source,\n                      int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of receive buffer (choice)\n       count  - number of elements in receive buffer (integer)\n       datatype\n              - datatype of each receive buffer element (handle)\n       source - rank of source (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       irecv.c\n\n\n\n                                  11/14/2001                      MPI_Irecv(3)\n\n\n\n\nMPI_Irsend\n\n\nMPI_Irsend(3)                         MPI                        MPI_Irsend(3)\n\n\n\nNAME\n       MPI_Irsend -  Starts a nonblocking ready send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Irsend( void *buf, int count, MPI_Datatype datatype, int dest,\n                      int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle) Output Parameter:\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nLOCATION\n       irsend.c\n\n\n\n                                  11/14/2001                     MPI_Irsend(3)\n\n\n\n\nMPI_Isend\n\n\nMPI_Isend(3)                          MPI                         MPI_Isend(3)\n\n\n\nNAME\n       MPI_Isend -  Begins a nonblocking send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Isend( void *buf, int count, MPI_Datatype datatype, int dest, int tag,\n                      MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nLOCATION\n       isend.c\n\n\n\n                                  11/14/2001                      MPI_Isend(3)\n\n\n\n\nMPI_Issend\n\n\nMPI_Issend(3)                         MPI                        MPI_Issend(3)\n\n\n\nNAME\n       MPI_Issend -  Starts a nonblocking synchronous send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Issend( void *buf, int count, MPI_Datatype datatype, int dest,\n                      int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       issend.c\n\n\n\n                                  11/14/2001                     MPI_Issend(3)\n\n\n\n\nMPI_Keyval_create\n\n\nMPI_Keyval_create(3)                  MPI                 MPI_Keyval_create(3)\n\n\n\nNAME\n       MPI_Keyval_create -  Generates a new attribute key\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Keyval_create (\n               MPI_Copy_function *copy_fn,\n               MPI_Delete_function *delete_fn,\n               int *keyval,\n               void *extra_state )\n\nINPUT PARAMETERS\n       copy_fn\n              - Copy callback function for keyval\n\n       delete_fn\n              - Delete callback function for keyval\n\n       extra_state\n              - Extra state for callback functions\n\n\nOUTPUT PARAMETER\n       keyval - key value for future access (integer)\n\n\nNOTES\n       Key values are global (available for any and all communicators).\n\n       There  are  subtle  differences between C and Fortran that require that\n       the copy_fn be written in the same language that  MPI_Keyval_create  is\n       called  from.   This  should not be a problem for most users; only pro-\n       gramers using both Fortran and C in the same program need  to  be  sure\n       that they follow this rule.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       keyvalcreate.c\n\n\n\n                                  11/14/2001              MPI_Keyval_create(3)\n\n\n\n\nMPI_Keyval_free\n\n\nMPI_Keyval_free(3)                    MPI                   MPI_Keyval_free(3)\n\n\n\nNAME\n       MPI_Keyval_free -  Frees attribute key for communicator cache attribute\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Keyval_free ( int *keyval )\n\nINPUT PARAMETER\n       keyval - Frees the integer key value (integer)\n\n\nNOTE\n       Key values are global (they can be used with any and all communicators)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              keys.\n\n\nSEE ALSO\n       MPI_Keyval_create\n\nLOCATION\n       keyval_free.c\n\n\n\n                                   6/12/2002                MPI_Keyval_free(3)\n\n\n\n\nMPI_Op_create\n\n\nMPI_Op_create(3)                      MPI                     MPI_Op_create(3)\n\n\n\nNAME\n       MPI_Op_create -  Creates a user-defined combination function handle\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Op_create(\n               MPI_User_function *function,\n               int commute,\n               MPI_Op *op )\n\nINPUT PARAMETERS\n       function\n              - user defined function (function)\n       commute\n              - true if commutative;  false otherwise.\n\n\nOUTPUT PARAMETER\n       op     - operation (handle)\n\n\nNOTES ON THE USER FUNCTION\n       The calling list for the user function type is\n       typedef void (MPI_User_function) ( void * a,\n       void * b, int * len, MPI_Datatype * );\n\n       where  the  operation  is  b[i] = a[i] op b[i] , for i=0,...,len-1 .  A\n       pointer to the datatype given to the MPI collective computation routine\n       (i.e.,  MPI_Reduce , MPI_Allreduce , MPI_Scan , or MPI_Reduce_scatter )\n       is also passed to the user-specified routine.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The  reduction functions ( MPI_Op ) do not return an error value.  As a\n       result, if the functions detect an error, all they  can  do  is  either\n       call  MPI_Abort  or silently skip the problem.  Thus, if you change the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The  reason  for  this is the performance problems in ensuring that all\n       collective routines return the same error value.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Op_free\n\nLOCATION\n       opcreate.c\n\n\n\n                                  11/14/2001                  MPI_Op_create(3)\n\n\n\n\nMPI_Op_free\n\n\nMPI_Op_free(3)                        MPI                       MPI_Op_free(3)\n\n\n\nNAME\n       MPI_Op_free -  Frees a user-defined combination function handle\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Op_free( MPI_Op *op )\n\nINPUT PARAMETER\n       op     - operation (handle)\n\n\nNOTES\n       op is set to MPI_OP_NULL on exit.\n\n\nNULL HANDLES\n       The MPI 1.1 specification, in the section on opaque objects, explicitly\n\nDISALLOWS FREEING A NULL COMMUNICATOR. THE TEXT FROM THE STANDARD IS\n       A null handle argument is an erroneous IN argument in MPI calls, unless an\n       exception is explicitly stated in the text that defines the function. Such\n       exception is allowed for handles to request objects in Wait and Test calls\n       (sections Communication Completion and Multiple Completions ). Otherwise, a\n       null handle can only be passed to a function that allocates a new object and\n       returns a reference to it in the handle.\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_ARG\n              -  Invalid  argument;  the error code associated with this error\n              indicates an attempt to free an MPI permanent  operation  (e.g.,\n              MPI_SUM ).  *N/ /*N MPI_ERR_PERM_KEY\n       MPI_ERR_ARG\n              -  Invalid  argument;  the error code associated with this error\n              indicates an attempt to free or chnage an MPI  permanent  keyval\n              (e.g., MPI_TAG_UB ).  *N/ /*N MPI_ERR_UNKNOWN\n       MPI_ERR_UNKNOWN\n              -  Unknown error.  You should never see this.  If you do, report\n              it to mpi-bugs@mcs.anl.gov .\n\n\n\nSEE ALSO\n       MPI_Op_create\n\nLOCATION\n       opfree.c\n\n\n\n                                  11/14/2001                    MPI_Op_free(3)\n\n\n\n\nMPI_Pack\n\n\nMPI_Pack(3)                           MPI                          MPI_Pack(3)\n\n\n\nNAME\n       MPI_Pack -  Packs a datatype into contiguous memory\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Pack ( void *inbuf, int incount, MPI_Datatype datatype,\n                      void *outbuf, int outcount, int *position, MPI_Comm comm )\n\nINPUT PARAMETERS\n       inbuf  - input buffer start (choice)\n       incount\n              - number of input data items (integer)\n       datatype\n              - datatype of each input data item (handle)\n       outcount\n              - output buffer size, in bytes (integer)\n       position\n              - current position in buffer, in bytes (integer)\n       comm   - communicator for packed message (handle)\n\n\nOUTPUT PARAMETER\n       outbuf - output buffer start (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Unpack, MPI_Pack_size\n\n\nLOCATION\n       pack.c\n\n\n\n                                  11/14/2001                       MPI_Pack(3)\n\n\n\n\nMPI_Pack_size\n\n\nMPI_Pack_size(3)                      MPI                     MPI_Pack_size(3)\n\n\n\nNAME\n       MPI_Pack_size  -  Returns the upper bound on the amount of space needed\n       to pack a message\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Pack_size ( int incount, MPI_Datatype datatype, MPI_Comm comm,\n                          int *size )\n\nINPUT PARAMETERS\n       incount\n              - count argument to packing call (integer)\n       datatype\n              - datatype argument to packing call (handle)\n       comm   - communicator argument to packing call (handle)\n\n\nOUTPUT PARAMETER\n       size   - upper bound on size of packed message, in bytes (integer)\n\n\nNOTES\n       The MPI standard document describes this in terms of MPI_Pack , but  it\n       applies  to  both MPI_Pack and MPI_Unpack .  That is, the value size is\n       the maximum that is needed by either MPI_Pack or MPI_Unpack .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       pack_size.c\n\n\n\n                                  11/14/2001                  MPI_Pack_size(3)\n\n\n\n\nMPI_Pcontrol\n\n\nMPI_Pcontrol(3)                       MPI                      MPI_Pcontrol(3)\n\n\n\nNAME\n       MPI_Pcontrol -  Controls profiling\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Pcontrol( int level )\n\nINPUT PARAMETERS\n       level  - Profiling level\n\n\nNOTES\n       This  routine  provides  a common interface for profiling control.  The\n       interpretation of level and any other arguments is left to the  profil-\n       ing library.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       pcontrol.c\n\n\n\n                                  11/14/2001                   MPI_Pcontrol(3)\n\n\n\n\nMPI_Probe\n\n\nMPI_Probe(3)                          MPI                         MPI_Probe(3)\n\n\n\nNAME\n       MPI_Probe -  Blocking test for a message\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Probe( int source, int tag, MPI_Comm comm, MPI_Status *status )\n\nINPUT PARAMETERS\n       source - source rank, or MPI_ANY_SOURCE (integer)\n       tag    - tag value or MPI_ANY_TAG (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       status - status object (Status)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       probe.c\n\n\n\n                                   12/7/2004                      MPI_Probe(3)\n\n\n\n\nMPI_Recv_init\n\n\nMPI_Recv_init(3)                      MPI                     MPI_Recv_init(3)\n\n\n\nNAME\n       MPI_Recv_init -  Builds a handle for a receive\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Recv_init( void *buf, int count, MPI_Datatype datatype, int source,\n                         int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of receive buffer (choice)\n       count  - number of elements received (integer)\n       datatype\n              - type of each element (handle)\n       source - rank of source or MPI_ANY_SOURCE (integer)\n       tag    - message tag or MPI_ANY_TAG (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Start, MPI_Request_free\n\nLOCATION\n       create_recv.c\n\n\n\n                                  11/14/2001                  MPI_Recv_init(3)\n\n\n\n\nMPI_Recv\n\n\nMPI_Recv(3)                           MPI                          MPI_Recv(3)\n\n\n\nNAME\n       MPI_Recv -  Basic receive\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Recv( void *buf, int count, MPI_Datatype datatype, int source,\n                     int tag, MPI_Comm comm, MPI_Status *status )\n\nOUTPUT PARAMETERS\n       buf    - initial address of receive buffer (choice)\n       status - status object (Status)\n\n\nINPUT PARAMETERS\n       count  - maximum number of elements in receive buffer (integer)\n       datatype\n              - datatype of each receive buffer element (handle)\n       source - rank of source (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES\n       The  count  argument  indicates  the  maximum  length of a message; the\n       actual number can be determined with MPI_Get_count .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       recv.c\n\n\n\n                                   2/24/2004                       MPI_Recv(3)\n\n\n\n\nMPI_Reduce\n\n\nMPI_Reduce(3)                         MPI                        MPI_Reduce(3)\n\n\n\nNAME\n       MPI_Reduce -  Reduces values on all processes to a single value\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Reduce ( void *sendbuf, void *recvbuf, int count,\n                       MPI_Datatype datatype, MPI_Op op, int root, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - data type of elements of send buffer (handle)\n       op     - reduce operation (handle)\n       root   - rank of root process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice, significant only at root )\n\n\nALGORITHM\n       This implementation currently uses a simple tree algorithm.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The reduction functions ( MPI_Op ) do not return an error value.  As  a\n       result,  if  the  functions  detect an error, all they can do is either\n       call MPI_Abort or silently skip the problem.  Thus, if you  change  the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The reason for this is the performance problems in  ensuring  that  all\n       collective routines return the same error value.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_BUFFER\n              - This error class is associcated with an error code that  indi-\n              cates  that  two  buffer  arguments  are  aliased ; that is, the\n              describe overlapping storage (often  the  exact  same  storage).\n              This  is prohibited in MPI (because it is prohibited by the For-\n              tran standard, and rather than have a separate case  for  C  and\n              Fortran, the MPI Forum adopted the more restrictive requirements\n              of Fortran).\n\nLOCATION\n       reduce.c\n\n\n\n                                   2/19/2002                     MPI_Reduce(3)\n\n\n\n\nMPI_Reduce_scatter\n\n\nMPI_Reduce_scatter(3)                 MPI                MPI_Reduce_scatter(3)\n\n\n\nNAME\n       MPI_Reduce_scatter -  Combines values and scatters the results\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Reduce_scatter ( void *sendbuf, void *recvbuf, int *recvcnts,\n                              MPI_Datatype datatype, MPI_Op op, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       recvcounts\n              - integer array specifying the number of elements in result dis-\n              tributed to each process.  Array must be identical on all  call-\n              ing processes.\n       datatype\n              - data type of elements of input buffer (handle)\n       op     - operation (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - starting address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The reduction functions ( MPI_Op ) do not return an error value.  As  a\n       result,  if  the  functions  detect an error, all they can do is either\n       call MPI_Abort or silently skip the problem.  Thus, if you  change  the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The reason for this is the performance problems in  ensuring  that  all\n       collective routines return the same error value.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_OP\n              - Invalid operation.  MPI operations (objects of type  MPI_Op  )\n              must either be one of the predefined operations (e.g., MPI_SUM )\n              or created with MPI_Op_create .\n\n       MPI_ERR_BUFFER\n              - This error class is associcated with an error code that  indi-\n              cates  that  two  buffer  arguments  are  aliased ; that is, the\n              describe overlapping storage (often  the  exact  same  storage).\n              This  is prohibited in MPI (because it is prohibited by the For-\n              tran standard, and rather than have a separate case  for  C  and\n              Fortran, the MPI Forum adopted the more restrictive requirements\n              of Fortran).\n\nLOCATION\n       red_scat.c\n\n\n\n                                  11/14/2001             MPI_Reduce_scatter(3)\n\n\n\n\nMPI_Request_free\n\n\nMPI_Request_free(3)                   MPI                  MPI_Request_free(3)\n\n\n\nNAME\n       MPI_Request_free -  Frees a communication request object\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Request_free( MPI_Request *request )\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES\n       This  routine is normally used to free persistent requests created with\n       either MPI_Recv_init or MPI_Send_init and friends.  However, it can  be\n       used to free a request created with MPI_Irecv or MPI_Isend and friends;\n       in that case the use can not use the test/wait routines on the request.\n\n       It  is  permitted  to free an active request.  However, once freed, you\n       can not use the request in a wait or test routine (e.g., MPI_Wait ).\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       also: MPI_Isend, MPI_Irecv, MPI_Issend, MPI_Ibsend, MPI_Irsend,\n       MPI_Recv_init, MPI_Send_init, MPI_Ssend_init, MPI_Rsend_init, MPI_Wait,\n       MPI_Test, MPI_Waitall, MPI_Waitany, MPI_Waitsome, MPI_Testall, MPI_Tes-\n       tany, MPI_Testsome\n\nLOCATION\n       commreq_free.c\n\n\n\n                                  11/14/2001               MPI_Request_free(3)\n\n\n\n\nMPI_Rsend_init\n\n\nMPI_Rsend_init(3)                     MPI                    MPI_Rsend_init(3)\n\n\n\nNAME\n       MPI_Rsend_init -  Builds a handle for a ready send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Rsend_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                          int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Start, MPI_Request_free, MPI_Send_init\n\nLOCATION\n       rsend_init.c\n\n\n\n                                  11/14/2001                 MPI_Rsend_init(3)\n\n\n\n\nMPI_Rsend\n\n\nMPI_Rsend(3)                          MPI                         MPI_Rsend(3)\n\n\n\nNAME\n       MPI_Rsend -  Basic ready send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Rsend( void *buf, int count, MPI_Datatype datatype, int dest,\n                      int tag, MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       rsend.c\n\n\n\n                                  11/14/2001                      MPI_Rsend(3)\n\n\n\n\nMPI_Scan\n\n\nMPI_Scan(3)                           MPI                          MPI_Scan(3)\n\n\n\nNAME\n       MPI_Scan -  Computes the scan (partial reductions) of data on a collec-\n       tion of processes\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Scan ( void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype,\n                      MPI_Op op, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       count  - number of elements in input buffer (integer)\n       datatype\n              - data type of elements of input buffer (handle)\n       op     - operation (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - starting address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The  reduction functions ( MPI_Op ) do not return an error value.  As a\n       result, if the functions detect an error, all they  can  do  is  either\n       call  MPI_Abort  or silently skip the problem.  Thus, if you change the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The  reason  for  this is the performance problems in ensuring that all\n       collective routines return the same error value.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n       MPI_ERR_BUFFER\n              -  This error class is associcated with an error code that indi-\n              cates that two buffer arguments  are  aliased  ;  that  is,  the\n              describe  overlapping  storage  (often  the exact same storage).\n              This is prohibited in MPI (because it is prohibited by the  For-\n              tran  standard,  and  rather than have a separate case for C and\n              Fortran, the MPI Forum adopted the more restrictive requirements\n              of Fortran).\n\nLOCATION\n       scan.c\n\n\n\n                                  11/14/2001                       MPI_Scan(3)\n\n\n\n\nMPI_Scatter\n\n\nMPI_Scatter(3)                        MPI                       MPI_Scatter(3)\n\n\n\nNAME\n       MPI_Scatter -  Sends data from one task to all other tasks in a group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Scatter (\n               void *sendbuf,\n               int sendcnt,\n               MPI_Datatype sendtype,\n               void *recvbuf,\n               int recvcnt,\n               MPI_Datatype recvtype,\n               int root,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - address of send buffer (choice, significant only at root )\n       sendcount\n              -  number of elements sent to each process (integer, significant\n              only at root )\n       sendtype\n              - data type of send buffer elements (significant only at root  )\n              (handle)\n       recvcount\n              - number of elements in receive buffer (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       root   - rank of sending process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\nLOCATION\n       scatter.c\n\n\n\n                                   4/5/2004                     MPI_Scatter(3)\n\n\n\n\nMPI_Scatterv\n\n\nMPI_Scatterv(3)                       MPI                      MPI_Scatterv(3)\n\n\n\nNAME\n       MPI_Scatterv -  Scatters a buffer in parts to all tasks in a group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Scatterv (\n               void *sendbuf,\n               int *sendcnts,\n               int *displs,\n               MPI_Datatype sendtype,\n               void *recvbuf,\n               int recvcnt,\n               MPI_Datatype recvtype,\n               int root,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - address of send buffer (choice, significant only at root )\n       sendcounts\n              -  integer array (of length group size) specifying the number of\n              elements to send to each processor\n       displs - integer array (of length group size). Entry  i  specifies  the\n              displacement (relative to sendbuf  from which to take the outgo-\n              ing data to process i\n\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              - number of elements in receive buffer (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       root   - rank of sending process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       scatterv.c\n\n\n\n                                   2/21/2002                   MPI_Scatterv(3)\n\n\n\n\nMPI_Send_init\n\n\nMPI_Send_init(3)                      MPI                     MPI_Send_init(3)\n\n\n\nNAME\n       MPI_Send_init -  Builds a handle for a standard send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Send_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                         int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle) Output Parameter:\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Start, MPI_Startall, MPI_Request_free\n\nLOCATION\n       create_send.c\n\n\n\n                                  11/14/2001                  MPI_Send_init(3)\n\n\n\n\nMPI_Send\n\n\nMPI_Send(3)                           MPI                          MPI_Send(3)\n\n\n\nNAME\n       MPI_Send -  Performs a basic send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Send( void *buf, int count, MPI_Datatype datatype, int dest,\n                     int tag, MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES\n       This routine may block until the message is received.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Isend, MPI_Bsend\n\nLOCATION\n       send.c\n\n\n\n                                  11/14/2001                       MPI_Send(3)\n\n\n\n\nMPI_Sendrecv\n\n\nMPI_Sendrecv(3)                       MPI                      MPI_Sendrecv(3)\n\n\n\nNAME\n       MPI_Sendrecv -  Sends and receives a message\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Sendrecv( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                        int dest, int sendtag,\n                         void *recvbuf, int recvcount, MPI_Datatype recvtype,\n                        int source, int recvtag, MPI_Comm comm, MPI_Status *status )\n\nINPUT PARAMETERS\n       sendbuf\n              - initial address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - type of elements in send buffer (handle)\n       dest   - rank of destination (integer)\n       sendtag\n              - send tag (integer)\n       recvcount\n              - number of elements in receive buffer (integer)\n       recvtype\n              - type of elements in receive buffer (handle)\n       source - rank of source (integer)\n       recvtag\n              - receive tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETERS\n       recvbuf\n              - initial address of receive buffer (choice)\n       status - status object (Status).  This refers to the receive operation.\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       sendrecv.c\n\n\n\n                                  11/14/2001                   MPI_Sendrecv(3)\n\n\n\n\nMPI_Sendrecv_replace\n\n\nMPI_Sendrecv_replace(3)               MPI              MPI_Sendrecv_replace(3)\n\n\n\nNAME\n       MPI_Sendrecv_replace -  Sends and receives using a single buffer\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Sendrecv_replace( void *buf, int count, MPI_Datatype datatype,\n                               int dest, int sendtag, int source, int recvtag,\n                               MPI_Comm comm, MPI_Status *status )\n\nINPUT PARAMETERS\n       count  - number of elements in send and receive buffer (integer)\n       datatype\n              - type of elements in send and receive buffer (handle)\n       dest   - rank of destination (integer)\n       sendtag\n              - send message tag (integer)\n       source - rank of source (integer)\n       recvtag\n              - receive message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETERS\n       buf    - initial address of send and receive buffer (choice)\n       status - status object (Status)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TRUNCATE\n              - Message truncated on receive.  The buffer size  specified  was\n              too small for the received message.  This is a recoverable error\n              in the MPICH implementation.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nLOCATION\n       sendrecv_rep.c\n\n\n\n                                  11/14/2001           MPI_Sendrecv_replace(3)\n\n\n\n\nMPI_Ssend_init\n\n\nMPI_Ssend_init(3)                     MPI                    MPI_Ssend_init(3)\n\n\n\nNAME\n       MPI_Ssend_init -  Builds a handle for a synchronous send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Ssend_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                          int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       ssend_init.c\n\n\n\n                                  11/14/2001                 MPI_Ssend_init(3)\n\n\n\n\nMPI_Ssend\n\n\nMPI_Ssend(3)                          MPI                         MPI_Ssend(3)\n\n\n\nNAME\n       MPI_Ssend -  Basic synchronous send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Ssend( void *buf, int count, MPI_Datatype datatype,\n                      int dest, int tag, MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       ssend.c\n\n\n\n                                  11/14/2001                      MPI_Ssend(3)\n\n\n\n\nMPI_Startall\n\n\nMPI_Startall(3)                       MPI                      MPI_Startall(3)\n\n\n\nNAME\n       MPI_Startall -  Starts a collection of requests\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Startall( int count, MPI_Request array_of_requests[] )\n\nINPUT PARAMETERS\n       count  - list length (integer)\n       array_of_requests\n              - array of requests (array of handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       startall.c\n\n\n\n                                  11/14/2001                   MPI_Startall(3)\n\n\n\n\nMPI_Start\n\n\nMPI_Start(3)                          MPI                         MPI_Start(3)\n\n\n\nNAME\n       MPI_Start -  Initiates a communication with a persistent request handle\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Start(\n               MPI_Request *request)\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n\n\nLOCATION\n       start.c\n\n\n\n                                  11/14/2001                      MPI_Start(3)\n\n\n\n\nMPI_Testall\n\n\nMPI_Testall(3)                        MPI                       MPI_Testall(3)\n\n\n\nNAME\n       MPI_Testall  -   Tests  for  the completion of all previously initiated\n       communications\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Testall(\n               int count,\n               MPI_Request array_of_requests[],\n               int *flag,\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       count  - lists length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       flag   - (logical)\n       array_of_statuses\n              - array of status objects (array of Status).   May  be  MPI_STA-\n              TUSES_IGNORE .\n\n\n\nNOTES\n       flag  is  true only if all requests have completed.  Otherwise, flag is\n       false and neither the array_of_requests nor  the  array_of_statuses  is\n       modified.\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_IN_STATUS\n              -  The  actual  error value is in the MPI_Status argument.  This\n              error  class  is  returned  only  from  the  multiple-completion\n              routines  ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Wait-\n              all , MPI_Waitany , and MPI_Waitsome ).  The field MPI_ERROR  in\n              the  status argument contains the error value or MPI_SUCCESS (no\n              error and complete) or  MPI_ERR_PENDING  to  indicate  that  the\n              request  has  not  completed.  The MPI Standard does not specify\n              what the result of the multiple completion routines is  when  an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait for all requests to either fail or  complete,  or  does  it\n              return  immediately  (with  the  MPI  definition of immediately,\n              which means independent of  actions  of  other  MPI  processes)?\n              MPICH  has  chosen  to  make  the return immediate (alternately,\n              local in MPI terms), and to use the error class  MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.  In most cases, only one request with an error  will  be\n              detected  in  each  call  to  an MPI routine that tests multiple\n              requests.  The requests that have not been processed (because an\n              error  occured in one of the requests) will have their MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n\n\nLOCATION\n       testall.c\n\n\n\n                                   2/19/2003                    MPI_Testall(3)\n\n\n\n\nMPI_Testany\n\n\nMPI_Testany(3)                        MPI                       MPI_Testany(3)\n\n\n\nNAME\n       MPI_Testany  -  Tests for completion of any previdously initiated  com-\n       munication\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Testany(\n               int count,\n               MPI_Request array_of_requests[],\n               int *index, int *flag,\n               MPI_Status *status )\n\nINPUT PARAMETERS\n       count  - list length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       index  - index of operation that completed, or  MPI_UNDEFINED  if  none\n              completed (integer)\n       flag   - true if one of the operations is complete (logical)\n       status - status object (Status).  May be MPI_STATUS_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n\nLOCATION\n       testany.c\n\n\n\n                                   1/9/2003                     MPI_Testany(3)\n\n\n\n\nMPI_Test_cancelled\n\n\nMPI_Test_cancelled(3)                 MPI                MPI_Test_cancelled(3)\n\n\n\nNAME\n       MPI_Test_cancelled -  Tests to see if a request was cancelled\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Test_cancelled(\n               MPI_Status *status,\n               int        *flag)\n\nINPUT PARAMETER\n       status - status object (Status)\n\n\nOUTPUT PARAMETER\n       flag   - (logical)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       testcancel.c\n\n\n\n                                  11/14/2001             MPI_Test_cancelled(3)\n\n\n\n\nMPI_Test\n\n\nMPI_Test(3)                           MPI                          MPI_Test(3)\n\n\n\nNAME\n       MPI_Test -  Tests for the completion of a send or receive\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Test (\n               MPI_Request  *request,\n               int          *flag,\n               MPI_Status   *status)\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nOUTPUT PARAMETER\n       flag   - true if operation completed (logical)\n       status - status object (Status).  May be MPI_STATUS_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              -  Invalid  MPI_Request  .   Either  null  or,  in the case of a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       test.c\n\n\n\n                                   1/9/2003                        MPI_Test(3)\n\n\n\n\nMPI_Testsome\n\n\nMPI_Testsome(3)                       MPI                      MPI_Testsome(3)\n\n\n\nNAME\n       MPI_Testsome -  Tests for some given communications to complete\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Testsome(\n               int incount,\n               MPI_Request array_of_requests[],\n               int *outcount,\n               int array_of_indices[],\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       incount\n              - length of array_of_requests (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       outcount\n              - number of completed requests (integer)\n       array_of_indices\n              -  array of indices of operations that completed (array of inte-\n              gers)\n       array_of_statuses\n              - array of status objects for operations that  completed  (array\n              of Status).  May be MPI_STATUSES_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_IN_STATUS\n              -  The  actual  error value is in the MPI_Status argument.  This\n              error  class  is  returned  only  from  the  multiple-completion\n              routines  ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Wait-\n              all , MPI_Waitany , and MPI_Waitsome ).  The field MPI_ERROR  in\n              the  status argument contains the error value or MPI_SUCCESS (no\n              error and complete) or  MPI_ERR_PENDING  to  indicate  that  the\n              request  has  not  completed.  The MPI Standard does not specify\n              what the result of the multiple completion routines is  when  an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait for all requests to either fail or  complete,  or  does  it\n              return  immediately  (with  the  MPI  definition of immediately,\n              which means independent of  actions  of  other  MPI  processes)?\n              MPICH  has  chosen  to  make  the return immediate (alternately,\n              local in MPI terms), and to use the error class  MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.  In most cases, only one request with an error  will  be\n              detected  in  each  call  to  an MPI routine that tests multiple\n              requests.  The requests that have not been processed (because an\n              error  occured in one of the requests) will have their MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n\n\nLOCATION\n       testsome.c\n\n\n\n                                   1/9/2003                    MPI_Testsome(3)\n\n\n\n\nMPI_Topo_test\n\n\nMPI_Topo_test(3)                      MPI                     MPI_Topo_test(3)\n\n\n\nNAME\n       MPI_Topo_test  -   Determines  the type of topology (if any) associated\n       with a  communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Topo_test ( MPI_Comm comm, int *top_type )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       top_type\n              - topology type of communicator comm (choice).\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Graph_create, MPI_Cart_create\n\nLOCATION\n       topo_test.c\n\n\n\n                                  11/14/2001                  MPI_Topo_test(3)\n\n\n\n\nMPI_Type_commit\n\n\nMPI_Type_commit(3)                    MPI                   MPI_Type_commit(3)\n\n\n\nNAME\n       MPI_Type_commit -  Commits the datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_commit ( MPI_Datatype *datatype )\n\nINPUT PARAMETER\n       datatype\n              - datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       type_commit.c\n\n\n\n                                  11/14/2001                MPI_Type_commit(3)\n\n\n\n\nMPI_Type_contiguous\n\n\nMPI_Type_contiguous(3)                MPI               MPI_Type_contiguous(3)\n\n\n\nNAME\n       MPI_Type_contiguous -  Creates a contiguous datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_contiguous(\n               int count,\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype)\n\nINPUT PARAMETERS\n       count  - replication count (nonnegative integer)\n       oldtype\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_contig.c\n\n\n\n                                  11/14/2001            MPI_Type_contiguous(3)\n\n\n\n\nMPI_Type_extent\n\n\nMPI_Type_extent(3)                    MPI                   MPI_Type_extent(3)\n\n\n\nNAME\n       MPI_Type_extent -  Returns the extent of a datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_extent( MPI_Datatype datatype, MPI_Aint *extent )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       extent - datatype extent (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       type_extent.c\n\n\n\n                                  11/14/2001                MPI_Type_extent(3)\n\n\n\n\nMPI_Type_free\n\n\nMPI_Type_free(3)                      MPI                     MPI_Type_free(3)\n\n\n\nNAME\n       MPI_Type_free -  Frees the datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_free ( MPI_Datatype *datatype )\n\nINPUT PARAMETER\n       datatype\n              - datatype that is freed (handle)\n\n\nPREDEFINED TYPES\n       The MPI standard states that (in Opaque Objects)\n       MPI provides certain predefined opaque objects and predefined, static handles\n       to these objects. Such objects may not be destroyed.\n\n\n       Thus,  it  is an error to free a predefined datatype.  The same section\n       makes it clear that it is an error to free a null datatype.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_free.c\n\n\n\n                                  11/14/2001                  MPI_Type_free(3)\n\n\n\n\nMPI_Type_hindexed\n\n\nMPI_Type_hindexed(3)                  MPI                 MPI_Type_hindexed(3)\n\n\n\nNAME\n       MPI_Type_hindexed -  Creates an indexed datatype with offsets in bytes\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_hindexed(\n               int count,\n               int blocklens[],\n               MPI_Aint indices[],\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  -  number  of  blocks  --  also number of entries in indices and\n              blocklens\n       blocklens\n              - number of elements in each block (array of  nonnegative  inte-\n              gers)\n       indices\n              - byte displacement of each block (array of MPI_Aint)\n       old_type\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       Also see the discussion for MPI_Type_indexed about the indices in  For-\n       tran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_hind.c\n\n\n\n                                   4/7/2003               MPI_Type_hindexed(3)\n\n\n\n\nMPI_Type_hvector\n\n\nMPI_Type_hvector(3)                   MPI                  MPI_Type_hvector(3)\n\n\n\nNAME\n       MPI_Type_hvector  -  Creates a vector (strided) datatype with offset in\n       bytes\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_hvector(\n               int count,\n               int blocklen,\n               MPI_Aint stride,\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  - number of blocks (nonnegative integer)\n       blocklength\n              - number of elements in each block (nonnegative integer)\n       stride - number of bytes between start of each block (integer)\n       old_type\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_hvec.c\n\n\n\n                                  11/14/2001               MPI_Type_hvector(3)\n\n\n\n\nMPI_Type_indexed\n\n\nMPI_Type_indexed(3)                   MPI                  MPI_Type_indexed(3)\n\n\n\nNAME\n       MPI_Type_indexed -  Creates an indexed datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_indexed(\n               int count,\n               int blocklens[],\n               int indices[],\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  -  number  of  blocks  --  also number of entries in indices and\n              blocklens\n       blocklens\n              - number of elements in each block (array of  nonnegative  inte-\n              gers)\n       indices\n              -  displacement of each block in multiples of old_type (array of\n              integers)\n       old_type\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       The  indices are displacements, and are based on a zero origin.  A com-\n       mon error is to do something like to following\n       integer a(100)\n       integer blens(10), indices(10)\n       do i=1,10\n       blens(i)   = 1\n       10       indices(i) = 1 + (i-1)*10\n       call MPI_TYPE_INDEXED(10,blens,indices,MPI_INTEGER,newtype,ierr)\n       call MPI_TYPE_COMMIT(newtype,ierr)\n       call MPI_SEND(a,1,newtype,...)\n\n       expecting this to send a(1),a(11),...  because the indices have  values\n       1,11,...   .  Because these are displacements from the beginning of a ,\n       it actually sends a(1+1),a(1+11),...  .\n\n\n       If you wish to consider the displacements as  indices  into  a  Fortran\n       array, consider declaring the Fortran array with a zero origin\n       integer a(0:99)\n\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_ind.c\n\n\n\n                                  11/14/2001               MPI_Type_indexed(3)\n\n\n\n\nMPI_Type_lb\n\n\nMPI_Type_lb(3)                        MPI                       MPI_Type_lb(3)\n\n\n\nNAME\n       MPI_Type_lb -  Returns the lower-bound of a datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_lb ( MPI_Datatype datatype, MPI_Aint *displacement )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       displacement\n              - displacement of lower bound from origin, in bytes (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_lb.c\n\n\n\n                                  11/14/2001                    MPI_Type_lb(3)\n\n\n\n\nMPI_Type_size\n\n\nMPI_Type_size(3)                      MPI                     MPI_Type_size(3)\n\n\n\nNAME\n       MPI_Type_size  -  Return the number of bytes occupied by entries in the\n       datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_size ( MPI_Datatype datatype, int *size )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       size   - datatype size (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_size.c\n\n\n\n                                  11/14/2001                  MPI_Type_size(3)\n\n\n\n\nMPI_Type_struct\n\n\nMPI_Type_struct(3)                    MPI                   MPI_Type_struct(3)\n\n\n\nNAME\n       MPI_Type_struct -  Creates a struct datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_struct(\n               int count,\n               int blocklens[],\n               MPI_Aint indices[],\n               MPI_Datatype old_types[],\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  - number of blocks (integer) -- also number of entries in arrays\n              array_of_types  ,  array_of_displacements   and  array_of_block-\n              lengths\n       blocklens\n              - number of elements in each block (array)\n       indices\n              - byte displacement of each block (array)\n       old_types\n              -  type  of elements in each block (array of handles to datatype\n              objects)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES\n       If an upperbound is set explicitly by using the MPI datatype  MPI_UB  ,\n       the corresponding index must be positive.\n\n       The  MPI  standard  originally  made vague statements about padding and\n       alignment; this was intended to allow the simple definition  of  struc-\n       tures that could be sent with a count greater than one.  For example,\n       struct { int a; char b; } foo;\n\n       may  have  sizeof(foo)  >  sizeof(int)  +  sizeof(char)  ; for example,\n       sizeof(foo) == 2*sizeof(int) .  The initial version of the MPI standard\n       defined  the  extent  of  a datatype as including an epsilon that would\n       have allowed an implementation to make the extent an MPI  datatype  for\n       this structure equal to 2*sizeof(int) .\n\n       However, since different systems might define different paddings, there\n       was much discussion by the MPI Forum about what was the  correct  value\n       of  epsilon,  and  one  suggestion was to define epsilon as zero.  This\n       would have been the best thing to do in MPI 1.0, particularly since the\n       MPI_UB  type  allows  the  user to easily set the end of the structure.\n       Unfortunately, this change did not make it  into  the  final  document.\n       Currently,  this  routine does not add any padding, since the amount of\n       padding needed is determined by the compiler that the user is using  to\n       build  their  code, not the compiler used to construct the MPI library.\n       A later version of MPICH  may  provide  for  some  natural  choices  of\n       padding  (e.g.,  multiple of the size of the largest basic member), but\n       users are advised to never depend on this, even with vendor MPI  imple-\n       mentations.   Instead,  if  you define a structure datatype and wish to\n       send or receive multiple items, you should explicitly include an MPI_UB\n       entry  as the last member of the structure.  For example, the following\n       code can be used for the structure foo\n       blen[0] = 1; indices[0] = 0; oldtypes[0] = MPI_INT;\n       blen[1] = 1; indices[1] = &foo.b - &foo; oldtypes[1] = MPI_CHAR;\n       blen[2] = 1; indices[2] = sizeof(foo); oldtypes[2] = MPI_UB;\n       MPI_Type_struct( 3, blen, indices, oldtypes, &newtype );\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_struct.c\n\n\n\n                                   7/12/2002                MPI_Type_struct(3)\n\n\n\n\nMPI_Type_ub\n\n\nMPI_Type_ub(3)                        MPI                       MPI_Type_ub(3)\n\n\n\nNAME\n       MPI_Type_ub -  Returns the upper bound of a datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_ub ( MPI_Datatype datatype, MPI_Aint *displacement )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       displacement\n              - displacement of upper bound from origin, in bytes (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_ub.c\n\n\n\n                                  11/14/2001                    MPI_Type_ub(3)\n\n\n\n\nMPI_Type_vector\n\n\nMPI_Type_vector(3)                    MPI                   MPI_Type_vector(3)\n\n\n\nNAME\n       MPI_Type_vector -  Creates a vector (strided) datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_vector(\n               int count,\n               int blocklen,\n               int stride,\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  - number of blocks (nonnegative integer)\n       blocklength\n              - number of elements in each block (nonnegative integer)\n       stride - number of elements between start of each block (integer)\n       oldtype\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       type_vec.c\n\n\n\n                                  11/14/2001                MPI_Type_vector(3)\n\n\n\n\nMPI_Unpack\n\n\nMPI_Unpack(3)                         MPI                        MPI_Unpack(3)\n\n\n\nNAME\n       MPI_Unpack -  Unpack a datatype into contiguous memory\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Unpack ( void *inbuf, int insize, int *position,\n                       void *outbuf, int outcount, MPI_Datatype datatype,\n                       MPI_Comm comm )\n\nINPUT PARAMETERS\n       inbuf  - input buffer start (choice)\n       insize - size of input buffer, in bytes (integer)\n       position\n              - current position in bytes (integer)\n       outcount\n              - number of items to be unpacked (integer)\n       datatype\n              - datatype of each output data item (handle)\n       comm   - communicator for packed message (handle)\n\n\nOUTPUT PARAMETER\n       outbuf - output buffer start (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Pack, MPI_Pack_size\n\nLOCATION\n       unpack.c\n\n\n\n                                  11/14/2001                     MPI_Unpack(3)\n\n\n\n\nMPI_Waitall\n\n\nMPI_Waitall(3)                        MPI                       MPI_Waitall(3)\n\n\n\nNAME\n       MPI_Waitall -  Waits for all given communications to complete\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Waitall(\n               int count,\n               MPI_Request array_of_requests[],\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       count  - lists length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETER\n       array_of_statuses\n              -  array  of  status objects (array of Status).  May be MPI_STA-\n              TUSES_IGNORE\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For send operations, the only use of status is  for  MPI_Test_cancelled\n       or  in  the  case  that  there is an error, in which case the MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_IN_STATUS\n              - The actual error value is in the  MPI_Status  argument.   This\n              error  class  is returned only from the multiple-completion rou-\n              tines ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Waitall ,\n              MPI_Waitany  ,  and  MPI_Waitsome ).  The field MPI_ERROR in the\n              status argument contains the  error  value  or  MPI_SUCCESS  (no\n              error  and  complete)  or  MPI_ERR_PENDING  to indicate that the\n              request has not completed.  The MPI Standard  does  not  specify\n              what  the  result of the multiple completion routines is when an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait  for  all  requests  to either fail or complete, or does it\n              return immediately (with  the  MPI  definition  of  immediately,\n              which  means  independent  of  actions  of other MPI processes)?\n              MPICH has chosen to  make  the  return  immediate  (alternately,\n              local  in MPI terms), and to use the error class MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.   In  most cases, only one request with an error will be\n              detected in each call to an  MPI  routine  that  tests  multiple\n              requests.  The requests that have not been processed (because an\n              error occured in one of the requests) will have their  MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n       MPI_ERR_PENDING\n              - Pending request (not an error).  See MPI_ERR_IN_STATUS .\n\n              This  value indicates that the request is not complete nor has a\n              encountered a detected error.\n\nLOCATION\n       waitall.c\n\n\n\n                                   2/24/2004                    MPI_Waitall(3)\n\n\n\n\nMPI_Waitany\n\n\nMPI_Waitany(3)                        MPI                       MPI_Waitany(3)\n\n\n\nNAME\n       MPI_Waitany -  Waits for any specified send or receive to complete\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Waitany(\n               int count,\n               MPI_Request array_of_requests[],\n               int *index,\n               MPI_Status *status )\n\nINPUT PARAMETERS\n       count  - list length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       index  -  index  of  handle for operation that completed (integer).  In\n              the range 0 to count-1 .  In Fortran, the range is 1 to count  .\n\n       status - status object (Status).  May be MPI_STATUS_IGNORE .\n\n\n\nNOTES\n       If all of the requests are MPI_REQUEST_NULL , then index is returned as\n       MPI_UNDEFINED , and status is returned as an empty status.\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For send operations, the only use of status is  for  MPI_Test_cancelled\n       or  in  the  case  that  there is an error, in which case the MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       waitany.c\n\n\n\n                                   1/9/2003                     MPI_Waitany(3)\n\n\n\n\nMPI_Wait\n\n\nMPI_Wait(3)                           MPI                          MPI_Wait(3)\n\n\n\nNAME\n       MPI_Wait -  Waits for an MPI send or receive to complete\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Wait (\n               MPI_Request  *request,\n               MPI_Status   *status)\n\nINPUT PARAMETER\n       request\n              - request (handle)\n\n\nOUTPUT PARAMETER\n       status - status object (Status) .  May be MPI_STATUS_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              -  Invalid  MPI_Request  .   Either  null  or,  in the case of a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       wait.c\n\n\n\n                                   1/9/2003                        MPI_Wait(3)\n\n\n\n\nMPI_Waitsome\n\n\nMPI_Waitsome(3)                       MPI                      MPI_Waitsome(3)\n\n\n\nNAME\n       MPI_Waitsome -  Waits for some given communications to complete\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Waitsome(\n               int incount,\n               MPI_Request array_of_requests[],\n               int *outcount,\n               int array_of_indices[],\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       incount\n              - length of array_of_requests (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       outcount\n              - number of completed requests (integer)\n       array_of_indices\n              -  array of indices of operations that completed (array of inte-\n              gers)\n       array_of_statuses\n              - array of status objects for operations that  completed  (array\n              of Status).  May be MPI_STATUSES_IGNORE .\n\n\n\nNOTES\n       The  array  of  indicies are in the range 0 to incount - 1 for C and in\n       the range 1 to incount for Fortran.\n\n       Null requests are ignored; if all requests are null, then  the  routine\n       returns with outcount set to MPI_UNDEFINED .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              -  Invalid  MPI_Request  .   Either  null  or,  in the case of a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_IN_STATUS\n              -  The  actual  error value is in the MPI_Status argument.  This\n              error class is returned only from the  multiple-completion  rou-\n              tines ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Waitall ,\n              MPI_Waitany , and MPI_Waitsome ).  The field  MPI_ERROR  in  the\n              status  argument  contains  the  error  value or MPI_SUCCESS (no\n              error and complete) or  MPI_ERR_PENDING  to  indicate  that  the\n              request  has  not  completed.  The MPI Standard does not specify\n              what the result of the multiple completion routines is  when  an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait for all requests to either fail or  complete,  or  does  it\n              return  immediately  (with  the  MPI  definition of immediately,\n              which means independent of  actions  of  other  MPI  processes)?\n              MPICH  has  chosen  to  make  the return immediate (alternately,\n              local in MPI terms), and to use the error class  MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.  In most cases, only one request with an error  will  be\n              detected  in  each  call  to  an MPI routine that tests multiple\n              requests.  The requests that have not been processed (because an\n              error  occured in one of the requests) will have their MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n\nLOCATION\n       waitsome.c\n\n\n\n                                   1/9/2003                    MPI_Waitsome(3)\n\n\n\n\nMPI_Wtick\n\n\nMPI_Wtick(3)                          MPI                         MPI_Wtick(3)\n\n\n\nNAME\n       MPI_Wtick -  Returns the resolution of MPI_Wtime\n\nSYNOPSIS\n       #include \"mpi.h\"\n       double MPI_Wtick()\n\nRETURN VALUE\n       Time in seconds of the resolution of MPI_Wtime .\n\n\nNOTES FOR FORTRAN\n       This  is  a  function, declared as DOUBLE PRECISION MPI_WTICK() in For-\n       tran.\n\n\nLOCATION\n       wtick.c\n\n\n\n                                   8/20/2004                      MPI_Wtick(3)\n\n\n\n\nMPI_Wtime\n\n\nMPI_Wtime(3)                          MPI                         MPI_Wtime(3)\n\n\n\nNAME\n       MPI_Wtime -  Returns an elapsed time on the calling processor\n\nSYNOPSIS\n       #include \"mpi.h\"\n       double MPI_Wtime()\n\nRETURN VALUE\n       Time in seconds since an arbitrary time in the past.\n\n\nNOTES\n       This is intended to be a high-resolution, elapsed (or wall) clock.  See\n       MPI_WTICK to determine the resolution of MPI_WTIME .\n\n       If the attribute MPI_WTIME_IS_GLOBAL is  defined  and  true,  then  the\n       value is synchronized across all processes in MPI_COMM_WORLD .\n\n\n\nNOTES FOR FORTRAN\n       This  is  a  function, declared as DOUBLE PRECISION MPI_WTIME() in For-\n       tran.\n\n\nSEE ALSO\n       also: MPI_Wtick, MPI_Attr_get\n\nLOCATION\n       wtime.c\n\n\n\n                                  11/14/2001                      MPI_Wtime(3)",
            "title": "MPI Lib"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_abort",
            "text": "MPI_Abort(3)                          MPI                         MPI_Abort(3)\n\n\n\nNAME\n       MPI_Abort -  Terminates MPI execution environment\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Abort( MPI_Comm comm, int errorcode )\n\nINPUT PARAMETERS\n       comm   - communicator of tasks to abort\n       errorcode\n              - error code to return to invoking environment\n\n\nNOTES\n       Terminates all MPI processes associated with the communicator comm ; in\n       most systems (all to date), terminates all processes.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       abort.c\n\n\n\n                                  12/13/2001                      MPI_Abort(3)",
            "title": "MPI_Abort"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_address",
            "text": "MPI_Address(3)                        MPI                       MPI_Address(3)\n\n\n\nNAME\n       MPI_Address -  Gets the address of a location in memory\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Address( void *location, MPI_Aint *address)\n\nINPUT PARAMETERS\n       location\n              - location in caller memory (choice)\n\n\nOUTPUT PARAMETER\n       address\n              - address of location (integer)\n\n\nNOTE\n       This  routine  is  provided for both the Fortran and C programmers.  On\n       many systems, the address returned by this routine will be the same  as\n       produced by the C & operator, but this is not required in C and may not\n       be true of systems with word- rather than byte-oriented instructions or\n       systems with segmented address spaces.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       address.c\n\n\n\n                                  11/14/2001                    MPI_Address(3)",
            "title": "MPI_Address"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_allgather",
            "text": "MPI_Allgather(3)                      MPI                     MPI_Allgather(3)\n\n\n\nNAME\n       MPI_Allgather  -   Gathers data from all tasks and distribute it to all\n       tasks\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Allgather ( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                           void *recvbuf, int recvcount, MPI_Datatype recvtype,\n                          MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              - number of elements received from any process (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES\n       The MPI standard (1.0 and 1.1) says that\n\n       The jth block of data sent from each proess is received by  every  pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This is misleading; a better description is\n\n       The  block  of data sent from the jth process is received by every pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This text was suggested by Rajeev Thakur.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler  may  be  changed  with  MPI_Errhandler_set  ;  the\n       predefined error handler MPI_ERRORS_RETURN may be used to  cause  error\n       values  to  be  returned.  Note that MPI does not guarentee that an MPI\n       program can continue past an error.\n\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       allgather.c\n\n\n\n                                   10/1/2004                  MPI_Allgather(3)",
            "title": "MPI_Allgather"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_allgatherv",
            "text": "MPI_Allgatherv(3)                     MPI                    MPI_Allgatherv(3)\n\n\n\nNAME\n       MPI_Allgatherv -  Gathers data from all tasks and deliver it to all\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Allgatherv ( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                            void *recvbuf, int *recvcounts, int *displs,\n                           MPI_Datatype recvtype, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcounts\n              -  integer array (of length group size) containing the number of\n              elements that are received from each process\n       displs - integer array (of length group size). Entry  i  specifies  the\n              displacement (relative to recvbuf ) at which to place the incom-\n              ing data from process i\n\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES\n       The MPI standard (1.0 and 1.1) says that\n\n       The jth block of data sent from each proess is received by  every  pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This is misleading; a better description is\n\n       The  block  of data sent from the jth process is received by every pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This text was suggested by Rajeev Thakur.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       allgatherv.c\n\n\n\n                                  11/14/2001                 MPI_Allgatherv(3)",
            "title": "MPI_Allgatherv"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_allreduce",
            "text": "MPI_Allreduce(3)                      MPI                     MPI_Allreduce(3)\n\n\n\nNAME\n       MPI_Allreduce  -  Combines values from all processes and distribute the\n       result back to all processes\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Allreduce ( void *sendbuf, void *recvbuf, int count,\n                          MPI_Datatype datatype, MPI_Op op, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - data type of elements of send buffer (handle)\n       op     - operation (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - starting address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The  reduction functions ( MPI_Op ) do not return an error value.  As a\n       result, if the functions detect an error, all they  can  do  is  either\n       call  MPI_Abort  or silently skip the problem.  Thus, if you change the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The  reason  for  this is the performance problems in ensuring that all\n       collective routines return the same error value.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_OP\n              - Invalid operation.  MPI operations (objects of type  MPI_Op  )\n              must either be one of the predefined operations (e.g., MPI_SUM )\n              or created with MPI_Op_create .\n\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       allreduce.c\n\n\n\n                                  11/14/2001                  MPI_Allreduce(3)",
            "title": "MPI_Allreduce"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_alltoall",
            "text": "MPI_Alltoall(3)                       MPI                      MPI_Alltoall(3)\n\n\n\nNAME\n       MPI_Alltoall -  Sends data from all to all processes\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Alltoall( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                         void *recvbuf, int recvcnt, MPI_Datatype recvtype,\n                        MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements to send to each process (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              - number of elements received from any process (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\nLOCATION\n       alltoall.c\n\n\n\n                                  11/14/2001                   MPI_Alltoall(3)",
            "title": "MPI_Alltoall"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_alltoallv",
            "text": "MPI_Alltoallv(3)                      MPI                     MPI_Alltoallv(3)\n\n\n\nNAME\n       MPI_Alltoallv -  Sends data from all to all processes, with a displace-\n       ment\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Alltoallv (\n               void *sendbuf,\n               int *sendcnts,\n               int *sdispls,\n               MPI_Datatype sendtype,\n               void *recvbuf,\n               int *recvcnts,\n               int *rdispls,\n               MPI_Datatype recvtype,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcounts\n              - integer array equal to the group size specifying the number of\n              elements to send to each processor\n       sdispls\n              -  integer  array  (of length group size). Entry j specifies the\n              displacement (relative to sendbuf  from which to take the outgo-\n              ing data destined for process j\n\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcounts\n              -  integer  array equal to the group size specifying the maximum\n              number of elements that can be received from each processor\n       rdispls\n              - integer array (of length group size). Entry  i  specifies  the\n              displacement  (relative to recvbuf  at which to place the incom-\n              ing data from process i\n\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       alltoallv.c\n\n\n\n                                  11/14/2001                  MPI_Alltoallv(3)",
            "title": "MPI_Alltoallv"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_attr_delete",
            "text": "MPI_Attr_delete(3)                    MPI                   MPI_Attr_delete(3)\n\n\n\nNAME\n       MPI_Attr_delete -  Deletes attribute value associated with a key\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Attr_delete ( MPI_Comm comm, int keyval )\n\nINPUT PARAMETERS\n       comm   - communicator to which attribute is attached (handle)\n       keyval - The key value of the deleted attribute (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              keys.\n\nLOCATION\n       attr_delval.c\n\n\n\n                                  11/14/2001                MPI_Attr_delete(3)",
            "title": "MPI_Attr_delete"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_attr_get",
            "text": "MPI_Attr_get(3)                       MPI                      MPI_Attr_get(3)\n\n\n\nNAME\n       MPI_Attr_get -  Retrieves attribute value by key\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Attr_get (\n               MPI_Comm comm,\n               int keyval,\n               void *attr_value,\n               int *flag )\n\nINPUT PARAMETERS\n       comm   - communicator to which attribute is attached (handle)\n       keyval - key value (integer)\n\n\nOUTPUT PARAMETERS\n       attr_value\n              - attribute value, unless flag = false\n       flag   -  true  if  an  attribute  value  was  extracted;   false if no\n              attribute is associated with the key\n\n\nNOTES\n       Attributes must be extracted  from  the  same  language  as  they  were\n       inserted  in  with  MPI_ATTR_PUT  .   The notes for C and Fortran below\n       explain why.\n\n\nNOTES FOR C\n       Even though the attr_value arguement is declared as  void  *  ,  it  is\n       really  the  address of a void pointer.  See the rationale in the stan-\n       dard for more details.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       The  attr_value  in  Fortran  is  a pointer to a Fortran integer, not a\n       pointer to a void * .\n\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_OTHER\n              - Other error; the error code associated with this  error  indi-\n              cates an attempt to use an invalue keyval.\n\nLOCATION\n       attr_getval.c\n\n\n\n                                  11/14/2001                   MPI_Attr_get(3)",
            "title": "MPI_Attr_get"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_attr_put",
            "text": "MPI_Attr_put(3)                       MPI                      MPI_Attr_put(3)\n\n\n\nNAME\n       MPI_Attr_put -  Stores attribute value associated with a key\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Attr_put ( MPI_Comm comm, int keyval, void *attr_value )\n\nINPUT PARAMETERS\n       comm   - communicator to which attribute will be attached (handle)\n       keyval - key value, as returned by MPI_KEYVAL_CREATE (integer)\n       attribute_val\n              - attribute value\n\n\nNOTES\n       Values of the permanent attributes MPI_TAG_UB , MPI_HOST , MPI_IO , and\n       MPI_WTIME_IS_GLOBAL may not be changed.\n\n       The type of the attribute value depends on  whether  C  or  Fortran  is\n       being  used.  In C, an attribute value is a pointer ( void * ); in For-\n       tran, it is a single integer ( not a  pointer,  since  Fortran  has  no\n       pointers  and  there are systems for which a pointer does not fit in an\n       integer (e.g., any > 32 bit address system that uses 64 bits  for  For-\n       tran DOUBLE PRECISION ).\n\n       If an attribute is already present, the delete function (specified when\n       the corresponding keyval was created) will be called.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_OTHER\n              -  Other  error; the error code associated with this error indi-\n              cates an attempt to use an invalue keyval.\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              keys.\n\n\nSEE ALSO\n       MPI_Attr_get, MPI_Keyval_create, MPI_Attr_delete\n\nLOCATION\n       attr_putval.c\n\n\n\n                                  11/14/2001                   MPI_Attr_put(3)",
            "title": "MPI_Attr_put"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_barrier",
            "text": "MPI_Barrier(3)                        MPI                       MPI_Barrier(3)\n\n\n\nNAME\n       MPI_Barrier -  Blocks until all process have reached this routine.\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Barrier (\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n\n\nNOTES\n       Blocks  the  caller  until  all  group members have called it; the call\n       returns at any process only after all group members  have  entered  the\n       call.\n\n\nALGORITHM\n       If the underlying device cannot do better, a tree-like or combine algo-\n       rithm is used to broadcast a message wto all members of the  communica-\n       tor.   We  can  modifiy  this  to  use  \"blocks\"  at  a later time (see\n       MPI_Bcast ).\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       barrier.c\n\n\n\n                                  11/14/2001                    MPI_Barrier(3)",
            "title": "MPI_Barrier"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_bcast",
            "text": "MPI_Bcast(3)                          MPI                         MPI_Bcast(3)\n\n\n\nNAME\n       MPI_Bcast  -  Broadcasts a message from the process with rank \"root\" to\n       all other processes of the group.\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Bcast ( void *buffer, int count, MPI_Datatype datatype, int root,\n                      MPI_Comm comm )\n\nINPUT/OUTPUT PARAMETERS\n       buffer - starting address of buffer (choice)\n       count  - number of entries in buffer (integer)\n       datatype\n              - data type of buffer (handle)\n       root   - rank of broadcast root (integer)\n       comm   - communicator (handle)\n\n\nALGORITHM\n       If the underlying device does not take  responsibility,  this  function\n       uses  a  tree-like algorithm to broadcast the message to blocks of pro-\n       cesses.  A linear algorithm is then used to broadcast the message  from\n       the    first   process   in   a   block   to   all   other   processes.\n       MPIR_BCAST_BLOCK_SIZE determines the size of blocks.  If this is set to\n       1, then this function is equivalent to using a pure tree algorithm.  If\n       it is set to the size of the group or greater,  it  is  a  pure  linear\n       algorithm.   The  value  should be adjusted to determine the most effi-\n       cient value on different machines.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_ROOT\n              - Invalid root.  The root must be specified as  a  rank  in  the\n              communicator.   Ranks  must  be between zero and the size of the\n              communicator minus one.\n\nLOCATION\n       bcast.c\n\n\n\n                                  11/14/2001                      MPI_Bcast(3)",
            "title": "MPI_Bcast"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_bsend_init",
            "text": "MPI_Bsend_init(3)                     MPI                    MPI_Bsend_init(3)\n\n\n\nNAME\n       MPI_Bsend_init -  Builds a handle for a buffered send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Bsend_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                          int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n\nLOCATION\n       bsend_init.c\n\n\n\n                                  12/13/2001                 MPI_Bsend_init(3)",
            "title": "MPI_Bsend_init"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_bsend",
            "text": "MPI_Bsend(3)                          MPI                         MPI_Bsend(3)\n\n\n\nNAME\n       MPI_Bsend -  Basic send with user-specified buffering\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Bsend(\n               void *buf,\n               int count,\n               MPI_Datatype datatype,\n               int dest,\n               int tag,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES\n       This  send is provided as a convenience function; it allows the user to\n       send messages without worring about where they  are  buffered  (because\n       the user must have provided buffer space with MPI_Buffer_attach ).\n\n       In deciding how much buffer space to allocate, remember that the buffer\n       space is not available for reuse by subsequent MPI_Bsend s  unless  you\n       are certain that the message has been received (not just that it should\n       have been received).  For example, this code does not  allocate  enough\n       buffer space\n       MPI_Buffer_attach( b, n*sizeof(double) + MPI_BSEND_OVERHEAD );\n       for (i=0; i<m; i++) {\n       MPI_Bsend( buf, n, MPI_DOUBLE, ... );\n       }\n\n       because only enough buffer space is provided for a single send, and the\n       loop may start a second MPI_Bsend before the first is done  making  use\n       of the buffer.\n\n       In C, you can force the messages to be delivered by\n       MPI_Buffer_detach( &b, &n );\n       MPI_Buffer_attach( b, n );\n\n       (The  MPI_Buffer_detach  will  not complete until all buffered messages\n       are delivered.)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n\n\nSEE ALSO\n       MPI_Buffer_attach, MPI_Ibsend, MPI_Bsend_init\n\nLOCATION\n       bsend.c\n\n\n\n                                  11/14/2001                      MPI_Bsend(3)",
            "title": "MPI_Bsend"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_buffer_attach",
            "text": "MPI_Buffer_attach(3)                  MPI                 MPI_Buffer_attach(3)\n\n\n\nNAME\n       MPI_Buffer_attach -  Attaches a user-defined buffer for sending\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Buffer_attach( void *buffer, int size )\n\nINPUT PARAMETERS\n       buffer - initial buffer address (choice)\n       size   - buffer size, in bytes (integer)\n\n\nNOTES\n       The size given should be the sum of the sizes of all outstanding Bsends\n       that you intend to have, plus a few hundred bytes for each  Bsend  that\n       you  do.   For  the  purposes  of  calculating  size,  you  should  use\n       MPI_Pack_size .\n\n       In other words, in the code\n       MPI_Buffer_attach( buffer, size );\n       MPI_Bsend( ..., count=20, datatype=type1,  ... );\n       .\n       .\n       .\n       MPI_Bsend( ..., count=40, datatype=type2, ... );\n\n       the value of size in the MPI_Buffer_attach call should be greater  than\n       the value computed by\n       MPI_Pack_size( 20, type1, comm, &s1 );\n       MPI_Pack_size( 40, type2, comm, &s2 );\n       size = s1 + s2 + 2 * MPI_BSEND_OVERHEAD;\n\n       The  MPI_BSEND_OVERHEAD  gives  the maximum amount of space that may be\n       used in the buffer for use by the BSEND routines in using  the  buffer.\n       This value is in mpi.h (for C) and mpif.h (for Fortran).\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_INTERN\n              - An internal error has been detected.  This is  fatal.   Please\n              send a bug report to mpi-bugs@mcs.anl.gov .\n\n\n\nSEE ALSO\n       MPI_Buffer_detach, MPI_Bsend\n\nLOCATION\n       bufattach.c\n\n\n\n                                  11/14/2001              MPI_Buffer_attach(3)",
            "title": "MPI_Buffer_attach"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_buffer_detach",
            "text": "MPI_Buffer_detach(3)                  MPI                 MPI_Buffer_detach(3)\n\n\n\nNAME\n       MPI_Buffer_detach  -   Removes an existing buffer (for use in MPI_Bsend\n       etc)\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Buffer_detach(\n               void *bufferptr,\n               int *size )\n\nOUTPUT PARAMETERS\n       buffer - initial buffer address (choice)\n       size   - buffer size, in bytes (integer)\n\n\nNOTES\n       The reason that MPI_Buffer_detach returns the address and size  of  the\n       buffer  being  detached  is  to  allow  nested libraries to replace and\n       restore the buffer.  For example, consider\n\n       int size, mysize, idummy;\n       void *ptr, *myptr, *dummy;\n       MPI_Buffer_detach( &ptr, &size );\n       MPI_Buffer_attach( myptr, mysize );\n       .\n       .\n       .\n       .\n       .\n       .\n       library code ...\n       .\n       .\n       .\n       MPI_Buffer_detach( &dummy, &idummy );\n       MPI_Buffer_attach( ptr, size );\n\n\n       This is much like the action of the Unix signal  routine  and  has  the\n       same  strengths (it is simple) and weaknesses (it only works for nested\n       usages).\n\n       Note that for this approach  to  work,  MPI_Buffer_detach  must  return\n       MPI_SUCCESS  even  when there is no buffer to detach.  In that case, it\n       returns a size of zero.  The MPI  1.1  standard  for  MPI_BUFFER_DETACH\n       contains the text\n\n       The statements made in this section describe the behavior of MPI for\n       buffered-mode sends. When no buffer is currently associated, MPI behaves\n       as if a zero-sized buffer is associated with the process.\n\n\n       This  could  be  read  as  applying only to the various Bsend routines.\n       This  implementation  takes  the  position   that   this   applies   to\n       MPI_BUFFER_DETACH as well.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       The Fortran binding for this routine  is  different.   Because  Fortran\n       does  not  have  pointers, it is impossible to provide a way to use the\n       output of this routine to exchange buffers.  In  this  case,  only  the\n       size field is set.\n\n\nNOTES FOR C\n       Even though the bufferptr argument is declared as void * , it is really\n       the address of a void pointer.  See the rationale in the  standard  for\n       more details.\n\nLOCATION\n       buffree.c\n\n\n\n                                  11/14/2001              MPI_Buffer_detach(3)",
            "title": "MPI_Buffer_detach"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cancel",
            "text": "MPI_Cancel(3)                         MPI                        MPI_Cancel(3)\n\n\n\nNAME\n       MPI_Cancel -  Cancels a communication request\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cancel( MPI_Request *request )\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTE\n       Cancel  has  only  been implemented for receive requests; it is a no-op\n       for send requests.  The primary expected use of MPI_Cancel is in multi-\n       buffering  schemes,  where  speculative  MPI_Irecvs are made.  When the\n       computation completes, some of these receive requests may remain; using\n       MPI_Cancel allows the user to cancel these unsatisfied requests.\n\n       Cancelling  a  send  operation  is  much  more difficult, in large part\n       because the send will usually  be  at  least  partially  complete  (the\n       information  on  the tag, size, and source are usually sent immediately\n       to the destination).  As of version 1.2.0, MPICH supports cancelling of\n       sends.   Users are advised that cancelling a send, while a local opera-\n       tion (as defined by the MPI standard), is likely to be expensive  (usu-\n       ally generating one or more internal messages).\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNULL HANDLES\n       The MPI 1.1 specification, in the section on opaque objects, explicitly\n\nDISALLOWS FREEING A NULL COMMUNICATOR. THE TEXT FROM THE STANDARD IS\n       A null handle argument is an erroneous IN argument in MPI calls, unless an\n       exception is explicitly stated in the text that defines the function. Such\n       exception is allowed for handles to request objects in Wait and Test calls\n       (sections Communication Completion and Multiple Completions ). Otherwise, a\n       null handle can only be passed to a function that allocates a new object and\n       returns a reference to it in the handle.\n\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cancel.c\n\n\n\n                                  11/14/2001                     MPI_Cancel(3)",
            "title": "MPI_Cancel"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cart_coords",
            "text": "MPI_Cart_coords(3)                    MPI                   MPI_Cart_coords(3)\n\n\n\nNAME\n       MPI_Cart_coords  -   Determines  process  coords  in cartesian topology\n       given rank in group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cart_coords ( MPI_Comm comm, int rank, int maxdims, int *coords )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       rank   - rank of a process within group of comm (integer)\n       maxdims\n              - length of vector coords in the calling program (integer)\n\n\nOUTPUT PARAMETER\n       coords - integer array (of size ndims ) containing the Cartesian  coor-\n              dinates of specified process (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_DIMS\n              - Illegal dimension argument.  A dimension argument is  null  or\n              its length is less than or equal to zero.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       cart_coords.c\n\n\n\n                                   3/28/2002                MPI_Cart_coords(3)",
            "title": "MPI_Cart_coords"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cart_create",
            "text": "MPI_Cart_create(3)                    MPI                   MPI_Cart_create(3)\n\n\n\nNAME\n       MPI_Cart_create  -  Makes a new communicator to which topology informa-\n       tion has been attached\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cart_create ( MPI_Comm comm_old, int ndims, int *dims, int *periods,\n                            int reorder, MPI_Comm *comm_cart )\n\nINPUT PARAMETERS\n       comm_old\n              - input communicator (handle)\n       ndims  - number of dimensions of cartesian grid (integer)\n       dims   - integer array of size ndims specifying the number of processes\n              in each dimension\n       periods\n              -  logical  array  of  size ndims specifying whether the grid is\n              periodic (true) or not (false) in each dimension\n       reorder\n              - ranking may be reordered (true) or not (false) (logical)\n\n\nOUTPUT PARAMETER\n       comm_cart\n              - communicator with new cartesian topology (handle)\n\n\nALGORITHM\n       We ignore reorder info currently.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_DIMS\n              - Illegal dimension argument.  A dimension argument is  null  or\n              its length is less than or equal to zero.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_create.c\n\n\n\n                                  11/14/2001                MPI_Cart_create(3)",
            "title": "MPI_Cart_create"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cartdim_get",
            "text": "MPI_Cartdim_get(3)                    MPI                   MPI_Cartdim_get(3)\n\n\n\nNAME\n       MPI_Cartdim_get  -  Retrieves Cartesian topology information associated\n       with a  communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cartdim_get ( MPI_Comm comm, int *ndims )\n\nINPUT PARAMETER\n       comm   - communicator with cartesian structure (handle)\n\n\nOUTPUT PARAMETER\n       ndims  - number of dimensions of the cartesian structure (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cartdim_get.c\n\n\n\n                                  11/14/2001                MPI_Cartdim_get(3)",
            "title": "MPI_Cartdim_get"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cart_get",
            "text": "MPI_Cart_get(3)                       MPI                      MPI_Cart_get(3)\n\n\n\nNAME\n       MPI_Cart_get  -   Retrieves  Cartesian  topology information associated\n       with a  communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cart_get (\n               MPI_Comm comm,\n               int maxdims,\n               int *dims,\n               int *periods,\n               int *coords )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       maxdims\n              - length of vectors dims , periods , and coords in  the  calling\n              program (integer)\n\n\nOUTPUT PARAMETERS\n       dims   -  number  of  processes  for each cartesian dimension (array of\n              integer)\n       periods\n              - periodicity (true/false) for each cartesian  dimension  (array\n              of logical)\n       coords -  coordinates  of calling process in cartesian structure (array\n              of integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_get.c\n\n\n\n                                  11/14/2001                   MPI_Cart_get(3)",
            "title": "MPI_Cart_get"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cart_map",
            "text": "MPI_Cart_map(3)                       MPI                      MPI_Cart_map(3)\n\n\n\nNAME\n       MPI_Cart_map -  Maps process to Cartesian topology information\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cart_map (\n               MPI_Comm comm_old,\n               int ndims,\n               int *dims,\n               int *periods,\n               int *newrank)\n\nINPUT PARAMETERS\n       comm   - input communicator (handle)\n       ndims  - number of dimensions of Cartesian structure (integer)\n       dims   - integer array of size ndims specifying the number of processes\n              in each coordinate direction\n       periods\n              - logical array of size ndims specifying the periodicity  speci-\n              fication in each coordinate direction\n\n\nOUTPUT PARAMETER\n       newrank\n              -  reordered rank of the calling process; MPI_UNDEFINED if call-\n              ing process does not belong to grid (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_DIMS\n              -  Illegal  dimension argument.  A dimension argument is null or\n              its length is less than or equal to zero.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_map.c\n\n\n\n                                   3/28/2002                   MPI_Cart_map(3)",
            "title": "MPI_Cart_map"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cart_rank",
            "text": "MPI_Cart_rank(3)                      MPI                     MPI_Cart_rank(3)\n\n\n\nNAME\n       MPI_Cart_rank  -   Determines process rank in communicator given Carte-\n       sian location\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cart_rank (\n               MPI_Comm comm,\n               int *coords,\n               int *rank )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       coords - integer array (of size ndims ) specifying the cartesian  coor-\n              dinates of a process\n\n\nOUTPUT PARAMETER\n       rank   - rank of specified process (integer)\n\n\nNOTES\n       Out-of-range  coordinates  are  erroneous  for non-periodic dimensions.\n       Versions of MPICH before 1.2.2 returned MPI_PROC_NULL for the  rank  in\n       this case.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_rank.c\n\n\n\n                                  11/14/2001                  MPI_Cart_rank(3)",
            "title": "MPI_Cart_rank"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cart_shift",
            "text": "MPI_Cart_shift(3)                     MPI                    MPI_Cart_shift(3)\n\n\n\nNAME\n       MPI_Cart_shift  -   Returns  the  shifted source and destination ranks,\n       given a  shift direction and amount\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cart_shift ( MPI_Comm comm, int direction, int displ,\n                           int *source, int *dest )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       direction\n              - coordinate dimension of shift (integer)\n       disp   - displacement (> 0: upwards shift, < 0: downwards shift) (inte-\n              ger)\n\n\nOUTPUT PARAMETERS\n       rank_source\n              - rank of source process (integer)\n       rank_dest\n              - rank of destination process (integer)\n\n\nNOTES\n       The  direction  argument  is  in the range [0,n-1] for an n-dimensional\n       Cartesian mesh.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_shift.c\n\n\n\n                                  11/14/2001                 MPI_Cart_shift(3)",
            "title": "MPI_Cart_shift"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cart_sub",
            "text": "MPI_Cart_sub(3)                       MPI                      MPI_Cart_sub(3)\n\n\n\nNAME\n       MPI_Cart_sub  -   Partitions  a communicator into subgroups which  form\n       lower-dimensional cartesian subgrids\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Cart_sub ( MPI_Comm comm, int *remain_dims, MPI_Comm *comm_new )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       remain_dims\n              - the i th entry of  remain_dims  specifies  whether  the  i  th\n              dimension  is  kept  in the subgrid (true) or is dropped (false)\n              (logical vector)\n\n\nOUTPUT PARAMETER\n       newcomm\n              - communicator containing the subgrid that includes the  calling\n              process (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_sub.c\n\n\n\n                                  11/14/2001                   MPI_Cart_sub(3)",
            "title": "MPI_Cart_sub"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_compare",
            "text": "MPI_Comm_compare(3)                   MPI                  MPI_Comm_compare(3)\n\n\n\nNAME\n       MPI_Comm_compare -  Compares two communicators\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_compare (\n               MPI_Comm  comm1,\n               MPI_Comm  comm2,\n               int *result)\n\nINPUT PARAMETERS\n       comm1  - comm1 (handle)\n       comm2  - comm2 (handle)\n\n\nOUTPUT PARAMETER\n       result -  integer which is MPI_IDENT if the contexts and groups are the\n              same, MPI_CONGRUENT if different contexts but identical  groups,\n              MPI_SIMILAR  if  different  contexts  but  similar  groups,  and\n              MPI_UNEQUAL otherwise\n\n\nUSING 'MPI_COMM_NULL' WITH 'MPI_COMM_COMPARE'\n       It is an error  to  use  MPI_COMM_NULL  as  one  of  the  arguments  to\n       MPI_Comm_compare .  The relevant sections of the MPI standard are\n\n       .   (2.4.1  Opaque  Objects)  A null handle argument is an erroneous IN\n       argument in MPI calls, unless an exception is explicitly stated in  the\n       text that defines the function.\n\n       .   (5.4.1. Communicator Accessors) <no text in MPI_COMM_COMPARE allow-\n       ing a null handle>\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       commcompare.c\n\n\n\n                                  11/14/2001               MPI_Comm_compare(3)",
            "title": "MPI_Comm_compare"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_create",
            "text": "MPI_Comm_create(3)                    MPI                   MPI_Comm_create(3)\n\n\n\nNAME\n       MPI_Comm_create -  Creates a new communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_create ( MPI_Comm comm, MPI_Group group, MPI_Comm *comm_out )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n       group  - group, which is a subset of the group of comm (handle)\n\n\nOUTPUT PARAMETER\n       comm_out\n              - new communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Comm_free\n\nLOCATION\n       comm_create.c\n\n\n\n                                  11/14/2001                MPI_Comm_create(3)",
            "title": "MPI_Comm_create"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_dup",
            "text": "MPI_Comm_dup(3)                       MPI                      MPI_Comm_dup(3)\n\n\n\nNAME\n       MPI_Comm_dup -  Duplicates an existing communicator with all its cached\n       information\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_dup (\n               MPI_Comm comm,\n               MPI_Comm *comm_out )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       newcomm\n              - A new communicator over the same group as comm but with a  new\n              context. See notes.  (handle)\n\n\nNOTES\n       This routine is used to create a new communicator that has a new commu-\n       nication context but contains the same group of processes as the  input\n       communicator.  Since all MPI communication is performed within a commu-\n       nicator (specifies as the group of processes plus  the  context),  this\n       routine  provides an effective way to create a private communicator for\n       use by a software module or library.  In particular, no library routine\n       should  use MPI_COMM_WORLD as the communicator; instead, a duplicate of\n       a user-specified communicator should always be used.  For more informa-\n       tion, see Using MPI, 2nd edition.\n\n       Because  this routine essentially produces a copy of a communicator, it\n       also copies any attributes that have been defined on the input communi-\n       cator, using the attribute copy function specified by the copy_function\n       argument to MPI_Keyval_create .  This is particularly  useful  for  (a)\n       attributes that describe some property of the group associated with the\n       communicator, such as its interconnection topology and  (b)  communica-\n       tors  that  are  given back to the user; the attibutes in this case can\n       track subsequent MPI_Comm_dup operations on this communicator.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Comm_free, MPI_Keyval_create, MPI_Attr_set, MPI_Attr_delete\n\n\nLOCATION\n       comm_dup.c\n\n\n\n                                  11/14/2001                   MPI_Comm_dup(3)",
            "title": "MPI_Comm_dup"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_free",
            "text": "MPI_Comm_free(3)                      MPI                     MPI_Comm_free(3)\n\n\n\nNAME\n       MPI_Comm_free -  Marks the communicator object for deallocation\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_free ( MPI_Comm *commp )\n\nINPUT PARAMETER\n       comm   - communicator to be destroyed (handle)\n\n\nNULL HANDLES\n       The MPI 1.1 specification, in the section on opaque objects, explicitly\n\nDISALLOWS FREEING A NULL COMMUNICATOR. THE TEXT FROM THE STANDARD IS\n       A null handle argument is an erroneous IN argument in MPI calls, unless an\n       exception is explicitly stated in the text that defines the function. Such\n       exception is allowed for handles to request objects in Wait and Test calls\n       (sections Communication Completion and Multiple Completions ). Otherwise, a\n       null handle can only be passed to a function that allocates a new object and\n       returns a reference to it in the handle.\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_free.c\n\n\n\n                                  10/31/2002                  MPI_Comm_free(3)",
            "title": "MPI_Comm_free"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_group",
            "text": "MPI_Comm_group(3)                     MPI                    MPI_Comm_group(3)\n\n\n\nNAME\n       MPI_Comm_group -  Accesses the group associated with given communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_group (\n               MPI_Comm comm,\n               MPI_Group *group )\n\nINPUT PARAMETER\n       comm   - Communicator\n\n\nOUTPUT PARAMETER\n       group  - Group in communicator\n\n\nUSING 'MPI_COMM_NULL' WITH 'MPI_COMM_GROUP'\n       It is an error  to  use  MPI_COMM_NULL  as  one  of  the  arguments  to\n       MPI_Comm_group .  The relevant sections of the MPI standard are\n\n       .   (2.4.1  Opaque  Objects)  A null handle argument is an erroneous IN\n       argument in MPI calls, unless an exception is explicitly stated in  the\n       text that defines the function.\n\n       .   (5.3.2.  Group  Constructors) <no text in MPI_COMM_GROUP allowing a\n       null handle>\n\n       Previous versions of MPICH allow MPI_COMM_NULL in  this  function.   In\n       the interests of promoting portability of applications, we have changed\n       the behavior of MPI_Comm_group to detect  this  violation  of  the  MPI\n       standard.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       comm_group.c\n\n\n\n                                  11/14/2001                 MPI_Comm_group(3)",
            "title": "MPI_Comm_group"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_rank",
            "text": "MPI_Comm_rank(3)                      MPI                     MPI_Comm_rank(3)\n\n\n\nNAME\n       MPI_Comm_rank -  Determines the rank of the calling process in the com-\n       municator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_rank ( MPI_Comm comm, int *rank )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       rank   - rank of the calling process in group of comm (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       comm_rank.c\n\n\n\n                                  11/14/2001                  MPI_Comm_rank(3)",
            "title": "MPI_Comm_rank"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_remote_group",
            "text": "MPI_Comm_remote_group(3)              MPI             MPI_Comm_remote_group(3)\n\n\n\nNAME\n       MPI_Comm_remote_group -  Accesses the remote group associated with  the\n       given inter-communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_remote_group ( MPI_Comm comm, MPI_Group *group )\n\nINPUT PARAMETER\n       comm   - Communicator (must be intercommunicator)\n\n\nOUTPUT PARAMETER\n       group  - remote group of communicator\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       comm_rgroup.c\n\n\n\n                                  11/14/2001          MPI_Comm_remote_group(3)",
            "title": "MPI_Comm_remote_group"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_remote_size",
            "text": "MPI_Comm_remote_size(3)               MPI              MPI_Comm_remote_size(3)\n\n\n\nNAME\n       MPI_Comm_remote_size  -  Determines the size of the remote group  asso-\n       ciated with an inter-communictor\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_remote_size ( MPI_Comm comm, int *size )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       size   - number of processes in the group of comm (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_rsize.c\n\n\n\n                                  11/14/2001           MPI_Comm_remote_size(3)",
            "title": "MPI_Comm_remote_size"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_size",
            "text": "MPI_Comm_size(3)                      MPI                     MPI_Comm_size(3)\n\n\n\nNAME\n       MPI_Comm_size  -   Determines  the  size of the group associated with a\n       communictor\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_size ( MPI_Comm comm, int *size )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       size   - number of processes in the group of comm (integer)\n\n\nNOTES\n       MPI_COMM_NULL is not considered a valid argument to this function.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_size.c\n\n\n\n                                  11/14/2001                  MPI_Comm_size(3)",
            "title": "MPI_Comm_size"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_split",
            "text": "MPI_Comm_split(3)                     MPI                    MPI_Comm_split(3)\n\n\n\nNAME\n       MPI_Comm_split -  Creates new communicators based on colors and keys\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_split ( MPI_Comm comm, int color, int key, MPI_Comm *comm_out )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n       color  - control of subset assignment (nonnegative integer).  Processes\n              with the same color are in the same new communicator\n       key    - control of rank assigment (integer)\n\n\nOUTPUT PARAMETER\n       newcomm\n              - new communicator (handle)\n\n\nNOTES\n       The color must be non-negative or MPI_UNDEFINED .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nALGORITHM\n       The current algorithm used has quite a few (read: a lot of) inefficien-\n       cies that can be removed.  Here is what we do for now\n\n       1) A table is built of colors, and keys (has a next field also).\n       2) The tables of all processes are merged using\n       MPI_Allreduce\n       .\n       3) Two contexts are allocated for all the comms to be created.  These\n       same two contexts can be used for all created communicators since\n       the communicators will not overlap.\n       4) If the local process has a color of\n       MPI_UNDEFINED\n       , it can return\n       a\n       NULL\n       comm.\n       5) The table entries that match the local process color are sorted\n       by key/rank.\n       6) A group is created from the sorted list and a communicator is created\n       with this group and the previously allocated contexts.\n\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Comm_free\n\nLOCATION\n       comm_split.c\n\n\n\n                                   8/29/2002                 MPI_Comm_split(3)",
            "title": "MPI_Comm_split"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_test_inter",
            "text": "MPI_Comm_test_inter(3)                MPI               MPI_Comm_test_inter(3)\n\n\n\nNAME\n       MPI_Comm_test_inter -  Tests to see if a comm is an inter-communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Comm_test_inter ( MPI_Comm comm, int *flag )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       flag   - (logical)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_testic.c\n\n\n\n                                  11/14/2001            MPI_Comm_test_inter(3)",
            "title": "MPI_Comm_test_inter"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_dims_create",
            "text": "MPI_Dims_create(3)                    MPI                   MPI_Dims_create(3)\n\n\n\nNAME\n       MPI_Dims_create -  Creates a division of processors in a cartesian grid\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Dims_create(\n               int nnodes,\n               int ndims,\n               int *dims)\n\nINPUT PARAMETERS\n       nnodes - number of nodes in a grid (integer)\n       ndims  - number of cartesian dimensions (integer)\n\n\nIN/OUT PARAMETER\n       dims   - integer array of size ndims specifying the number of nodes  in\n              each dimension\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       dims_create.c\n\n\n\n                                   4/24/2002                MPI_Dims_create(3)",
            "title": "MPI_Dims_create"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_errhandler_create",
            "text": "MPI_Errhandler_create(3)              MPI             MPI_Errhandler_create(3)\n\n\n\nNAME\n       MPI_Errhandler_create -  Creates an MPI-style errorhandler\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Errhandler_create(\n               MPI_Handler_function *function,\n               MPI_Errhandler       *errhandler)\n\nINPUT PARAMETER\n       function\n              - user defined error handling procedure\n\n\nOUTPUT PARAMETER\n       errhandler\n              - MPI error handler (handle)\n\n\nNOTES\n       The  MPI  Standard  states  that  an implementation may make the output\n       value (errhandler) simply the address of the  function.   However,  the\n       action  of  MPI_Errhandler_free  makes  this  impossible,  since  it is\n       required to set the value of the argument to MPI_ERRHANDLER_NULL .   In\n       addition,  the actual error handler must remain until all communicators\n       that use it are freed.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       errcreate.c\n\n\n\n                                  11/14/2001          MPI_Errhandler_create(3)",
            "title": "MPI_Errhandler_create"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_errhandler_free",
            "text": "MPI_Errhandler_free(3)                MPI               MPI_Errhandler_free(3)\n\n\n\nNAME\n       MPI_Errhandler_free -  Frees an MPI-style errorhandler\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Errhandler_free( MPI_Errhandler *errhandler )\n\nINPUT PARAMETER\n       errhandler\n              -  MPI  error  handler  (handle).  Set to MPI_ERRHANDLER_NULL on\n              exit.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       errfree.c\n\n\n\n                                  11/14/2001            MPI_Errhandler_free(3)",
            "title": "MPI_Errhandler_free"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_errhandler_get",
            "text": "MPI_Errhandler_get(3)                 MPI                MPI_Errhandler_get(3)\n\n\n\nNAME\n       MPI_Errhandler_get -  Gets the error handler for a communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Errhandler_get( MPI_Comm comm, MPI_Errhandler *errhandler )\n\nINPUT PARAMETER\n       comm   - communicator to get the error handler from (handle)\n\n\nOUTPUT PARAMETER\n       errhandler\n              - MPI error handler currently associated with communicator (han-\n              dle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTE ON IMPLEMENTATION\n       The  MPI Standard was unclear on whether this routine required the user\n       to call MPI_Errhandler_free once for each call made to this routine  in\n       order  to  free  the  error  handler.  After some debate, the MPI Forum\n       added an explicit statement that users are required to call MPI_Errhan-\n       dler_free  when the return value from this routine is no longer needed.\n       This behavior is similar to the other MPI routines for getting objects;\n       for  example, MPI_Comm_group requires that the user call MPI_Group_free\n       when the group returned by MPI_Comm_group is no longer needed.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       errget.c\n\n\n\n                                  11/14/2001             MPI_Errhandler_get(3)",
            "title": "MPI_Errhandler_get"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_errhandler_set",
            "text": "MPI_Errhandler_set(3)                 MPI                MPI_Errhandler_set(3)\n\n\n\nNAME\n       MPI_Errhandler_set -  Sets the error handler for a communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Errhandler_set( MPI_Comm comm, MPI_Errhandler errhandler )\n\nINPUT PARAMETERS\n       comm   - communicator to set the error handler for (handle)\n       errhandler\n              - new MPI error handler for communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       errset.c\n\n\n\n                                  11/14/2001             MPI_Errhandler_set(3)",
            "title": "MPI_Errhandler_set"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_error_class",
            "text": "MPI_Error_class(3)                    MPI                   MPI_Error_class(3)\n\n\n\nNAME\n       MPI_Error_class -  Converts an error code into an error class\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Error_class(\n               int errorcode,\n               int *errorclass)\n\nINPUT PARAMETER\n       errorcode\n              - Error code returned by an MPI routine\n\n\nOUTPUT PARAMETER\n       errorclass\n              - Error class associated with errorcode\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       errclass.c\n\n\n\n                                  11/14/2001                MPI_Error_class(3)",
            "title": "MPI_Error_class"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_error_string",
            "text": "MPI_Error_string(3)                   MPI                  MPI_Error_string(3)\n\n\n\nNAME\n       MPI_Error_string -  Return a string for a given error code\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Error_string( int errorcode, char *string, int *resultlen )\n\nINPUT PARAMETERS\n       errorcode\n              - Error code returned by an MPI routine or an MPI error class\n\n\nOUTPUT PARAMETER\n       string - Text that corresponds to the errorcode\n       resultlen\n              - Length of string\n\n              Notes:  Error codes are the values return by MPI routines (in C)\n              or in the ierr argument (in Fortran).  These  can  be  converted\n              into error classes with the routine MPI_Error_class .\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       errorstring.c\n\n\n\n                                  11/14/2001               MPI_Error_string(3)",
            "title": "MPI_Error_string"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_finalize",
            "text": "MPI_Finalize(3)                       MPI                      MPI_Finalize(3)\n\n\n\nNAME\n       MPI_Finalize -  Terminates MPI execution environment\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Finalize()\n\nNOTES\n       All  processes  must  call  this routine before exiting.  The number of\n       processes running after this routine is called is undefined; it is best\n       not  to perform much more than a return rc after calling MPI_Finalize .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       finalize.c\n\n\n\n                                   4/9/2002                    MPI_Finalize(3)",
            "title": "MPI_Finalize"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_gather",
            "text": "MPI_Gather(3)                         MPI                        MPI_Gather(3)\n\n\n\nNAME\n       MPI_Gather -  Gathers together values from a group of processes\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Gather ( void *sendbuf, int sendcnt, MPI_Datatype sendtype,\n                       void *recvbuf, int recvcount, MPI_Datatype recvtype,\n                       int root, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              -  number  of elements for any single receive (integer, signifi-\n              cant only at root)\n       recvtype\n              - data type of recv buffer elements (significant only  at  root)\n              (handle)\n       root   - rank of receiving process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice, significant only at root )\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\nLOCATION\n       gather.c\n\n\n\n                                  11/14/2001                     MPI_Gather(3)",
            "title": "MPI_Gather"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_gatherv",
            "text": "MPI_Gatherv(3)                        MPI                       MPI_Gatherv(3)\n\n\n\nNAME\n       MPI_Gatherv -  Gathers into specified locations from all processes in a\n       group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Gatherv ( void *sendbuf, int sendcnt, MPI_Datatype sendtype,\n                         void *recvbuf, int *recvcnts, int *displs,\n                        MPI_Datatype recvtype,\n                         int root, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcounts\n              - integer array (of length group size) containing the number  of\n              elements  that  are received from each process (significant only\n              at root )\n       displs - integer array (of length group size). Entry  i  specifies  the\n              displacement relative to recvbuf  at which to place the incoming\n              data from process i (significant only at root)\n       recvtype\n              - data type of recv buffer elements (significant only at root  )\n              (handle)\n       root   - rank of receiving process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice, significant only at root )\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       gatherv.c\n\n\n\n                                   2/19/2002                    MPI_Gatherv(3)",
            "title": "MPI_Gatherv"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_get_count",
            "text": "MPI_Get_count(3)                      MPI                     MPI_Get_count(3)\n\n\n\nNAME\n       MPI_Get_count -  Gets the number of \"top level\" elements\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Get_count(\n               MPI_Status *status,\n               MPI_Datatype datatype,\n               int *count )\n\nINPUT PARAMETERS\n       status - return status of receive operation (Status)\n       datatype\n              - datatype of each receive buffer element (handle)\n\n\nOUTPUT PARAMETER\n       count  -  number  of  received elements (integer) Notes: If the size of\n              the datatype is zero, this routine will return a count of  zero.\n              If  the amount of data in status is not an exact multiple of the\n              size of datatype (so that count would not be integral), a  count\n              of MPI_UNDEFINED is returned instead.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       getcount.c\n\n\n\n                                  11/14/2001                  MPI_Get_count(3)",
            "title": "MPI_Get_count"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_get_elements",
            "text": "MPI_Get_elements(3)                   MPI                  MPI_Get_elements(3)\n\n\n\nNAME\n       MPI_Get_elements -  Returns the number of basic elements in a datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Get_elements ( MPI_Status *status, MPI_Datatype datatype,\n                             int *elements )\n\nINPUT PARAMETERS\n       status - return status of receive operation (Status)\n       datatype\n              - datatype used by receive operation (handle)\n\n\nOUTPUT PARAMETER\n       count  - number of received basic elements (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\n\nLOCATION\n       getelements.c\n\n\n\n                                  11/14/2001               MPI_Get_elements(3)",
            "title": "MPI_Get_elements"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_get_processor_name",
            "text": "MPI_Get_processor_name(3)             MPI            MPI_Get_processor_name(3)\n\n\n\nNAME\n       MPI_Get_processor_name -  Gets the name of the processor\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Get_processor_name(\n               char *name,\n               int *resultlen)\n\nOUTPUT PARAMETERS\n       name   -  A  unique  specifier  for  the actual (as opposed to virtual)\n              node. This must be an array of  size  at  least  MPI_MAX_PROCES-\n              SOR_NAME .\n\n       resultlen\n              - Length (in characters) of the name\n\n\nNOTES\n       The  name  returned should identify a particular piece of hardware; the\n       exact format is implementation defined.  This name may or  may  not  be\n       the same as might be returned by gethostname , uname , or sysinfo .\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       getpname.c\n\n\n\n                                  11/14/2001         MPI_Get_processor_name(3)",
            "title": "MPI_Get_processor_name"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_get_version",
            "text": "MPI_Get_version(3)                    MPI                   MPI_Get_version(3)\n\n\n\nNAME\n       MPI_Get_version -  Gets the version of MPI\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Get_version(\n               int *version,\n               int *subversion )\n\nOUTPUT PARAMETERS\n       version\n              - Major version of MPI (1 or 2)\n       subversion\n              - Minor version of MPI.\n\n\nNOTES\n       The  defined  values  MPI_VERSION  and  MPI_SUBVERSION contain the same\n       information.  This routine allows you to check that the library matches\n       the version specified in the mpi.h and mpif.h files.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       getversion.c\n\n\n\n                                  11/14/2001                MPI_Get_version(3)",
            "title": "MPI_Get_version"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_graph_create",
            "text": "MPI_Graph_create(3)                   MPI                  MPI_Graph_create(3)\n\n\n\nNAME\n       MPI_Graph_create -  Makes a new communicator to which topology informa-\n       tion has been attached\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Graph_create ( MPI_Comm comm_old, int nnodes, int *index, int *edges,\n                             int reorder, MPI_Comm *comm_graph )\n\nINPUT PARAMETERS\n       comm_old\n              - input communicator without topology (handle)\n       nnodes - number of nodes in graph (integer)\n       index  - array of integers describing node degrees (see below)\n       edges  - array of integers describing graph edges (see below)\n       reorder\n              - ranking may be reordered (true) or not (false) (logical)\n\n\nOUTPUT PARAMETER\n       comm_graph\n              - communicator with graph topology added (handle)\n\n\nALGORITHM\n       We ignore the reorder info currently.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graphcreate.c\n\n\n\n                                   1/4/2002                MPI_Graph_create(3)",
            "title": "MPI_Graph_create"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_graphdims_get",
            "text": "MPI_Graphdims_get(3)                  MPI                 MPI_Graphdims_get(3)\n\n\n\nNAME\n       MPI_Graphdims_get  -   Retrieves  graph topology information associated\n       with a  communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Graphdims_get ( MPI_Comm comm, int *nnodes, int *nedges )\n\nINPUT PARAMETERS\n       comm   - communicator for group with graph structure (handle)\n\n\nOUTPUT PARAMETER\n       nnodes - number of nodes in graph (integer)\n       nedges - number of edges in graph (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graphdimsget.c\n\n\n\n                                  11/14/2001              MPI_Graphdims_get(3)",
            "title": "MPI_Graphdims_get"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_graph_get",
            "text": "MPI_Graph_get(3)                      MPI                     MPI_Graph_get(3)\n\n\n\nNAME\n       MPI_Graph_get -  Retrieves graph topology information associated with a\n       communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Graph_get ( MPI_Comm comm, int maxindex, int maxedges,\n                          int *index, int *edges )\n\nINPUT PARAMETERS\n       comm   - communicator with graph structure (handle)\n       maxindex\n              - length of vector index in the calling program  (integer)\n       maxedges\n              - length of vector edges in the calling program  (integer)\n\n\nOUTPUT PARAMETER\n       index  - array of integers containing the graph structure (for  details\n              see the definition of MPI_GRAPH_CREATE )\n       edges  - array of integers containing the graph structure\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graph_get.c\n\n\n\n                                   1/4/2002                   MPI_Graph_get(3)",
            "title": "MPI_Graph_get"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_graph_map",
            "text": "MPI_Graph_map(3)                      MPI                     MPI_Graph_map(3)\n\n\n\nNAME\n       MPI_Graph_map -  Maps process to graph topology information\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Graph_map ( MPI_Comm comm_old, int nnodes, int *index, int *edges,\n                          int *newrank )\n\nINPUT PARAMETERS\n       comm   - input communicator (handle)\n       nnodes - number of graph nodes (integer)\n       index  -   integer   array   specifying   the   graph   structure,  see\n              MPI_GRAPH_CREATE\n\n       edges  - integer array specifying the graph structure\n\n\nOUTPUT PARAMETER\n       newrank\n              - reordered rank of the calling process;  MPI_UNDEFINED  if  the\n              calling process does not belong to graph (integer)\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graph_map.c\n\n\n\n                                   1/4/2002                   MPI_Graph_map(3)",
            "title": "MPI_Graph_map"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_graph_neighbors_count",
            "text": "MPI_Graph_neighbors_count(3)          MPI         MPI_Graph_neighbors_count(3)\n\n\n\nNAME\n       MPI_Graph_neighbors_count  -  Returns the number of neighbors of a node\n       associated with a graph topology\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Graph_neighbors_count ( MPI_Comm comm, int rank, int *nneighbors )\n\nINPUT PARAMETERS\n       comm   - communicator with graph topology (handle)\n       rank   - rank of process in group of comm (integer)\n\n\nOUTPUT PARAMETER\n       nneighbors\n              - number of neighbors of specified process (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       graphnbrcnt.c\n\n\n\n                                  11/14/2001      MPI_Graph_neighbors_count(3)",
            "title": "MPI_Graph_neighbors_count"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_graph_neighbors",
            "text": "MPI_Graph_neighbors(3)                MPI               MPI_Graph_neighbors(3)\n\n\n\nNAME\n       MPI_Graph_neighbors -  Returns the neighbors of a node associated  with\n       a graph topology\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Graph_neighbors ( MPI_Comm comm, int rank, int maxneighbors,\n                               int *neighbors )\n\nINPUT PARAMETERS\n       comm   - communicator with graph topology (handle)\n       rank   - rank of process in group of comm (integer)\n       maxneighbors\n              - size of array neighbors (integer)\n\n\nOUTPUT PARAMETERS\n       neighbors\n              - ranks of processes that are  neighbors  to  specified  process\n              (array of integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       graph_nbr.c\n\n\n\n                                  11/14/2001            MPI_Graph_neighbors(3)",
            "title": "MPI_Graph_neighbors"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_compare",
            "text": "MPI_Group_compare(3)                  MPI                 MPI_Group_compare(3)\n\n\n\nNAME\n       MPI_Group_compare -  Compares two groups\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_compare ( MPI_Group group1, MPI_Group group2, int *result )\n\nINPUT PARAMETERS\n       group1 - group1 (handle)\n       group2 - group2 (handle)\n\n\nOUTPUT PARAMETER\n       result - integer which is MPI_IDENT if the order and members of the two\n              groups are the same, MPI_SIMILAR if only  the  members  are  the\n              same, and MPI_UNEQUAL otherwise\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       groupcompare.c\n\n\n\n                                  11/14/2001              MPI_Group_compare(3)",
            "title": "MPI_Group_compare"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_difference",
            "text": "MPI_Group_difference(3)               MPI              MPI_Group_difference(3)\n\n\n\nNAME\n       MPI_Group_difference -  Makes a group from the difference of two groups\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_difference ( MPI_Group group1, MPI_Group group2,\n                                MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group1 - first group (handle)\n       group2 - second group (handle)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - difference group (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_diff.c\n\n\n\n                                  11/14/2001           MPI_Group_difference(3)",
            "title": "MPI_Group_difference"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_excl",
            "text": "MPI_Group_excl(3)                     MPI                    MPI_Group_excl(3)\n\n\n\nNAME\n       MPI_Group_excl  -  Produces a group by reordering an existing group and\n       taking only unlisted members\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_excl ( MPI_Group group, int n, int *ranks, MPI_Group *newgroup )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of elements in array ranks (integer)\n       ranks  - array of integer ranks in group not to appear in newgroup\n\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, preserving the order defined  by\n              group (handle)\n\n\nNOTE\n       Currently,  each  of  the  ranks to exclude must be a valid rank in the\n       group and all elements must be distinct or the function  is  erroneous.\n       This restriction is per the draft.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_excl.c\n\n\n\n                                  11/14/2001                 MPI_Group_excl(3)",
            "title": "MPI_Group_excl"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_free",
            "text": "MPI_Group_free(3)                     MPI                    MPI_Group_free(3)\n\n\n\nNAME\n       MPI_Group_free -  Frees a group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_free ( MPI_Group *group )\n       Input Parameter\n       group  - group (handle)\n\n\nNOTES\n       On output, group is set to MPI_GROUP_NULL .\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              groups.\n\nLOCATION\n       group_free.c\n\n\n\n                                  11/14/2001                 MPI_Group_free(3)",
            "title": "MPI_Group_free"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_incl",
            "text": "MPI_Group_incl(3)                     MPI                    MPI_Group_incl(3)\n\n\n\nNAME\n       MPI_Group_incl  -  Produces a group by reordering an existing group and\n       taking only listed members\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_incl ( MPI_Group group, int n, int *ranks, MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of elements in array ranks  (and  size  of  newgroup  )\n              (integer)\n       ranks  -  ranks  of  processes in group to appear in newgroup (array of\n              integers)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, in the order defined by ranks\n\n              (handle)\n\n\nNOTE\n       This implementation does not currently check to see that  the  list  of\n       ranks to ensure that there are no duplicates.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_incl.c\n\n\n\n                                  11/14/2001                 MPI_Group_incl(3)",
            "title": "MPI_Group_incl"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_intersection",
            "text": "MPI_Group_intersection(3)             MPI            MPI_Group_intersection(3)\n\n\n\nNAME\n       MPI_Group_intersection  -   Produces a group as the intersection of two\n       existing groups\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_intersection ( MPI_Group group1, MPI_Group group2,\n                                  MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group1 - first group (handle)\n       group2 - second group (handle)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - intersection group (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_inter.c\n\n\n\n                                  11/14/2001         MPI_Group_intersection(3)",
            "title": "MPI_Group_intersection"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_range_excl",
            "text": "MPI_Group_range_excl(3)               MPI              MPI_Group_range_excl(3)\n\n\n\nNAME\n       MPI_Group_range_excl  -   Produces  a group by excluding ranges of pro-\n       cesses from an existing group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_range_excl ( MPI_Group group, int n, int ranges[][3],\n                                MPI_Group *newgroup )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of elements in array ranks (integer)\n       ranges - a one-dimensional array of integer triplets of the form (first\n              rank,  last rank, stride), indicating the ranks in group of pro-\n              cesses to be excluded from the output group newgroup .\n\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, preserving the  order  in  group\n              (handle)\n\n\nNOTE\n       Currently,  each  of  the  ranks to exclude must be a valid rank in the\n       group and all elements must be distinct or the function  is  erroneous.\n       This restriction is per the draft.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_rexcl.c\n\n\n\n                                  11/14/2001           MPI_Group_range_excl(3)",
            "title": "MPI_Group_range_excl"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_range_incl",
            "text": "MPI_Group_range_incl(3)               MPI              MPI_Group_range_incl(3)\n\n\n\nNAME\n       MPI_Group_range_incl  -  Creates a new group from ranges of ranks in an\n       existing group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_range_incl ( MPI_Group group, int n, int ranges[][3],\n                                MPI_Group *newgroup )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of triplets in array ranges (integer)\n       ranges - a one-dimensional array  of  integer  triplets,  of  the  form\n              (first  rank,  last  rank,  stride) indicating ranks in group or\n              processes to be included in newgroup\n\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, in the order defined  by  ranges\n              (handle)\n\n\nNOTE\n       This  implementation  does  not currently check to see that the list of\n       ranges to include are valid ranks in the group.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_rincl.c\n\n\n\n                                  11/14/2001           MPI_Group_range_incl(3)",
            "title": "MPI_Group_range_incl"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_rank",
            "text": "MPI_Group_rank(3)                     MPI                    MPI_Group_rank(3)\n\n\n\nNAME\n       MPI_Group_rank -  Returns the rank of this process in the given group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_rank ( MPI_Group group, int *rank )\n\nINPUT PARAMETERS\n       group  - group (handle)\n\n\nOUTPUT PARAMETER\n       rank   -  rank of the calling process in group, or MPI_UNDEFINED if the\n              process is not a member (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       group_rank.c\n\n\n\n                                  11/14/2001                 MPI_Group_rank(3)",
            "title": "MPI_Group_rank"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_size",
            "text": "MPI_Group_size(3)                     MPI                    MPI_Group_size(3)\n\n\n\nNAME\n       MPI_Group_size -  Returns the size of a group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_size ( MPI_Group group, int *size )\n\nINPUT PARAMETERS\n       group  - group (handle) Output Parameter:\n       size   - number of processes in the group (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       group_size.c\n\n\n\n                                  11/14/2001                 MPI_Group_size(3)",
            "title": "MPI_Group_size"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_translate_ranks",
            "text": "MPI_Group_translate_ranks(3)          MPI         MPI_Group_translate_ranks(3)\n\n\n\nNAME\n       MPI_Group_translate_ranks  -   Translates the ranks of processes in one\n       group to  those in another group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_translate_ranks ( MPI_Group group_a, int n, int *ranks_a,\n                                    MPI_Group group_b, int *ranks_b )\n\nINPUT PARAMETERS\n       group1 - group1 (handle)\n       n      - number of ranks in ranks1 and ranks2 arrays (integer)\n       ranks1 - array of zero or more valid ranks in group1\n\n       group2 - group2 (handle)\n\n\nOUTPUT PARAMETER\n       ranks2 - array of corresponding ranks in group2, MPI_UNDEFINED when  no\n              correspondence exists.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       group_tranks.c\n\n\n\n                                  11/14/2001      MPI_Group_translate_ranks(3)",
            "title": "MPI_Group_translate_ranks"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_union",
            "text": "MPI_Group_union(3)                    MPI                   MPI_Group_union(3)\n\n\n\nNAME\n       MPI_Group_union -  Produces a group by combining two groups\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Group_union ( MPI_Group group1, MPI_Group group2,\n                            MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group1 - first group (handle)\n       group2 - second group (handle)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - union group (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_union.c\n\n\n\n                                  11/14/2001                MPI_Group_union(3)",
            "title": "MPI_Group_union"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_ibsend",
            "text": "MPI_Ibsend(3)                         MPI                        MPI_Ibsend(3)\n\n\n\nNAME\n       MPI_Ibsend -  Starts a nonblocking buffered send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Ibsend( void *buf, int count, MPI_Datatype datatype, int dest, int tag,\n                      MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\n\nLOCATION\n       ibsend.c\n\n\n\n                                  11/14/2001                     MPI_Ibsend(3)",
            "title": "MPI_Ibsend"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_initialized",
            "text": "MPI_Initialized(3)                    MPI                   MPI_Initialized(3)\n\n\n\nNAME\n       MPI_Initialized -  Indicates whether MPI_Init has been called.\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Initialized( int *flag )\n\nOUTPUT PARAMETER\n       flag   -  Flag is true if MPI_Init has been called and false otherwise.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       initialize.c\n\n\n\n                                  11/14/2001                MPI_Initialized(3)",
            "title": "MPI_Initialized"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_init",
            "text": "MPI_Init(3)                           MPI                          MPI_Init(3)\n\n\n\nNAME\n       MPI_Init -  Initialize the MPI execution environment\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Init(int *argc, char ***argv)\n\nINPUT PARAMETERS\n       argc   - Pointer to the number of arguments\n       argv   - Pointer to the argument vector\n\n\nCOMMAND LINE ARGUMENTS\n       MPI specifies no command-line arguments but does allow an MPI implemen-\n       tation to make use of them.\n\n       -mpiqueue\n              - print out the state of the message queues when MPI_FINALIZE is\n              called.   All  processors print; the output may be hard to deci-\n              pher.  This is intended as a debugging aid.\n\n       -mpiversion\n              - print out the version of the implementation  (  not  of  MPI),\n              including the arguments that were used with configure.\n\n       -mpinice nn\n              -  Increments the nice value by nn (lowering the priority of the\n              program by nn ).  nn must be positive (except  for  root).   Not\n              all systems support this argument; those that do not will ignore\n              it.\n\n       -mpedbg\n              - Start a debugger in an xterm  window  if  there  is  an  error\n              (either detected by MPI or a normally fatal signal).  This works\n              only if MPICH was configured with -mpedbg .  CURRENTLY DISABLED.\n              If  you  have  TotalView, -mpichtv or mpirun -tv will give you a\n              better environment anyway.\n\n       -mpimem\n              - If MPICH was built with -DMPIR_DEBUG_MEM  ,  this  checks  all\n              malloc  and  free  operations  (internal  to MPICH) for signs of\n              injury to the memory allocation areas.\n\n       -mpidb options\n              - Activate various debugging options.  Some require  that  MPICH\n              have  been  built  with special options.  These are intended for\n              debugging MPICH, not for debugging user programs.  The available\n              options include:\n              mem     - Enable dynamic memory tracing of internal MPI objects\n              memall  - Generate output of all memory allocation/deallocation\n              ptr     - Enable tracing of internal MPI pointer conversions\n              rank n  - Limit subsequent -mpidb options to on the process with\n              the specified rank in MPI_COMM_WORLD.  A rank of -1\n              selects all of MPI_COMM_WORLD.\n              ref     - Trace use of internal MPI objects\n              reffile filename - Trace use of internal MPI objects with output\n              to the indicated file\n              trace   - Trace routine calls\n\n\n\nNOTES\n       Note  that  the  Fortran  binding  for  this routine has only the error\n       return argument ( MPI_INIT(ierror) )\n\n       Because the Fortran and C versions of MPI_Init are different, there  is\n       a  restriction  on  who can call MPI_Init .  The version (Fortran or C)\n       must match the main program.  That is, if the main  program  is  in  C,\n       then  the C version of MPI_Init must be called.  If the main program is\n       in Fortran, the Fortran version must be called.\n\n       On exit from this routine, all processes will have a copy of the  argu-\n       ment  list.   This  is  not  required  by  the MPI standard, and truely\n       portable codes should not rely on it.  This is provided as a service by\n       this implementation (an MPI implementation is allowed to distribute the\n       command line arguments but is not required to).\n\n       Command line arguments are not provided to Fortran programs.  More pre-\n       cisely,  non-standard  Fortran  routines  such as getarg and iargc have\n       undefined behavior in MPI and in this implementation.\n\n       The MPI standard does not say what a program can do before an  MPI_INIT\n       or  after an MPI_FINALIZE .  In the MPICH implementation, you should do\n       as little as possible.  In particular, avoid anything that changes  the\n       external  state of the program, such as opening files, reading standard\n       input or writing to standard output.\n\n\nSIGNALS USED\n       The MPI standard requires that all signals  used  be  documented.   The\n       MPICH  implementation  itself uses no signals, but some of the software\n       that MPICH relies on may use some signals.  The list below  is  partial\n       and  should  be  independantly checked if you (and any package that you\n       use) depend on particular signals.\n\n\nIBM POE/MPL FOR SP2\n       SIGHUP, SIGINT, SIGQUIT, SIGFPE, SIGSEGV,  SIGPIPE,  SIGALRM,  SIGTERM,\n       SIGIO\n\n\n-MPEDBG SWITCH\n       SIGQUIT, SIGILL, SIGFPE, SIGBUS, SIGSEGV, SIGSYS\n\n\nMEIKO CS2\n       SIGUSR2\n\n\nCH_P4 DEVICE\n       SIGUSR1\n\n       The ch_p4 device also catches SIGINT, SIGFPE, SIGBUS, and SIGSEGV; this\n       helps the p4 device (and MPICH) more gracefully abort a failed program.\n\n\nINTEL PARAGON (CH_NX AND NX DEVICE)\n       SIGUSR2\n\n\nSHARED MEMORY (CH_SHMEM DEVICE)\n       SIGCHLD\n\n       Note  that  if  you are using software that needs the same signals, you\n       may find that there is no way to use that software with the MPI  imple-\n       mentation.   The  signals  that cause the most trouble for applications\n       include SIGIO , SIGALRM , and SIGPIPE .  For example, using  SIGIO  and\n       SIGPIPE may prevent X11 routines from working.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_OTHER\n              - This error class is associated with an error code  that  indi-\n              cates  that  an attempt was made to call MPI_INIT a second time.\n              MPI_INIT may only be called once in a program.\n\nLOCATION\n       init.c\n\n\n\n                                   4/8/2002                        MPI_Init(3)",
            "title": "MPI_Init"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_init_thread",
            "text": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\" />\n<title>404 Not Found</title>\n</head>\n\n<body>\n<p><strong>HTTP 404 - Not Found</strong><p />\n\nThe requested URL was not found on this server.\n</body>\n</html>",
            "title": "mpi_init_thread"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_intercomm_create",
            "text": "MPI_Intercomm_create(3)               MPI              MPI_Intercomm_create(3)\n\n\n\nNAME\n       MPI_Intercomm_create  -  Creates an intercommuncator from two intracom-\n       municators\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Intercomm_create ( MPI_Comm local_comm, int local_leader,\n                                MPI_Comm peer_comm, int remote_leader, int tag,\n                                MPI_Comm *comm_out )\n\nINPUT PARAMTERS\n       local_comm\n              - Local (intra)communicator\n       local_leader\n              - Rank in local_comm of leader (often 0)\n       peer_comm\n              - Remote communicator\n       remote_leader\n              - Rank in peer_comm of remote leader (often 0)\n       tag    - Message tag to use in constructing intercommunicator; if  mul-\n              tiple MPI_Intercomm_creates are being made, they should use dif-\n              ferent tags (more precisely, ensure that the  local  and  remote\n              leaders  are  using different tags for each MPI_intercomm_create\n              ).\n\n\nOUTPUT PARAMETER\n       comm_out\n              - Created intercommunicator\n\n\nNOTES\n       The MPI 1.1 Standard contains two mutually exclusive  comments  on  the\n       input intracommunicators.  One says that their repective groups must be\n       disjoint; the other that the leaders can be the  same  process.   After\n       some  discussion  by the MPI Forum, it has been decided that the groups\n       must be disjoint.  Note that the reason given for this in the  standard\n       is  not  the  reason  for  this choice; rather, the other operations on\n       intercommunicators (like MPI_Intercomm_merge ) do not make sense if the\n       groups are not disjoint.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nALGORITHM\n       1) Allocate a send context, an inter\n              - coll context, and an intra-coll context\n       2) Send send_context and lrank_to_grank list from local comm group\n              - if I'm the local_leader.\n       3) If I'm the local leader, then wait on the posted sends and receives\n              - to complete.  Post the receive for the remote  group  informa-\n              tion and wait for it to complete.\n       4) Broadcast information received from the remote leader.\n              - . 5) Create the inter_communicator from the information we now\n              have.\n       An inter\n              - communicator ends up with three levels of communicators.   The\n              inter-communicator  returned  to the user, a \"collective\" inter-\n              communicator that can be used for  safe  communications  between\n              local  & remote groups, and a collective intra-communicator that\n              can be used to allocate new contexts during the  merge  and  dup\n              operations.\n\n              For the resulting inter-communicator, comm_out\n\n\n              comm_out                       = inter-communicator\n              comm_out->comm_coll            = \"collective\" inter-communicator\n              comm_out->comm_coll->comm_coll = safe collective intra-communicator\n\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Intercomm_merge, MPI_Comm_free, MPI_Comm_remote_group,\n       MPI_Comm_remote_size\n\nLOCATION\n       ic_create.c\n\n\n\n                                  11/14/2001           MPI_Intercomm_create(3)",
            "title": "MPI_Intercomm_create"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_intercomm_merge",
            "text": "MPI_Intercomm_merge(3)                MPI               MPI_Intercomm_merge(3)\n\n\n\nNAME\n       MPI_Intercomm_merge  -  Creates an intracommuncator from an intercommu-\n       nicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Intercomm_merge ( MPI_Comm comm, int high, MPI_Comm *comm_out )\n\nINPUT PARAMETERS\n       comm   - Intercommunicator\n       high   - Used to order the groups of the two intracommunicators  within\n              comm when creating the new communicator.\n\n\nOUTPUT PARAMETER\n       comm_out\n              - Created intracommunicator\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nALGORITHM\n       1) Allocate two contexts\n       2) Local and remote group leaders swap high values\n       3) Determine the high value.\n       4) Merge the two groups and make the intra-communicator\n\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Intercomm_create, MPI_Comm_free\n\nLOCATION\n       ic_merge.c\n\n\n\n                                  11/14/2001            MPI_Intercomm_merge(3)",
            "title": "MPI_Intercomm_merge"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_iprobe",
            "text": "MPI_Iprobe(3)                         MPI                        MPI_Iprobe(3)\n\n\n\nNAME\n       MPI_Iprobe -  Nonblocking test for a message\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Iprobe( int source, int tag, MPI_Comm comm, int *flag,\n                      MPI_Status *status )\n\nINPUT PARAMETERS\n       source - source rank, or MPI_ANY_SOURCE (integer)\n       tag    - tag value or MPI_ANY_TAG (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       flag   - (logical)\n       status - status object (Status)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       iprobe.c\n\n\n\n                                   12/7/2004                     MPI_Iprobe(3)",
            "title": "MPI_Iprobe"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_irecv",
            "text": "MPI_Irecv(3)                          MPI                         MPI_Irecv(3)\n\n\n\nNAME\n       MPI_Irecv -  Begins a nonblocking receive\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Irecv( void *buf, int count, MPI_Datatype datatype, int source,\n                      int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of receive buffer (choice)\n       count  - number of elements in receive buffer (integer)\n       datatype\n              - datatype of each receive buffer element (handle)\n       source - rank of source (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       irecv.c\n\n\n\n                                  11/14/2001                      MPI_Irecv(3)",
            "title": "MPI_Irecv"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_irsend",
            "text": "MPI_Irsend(3)                         MPI                        MPI_Irsend(3)\n\n\n\nNAME\n       MPI_Irsend -  Starts a nonblocking ready send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Irsend( void *buf, int count, MPI_Datatype datatype, int dest,\n                      int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle) Output Parameter:\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nLOCATION\n       irsend.c\n\n\n\n                                  11/14/2001                     MPI_Irsend(3)",
            "title": "MPI_Irsend"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_isend",
            "text": "MPI_Isend(3)                          MPI                         MPI_Isend(3)\n\n\n\nNAME\n       MPI_Isend -  Begins a nonblocking send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Isend( void *buf, int count, MPI_Datatype datatype, int dest, int tag,\n                      MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nLOCATION\n       isend.c\n\n\n\n                                  11/14/2001                      MPI_Isend(3)",
            "title": "MPI_Isend"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_issend",
            "text": "MPI_Issend(3)                         MPI                        MPI_Issend(3)\n\n\n\nNAME\n       MPI_Issend -  Starts a nonblocking synchronous send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Issend( void *buf, int count, MPI_Datatype datatype, int dest,\n                      int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       issend.c\n\n\n\n                                  11/14/2001                     MPI_Issend(3)",
            "title": "MPI_Issend"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_keyval_create",
            "text": "MPI_Keyval_create(3)                  MPI                 MPI_Keyval_create(3)\n\n\n\nNAME\n       MPI_Keyval_create -  Generates a new attribute key\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Keyval_create (\n               MPI_Copy_function *copy_fn,\n               MPI_Delete_function *delete_fn,\n               int *keyval,\n               void *extra_state )\n\nINPUT PARAMETERS\n       copy_fn\n              - Copy callback function for keyval\n\n       delete_fn\n              - Delete callback function for keyval\n\n       extra_state\n              - Extra state for callback functions\n\n\nOUTPUT PARAMETER\n       keyval - key value for future access (integer)\n\n\nNOTES\n       Key values are global (available for any and all communicators).\n\n       There  are  subtle  differences between C and Fortran that require that\n       the copy_fn be written in the same language that  MPI_Keyval_create  is\n       called  from.   This  should not be a problem for most users; only pro-\n       gramers using both Fortran and C in the same program need  to  be  sure\n       that they follow this rule.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       keyvalcreate.c\n\n\n\n                                  11/14/2001              MPI_Keyval_create(3)",
            "title": "MPI_Keyval_create"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_keyval_free",
            "text": "MPI_Keyval_free(3)                    MPI                   MPI_Keyval_free(3)\n\n\n\nNAME\n       MPI_Keyval_free -  Frees attribute key for communicator cache attribute\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Keyval_free ( int *keyval )\n\nINPUT PARAMETER\n       keyval - Frees the integer key value (integer)\n\n\nNOTE\n       Key values are global (they can be used with any and all communicators)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              keys.\n\n\nSEE ALSO\n       MPI_Keyval_create\n\nLOCATION\n       keyval_free.c\n\n\n\n                                   6/12/2002                MPI_Keyval_free(3)",
            "title": "MPI_Keyval_free"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_op_create",
            "text": "MPI_Op_create(3)                      MPI                     MPI_Op_create(3)\n\n\n\nNAME\n       MPI_Op_create -  Creates a user-defined combination function handle\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Op_create(\n               MPI_User_function *function,\n               int commute,\n               MPI_Op *op )\n\nINPUT PARAMETERS\n       function\n              - user defined function (function)\n       commute\n              - true if commutative;  false otherwise.\n\n\nOUTPUT PARAMETER\n       op     - operation (handle)\n\n\nNOTES ON THE USER FUNCTION\n       The calling list for the user function type is\n       typedef void (MPI_User_function) ( void * a,\n       void * b, int * len, MPI_Datatype * );\n\n       where  the  operation  is  b[i] = a[i] op b[i] , for i=0,...,len-1 .  A\n       pointer to the datatype given to the MPI collective computation routine\n       (i.e.,  MPI_Reduce , MPI_Allreduce , MPI_Scan , or MPI_Reduce_scatter )\n       is also passed to the user-specified routine.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The  reduction functions ( MPI_Op ) do not return an error value.  As a\n       result, if the functions detect an error, all they  can  do  is  either\n       call  MPI_Abort  or silently skip the problem.  Thus, if you change the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The  reason  for  this is the performance problems in ensuring that all\n       collective routines return the same error value.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Op_free\n\nLOCATION\n       opcreate.c\n\n\n\n                                  11/14/2001                  MPI_Op_create(3)",
            "title": "MPI_Op_create"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_op_free",
            "text": "MPI_Op_free(3)                        MPI                       MPI_Op_free(3)\n\n\n\nNAME\n       MPI_Op_free -  Frees a user-defined combination function handle\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Op_free( MPI_Op *op )\n\nINPUT PARAMETER\n       op     - operation (handle)\n\n\nNOTES\n       op is set to MPI_OP_NULL on exit.\n\n\nNULL HANDLES\n       The MPI 1.1 specification, in the section on opaque objects, explicitly\n\nDISALLOWS FREEING A NULL COMMUNICATOR. THE TEXT FROM THE STANDARD IS\n       A null handle argument is an erroneous IN argument in MPI calls, unless an\n       exception is explicitly stated in the text that defines the function. Such\n       exception is allowed for handles to request objects in Wait and Test calls\n       (sections Communication Completion and Multiple Completions ). Otherwise, a\n       null handle can only be passed to a function that allocates a new object and\n       returns a reference to it in the handle.\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_ARG\n              -  Invalid  argument;  the error code associated with this error\n              indicates an attempt to free an MPI permanent  operation  (e.g.,\n              MPI_SUM ).  *N/ /*N MPI_ERR_PERM_KEY\n       MPI_ERR_ARG\n              -  Invalid  argument;  the error code associated with this error\n              indicates an attempt to free or chnage an MPI  permanent  keyval\n              (e.g., MPI_TAG_UB ).  *N/ /*N MPI_ERR_UNKNOWN\n       MPI_ERR_UNKNOWN\n              -  Unknown error.  You should never see this.  If you do, report\n              it to mpi-bugs@mcs.anl.gov .\n\n\n\nSEE ALSO\n       MPI_Op_create\n\nLOCATION\n       opfree.c\n\n\n\n                                  11/14/2001                    MPI_Op_free(3)",
            "title": "MPI_Op_free"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_pack",
            "text": "MPI_Pack(3)                           MPI                          MPI_Pack(3)\n\n\n\nNAME\n       MPI_Pack -  Packs a datatype into contiguous memory\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Pack ( void *inbuf, int incount, MPI_Datatype datatype,\n                      void *outbuf, int outcount, int *position, MPI_Comm comm )\n\nINPUT PARAMETERS\n       inbuf  - input buffer start (choice)\n       incount\n              - number of input data items (integer)\n       datatype\n              - datatype of each input data item (handle)\n       outcount\n              - output buffer size, in bytes (integer)\n       position\n              - current position in buffer, in bytes (integer)\n       comm   - communicator for packed message (handle)\n\n\nOUTPUT PARAMETER\n       outbuf - output buffer start (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Unpack, MPI_Pack_size\n\n\nLOCATION\n       pack.c\n\n\n\n                                  11/14/2001                       MPI_Pack(3)",
            "title": "MPI_Pack"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_pack_size",
            "text": "MPI_Pack_size(3)                      MPI                     MPI_Pack_size(3)\n\n\n\nNAME\n       MPI_Pack_size  -  Returns the upper bound on the amount of space needed\n       to pack a message\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Pack_size ( int incount, MPI_Datatype datatype, MPI_Comm comm,\n                          int *size )\n\nINPUT PARAMETERS\n       incount\n              - count argument to packing call (integer)\n       datatype\n              - datatype argument to packing call (handle)\n       comm   - communicator argument to packing call (handle)\n\n\nOUTPUT PARAMETER\n       size   - upper bound on size of packed message, in bytes (integer)\n\n\nNOTES\n       The MPI standard document describes this in terms of MPI_Pack , but  it\n       applies  to  both MPI_Pack and MPI_Unpack .  That is, the value size is\n       the maximum that is needed by either MPI_Pack or MPI_Unpack .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       pack_size.c\n\n\n\n                                  11/14/2001                  MPI_Pack_size(3)",
            "title": "MPI_Pack_size"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_pcontrol",
            "text": "MPI_Pcontrol(3)                       MPI                      MPI_Pcontrol(3)\n\n\n\nNAME\n       MPI_Pcontrol -  Controls profiling\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Pcontrol( int level )\n\nINPUT PARAMETERS\n       level  - Profiling level\n\n\nNOTES\n       This  routine  provides  a common interface for profiling control.  The\n       interpretation of level and any other arguments is left to the  profil-\n       ing library.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       pcontrol.c\n\n\n\n                                  11/14/2001                   MPI_Pcontrol(3)",
            "title": "MPI_Pcontrol"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_probe",
            "text": "MPI_Probe(3)                          MPI                         MPI_Probe(3)\n\n\n\nNAME\n       MPI_Probe -  Blocking test for a message\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Probe( int source, int tag, MPI_Comm comm, MPI_Status *status )\n\nINPUT PARAMETERS\n       source - source rank, or MPI_ANY_SOURCE (integer)\n       tag    - tag value or MPI_ANY_TAG (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       status - status object (Status)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       probe.c\n\n\n\n                                   12/7/2004                      MPI_Probe(3)",
            "title": "MPI_Probe"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_recv_init",
            "text": "MPI_Recv_init(3)                      MPI                     MPI_Recv_init(3)\n\n\n\nNAME\n       MPI_Recv_init -  Builds a handle for a receive\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Recv_init( void *buf, int count, MPI_Datatype datatype, int source,\n                         int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of receive buffer (choice)\n       count  - number of elements received (integer)\n       datatype\n              - type of each element (handle)\n       source - rank of source or MPI_ANY_SOURCE (integer)\n       tag    - message tag or MPI_ANY_TAG (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Start, MPI_Request_free\n\nLOCATION\n       create_recv.c\n\n\n\n                                  11/14/2001                  MPI_Recv_init(3)",
            "title": "MPI_Recv_init"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_recv",
            "text": "MPI_Recv(3)                           MPI                          MPI_Recv(3)\n\n\n\nNAME\n       MPI_Recv -  Basic receive\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Recv( void *buf, int count, MPI_Datatype datatype, int source,\n                     int tag, MPI_Comm comm, MPI_Status *status )\n\nOUTPUT PARAMETERS\n       buf    - initial address of receive buffer (choice)\n       status - status object (Status)\n\n\nINPUT PARAMETERS\n       count  - maximum number of elements in receive buffer (integer)\n       datatype\n              - datatype of each receive buffer element (handle)\n       source - rank of source (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES\n       The  count  argument  indicates  the  maximum  length of a message; the\n       actual number can be determined with MPI_Get_count .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       recv.c\n\n\n\n                                   2/24/2004                       MPI_Recv(3)",
            "title": "MPI_Recv"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_reduce",
            "text": "MPI_Reduce(3)                         MPI                        MPI_Reduce(3)\n\n\n\nNAME\n       MPI_Reduce -  Reduces values on all processes to a single value\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Reduce ( void *sendbuf, void *recvbuf, int count,\n                       MPI_Datatype datatype, MPI_Op op, int root, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - data type of elements of send buffer (handle)\n       op     - reduce operation (handle)\n       root   - rank of root process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice, significant only at root )\n\n\nALGORITHM\n       This implementation currently uses a simple tree algorithm.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The reduction functions ( MPI_Op ) do not return an error value.  As  a\n       result,  if  the  functions  detect an error, all they can do is either\n       call MPI_Abort or silently skip the problem.  Thus, if you  change  the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The reason for this is the performance problems in  ensuring  that  all\n       collective routines return the same error value.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_BUFFER\n              - This error class is associcated with an error code that  indi-\n              cates  that  two  buffer  arguments  are  aliased ; that is, the\n              describe overlapping storage (often  the  exact  same  storage).\n              This  is prohibited in MPI (because it is prohibited by the For-\n              tran standard, and rather than have a separate case  for  C  and\n              Fortran, the MPI Forum adopted the more restrictive requirements\n              of Fortran).\n\nLOCATION\n       reduce.c\n\n\n\n                                   2/19/2002                     MPI_Reduce(3)",
            "title": "MPI_Reduce"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_reduce_scatter",
            "text": "MPI_Reduce_scatter(3)                 MPI                MPI_Reduce_scatter(3)\n\n\n\nNAME\n       MPI_Reduce_scatter -  Combines values and scatters the results\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Reduce_scatter ( void *sendbuf, void *recvbuf, int *recvcnts,\n                              MPI_Datatype datatype, MPI_Op op, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       recvcounts\n              - integer array specifying the number of elements in result dis-\n              tributed to each process.  Array must be identical on all  call-\n              ing processes.\n       datatype\n              - data type of elements of input buffer (handle)\n       op     - operation (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - starting address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The reduction functions ( MPI_Op ) do not return an error value.  As  a\n       result,  if  the  functions  detect an error, all they can do is either\n       call MPI_Abort or silently skip the problem.  Thus, if you  change  the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The reason for this is the performance problems in  ensuring  that  all\n       collective routines return the same error value.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_OP\n              - Invalid operation.  MPI operations (objects of type  MPI_Op  )\n              must either be one of the predefined operations (e.g., MPI_SUM )\n              or created with MPI_Op_create .\n\n       MPI_ERR_BUFFER\n              - This error class is associcated with an error code that  indi-\n              cates  that  two  buffer  arguments  are  aliased ; that is, the\n              describe overlapping storage (often  the  exact  same  storage).\n              This  is prohibited in MPI (because it is prohibited by the For-\n              tran standard, and rather than have a separate case  for  C  and\n              Fortran, the MPI Forum adopted the more restrictive requirements\n              of Fortran).\n\nLOCATION\n       red_scat.c\n\n\n\n                                  11/14/2001             MPI_Reduce_scatter(3)",
            "title": "MPI_Reduce_scatter"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_request_free",
            "text": "MPI_Request_free(3)                   MPI                  MPI_Request_free(3)\n\n\n\nNAME\n       MPI_Request_free -  Frees a communication request object\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Request_free( MPI_Request *request )\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES\n       This  routine is normally used to free persistent requests created with\n       either MPI_Recv_init or MPI_Send_init and friends.  However, it can  be\n       used to free a request created with MPI_Irecv or MPI_Isend and friends;\n       in that case the use can not use the test/wait routines on the request.\n\n       It  is  permitted  to free an active request.  However, once freed, you\n       can not use the request in a wait or test routine (e.g., MPI_Wait ).\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       also: MPI_Isend, MPI_Irecv, MPI_Issend, MPI_Ibsend, MPI_Irsend,\n       MPI_Recv_init, MPI_Send_init, MPI_Ssend_init, MPI_Rsend_init, MPI_Wait,\n       MPI_Test, MPI_Waitall, MPI_Waitany, MPI_Waitsome, MPI_Testall, MPI_Tes-\n       tany, MPI_Testsome\n\nLOCATION\n       commreq_free.c\n\n\n\n                                  11/14/2001               MPI_Request_free(3)",
            "title": "MPI_Request_free"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_rsend_init",
            "text": "MPI_Rsend_init(3)                     MPI                    MPI_Rsend_init(3)\n\n\n\nNAME\n       MPI_Rsend_init -  Builds a handle for a ready send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Rsend_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                          int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Start, MPI_Request_free, MPI_Send_init\n\nLOCATION\n       rsend_init.c\n\n\n\n                                  11/14/2001                 MPI_Rsend_init(3)",
            "title": "MPI_Rsend_init"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_rsend",
            "text": "MPI_Rsend(3)                          MPI                         MPI_Rsend(3)\n\n\n\nNAME\n       MPI_Rsend -  Basic ready send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Rsend( void *buf, int count, MPI_Datatype datatype, int dest,\n                      int tag, MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       rsend.c\n\n\n\n                                  11/14/2001                      MPI_Rsend(3)",
            "title": "MPI_Rsend"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_scan",
            "text": "MPI_Scan(3)                           MPI                          MPI_Scan(3)\n\n\n\nNAME\n       MPI_Scan -  Computes the scan (partial reductions) of data on a collec-\n       tion of processes\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Scan ( void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype,\n                      MPI_Op op, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       count  - number of elements in input buffer (integer)\n       datatype\n              - data type of elements of input buffer (handle)\n       op     - operation (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - starting address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The  reduction functions ( MPI_Op ) do not return an error value.  As a\n       result, if the functions detect an error, all they  can  do  is  either\n       call  MPI_Abort  or silently skip the problem.  Thus, if you change the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The  reason  for  this is the performance problems in ensuring that all\n       collective routines return the same error value.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n       MPI_ERR_BUFFER\n              -  This error class is associcated with an error code that indi-\n              cates that two buffer arguments  are  aliased  ;  that  is,  the\n              describe  overlapping  storage  (often  the exact same storage).\n              This is prohibited in MPI (because it is prohibited by the  For-\n              tran  standard,  and  rather than have a separate case for C and\n              Fortran, the MPI Forum adopted the more restrictive requirements\n              of Fortran).\n\nLOCATION\n       scan.c\n\n\n\n                                  11/14/2001                       MPI_Scan(3)",
            "title": "MPI_Scan"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_scatter",
            "text": "MPI_Scatter(3)                        MPI                       MPI_Scatter(3)\n\n\n\nNAME\n       MPI_Scatter -  Sends data from one task to all other tasks in a group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Scatter (\n               void *sendbuf,\n               int sendcnt,\n               MPI_Datatype sendtype,\n               void *recvbuf,\n               int recvcnt,\n               MPI_Datatype recvtype,\n               int root,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - address of send buffer (choice, significant only at root )\n       sendcount\n              -  number of elements sent to each process (integer, significant\n              only at root )\n       sendtype\n              - data type of send buffer elements (significant only at root  )\n              (handle)\n       recvcount\n              - number of elements in receive buffer (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       root   - rank of sending process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\nLOCATION\n       scatter.c\n\n\n\n                                   4/5/2004                     MPI_Scatter(3)",
            "title": "MPI_Scatter"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_scatterv",
            "text": "MPI_Scatterv(3)                       MPI                      MPI_Scatterv(3)\n\n\n\nNAME\n       MPI_Scatterv -  Scatters a buffer in parts to all tasks in a group\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Scatterv (\n               void *sendbuf,\n               int *sendcnts,\n               int *displs,\n               MPI_Datatype sendtype,\n               void *recvbuf,\n               int recvcnt,\n               MPI_Datatype recvtype,\n               int root,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - address of send buffer (choice, significant only at root )\n       sendcounts\n              -  integer array (of length group size) specifying the number of\n              elements to send to each processor\n       displs - integer array (of length group size). Entry  i  specifies  the\n              displacement (relative to sendbuf  from which to take the outgo-\n              ing data to process i\n\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              - number of elements in receive buffer (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       root   - rank of sending process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       scatterv.c\n\n\n\n                                   2/21/2002                   MPI_Scatterv(3)",
            "title": "MPI_Scatterv"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_send_init",
            "text": "MPI_Send_init(3)                      MPI                     MPI_Send_init(3)\n\n\n\nNAME\n       MPI_Send_init -  Builds a handle for a standard send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Send_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                         int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle) Output Parameter:\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Start, MPI_Startall, MPI_Request_free\n\nLOCATION\n       create_send.c\n\n\n\n                                  11/14/2001                  MPI_Send_init(3)",
            "title": "MPI_Send_init"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_send",
            "text": "MPI_Send(3)                           MPI                          MPI_Send(3)\n\n\n\nNAME\n       MPI_Send -  Performs a basic send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Send( void *buf, int count, MPI_Datatype datatype, int dest,\n                     int tag, MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES\n       This routine may block until the message is received.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Isend, MPI_Bsend\n\nLOCATION\n       send.c\n\n\n\n                                  11/14/2001                       MPI_Send(3)",
            "title": "MPI_Send"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_sendrecv",
            "text": "MPI_Sendrecv(3)                       MPI                      MPI_Sendrecv(3)\n\n\n\nNAME\n       MPI_Sendrecv -  Sends and receives a message\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Sendrecv( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                        int dest, int sendtag,\n                         void *recvbuf, int recvcount, MPI_Datatype recvtype,\n                        int source, int recvtag, MPI_Comm comm, MPI_Status *status )\n\nINPUT PARAMETERS\n       sendbuf\n              - initial address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - type of elements in send buffer (handle)\n       dest   - rank of destination (integer)\n       sendtag\n              - send tag (integer)\n       recvcount\n              - number of elements in receive buffer (integer)\n       recvtype\n              - type of elements in receive buffer (handle)\n       source - rank of source (integer)\n       recvtag\n              - receive tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETERS\n       recvbuf\n              - initial address of receive buffer (choice)\n       status - status object (Status).  This refers to the receive operation.\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       sendrecv.c\n\n\n\n                                  11/14/2001                   MPI_Sendrecv(3)",
            "title": "MPI_Sendrecv"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_sendrecv_replace",
            "text": "MPI_Sendrecv_replace(3)               MPI              MPI_Sendrecv_replace(3)\n\n\n\nNAME\n       MPI_Sendrecv_replace -  Sends and receives using a single buffer\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Sendrecv_replace( void *buf, int count, MPI_Datatype datatype,\n                               int dest, int sendtag, int source, int recvtag,\n                               MPI_Comm comm, MPI_Status *status )\n\nINPUT PARAMETERS\n       count  - number of elements in send and receive buffer (integer)\n       datatype\n              - type of elements in send and receive buffer (handle)\n       dest   - rank of destination (integer)\n       sendtag\n              - send message tag (integer)\n       source - rank of source (integer)\n       recvtag\n              - receive message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETERS\n       buf    - initial address of send and receive buffer (choice)\n       status - status object (Status)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TRUNCATE\n              - Message truncated on receive.  The buffer size  specified  was\n              too small for the received message.  This is a recoverable error\n              in the MPICH implementation.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nLOCATION\n       sendrecv_rep.c\n\n\n\n                                  11/14/2001           MPI_Sendrecv_replace(3)",
            "title": "MPI_Sendrecv_replace"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_ssend_init",
            "text": "MPI_Ssend_init(3)                     MPI                    MPI_Ssend_init(3)\n\n\n\nNAME\n       MPI_Ssend_init -  Builds a handle for a synchronous send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Ssend_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                          int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       ssend_init.c\n\n\n\n                                  11/14/2001                 MPI_Ssend_init(3)",
            "title": "MPI_Ssend_init"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_ssend",
            "text": "MPI_Ssend(3)                          MPI                         MPI_Ssend(3)\n\n\n\nNAME\n       MPI_Ssend -  Basic synchronous send\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Ssend( void *buf, int count, MPI_Datatype datatype,\n                      int dest, int tag, MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       ssend.c\n\n\n\n                                  11/14/2001                      MPI_Ssend(3)",
            "title": "MPI_Ssend"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_startall",
            "text": "MPI_Startall(3)                       MPI                      MPI_Startall(3)\n\n\n\nNAME\n       MPI_Startall -  Starts a collection of requests\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Startall( int count, MPI_Request array_of_requests[] )\n\nINPUT PARAMETERS\n       count  - list length (integer)\n       array_of_requests\n              - array of requests (array of handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       startall.c\n\n\n\n                                  11/14/2001                   MPI_Startall(3)",
            "title": "MPI_Startall"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_start",
            "text": "MPI_Start(3)                          MPI                         MPI_Start(3)\n\n\n\nNAME\n       MPI_Start -  Initiates a communication with a persistent request handle\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Start(\n               MPI_Request *request)\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n\n\nLOCATION\n       start.c\n\n\n\n                                  11/14/2001                      MPI_Start(3)",
            "title": "MPI_Start"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_testall",
            "text": "MPI_Testall(3)                        MPI                       MPI_Testall(3)\n\n\n\nNAME\n       MPI_Testall  -   Tests  for  the completion of all previously initiated\n       communications\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Testall(\n               int count,\n               MPI_Request array_of_requests[],\n               int *flag,\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       count  - lists length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       flag   - (logical)\n       array_of_statuses\n              - array of status objects (array of Status).   May  be  MPI_STA-\n              TUSES_IGNORE .\n\n\n\nNOTES\n       flag  is  true only if all requests have completed.  Otherwise, flag is\n       false and neither the array_of_requests nor  the  array_of_statuses  is\n       modified.\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_IN_STATUS\n              -  The  actual  error value is in the MPI_Status argument.  This\n              error  class  is  returned  only  from  the  multiple-completion\n              routines  ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Wait-\n              all , MPI_Waitany , and MPI_Waitsome ).  The field MPI_ERROR  in\n              the  status argument contains the error value or MPI_SUCCESS (no\n              error and complete) or  MPI_ERR_PENDING  to  indicate  that  the\n              request  has  not  completed.  The MPI Standard does not specify\n              what the result of the multiple completion routines is  when  an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait for all requests to either fail or  complete,  or  does  it\n              return  immediately  (with  the  MPI  definition of immediately,\n              which means independent of  actions  of  other  MPI  processes)?\n              MPICH  has  chosen  to  make  the return immediate (alternately,\n              local in MPI terms), and to use the error class  MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.  In most cases, only one request with an error  will  be\n              detected  in  each  call  to  an MPI routine that tests multiple\n              requests.  The requests that have not been processed (because an\n              error  occured in one of the requests) will have their MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n\n\nLOCATION\n       testall.c\n\n\n\n                                   2/19/2003                    MPI_Testall(3)",
            "title": "MPI_Testall"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_testany",
            "text": "MPI_Testany(3)                        MPI                       MPI_Testany(3)\n\n\n\nNAME\n       MPI_Testany  -  Tests for completion of any previdously initiated  com-\n       munication\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Testany(\n               int count,\n               MPI_Request array_of_requests[],\n               int *index, int *flag,\n               MPI_Status *status )\n\nINPUT PARAMETERS\n       count  - list length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       index  - index of operation that completed, or  MPI_UNDEFINED  if  none\n              completed (integer)\n       flag   - true if one of the operations is complete (logical)\n       status - status object (Status).  May be MPI_STATUS_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n\nLOCATION\n       testany.c\n\n\n\n                                   1/9/2003                     MPI_Testany(3)",
            "title": "MPI_Testany"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_test_cancelled",
            "text": "MPI_Test_cancelled(3)                 MPI                MPI_Test_cancelled(3)\n\n\n\nNAME\n       MPI_Test_cancelled -  Tests to see if a request was cancelled\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Test_cancelled(\n               MPI_Status *status,\n               int        *flag)\n\nINPUT PARAMETER\n       status - status object (Status)\n\n\nOUTPUT PARAMETER\n       flag   - (logical)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       testcancel.c\n\n\n\n                                  11/14/2001             MPI_Test_cancelled(3)",
            "title": "MPI_Test_cancelled"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_test",
            "text": "MPI_Test(3)                           MPI                          MPI_Test(3)\n\n\n\nNAME\n       MPI_Test -  Tests for the completion of a send or receive\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Test (\n               MPI_Request  *request,\n               int          *flag,\n               MPI_Status   *status)\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nOUTPUT PARAMETER\n       flag   - true if operation completed (logical)\n       status - status object (Status).  May be MPI_STATUS_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              -  Invalid  MPI_Request  .   Either  null  or,  in the case of a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       test.c\n\n\n\n                                   1/9/2003                        MPI_Test(3)",
            "title": "MPI_Test"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_testsome",
            "text": "MPI_Testsome(3)                       MPI                      MPI_Testsome(3)\n\n\n\nNAME\n       MPI_Testsome -  Tests for some given communications to complete\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Testsome(\n               int incount,\n               MPI_Request array_of_requests[],\n               int *outcount,\n               int array_of_indices[],\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       incount\n              - length of array_of_requests (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       outcount\n              - number of completed requests (integer)\n       array_of_indices\n              -  array of indices of operations that completed (array of inte-\n              gers)\n       array_of_statuses\n              - array of status objects for operations that  completed  (array\n              of Status).  May be MPI_STATUSES_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_IN_STATUS\n              -  The  actual  error value is in the MPI_Status argument.  This\n              error  class  is  returned  only  from  the  multiple-completion\n              routines  ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Wait-\n              all , MPI_Waitany , and MPI_Waitsome ).  The field MPI_ERROR  in\n              the  status argument contains the error value or MPI_SUCCESS (no\n              error and complete) or  MPI_ERR_PENDING  to  indicate  that  the\n              request  has  not  completed.  The MPI Standard does not specify\n              what the result of the multiple completion routines is  when  an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait for all requests to either fail or  complete,  or  does  it\n              return  immediately  (with  the  MPI  definition of immediately,\n              which means independent of  actions  of  other  MPI  processes)?\n              MPICH  has  chosen  to  make  the return immediate (alternately,\n              local in MPI terms), and to use the error class  MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.  In most cases, only one request with an error  will  be\n              detected  in  each  call  to  an MPI routine that tests multiple\n              requests.  The requests that have not been processed (because an\n              error  occured in one of the requests) will have their MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n\n\nLOCATION\n       testsome.c\n\n\n\n                                   1/9/2003                    MPI_Testsome(3)",
            "title": "MPI_Testsome"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_topo_test",
            "text": "MPI_Topo_test(3)                      MPI                     MPI_Topo_test(3)\n\n\n\nNAME\n       MPI_Topo_test  -   Determines  the type of topology (if any) associated\n       with a  communicator\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Topo_test ( MPI_Comm comm, int *top_type )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       top_type\n              - topology type of communicator comm (choice).\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Graph_create, MPI_Cart_create\n\nLOCATION\n       topo_test.c\n\n\n\n                                  11/14/2001                  MPI_Topo_test(3)",
            "title": "MPI_Topo_test"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_commit",
            "text": "MPI_Type_commit(3)                    MPI                   MPI_Type_commit(3)\n\n\n\nNAME\n       MPI_Type_commit -  Commits the datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_commit ( MPI_Datatype *datatype )\n\nINPUT PARAMETER\n       datatype\n              - datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       type_commit.c\n\n\n\n                                  11/14/2001                MPI_Type_commit(3)",
            "title": "MPI_Type_commit"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_contiguous",
            "text": "MPI_Type_contiguous(3)                MPI               MPI_Type_contiguous(3)\n\n\n\nNAME\n       MPI_Type_contiguous -  Creates a contiguous datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_contiguous(\n               int count,\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype)\n\nINPUT PARAMETERS\n       count  - replication count (nonnegative integer)\n       oldtype\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_contig.c\n\n\n\n                                  11/14/2001            MPI_Type_contiguous(3)",
            "title": "MPI_Type_contiguous"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_extent",
            "text": "MPI_Type_extent(3)                    MPI                   MPI_Type_extent(3)\n\n\n\nNAME\n       MPI_Type_extent -  Returns the extent of a datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_extent( MPI_Datatype datatype, MPI_Aint *extent )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       extent - datatype extent (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       type_extent.c\n\n\n\n                                  11/14/2001                MPI_Type_extent(3)",
            "title": "MPI_Type_extent"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_free",
            "text": "MPI_Type_free(3)                      MPI                     MPI_Type_free(3)\n\n\n\nNAME\n       MPI_Type_free -  Frees the datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_free ( MPI_Datatype *datatype )\n\nINPUT PARAMETER\n       datatype\n              - datatype that is freed (handle)\n\n\nPREDEFINED TYPES\n       The MPI standard states that (in Opaque Objects)\n       MPI provides certain predefined opaque objects and predefined, static handles\n       to these objects. Such objects may not be destroyed.\n\n\n       Thus,  it  is an error to free a predefined datatype.  The same section\n       makes it clear that it is an error to free a null datatype.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_free.c\n\n\n\n                                  11/14/2001                  MPI_Type_free(3)",
            "title": "MPI_Type_free"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_hindexed",
            "text": "MPI_Type_hindexed(3)                  MPI                 MPI_Type_hindexed(3)\n\n\n\nNAME\n       MPI_Type_hindexed -  Creates an indexed datatype with offsets in bytes\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_hindexed(\n               int count,\n               int blocklens[],\n               MPI_Aint indices[],\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  -  number  of  blocks  --  also number of entries in indices and\n              blocklens\n       blocklens\n              - number of elements in each block (array of  nonnegative  inte-\n              gers)\n       indices\n              - byte displacement of each block (array of MPI_Aint)\n       old_type\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       Also see the discussion for MPI_Type_indexed about the indices in  For-\n       tran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_hind.c\n\n\n\n                                   4/7/2003               MPI_Type_hindexed(3)",
            "title": "MPI_Type_hindexed"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_hvector",
            "text": "MPI_Type_hvector(3)                   MPI                  MPI_Type_hvector(3)\n\n\n\nNAME\n       MPI_Type_hvector  -  Creates a vector (strided) datatype with offset in\n       bytes\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_hvector(\n               int count,\n               int blocklen,\n               MPI_Aint stride,\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  - number of blocks (nonnegative integer)\n       blocklength\n              - number of elements in each block (nonnegative integer)\n       stride - number of bytes between start of each block (integer)\n       old_type\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_hvec.c\n\n\n\n                                  11/14/2001               MPI_Type_hvector(3)",
            "title": "MPI_Type_hvector"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_indexed",
            "text": "MPI_Type_indexed(3)                   MPI                  MPI_Type_indexed(3)\n\n\n\nNAME\n       MPI_Type_indexed -  Creates an indexed datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_indexed(\n               int count,\n               int blocklens[],\n               int indices[],\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  -  number  of  blocks  --  also number of entries in indices and\n              blocklens\n       blocklens\n              - number of elements in each block (array of  nonnegative  inte-\n              gers)\n       indices\n              -  displacement of each block in multiples of old_type (array of\n              integers)\n       old_type\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       The  indices are displacements, and are based on a zero origin.  A com-\n       mon error is to do something like to following\n       integer a(100)\n       integer blens(10), indices(10)\n       do i=1,10\n       blens(i)   = 1\n       10       indices(i) = 1 + (i-1)*10\n       call MPI_TYPE_INDEXED(10,blens,indices,MPI_INTEGER,newtype,ierr)\n       call MPI_TYPE_COMMIT(newtype,ierr)\n       call MPI_SEND(a,1,newtype,...)\n\n       expecting this to send a(1),a(11),...  because the indices have  values\n       1,11,...   .  Because these are displacements from the beginning of a ,\n       it actually sends a(1+1),a(1+11),...  .\n\n\n       If you wish to consider the displacements as  indices  into  a  Fortran\n       array, consider declaring the Fortran array with a zero origin\n       integer a(0:99)\n\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_ind.c\n\n\n\n                                  11/14/2001               MPI_Type_indexed(3)",
            "title": "MPI_Type_indexed"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_lb",
            "text": "MPI_Type_lb(3)                        MPI                       MPI_Type_lb(3)\n\n\n\nNAME\n       MPI_Type_lb -  Returns the lower-bound of a datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_lb ( MPI_Datatype datatype, MPI_Aint *displacement )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       displacement\n              - displacement of lower bound from origin, in bytes (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_lb.c\n\n\n\n                                  11/14/2001                    MPI_Type_lb(3)",
            "title": "MPI_Type_lb"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_size",
            "text": "MPI_Type_size(3)                      MPI                     MPI_Type_size(3)\n\n\n\nNAME\n       MPI_Type_size  -  Return the number of bytes occupied by entries in the\n       datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_size ( MPI_Datatype datatype, int *size )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       size   - datatype size (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_size.c\n\n\n\n                                  11/14/2001                  MPI_Type_size(3)",
            "title": "MPI_Type_size"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_struct",
            "text": "MPI_Type_struct(3)                    MPI                   MPI_Type_struct(3)\n\n\n\nNAME\n       MPI_Type_struct -  Creates a struct datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_struct(\n               int count,\n               int blocklens[],\n               MPI_Aint indices[],\n               MPI_Datatype old_types[],\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  - number of blocks (integer) -- also number of entries in arrays\n              array_of_types  ,  array_of_displacements   and  array_of_block-\n              lengths\n       blocklens\n              - number of elements in each block (array)\n       indices\n              - byte displacement of each block (array)\n       old_types\n              -  type  of elements in each block (array of handles to datatype\n              objects)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES\n       If an upperbound is set explicitly by using the MPI datatype  MPI_UB  ,\n       the corresponding index must be positive.\n\n       The  MPI  standard  originally  made vague statements about padding and\n       alignment; this was intended to allow the simple definition  of  struc-\n       tures that could be sent with a count greater than one.  For example,\n       struct { int a; char b; } foo;\n\n       may  have  sizeof(foo)  >  sizeof(int)  +  sizeof(char)  ; for example,\n       sizeof(foo) == 2*sizeof(int) .  The initial version of the MPI standard\n       defined  the  extent  of  a datatype as including an epsilon that would\n       have allowed an implementation to make the extent an MPI  datatype  for\n       this structure equal to 2*sizeof(int) .\n\n       However, since different systems might define different paddings, there\n       was much discussion by the MPI Forum about what was the  correct  value\n       of  epsilon,  and  one  suggestion was to define epsilon as zero.  This\n       would have been the best thing to do in MPI 1.0, particularly since the\n       MPI_UB  type  allows  the  user to easily set the end of the structure.\n       Unfortunately, this change did not make it  into  the  final  document.\n       Currently,  this  routine does not add any padding, since the amount of\n       padding needed is determined by the compiler that the user is using  to\n       build  their  code, not the compiler used to construct the MPI library.\n       A later version of MPICH  may  provide  for  some  natural  choices  of\n       padding  (e.g.,  multiple of the size of the largest basic member), but\n       users are advised to never depend on this, even with vendor MPI  imple-\n       mentations.   Instead,  if  you define a structure datatype and wish to\n       send or receive multiple items, you should explicitly include an MPI_UB\n       entry  as the last member of the structure.  For example, the following\n       code can be used for the structure foo\n       blen[0] = 1; indices[0] = 0; oldtypes[0] = MPI_INT;\n       blen[1] = 1; indices[1] = &foo.b - &foo; oldtypes[1] = MPI_CHAR;\n       blen[2] = 1; indices[2] = sizeof(foo); oldtypes[2] = MPI_UB;\n       MPI_Type_struct( 3, blen, indices, oldtypes, &newtype );\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_struct.c\n\n\n\n                                   7/12/2002                MPI_Type_struct(3)",
            "title": "MPI_Type_struct"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_ub",
            "text": "MPI_Type_ub(3)                        MPI                       MPI_Type_ub(3)\n\n\n\nNAME\n       MPI_Type_ub -  Returns the upper bound of a datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_ub ( MPI_Datatype datatype, MPI_Aint *displacement )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       displacement\n              - displacement of upper bound from origin, in bytes (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_ub.c\n\n\n\n                                  11/14/2001                    MPI_Type_ub(3)",
            "title": "MPI_Type_ub"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_vector",
            "text": "MPI_Type_vector(3)                    MPI                   MPI_Type_vector(3)\n\n\n\nNAME\n       MPI_Type_vector -  Creates a vector (strided) datatype\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Type_vector(\n               int count,\n               int blocklen,\n               int stride,\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  - number of blocks (nonnegative integer)\n       blocklength\n              - number of elements in each block (nonnegative integer)\n       stride - number of elements between start of each block (integer)\n       oldtype\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       type_vec.c\n\n\n\n                                  11/14/2001                MPI_Type_vector(3)",
            "title": "MPI_Type_vector"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_unpack",
            "text": "MPI_Unpack(3)                         MPI                        MPI_Unpack(3)\n\n\n\nNAME\n       MPI_Unpack -  Unpack a datatype into contiguous memory\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Unpack ( void *inbuf, int insize, int *position,\n                       void *outbuf, int outcount, MPI_Datatype datatype,\n                       MPI_Comm comm )\n\nINPUT PARAMETERS\n       inbuf  - input buffer start (choice)\n       insize - size of input buffer, in bytes (integer)\n       position\n              - current position in bytes (integer)\n       outcount\n              - number of items to be unpacked (integer)\n       datatype\n              - datatype of each output data item (handle)\n       comm   - communicator for packed message (handle)\n\n\nOUTPUT PARAMETER\n       outbuf - output buffer start (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Pack, MPI_Pack_size\n\nLOCATION\n       unpack.c\n\n\n\n                                  11/14/2001                     MPI_Unpack(3)",
            "title": "MPI_Unpack"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_waitall",
            "text": "MPI_Waitall(3)                        MPI                       MPI_Waitall(3)\n\n\n\nNAME\n       MPI_Waitall -  Waits for all given communications to complete\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Waitall(\n               int count,\n               MPI_Request array_of_requests[],\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       count  - lists length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETER\n       array_of_statuses\n              -  array  of  status objects (array of Status).  May be MPI_STA-\n              TUSES_IGNORE\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For send operations, the only use of status is  for  MPI_Test_cancelled\n       or  in  the  case  that  there is an error, in which case the MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_IN_STATUS\n              - The actual error value is in the  MPI_Status  argument.   This\n              error  class  is returned only from the multiple-completion rou-\n              tines ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Waitall ,\n              MPI_Waitany  ,  and  MPI_Waitsome ).  The field MPI_ERROR in the\n              status argument contains the  error  value  or  MPI_SUCCESS  (no\n              error  and  complete)  or  MPI_ERR_PENDING  to indicate that the\n              request has not completed.  The MPI Standard  does  not  specify\n              what  the  result of the multiple completion routines is when an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait  for  all  requests  to either fail or complete, or does it\n              return immediately (with  the  MPI  definition  of  immediately,\n              which  means  independent  of  actions  of other MPI processes)?\n              MPICH has chosen to  make  the  return  immediate  (alternately,\n              local  in MPI terms), and to use the error class MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.   In  most cases, only one request with an error will be\n              detected in each call to an  MPI  routine  that  tests  multiple\n              requests.  The requests that have not been processed (because an\n              error occured in one of the requests) will have their  MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n       MPI_ERR_PENDING\n              - Pending request (not an error).  See MPI_ERR_IN_STATUS .\n\n              This  value indicates that the request is not complete nor has a\n              encountered a detected error.\n\nLOCATION\n       waitall.c\n\n\n\n                                   2/24/2004                    MPI_Waitall(3)",
            "title": "MPI_Waitall"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_waitany",
            "text": "MPI_Waitany(3)                        MPI                       MPI_Waitany(3)\n\n\n\nNAME\n       MPI_Waitany -  Waits for any specified send or receive to complete\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Waitany(\n               int count,\n               MPI_Request array_of_requests[],\n               int *index,\n               MPI_Status *status )\n\nINPUT PARAMETERS\n       count  - list length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       index  -  index  of  handle for operation that completed (integer).  In\n              the range 0 to count-1 .  In Fortran, the range is 1 to count  .\n\n       status - status object (Status).  May be MPI_STATUS_IGNORE .\n\n\n\nNOTES\n       If all of the requests are MPI_REQUEST_NULL , then index is returned as\n       MPI_UNDEFINED , and status is returned as an empty status.\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For send operations, the only use of status is  for  MPI_Test_cancelled\n       or  in  the  case  that  there is an error, in which case the MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       waitany.c\n\n\n\n                                   1/9/2003                     MPI_Waitany(3)",
            "title": "MPI_Waitany"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_wait",
            "text": "MPI_Wait(3)                           MPI                          MPI_Wait(3)\n\n\n\nNAME\n       MPI_Wait -  Waits for an MPI send or receive to complete\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Wait (\n               MPI_Request  *request,\n               MPI_Status   *status)\n\nINPUT PARAMETER\n       request\n              - request (handle)\n\n\nOUTPUT PARAMETER\n       status - status object (Status) .  May be MPI_STATUS_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              -  Invalid  MPI_Request  .   Either  null  or,  in the case of a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       wait.c\n\n\n\n                                   1/9/2003                        MPI_Wait(3)",
            "title": "MPI_Wait"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_waitsome",
            "text": "MPI_Waitsome(3)                       MPI                      MPI_Waitsome(3)\n\n\n\nNAME\n       MPI_Waitsome -  Waits for some given communications to complete\n\nSYNOPSIS\n       #include \"mpi.h\"\n       int MPI_Waitsome(\n               int incount,\n               MPI_Request array_of_requests[],\n               int *outcount,\n               int array_of_indices[],\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       incount\n              - length of array_of_requests (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       outcount\n              - number of completed requests (integer)\n       array_of_indices\n              -  array of indices of operations that completed (array of inte-\n              gers)\n       array_of_statuses\n              - array of status objects for operations that  completed  (array\n              of Status).  May be MPI_STATUSES_IGNORE .\n\n\n\nNOTES\n       The  array  of  indicies are in the range 0 to incount - 1 for C and in\n       the range 1 to incount for Fortran.\n\n       Null requests are ignored; if all requests are null, then  the  routine\n       returns with outcount set to MPI_UNDEFINED .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              -  Invalid  MPI_Request  .   Either  null  or,  in the case of a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_IN_STATUS\n              -  The  actual  error value is in the MPI_Status argument.  This\n              error class is returned only from the  multiple-completion  rou-\n              tines ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Waitall ,\n              MPI_Waitany , and MPI_Waitsome ).  The field  MPI_ERROR  in  the\n              status  argument  contains  the  error  value or MPI_SUCCESS (no\n              error and complete) or  MPI_ERR_PENDING  to  indicate  that  the\n              request  has  not  completed.  The MPI Standard does not specify\n              what the result of the multiple completion routines is  when  an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait for all requests to either fail or  complete,  or  does  it\n              return  immediately  (with  the  MPI  definition of immediately,\n              which means independent of  actions  of  other  MPI  processes)?\n              MPICH  has  chosen  to  make  the return immediate (alternately,\n              local in MPI terms), and to use the error class  MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.  In most cases, only one request with an error  will  be\n              detected  in  each  call  to  an MPI routine that tests multiple\n              requests.  The requests that have not been processed (because an\n              error  occured in one of the requests) will have their MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n\nLOCATION\n       waitsome.c\n\n\n\n                                   1/9/2003                    MPI_Waitsome(3)",
            "title": "MPI_Waitsome"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_wtick",
            "text": "MPI_Wtick(3)                          MPI                         MPI_Wtick(3)\n\n\n\nNAME\n       MPI_Wtick -  Returns the resolution of MPI_Wtime\n\nSYNOPSIS\n       #include \"mpi.h\"\n       double MPI_Wtick()\n\nRETURN VALUE\n       Time in seconds of the resolution of MPI_Wtime .\n\n\nNOTES FOR FORTRAN\n       This  is  a  function, declared as DOUBLE PRECISION MPI_WTICK() in For-\n       tran.\n\n\nLOCATION\n       wtick.c\n\n\n\n                                   8/20/2004                      MPI_Wtick(3)",
            "title": "MPI_Wtick"
        },
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_wtime",
            "text": "MPI_Wtime(3)                          MPI                         MPI_Wtime(3)\n\n\n\nNAME\n       MPI_Wtime -  Returns an elapsed time on the calling processor\n\nSYNOPSIS\n       #include \"mpi.h\"\n       double MPI_Wtime()\n\nRETURN VALUE\n       Time in seconds since an arbitrary time in the past.\n\n\nNOTES\n       This is intended to be a high-resolution, elapsed (or wall) clock.  See\n       MPI_WTICK to determine the resolution of MPI_WTIME .\n\n       If the attribute MPI_WTIME_IS_GLOBAL is  defined  and  true,  then  the\n       value is synchronized across all processes in MPI_COMM_WORLD .\n\n\n\nNOTES FOR FORTRAN\n       This  is  a  function, declared as DOUBLE PRECISION MPI_WTIME() in For-\n       tran.\n\n\nSEE ALSO\n       also: MPI_Wtick, MPI_Attr_get\n\nLOCATION\n       wtime.c\n\n\n\n                                  11/14/2001                      MPI_Wtime(3)",
            "title": "MPI_Wtime"
        },
        {
            "location": "/Dev/Markdown/Markdown/",
            "text": "Generate MD file from baunch of man files\n\n\nfor file in *.txt; do echo \"### $file\" >> result.md; echo '```' >> result.md; cat $file >> result.md; echo '```' >> result.md; echo >> result.md; done",
            "title": "Markdown"
        },
        {
            "location": "/Dev/Markdown/Markdown/#generate-md-file-from-baunch-of-man-files",
            "text": "for file in *.txt; do echo \"### $file\" >> result.md; echo '```' >> result.md; cat $file >> result.md; echo '```' >> result.md; echo >> result.md; done",
            "title": "Generate MD file from baunch of man files"
        },
        {
            "location": "/Dev/Perl/Perl_one-liners/",
            "text": "Useful One-Line Scripts for Perl\n\n\nFILE SPACING\n\n\n\n\nDouble space a file\n\n\n\n\nperl -pe '$\\=\"\\n\"'\nperl -pe 'BEGIN { $\\=\"\\n\" }'\nperl -pe '$_ .= \"\\n\"'\nperl -pe 's/$/\\n/'\nperl -nE 'say'\n\n\n\n\n\n\nDouble space a file, except the blank lines\n\n\n\n\nperl -pe '$_ .= \"\\n\" unless /^$/'\nperl -pe '$_ .= \"\\n\" if /\\S/'\n\n\n\n\n\n\nTriple space a file\n\n\n\n\nperl -pe '$\\=\"\\n\\n\"'\nperl -pe '$_.=\"\\n\\n\"'\n\n\n\n\n\n\nN-space a file\n\n\n\n\nperl -pe '$_.=\"\\n\"x7'\n\n\n\n\n\n\nAdd a blank line before every line\n\n\n\n\nperl -pe 's//\\n/'\n\n\n\n\n\n\nRemove all blank lines\n\n\n\n\nperl -ne 'print unless /^$/'\nperl -lne 'print if length'\nperl -ne 'print if /\\S/'\n\n\n\n\n\n\nRemove all consecutive blank lines, leaving just one\n\n\n\n\nperl -00 -pe ''\nperl -00pe0\n\n\n\n\n\n\nCompress/expand all blank lines into N consecutive ones\n\n\n\n\nperl -00 -pe '$_.=\"\\n\"x4'\n\n\n\n\n\n\nFold a file so that every set of 10 lines becomes one tab-separated line\n\n\n\n\nperl -lpe '$\\ = $. % 10 ? \"\\t\" : \"\\n\"'\n\n\n\n\nLINE NUMBERING\n\n\n\n\nNumber all lines in a file\n\n\n\n\nperl -pe '$_ = \"$. $_\"'\n\n\n\n\n\n\nNumber only non-empty lines in a file\n\n\n\n\nperl -pe '$_ = ++$a.\" $_\" if /./'\n\n\n\n\n\n\nNumber and print only non-empty lines in a file (drop empty lines)\n\n\n\n\nperl -ne 'print ++$a.\" $_\" if /./'\n\n\n\n\n\n\nNumber all lines but print line numbers only non-empty lines\n\n\n\n\nperl -pe '$_ = \"$. $_\" if /./'\n\n\n\n\n\n\nNumber only lines that match a pattern, print others unmodified\n\n\n\n\nperl -pe '$_ = ++$a.\" $_\" if /regex/'\n\n\n\n\n\n\nNumber and print only lines that match a pattern\n\n\n\n\nperl -ne 'print ++$a.\" $_\" if /regex/'\n\n\n\n\n\n\nNumber all lines, but print line numbers only for lines that match a pattern\n\n\n\n\nperl -pe '$_ = \"$. $_\" if /regex/'\n\n\n\n\n\n\nNumber all lines in a file using a custom format (emulate cat -n)\n\n\n\n\nperl -ne 'printf \"%-5d %s\", $., $_'\n\n\n\n\n\n\nPrint the total number of lines in a file (emulate wc -l)\n\n\n\n\nperl -lne 'END { print $. }'\nperl -le 'print $n=()=<>'\nperl -le 'print scalar(()=<>)'\nperl -le 'print scalar(@foo=<>)'\nperl -ne '}{print $.'\nperl -nE '}{say $.'\n\n\n\n\n\n\nPrint the number of non-empty lines in a file\n\n\n\n\nperl -le 'print scalar(grep{/./}<>)'\nperl -le 'print ~~grep{/./}<>'\nperl -le 'print~~grep/./,<>'\nperl -E 'say~~grep/./,<>'\n\n\n\n\n\n\nPrint the number of empty lines in a file\n\n\n\n\nperl -lne '$a++ if /^$/; END {print $a+0}'\nperl -le 'print scalar(grep{/^$/}<>)'\nperl -le 'print ~~grep{/^$/}<>'\nperl -E 'say~~grep{/^$/}<>'\n\n\n\n\n\n\nPrint the number of lines in a file that match a pattern (emulate grep -c)\n\n\n\n\nperl -lne '$a++ if /regex/; END {print $a+0}'\nperl -nE '$a++ if /regex/; END {say $a+0}'\n\n\n\n\nCALCULATIONS\n\n\n\n\nCheck if a number is a prime\n\n\n\n\nperl -lne '(1x$_) !~ /^1?$|^(11+?)\\1+$/ && print \"$_ is prime\"'\n\n\n\n\n\n\nPrint the sum of all the fields on a line\n\n\n\n\nperl -MList::Util=sum -alne 'print sum @F'\n\n\n\n\n\n\nPrint the sum of all the fields on all lines\n\n\n\n\nperl -MList::Util=sum -alne 'push @S,@F; END { print sum @S }'\nperl -MList::Util=sum -alne '$s += sum @F; END { print $s }'\n\n\n\n\n\n\nShuffle all fields on a line\n\n\n\n\nperl -MList::Util=shuffle -alne 'print \"@{[shuffle @F]}\"'\nperl -MList::Util=shuffle -alne 'print join \" \", shuffle @F'\n\n\n\n\n\n\nFind the minimum element on a line\n\n\n\n\nperl -MList::Util=min -alne 'print min @F'\n\n\n\n\n\n\nFind the minimum element over all the lines\n\n\n\n\nperl -MList::Util=min -alne '@M = (@M, @F); END { print min @M }'\nperl -MList::Util=min -alne '$min = min @F; $rmin = $min unless defined $rmin && $min > $rmin; END { print $rmin }'\n\n\n\n\n\n\nFind the maximum element on a line\n\n\n\n\nperl -MList::Util=max -alne 'print max @F'\n\n\n\n\n\n\nFind the maximum element over all the lines\n\n\n\n\nperl -MList::Util=max -alne '@M = (@M, @F); END { print max @M }'\n\n\n\n\n\n\nReplace each field with its absolute value\n\n\n\n\nperl -alne 'print \"@{[map { abs } @F]}\"'\n\n\n\n\n\n\nFind the total number of fields (words) on each line\n\n\n\n\nperl -alne 'print scalar @F'\n\n\n\n\n\n\nPrint the total number of fields (words) on each line followed by the line\n\n\n\n\nperl -alne 'print scalar @F, \" $_\"'\n\n\n\n\n\n\nFind the total number of fields (words) on all lines\n\n\n\n\nperl -alne '$t += @F; END { print $t}'\n\n\n\n\n\n\nPrint the total number of fields that match a pattern\n\n\n\n\nperl -alne 'map { /regex/ && $t++ } @F; END { print $t }'\nperl -alne '$t += /regex/ for @F; END { print $t }'\nperl -alne '$t += grep /regex/, @F; END { print $t }'\n\n\n\n\n\n\nPrint the total number of lines that match a pattern\n\n\n\n\nperl -lne '/regex/ && $t++; END { print $t }'\n\n\n\n\n\n\nPrint the number PI to n decimal places\n\n\n\n\nperl -Mbignum=bpi -le 'print bpi(n)'\n\n\n\n\n\n\nPrint the number PI to 39 decimal places\n\n\n\n\nperl -Mbignum=PI -le 'print PI'\n\n\n\n\n\n\nPrint the number E to n decimal places\n\n\n\n\nperl -Mbignum=bexp -le 'print bexp(1,n+1)'\n\n\n\n\n\n\nPrint the number E to 39 decimal places\n\n\n\n\nperl -Mbignum=e -le 'print e'\n\n\n\n\n\n\nPrint UNIX time (seconds since Jan 1, 1970, 00:00:00 UTC)\n\n\n\n\nperl -le 'print time'\n\n\n\n\n\n\nPrint GMT (Greenwich Mean Time) and local computer time\n\n\n\n\nperl -le 'print scalar gmtime'\nperl -le 'print scalar localtime'\n\n\n\n\n\n\nPrint local computer time in H:M:S format\n\n\n\n\nperl -le 'print join \":\", (localtime)[2,1,0]'\n\n\n\n\n\n\nPrint yesterday's date\n\n\n\n\nperl -MPOSIX -le '@now = localtime; $now[3] -= 1; print scalar localtime mktime @now'\n\n\n\n\n\n\nPrint date 14 months, 9 days and 7 seconds ago\n\n\n\n\nperl -MPOSIX -le '@now = localtime; $now[0] -= 7; $now[4] -= 14; $now[7] -= 9; print scalar localtime mktime @now'\n\n\n\n\n\n\nPrepend timestamps to stdout (GMT, localtime)\n\n\n\n\ntail -f logfile | perl -ne 'print scalar gmtime,\" \",$_'\ntail -f logfile | perl -ne 'print scalar localtime,\" \",$_'\n\n\n\n\n\n\nCalculate factorial of 5\n\n\n\n\nperl -MMath::BigInt -le 'print Math::BigInt->new(5)->bfac()'\nperl -le '$f = 1; $f *= $_ for 1..5; print $f'\n\n\n\n\n\n\nCalculate greatest common divisor (GCM)\n\n\n\n\nperl -MMath::BigInt=bgcd -le 'print bgcd(@list_of_numbers)'\n\n\n\n\n\n\nCalculate GCM of numbers 20 and 35 using Euclid's algorithm\n\n\n\n\nperl -le '$n = 20; $m = 35; ($m,$n) = ($n,$m%$n) while $n; print $m'\n\n\n\n\n\n\nCalculate least common multiple (LCM) of numbers 35, 20 and 8\n\n\n\n\nperl -MMath::BigInt=blcm -le 'print blcm(35,20,8)'\n\n\n\n\n\n\nCalculate LCM of 20 and 35 using Euclid's formula: n*m/gcd(n,m)\n\n\n\n\nperl -le '$a = $n = 20; $b = $m = 35; ($m,$n) = ($n,$m%$n) while $n; print $a*$b/$m'\n\n\n\n\n\n\nGenerate 10 random numbers between 5 and 15 (excluding 15)\n\n\n\n\nperl -le '$n=10; $min=5; $max=15; $, = \" \"; print map { int(rand($max-$min))+$min } 1..$n'\n\n\n\n\n\n\nFind and print all permutations of a list\n\n\n\n\nperl -MAlgorithm::Permute -le '$l = [1,2,3,4,5]; $p = Algorithm::Permute->new($l); print @r while @r = $p->next'\n\n\n\n\n\n\nGenerate the power set\n\n\n\n\nperl -MList::PowerSet=powerset -le '@l = (1,2,3,4,5); for (@{powerset(@l)}) { print \"@$_\" }'\n\n\n\n\n\n\nConvert an IP address to unsigned integer\n\n\n\n\nperl -le '$i=3; $u += ($_<<8*$i--) for \"127.0.0.1\" =~ /(\\d+)/g; print $u'\nperl -le '$ip=\"127.0.0.1\"; $ip =~ s/(\\d+)\\.?/sprintf(\"%02x\", $1)/ge; print hex($ip)'\nperl -le 'print unpack(\"N\", 127.0.0.1)'\nperl -MSocket -le 'print unpack(\"N\", inet_aton(\"127.0.0.1\"))'\n\n\n\n\n\n\nConvert an unsigned integer to an IP address\n\n\n\n\nperl -MSocket -le 'print inet_ntoa(pack(\"N\", 2130706433))'\nperl -le '$ip = 2130706433; print join \".\", map { (($ip>>8*($_))&0xFF) } reverse 0..3'\nperl -le '$ip = 2130706433; $, = \".\"; print map { (($ip>>8*($_))&0xFF) } reverse 0..3'\n\n\n\n\nSTRING CREATION AND ARRAY CREATION\n\n\n\n\nGenerate and print the alphabet\n\n\n\n\nperl -le 'print a..z'\nperl -le 'print (\"a\"..\"z\")'\nperl -le '$, = \",\"; print (\"a\"..\"z\")'\nperl -le 'print join \",\", (\"a\"..\"z\")'\n\n\n\n\n\n\nGenerate and print all the strings from \"a\" to \"zz\"\n\n\n\n\nperl -le 'print (\"a\"..\"zz\")'\nperl -le 'print \"aa\"..\"zz\"'\n\n\n\n\n\n\nCreate a hex lookup table\n\n\n\n\n@hex = (0..9, \"a\"..\"f\")\n\n\n\n\n\n\nConvert a decimal number to hex using @hex lookup table\n\n\n\n\nperl -le '$num = 255; @hex = (0..9, \"a\"..\"f\"); while ($num) { $s = $hex[($num%16)&15].$s; $num = int $num/16 } print $s'\nperl -le '$hex = sprintf(\"%x\", 255); print $hex'\nperl -le '$num = \"ff\"; print hex $num'\n\n\n\n\n\n\nGenerate a random 8 character password\n\n\n\n\nperl -le 'print map { (\"a\"..\"z\")[rand 26] } 1..8'\nperl -le 'print map { (\"a\"..\"z\", 0..9)[rand 36] } 1..8'\n\n\n\n\n\n\nCreate a string of specific length\n\n\n\n\nperl -le 'print \"a\"x50'\n\n\n\n\n\n\nCreate a repeated list of elements\n\n\n\n\nperl -le '@list = (1,2)x20; print \"@list\"'\n\n\n\n\n\n\nCreate an array from a string\n\n\n\n\n@months = split ' ', \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\"\n@months = qw/Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/\n\n\n\n\n\n\nCreate a string from an array\n\n\n\n\n@stuff = (\"hello\", 0..9, \"world\"); $string = join '-', @stuff\n\n\n\n\n\n\nFind the numeric values for characters in the string\n\n\n\n\nperl -le 'print join \", \", map { ord } split //, \"hello world\"'\n\n\n\n\n\n\nConvert a list of numeric ASCII values into a string\n\n\n\n\nperl -le '@ascii = (99, 111, 100, 105, 110, 103); print pack(\"C*\", @ascii)'\nperl -le '@ascii = (99, 111, 100, 105, 110, 103); print map { chr } @ascii'\n\n\n\n\n\n\nGenerate an array with odd numbers from 1 to 100\n\n\n\n\nperl -le '@odd = grep {$_ % 2 == 1} 1..100; print \"@odd\"'\nperl -le '@odd = grep { $_ & 1 } 1..100; print \"@odd\"'\n\n\n\n\n\n\nGenerate an array with even numbers from 1 to 100\n\n\n\n\nperl -le '@even = grep {$_ % 2 == 0} 1..100; print \"@even\"'\n\n\n\n\n\n\nFind the length of the string\n\n\n\n\nperl -le 'print length \"one-liners are great\"'\n\n\n\n\n\n\nFind the number of elements in an array\n\n\n\n\nperl -le '@array = (\"a\"..\"z\"); print scalar @array'\nperl -le '@array = (\"a\"..\"z\"); print $#array + 1'\n\n\n\n\nTEXT CONVERSION AND SUBSTITUTION\n\n\n\n\nROT13 a string\n\n\n\n\n'y/A-Za-z/N-ZA-Mn-za-m/'\n\n\n\n\n\n\nROT 13 a file\n\n\n\n\nperl -lpe 'y/A-Za-z/N-ZA-Mn-za-m/' file\n\n\n\n\n\n\nBase64 encode a string\n\n\n\n\nperl -MMIME::Base64 -e 'print encode_base64(\"string\")'\nperl -MMIME::Base64 -0777 -ne 'print encode_base64($_)' file\n\n\n\n\n\n\nBase64 decode a string\n\n\n\n\nperl -MMIME::Base64 -le 'print decode_base64(\"base64string\")'\nperl -MMIME::Base64 -ne 'print decode_base64($_)' file\n\n\n\n\n\n\nURL-escape a string\n\n\n\n\nperl -MURI::Escape -le 'print uri_escape($string)'\n\n\n\n\n\n\nURL-unescape a string\n\n\n\n\nperl -MURI::Escape -le 'print uri_unescape($string)'\n\n\n\n\n\n\nHTML-encode a string\n\n\n\n\nperl -MHTML::Entities -le 'print encode_entities($string)'\n\n\n\n\n\n\nHTML-decode a string\n\n\n\n\nperl -MHTML::Entities -le 'print decode_entities($string)'\n\n\n\n\n\n\nConvert all text to uppercase\n\n\n\n\nperl -nle 'print uc'\nperl -ple '$_=uc'\nperl -nle 'print \"\\U$_\"'\n\n\n\n\n\n\nConvert all text to lowercase\n\n\n\n\nperl -nle 'print lc'\nperl -ple '$_=lc'\nperl -nle 'print \"\\L$_\"'\n\n\n\n\n\n\nUppercase only the first word of each line\n\n\n\n\nperl -nle 'print ucfirst lc'\nperl -nle 'print \"\\u\\L$_\"'\n\n\n\n\n\n\nInvert the letter case\n\n\n\n\nperl -ple 'y/A-Za-z/a-zA-Z/'\n\n\n\n\n\n\nCamel case each line\n\n\n\n\nperl -ple 's/(\\w+)/\\u$1/g'\nperl -ple 's/(?<!['])(\\w+)/\\u\\1/g'\n\n\n\n\n\n\nStrip leading whitespace (spaces, tabs) from the beginning of each line\n\n\n\n\nperl -ple 's/^[ \\t]+//'\nperl -ple 's/^\\s+//'\n\n\n\n\n\n\nStrip trailing whitespace (space, tabs) from the end of each line\n\n\n\n\nperl -ple 's/[ \\t]+$//'\n\n\n\n\n\n\nStrip whitespace from the beginning and end of each line\n\n\n\n\nperl -ple 's/^[ \\t]+|[ \\t]+$//g'\n\n\n\n\n\n\nConvert UNIX newlines to DOS/Windows newlines\n\n\n\n\nperl -pe 's|\\n|\\r\\n|'\n\n\n\n\n\n\nConvert DOS/Windows newlines to UNIX newlines\n\n\n\n\nperl -pe 's|\\r\\n|\\n|'\n\n\n\n\n\n\nConvert UNIX newlines to Mac newlines\n\n\n\n\nperl -pe 's|\\n|\\r|'\n\n\n\n\n\n\nSubstitute (find and replace) \"foo\" with \"bar\" on each line\n\n\n\n\nperl -pe 's/foo/bar/'\n\n\n\n\n\n\nSubstitute (find and replace) all \"foo\"s with \"bar\" on each line\n\n\n\n\nperl -pe 's/foo/bar/g'\n\n\n\n\n\n\nSubstitute (find and replace) \"foo\" with \"bar\" on lines that match \"baz\"\n\n\n\n\nperl -pe '/baz/ && s/foo/bar/'\n\n\n\n\n\n\nBinary patch a file (find and replace a given array of bytes as hex numbers)\n\n\n\n\nperl -pi -e 's/\\x89\\xD8\\x48\\x8B/\\x90\\x90\\x48\\x8B/g' file\n\n\n\n\nSELECTIVE PRINTING AND DELETING OF CERTAIN LINES\n\n\n\n\nPrint the first line of a file (emulate head -1)\n\n\n\n\nperl -ne 'print; exit'\n\n\n\n\n\n\nPrint the first 10 lines of a file (emulate head -10)\n\n\n\n\nperl -ne 'print if $. <= 10'\nperl -ne '$. <= 10 && print'\nperl -ne 'print if 1..10'\n\n\n\n\n\n\nPrint the last line of a file (emulate tail -1)\n\n\n\n\nperl -ne '$last = $_; END { print $last }'\nperl -ne 'print if eof'\n\n\n\n\n\n\nPrint the last 10 lines of a file (emulate tail -10)\n\n\n\n\nperl -ne 'push @a, $_; @a = @a[@a-10..$#a]; END { print @a }'\n\n\n\n\n\n\nPrint only lines that match a regular expression\n\n\n\n\nperl -ne '/regex/ && print'\n\n\n\n\n\n\nPrint only lines that do not match a regular expression\n\n\n\n\nperl -ne '!/regex/ && print'\n\n\n\n\n\n\nPrint the line before a line that matches a regular expression\n\n\n\n\nperl -ne '/regex/ && $last && print $last; $last = $_'\n\n\n\n\n\n\nPrint the line after a line that matches a regular expression\n\n\n\n\nperl -ne 'if ($p) { print; $p = 0 } $p++ if /regex/'\n\n\n\n\n\n\nPrint lines that match regex AAA and regex BBB in any order\n\n\n\n\nperl -ne '/AAA/ && /BBB/ && print'\n\n\n\n\n\n\nPrint lines that don't match match regexes AAA and BBB\n\n\n\n\nperl -ne '!/AAA/ && !/BBB/ && print'\n\n\n\n\n\n\nPrint lines that match regex AAA followed by regex BBB followed by CCC\n\n\n\n\nperl -ne '/AAA.*BBB.*CCC/ && print'\n\n\n\n\n\n\nPrint lines that are 80 chars or longer\n\n\n\n\nperl -ne 'print if length >= 80'\n\n\n\n\n\n\nPrint lines that are less than 80 chars in length\n\n\n\n\nperl -ne 'print if length < 80'\n\n\n\n\n\n\nPrint only line 13\n\n\n\n\nperl -ne '$. == 13 && print && exit'\n\n\n\n\n\n\nPrint all lines except line 27\n\n\n\n\nperl -ne '$. != 27 && print'\nperl -ne 'print if $. != 27'\n\n\n\n\n\n\nPrint only lines 13, 19 and 67\n\n\n\n\nperl -ne 'print if $. == 13 || $. == 19 || $. == 67'\nperl -ne 'print if int($.) ~~ (13, 19, 67)'\n\n\n\n\n\n\nPrint all lines between two regexes (including lines that match regex)\n\n\n\n\nperl -ne 'print if /regex1/../regex2/'\n\n\n\n\n\n\nPrint all lines from line 17 to line 30\n\n\n\n\nperl -ne 'print if $. >= 17 && $. <= 30'\nperl -ne 'print if int($.) ~~ (17..30)'\nperl -ne 'print if grep { $_ == $. } 17..30'\n\n\n\n\n\n\nPrint the longest line\n\n\n\n\nperl -ne '$l = $_ if length($_) > length($l); END { print $l }'\n\n\n\n\n\n\nPrint the shortest line\n\n\n\n\nperl -ne '$s = $_ if $. == 1; $s = $_ if length($_) < length($s); END { print $s }'\n\n\n\n\n\n\nPrint all lines that contain a number\n\n\n\n\nperl -ne 'print if /\\d/'\n\n\n\n\n\n\nFind all lines that contain only a number\n\n\n\n\nperl -ne 'print if /^\\d+$/'\n\n\n\n\n\n\nPrint all lines that contain only characters\n\n\n\n\nperl -ne 'print if /^[[:alpha:]]+$/\n\n\n\n\n\n\nPrint every second line\n\n\n\n\nperl -ne 'print if $. % 2'\n\n\n\n\n\n\nPrint every second line, starting the second line\n\n\n\n\nperl -ne 'print if $. % 2 == 0'\n\n\n\n\n\n\nPrint all lines that repeat\n\n\n\n\nperl -ne 'print if ++$a{$_} == 2'\n\n\n\n\n\n\nPrint all unique lines\n\n\n\n\nperl -ne 'print unless $a{$_}++'\n\n\n\n\n\n\nPrint the first field (word) of every line (emulate cut -f 1 -d ' ')\n\n\n\n\nperl -alne 'print $F[0]'\n\n\n\n\nHANDY REGULAR EXPRESSIONS\n\n\n\n\nMatch something that looks like an IP address\n\n\n\n\n/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/\n/^(\\d{1,3}\\.){3}\\d{1,3}$/\n\n\n\n\n\n\nTest if a number is in range 0-255\n\n\n\n\n/^([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/\n\n\n\n\n\n\nMatch an IP address\n\n\n\n\nmy $ip_part = qr|([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|;\nif ($ip =~ /^($ip_part\\.){3}$ip_part$/) {\n say \"valid ip\";\n}\n\n\n\n\n\n\nCheck if the string looks like an email address\n\n\n\n\n/\\S+@\\S+\\.\\S+/\n\n\n\n\n\n\nCheck if the string is a decimal number\n\n\n\n\n/^\\d+$/\n/^[+-]?\\d+$/\n/^[+-]?\\d+\\.?\\d*$/\n\n\n\n\n\n\nCheck if the string is a hexadecimal number\n\n\n\n\n/^0x[0-9a-f]+$/i\n\n\n\n\n\n\nCheck if the string is an octal number\n\n\n\n\n/^0[0-7]+$/\n\n\n\n\n\n\nCheck if the string is binary\n\n\n\n\n/^[01]+$/\n\n\n\n\n\n\nCheck if a word appears twice in the string\n\n\n\n\n/(word).*\\1/\n\n\n\n\n\n\nIncrease all numbers by one in the string\n\n\n\n\n$str =~ s/(\\d+)/$1+1/ge\n\n\n\n\n\n\nExtract HTTP User-Agent string from the HTTP headers\n\n\n\n\n/^User-Agent: (.+)$/\n\n\n\n\n\n\nMatch printable ASCII characters\n\n\n\n\n/[ -~]/\n\n\n\n\n\n\nMatch unprintable ASCII characters\n\n\n\n\n/[^ -~]/\n\n\n\n\n\n\nMatch text between two HTML tags\n\n\n\n\nm|<strong>([^<]*)</strong>|\nm|<strong>(.*?)</strong>|\n\n\n\n\n\n\nReplace all \n tags with \n\n\n\n\n$html =~ s|<(/)?b>|<$1strong>|g\n\n\n\n\n\n\nExtract all matches from a regular expression\n\n\n\n\nmy @matches = $text =~ /regex/g;\n\n\n\n\nPERL TRICKS\n\n\n\n\nPrint the version of a Perl module\n\n\n\n\nperl -MModule -le 'print $Module::VERSION'\nperl -MLWP::UserAgent -le 'print $LWP::UserAgent::VERSION'\n\n\n\n\nCREDITS\n\n\n* Andy Lester       http://www.petdance.com\n* Shlomi Fish       http://www.shlomifish.org\n* Madars Virza      http://www.madars.org\n* caffecaldo        https://github.com/caffecaldo\n* Kirk Kimmel       https://github.com/kimmel\n* avar              https://github.com/avar\n* rent0n",
            "title": "Perl one liners"
        },
        {
            "location": "/Dev/Perl/Perl_one-liners/#useful-one-line-scripts-for-perl",
            "text": "",
            "title": "Useful One-Line Scripts for Perl"
        },
        {
            "location": "/Dev/Perl/Perl_one-liners/#file-spacing",
            "text": "Double space a file   perl -pe '$\\=\"\\n\"'\nperl -pe 'BEGIN { $\\=\"\\n\" }'\nperl -pe '$_ .= \"\\n\"'\nperl -pe 's/$/\\n/'\nperl -nE 'say'   Double space a file, except the blank lines   perl -pe '$_ .= \"\\n\" unless /^$/'\nperl -pe '$_ .= \"\\n\" if /\\S/'   Triple space a file   perl -pe '$\\=\"\\n\\n\"'\nperl -pe '$_.=\"\\n\\n\"'   N-space a file   perl -pe '$_.=\"\\n\"x7'   Add a blank line before every line   perl -pe 's//\\n/'   Remove all blank lines   perl -ne 'print unless /^$/'\nperl -lne 'print if length'\nperl -ne 'print if /\\S/'   Remove all consecutive blank lines, leaving just one   perl -00 -pe ''\nperl -00pe0   Compress/expand all blank lines into N consecutive ones   perl -00 -pe '$_.=\"\\n\"x4'   Fold a file so that every set of 10 lines becomes one tab-separated line   perl -lpe '$\\ = $. % 10 ? \"\\t\" : \"\\n\"'",
            "title": "FILE SPACING"
        },
        {
            "location": "/Dev/Perl/Perl_one-liners/#line-numbering",
            "text": "Number all lines in a file   perl -pe '$_ = \"$. $_\"'   Number only non-empty lines in a file   perl -pe '$_ = ++$a.\" $_\" if /./'   Number and print only non-empty lines in a file (drop empty lines)   perl -ne 'print ++$a.\" $_\" if /./'   Number all lines but print line numbers only non-empty lines   perl -pe '$_ = \"$. $_\" if /./'   Number only lines that match a pattern, print others unmodified   perl -pe '$_ = ++$a.\" $_\" if /regex/'   Number and print only lines that match a pattern   perl -ne 'print ++$a.\" $_\" if /regex/'   Number all lines, but print line numbers only for lines that match a pattern   perl -pe '$_ = \"$. $_\" if /regex/'   Number all lines in a file using a custom format (emulate cat -n)   perl -ne 'printf \"%-5d %s\", $., $_'   Print the total number of lines in a file (emulate wc -l)   perl -lne 'END { print $. }'\nperl -le 'print $n=()=<>'\nperl -le 'print scalar(()=<>)'\nperl -le 'print scalar(@foo=<>)'\nperl -ne '}{print $.'\nperl -nE '}{say $.'   Print the number of non-empty lines in a file   perl -le 'print scalar(grep{/./}<>)'\nperl -le 'print ~~grep{/./}<>'\nperl -le 'print~~grep/./,<>'\nperl -E 'say~~grep/./,<>'   Print the number of empty lines in a file   perl -lne '$a++ if /^$/; END {print $a+0}'\nperl -le 'print scalar(grep{/^$/}<>)'\nperl -le 'print ~~grep{/^$/}<>'\nperl -E 'say~~grep{/^$/}<>'   Print the number of lines in a file that match a pattern (emulate grep -c)   perl -lne '$a++ if /regex/; END {print $a+0}'\nperl -nE '$a++ if /regex/; END {say $a+0}'",
            "title": "LINE NUMBERING"
        },
        {
            "location": "/Dev/Perl/Perl_one-liners/#calculations",
            "text": "Check if a number is a prime   perl -lne '(1x$_) !~ /^1?$|^(11+?)\\1+$/ && print \"$_ is prime\"'   Print the sum of all the fields on a line   perl -MList::Util=sum -alne 'print sum @F'   Print the sum of all the fields on all lines   perl -MList::Util=sum -alne 'push @S,@F; END { print sum @S }'\nperl -MList::Util=sum -alne '$s += sum @F; END { print $s }'   Shuffle all fields on a line   perl -MList::Util=shuffle -alne 'print \"@{[shuffle @F]}\"'\nperl -MList::Util=shuffle -alne 'print join \" \", shuffle @F'   Find the minimum element on a line   perl -MList::Util=min -alne 'print min @F'   Find the minimum element over all the lines   perl -MList::Util=min -alne '@M = (@M, @F); END { print min @M }'\nperl -MList::Util=min -alne '$min = min @F; $rmin = $min unless defined $rmin && $min > $rmin; END { print $rmin }'   Find the maximum element on a line   perl -MList::Util=max -alne 'print max @F'   Find the maximum element over all the lines   perl -MList::Util=max -alne '@M = (@M, @F); END { print max @M }'   Replace each field with its absolute value   perl -alne 'print \"@{[map { abs } @F]}\"'   Find the total number of fields (words) on each line   perl -alne 'print scalar @F'   Print the total number of fields (words) on each line followed by the line   perl -alne 'print scalar @F, \" $_\"'   Find the total number of fields (words) on all lines   perl -alne '$t += @F; END { print $t}'   Print the total number of fields that match a pattern   perl -alne 'map { /regex/ && $t++ } @F; END { print $t }'\nperl -alne '$t += /regex/ for @F; END { print $t }'\nperl -alne '$t += grep /regex/, @F; END { print $t }'   Print the total number of lines that match a pattern   perl -lne '/regex/ && $t++; END { print $t }'   Print the number PI to n decimal places   perl -Mbignum=bpi -le 'print bpi(n)'   Print the number PI to 39 decimal places   perl -Mbignum=PI -le 'print PI'   Print the number E to n decimal places   perl -Mbignum=bexp -le 'print bexp(1,n+1)'   Print the number E to 39 decimal places   perl -Mbignum=e -le 'print e'   Print UNIX time (seconds since Jan 1, 1970, 00:00:00 UTC)   perl -le 'print time'   Print GMT (Greenwich Mean Time) and local computer time   perl -le 'print scalar gmtime'\nperl -le 'print scalar localtime'   Print local computer time in H:M:S format   perl -le 'print join \":\", (localtime)[2,1,0]'   Print yesterday's date   perl -MPOSIX -le '@now = localtime; $now[3] -= 1; print scalar localtime mktime @now'   Print date 14 months, 9 days and 7 seconds ago   perl -MPOSIX -le '@now = localtime; $now[0] -= 7; $now[4] -= 14; $now[7] -= 9; print scalar localtime mktime @now'   Prepend timestamps to stdout (GMT, localtime)   tail -f logfile | perl -ne 'print scalar gmtime,\" \",$_'\ntail -f logfile | perl -ne 'print scalar localtime,\" \",$_'   Calculate factorial of 5   perl -MMath::BigInt -le 'print Math::BigInt->new(5)->bfac()'\nperl -le '$f = 1; $f *= $_ for 1..5; print $f'   Calculate greatest common divisor (GCM)   perl -MMath::BigInt=bgcd -le 'print bgcd(@list_of_numbers)'   Calculate GCM of numbers 20 and 35 using Euclid's algorithm   perl -le '$n = 20; $m = 35; ($m,$n) = ($n,$m%$n) while $n; print $m'   Calculate least common multiple (LCM) of numbers 35, 20 and 8   perl -MMath::BigInt=blcm -le 'print blcm(35,20,8)'   Calculate LCM of 20 and 35 using Euclid's formula: n*m/gcd(n,m)   perl -le '$a = $n = 20; $b = $m = 35; ($m,$n) = ($n,$m%$n) while $n; print $a*$b/$m'   Generate 10 random numbers between 5 and 15 (excluding 15)   perl -le '$n=10; $min=5; $max=15; $, = \" \"; print map { int(rand($max-$min))+$min } 1..$n'   Find and print all permutations of a list   perl -MAlgorithm::Permute -le '$l = [1,2,3,4,5]; $p = Algorithm::Permute->new($l); print @r while @r = $p->next'   Generate the power set   perl -MList::PowerSet=powerset -le '@l = (1,2,3,4,5); for (@{powerset(@l)}) { print \"@$_\" }'   Convert an IP address to unsigned integer   perl -le '$i=3; $u += ($_<<8*$i--) for \"127.0.0.1\" =~ /(\\d+)/g; print $u'\nperl -le '$ip=\"127.0.0.1\"; $ip =~ s/(\\d+)\\.?/sprintf(\"%02x\", $1)/ge; print hex($ip)'\nperl -le 'print unpack(\"N\", 127.0.0.1)'\nperl -MSocket -le 'print unpack(\"N\", inet_aton(\"127.0.0.1\"))'   Convert an unsigned integer to an IP address   perl -MSocket -le 'print inet_ntoa(pack(\"N\", 2130706433))'\nperl -le '$ip = 2130706433; print join \".\", map { (($ip>>8*($_))&0xFF) } reverse 0..3'\nperl -le '$ip = 2130706433; $, = \".\"; print map { (($ip>>8*($_))&0xFF) } reverse 0..3'",
            "title": "CALCULATIONS"
        },
        {
            "location": "/Dev/Perl/Perl_one-liners/#string-creation-and-array-creation",
            "text": "Generate and print the alphabet   perl -le 'print a..z'\nperl -le 'print (\"a\"..\"z\")'\nperl -le '$, = \",\"; print (\"a\"..\"z\")'\nperl -le 'print join \",\", (\"a\"..\"z\")'   Generate and print all the strings from \"a\" to \"zz\"   perl -le 'print (\"a\"..\"zz\")'\nperl -le 'print \"aa\"..\"zz\"'   Create a hex lookup table   @hex = (0..9, \"a\"..\"f\")   Convert a decimal number to hex using @hex lookup table   perl -le '$num = 255; @hex = (0..9, \"a\"..\"f\"); while ($num) { $s = $hex[($num%16)&15].$s; $num = int $num/16 } print $s'\nperl -le '$hex = sprintf(\"%x\", 255); print $hex'\nperl -le '$num = \"ff\"; print hex $num'   Generate a random 8 character password   perl -le 'print map { (\"a\"..\"z\")[rand 26] } 1..8'\nperl -le 'print map { (\"a\"..\"z\", 0..9)[rand 36] } 1..8'   Create a string of specific length   perl -le 'print \"a\"x50'   Create a repeated list of elements   perl -le '@list = (1,2)x20; print \"@list\"'   Create an array from a string   @months = split ' ', \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\"\n@months = qw/Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/   Create a string from an array   @stuff = (\"hello\", 0..9, \"world\"); $string = join '-', @stuff   Find the numeric values for characters in the string   perl -le 'print join \", \", map { ord } split //, \"hello world\"'   Convert a list of numeric ASCII values into a string   perl -le '@ascii = (99, 111, 100, 105, 110, 103); print pack(\"C*\", @ascii)'\nperl -le '@ascii = (99, 111, 100, 105, 110, 103); print map { chr } @ascii'   Generate an array with odd numbers from 1 to 100   perl -le '@odd = grep {$_ % 2 == 1} 1..100; print \"@odd\"'\nperl -le '@odd = grep { $_ & 1 } 1..100; print \"@odd\"'   Generate an array with even numbers from 1 to 100   perl -le '@even = grep {$_ % 2 == 0} 1..100; print \"@even\"'   Find the length of the string   perl -le 'print length \"one-liners are great\"'   Find the number of elements in an array   perl -le '@array = (\"a\"..\"z\"); print scalar @array'\nperl -le '@array = (\"a\"..\"z\"); print $#array + 1'",
            "title": "STRING CREATION AND ARRAY CREATION"
        },
        {
            "location": "/Dev/Perl/Perl_one-liners/#text-conversion-and-substitution",
            "text": "ROT13 a string   'y/A-Za-z/N-ZA-Mn-za-m/'   ROT 13 a file   perl -lpe 'y/A-Za-z/N-ZA-Mn-za-m/' file   Base64 encode a string   perl -MMIME::Base64 -e 'print encode_base64(\"string\")'\nperl -MMIME::Base64 -0777 -ne 'print encode_base64($_)' file   Base64 decode a string   perl -MMIME::Base64 -le 'print decode_base64(\"base64string\")'\nperl -MMIME::Base64 -ne 'print decode_base64($_)' file   URL-escape a string   perl -MURI::Escape -le 'print uri_escape($string)'   URL-unescape a string   perl -MURI::Escape -le 'print uri_unescape($string)'   HTML-encode a string   perl -MHTML::Entities -le 'print encode_entities($string)'   HTML-decode a string   perl -MHTML::Entities -le 'print decode_entities($string)'   Convert all text to uppercase   perl -nle 'print uc'\nperl -ple '$_=uc'\nperl -nle 'print \"\\U$_\"'   Convert all text to lowercase   perl -nle 'print lc'\nperl -ple '$_=lc'\nperl -nle 'print \"\\L$_\"'   Uppercase only the first word of each line   perl -nle 'print ucfirst lc'\nperl -nle 'print \"\\u\\L$_\"'   Invert the letter case   perl -ple 'y/A-Za-z/a-zA-Z/'   Camel case each line   perl -ple 's/(\\w+)/\\u$1/g'\nperl -ple 's/(?<!['])(\\w+)/\\u\\1/g'   Strip leading whitespace (spaces, tabs) from the beginning of each line   perl -ple 's/^[ \\t]+//'\nperl -ple 's/^\\s+//'   Strip trailing whitespace (space, tabs) from the end of each line   perl -ple 's/[ \\t]+$//'   Strip whitespace from the beginning and end of each line   perl -ple 's/^[ \\t]+|[ \\t]+$//g'   Convert UNIX newlines to DOS/Windows newlines   perl -pe 's|\\n|\\r\\n|'   Convert DOS/Windows newlines to UNIX newlines   perl -pe 's|\\r\\n|\\n|'   Convert UNIX newlines to Mac newlines   perl -pe 's|\\n|\\r|'   Substitute (find and replace) \"foo\" with \"bar\" on each line   perl -pe 's/foo/bar/'   Substitute (find and replace) all \"foo\"s with \"bar\" on each line   perl -pe 's/foo/bar/g'   Substitute (find and replace) \"foo\" with \"bar\" on lines that match \"baz\"   perl -pe '/baz/ && s/foo/bar/'   Binary patch a file (find and replace a given array of bytes as hex numbers)   perl -pi -e 's/\\x89\\xD8\\x48\\x8B/\\x90\\x90\\x48\\x8B/g' file",
            "title": "TEXT CONVERSION AND SUBSTITUTION"
        },
        {
            "location": "/Dev/Perl/Perl_one-liners/#selective-printing-and-deleting-of-certain-lines",
            "text": "Print the first line of a file (emulate head -1)   perl -ne 'print; exit'   Print the first 10 lines of a file (emulate head -10)   perl -ne 'print if $. <= 10'\nperl -ne '$. <= 10 && print'\nperl -ne 'print if 1..10'   Print the last line of a file (emulate tail -1)   perl -ne '$last = $_; END { print $last }'\nperl -ne 'print if eof'   Print the last 10 lines of a file (emulate tail -10)   perl -ne 'push @a, $_; @a = @a[@a-10..$#a]; END { print @a }'   Print only lines that match a regular expression   perl -ne '/regex/ && print'   Print only lines that do not match a regular expression   perl -ne '!/regex/ && print'   Print the line before a line that matches a regular expression   perl -ne '/regex/ && $last && print $last; $last = $_'   Print the line after a line that matches a regular expression   perl -ne 'if ($p) { print; $p = 0 } $p++ if /regex/'   Print lines that match regex AAA and regex BBB in any order   perl -ne '/AAA/ && /BBB/ && print'   Print lines that don't match match regexes AAA and BBB   perl -ne '!/AAA/ && !/BBB/ && print'   Print lines that match regex AAA followed by regex BBB followed by CCC   perl -ne '/AAA.*BBB.*CCC/ && print'   Print lines that are 80 chars or longer   perl -ne 'print if length >= 80'   Print lines that are less than 80 chars in length   perl -ne 'print if length < 80'   Print only line 13   perl -ne '$. == 13 && print && exit'   Print all lines except line 27   perl -ne '$. != 27 && print'\nperl -ne 'print if $. != 27'   Print only lines 13, 19 and 67   perl -ne 'print if $. == 13 || $. == 19 || $. == 67'\nperl -ne 'print if int($.) ~~ (13, 19, 67)'   Print all lines between two regexes (including lines that match regex)   perl -ne 'print if /regex1/../regex2/'   Print all lines from line 17 to line 30   perl -ne 'print if $. >= 17 && $. <= 30'\nperl -ne 'print if int($.) ~~ (17..30)'\nperl -ne 'print if grep { $_ == $. } 17..30'   Print the longest line   perl -ne '$l = $_ if length($_) > length($l); END { print $l }'   Print the shortest line   perl -ne '$s = $_ if $. == 1; $s = $_ if length($_) < length($s); END { print $s }'   Print all lines that contain a number   perl -ne 'print if /\\d/'   Find all lines that contain only a number   perl -ne 'print if /^\\d+$/'   Print all lines that contain only characters   perl -ne 'print if /^[[:alpha:]]+$/   Print every second line   perl -ne 'print if $. % 2'   Print every second line, starting the second line   perl -ne 'print if $. % 2 == 0'   Print all lines that repeat   perl -ne 'print if ++$a{$_} == 2'   Print all unique lines   perl -ne 'print unless $a{$_}++'   Print the first field (word) of every line (emulate cut -f 1 -d ' ')   perl -alne 'print $F[0]'",
            "title": "SELECTIVE PRINTING AND DELETING OF CERTAIN LINES"
        },
        {
            "location": "/Dev/Perl/Perl_one-liners/#handy-regular-expressions",
            "text": "Match something that looks like an IP address   /^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/\n/^(\\d{1,3}\\.){3}\\d{1,3}$/   Test if a number is in range 0-255   /^([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/   Match an IP address   my $ip_part = qr|([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|;\nif ($ip =~ /^($ip_part\\.){3}$ip_part$/) {\n say \"valid ip\";\n}   Check if the string looks like an email address   /\\S+@\\S+\\.\\S+/   Check if the string is a decimal number   /^\\d+$/\n/^[+-]?\\d+$/\n/^[+-]?\\d+\\.?\\d*$/   Check if the string is a hexadecimal number   /^0x[0-9a-f]+$/i   Check if the string is an octal number   /^0[0-7]+$/   Check if the string is binary   /^[01]+$/   Check if a word appears twice in the string   /(word).*\\1/   Increase all numbers by one in the string   $str =~ s/(\\d+)/$1+1/ge   Extract HTTP User-Agent string from the HTTP headers   /^User-Agent: (.+)$/   Match printable ASCII characters   /[ -~]/   Match unprintable ASCII characters   /[^ -~]/   Match text between two HTML tags   m|<strong>([^<]*)</strong>|\nm|<strong>(.*?)</strong>|   Replace all   tags with    $html =~ s|<(/)?b>|<$1strong>|g   Extract all matches from a regular expression   my @matches = $text =~ /regex/g;",
            "title": "HANDY REGULAR EXPRESSIONS"
        },
        {
            "location": "/Dev/Perl/Perl_one-liners/#perl-tricks",
            "text": "Print the version of a Perl module   perl -MModule -le 'print $Module::VERSION'\nperl -MLWP::UserAgent -le 'print $LWP::UserAgent::VERSION'",
            "title": "PERL TRICKS"
        },
        {
            "location": "/Dev/Perl/Perl_one-liners/#credits",
            "text": "* Andy Lester       http://www.petdance.com\n* Shlomi Fish       http://www.shlomifish.org\n* Madars Virza      http://www.madars.org\n* caffecaldo        https://github.com/caffecaldo\n* Kirk Kimmel       https://github.com/kimmel\n* avar              https://github.com/avar\n* rent0n",
            "title": "CREDITS"
        },
        {
            "location": "/Dev/Perl/Perl_scripts_for_sa/",
            "text": "Perl tricks for system administrators\n\n\nDid you know that Perl is a great programming language for system administrators? Perl is platform-independent so you can do things on different operating systems without rewriting your scripts. Scripting in Perl is quick and easy, and its portability makes your scripts amazingly useful. Here are a few examples, just to get your creative juices flowing!\nRenaming a bunch of files\n\n\nSuppose you need to rename a whole bunch of files in a directory. In this case, we've got a directory full of .xml files, and we want to rename them all to .html. Easy-peasy!\n\n\n#!/usr/bin/perl\nuse strict;\nuse warnings;\n\nforeach my $file (glob \"*.xml\") {\n    my $new = substr($file, 0, -3) . \"html\";\n    rename $file, $new;\n}\n\n\n\n\nThen just cd to the directory where you need to make the change, and run the script. You could put this in a cron job, if you needed to run it regularly, and it is easily enhanced to accept parameters.\n\n\nSpeaking of accepting parameters, let's take a look at a script that does just that.\nCreating a Linux user account\n\n\nSuppose you need to regularly create Linux user accounts on your system, and the format of the username is first initial/last name, as is common in many businesses. (This is, of course, a good idea, until you get John Smith and Jane Smith working at the same company\u2014or want John to have two accounts, as he works part-time in two different departments. But humor me, okay?) Each user account needs to be in a group based on their department, and home directories are of the format /home/\n/\n. Let's take a look at a script to do that:\n\n\n#!/usr/bin/env perl\nuse strict;\nuse warnings;\n\nmy $adduser = '/usr/sbin/adduser';\n\nuse Getopt::Long qw(GetOptions);\n\n# If the user calls the script with no parameters, \n# give them help!\n\nif (not @ARGV) {\n    usage();\n}\n\n# Gather our options; if they specify any undefined option, \n# they'll get sent some help!\n\nmy %opts;\nGetOptions(\\%opts,\n    'fname=s',\n    'lname=s',\n    'dept=s',\n    'run',\n) or usage();\n\n# Let's validate our inputs. All three parameters are \n# required, and must be alphabetic.\n# You could be clever, and do this with a foreach loop, \n# but let's keep it simple for now.\n\nif (not $opts{fname} or $opts{fname} !~ /^[a-zA-Z]+$/) {\n    usage(\"First name must be alphabetic\");\n}\nif (not $opts{lname} or $opts{lname} !~ /^[a-zA-Z]+$/) {\n    usage(\"Last name must be alphabetic\");\n}\nif (not $opts{dept} or $opts{dept} !~ /^[a-zA-Z]+$/) {\n    usage(\"Department must be alphabetic\");\n}\n\n# Construct the username and home directory\n\nmy $username = lc( substr($opts{fname}, 0, 1) . $opts{lname});\nmy $home     = \"/home/$opts{dept}/$username\";\n\n# Show them what we've got ready to go.\n\nprint \"Name:           $opts{fname} $opts{lname}\\n\";\nprint \"Username:       $username\\n\";\nprint \"Department:     $opts{dept}\\n\";\nprint \"Home directory: $home\\n\\n\";\n\n# use qq() here, so that the quotes in the --gecos flag\n# get carried into the command!\n\nmy $cmd = qq($adduser --home $home --ingroup $opts{dept} \\\\\n--gecos \"$opts{fname} $opts{lname}\" $username);\n\nprint \"$cmd\\n\";\nif ($opts{run}) {\n    system $cmd;\n} else {\n    print \"You need to add the --run flag to actually execute\\n\";\n}\n\nsub usage {\n    my ($msg) = @_;\n    if ($msg) {\n        print \"$msg\\n\\n\";\n    }\n    print \"Usage: $0 --fname FirstName --lname LastName --dept Department --run\\n\";\n    exit;\n}\n\n\n\n\nAs with the previous script, there are opportunities for enhancement, but something like this might be all that you need for this task.\n\n\nOne more, just for fun!\nChange copyright text in every Perl source file in a directory tree\n\n\nNow we're going to try a mass edit. Suppose you've got a directory full of code, and each file has a copyright statement somewhere in it. (Rich Bowen wrote a great article, Copyright statements proliferate inside open source code a couple of years ago that discusses the wisdom of copyright statements in open source code. It is a good read, and I recommend it highly. But again, humor me.) You want to change that text in each and every file in the directory tree. File::Find and File::Slurp are your friends!\n\n\n#!/usr/bin/perl\nuse strict;\nuse warnings;\n\nuse File::Find qw(find);\nuse File::Slurp qw(read_file write_file);\n\n# If the user gives a directory name, use that. Otherwise, \n# use the current directory.\n\nmy $dir = $ARGV[0] || '.';\n\n# File::Find::find is kind of dark-arts magic. \n# You give it a reference to some code, \n# and a directory to hunt in, and it will \n# execute that code  on every file in the \n# directory, and all subdirectories. In this \n# case, \\&change_file is the reference \n# to our code, a subroutine.  You could, if \n# what you wanted to do was really short, \n# include it in a { } block instead. But doing \n# it this way is nice and readable.\n\nfind( \\&change_file, $dir);\n\nsub change_file {\n    my $name= $_;\n\n    # If the file is a directory, symlink, or other \n    # non-regular file, don't do anything\n\n    if (not -f $name) {\n        return;\n    }\n    # If it's not Perl, don't do anything.\n\n    if (substr($name, -3) ne \".pl\") {\n        return;\n    }\n    print \"$name\\n\";\n\n    # Gobble up the file, complete with carriage\n    # returns and everything. \n    # Be wary of this if you have very large files\n    # on a system with limited memory!\n\n    my $data = read_file($name);\n\n    # Use a regex to make the change. If the string appears \n    # more than once, this will change it everywhere!\n\n    $data =~ s/Copyright Old/Copyright New/g;\n\n    # Let's not ruin our original files\n\n    my $backup = \"$name.bak\";\n    rename $name, $backup; \n    write_file($name, $data);\n\n    return;\n}\n\n\n\n\nBecause of Perl's portability, you could use this script on a Windows system as well as a Linux system\u2014it Just Works because of the underlying Perl interpreter code. In our create-an-account code above, that one is not portable, but is Linux-specific because it uses Linux commands such as adduser.\n\n\nIn my experience, I've found it useful to have a Git repository of these things somewhere that I can clone on each new system I'm working with. Over time, you'll think of changes to make to the code to enhance the capabilities, or you'll add new scripts, and Git can help you make sure that all your tools and tricks are available on all your systems.\n\n\nI hope these little scripts have given you some ideas how you can use Perl to make your system administration life a little easier. In addition to these longer scripts, take a look at a fantastic list of Perl one-liners, and links to other Perl magic assembled by Mischa Peterson.",
            "title": "Perl scripts for sa"
        },
        {
            "location": "/Dev/Perl/Perl_scripts_for_sa/#perl-tricks-for-system-administrators",
            "text": "Did you know that Perl is a great programming language for system administrators? Perl is platform-independent so you can do things on different operating systems without rewriting your scripts. Scripting in Perl is quick and easy, and its portability makes your scripts amazingly useful. Here are a few examples, just to get your creative juices flowing!\nRenaming a bunch of files  Suppose you need to rename a whole bunch of files in a directory. In this case, we've got a directory full of .xml files, and we want to rename them all to .html. Easy-peasy!  #!/usr/bin/perl\nuse strict;\nuse warnings;\n\nforeach my $file (glob \"*.xml\") {\n    my $new = substr($file, 0, -3) . \"html\";\n    rename $file, $new;\n}  Then just cd to the directory where you need to make the change, and run the script. You could put this in a cron job, if you needed to run it regularly, and it is easily enhanced to accept parameters.  Speaking of accepting parameters, let's take a look at a script that does just that.\nCreating a Linux user account  Suppose you need to regularly create Linux user accounts on your system, and the format of the username is first initial/last name, as is common in many businesses. (This is, of course, a good idea, until you get John Smith and Jane Smith working at the same company\u2014or want John to have two accounts, as he works part-time in two different departments. But humor me, okay?) Each user account needs to be in a group based on their department, and home directories are of the format /home/ / . Let's take a look at a script to do that:  #!/usr/bin/env perl\nuse strict;\nuse warnings;\n\nmy $adduser = '/usr/sbin/adduser';\n\nuse Getopt::Long qw(GetOptions);\n\n# If the user calls the script with no parameters, \n# give them help!\n\nif (not @ARGV) {\n    usage();\n}\n\n# Gather our options; if they specify any undefined option, \n# they'll get sent some help!\n\nmy %opts;\nGetOptions(\\%opts,\n    'fname=s',\n    'lname=s',\n    'dept=s',\n    'run',\n) or usage();\n\n# Let's validate our inputs. All three parameters are \n# required, and must be alphabetic.\n# You could be clever, and do this with a foreach loop, \n# but let's keep it simple for now.\n\nif (not $opts{fname} or $opts{fname} !~ /^[a-zA-Z]+$/) {\n    usage(\"First name must be alphabetic\");\n}\nif (not $opts{lname} or $opts{lname} !~ /^[a-zA-Z]+$/) {\n    usage(\"Last name must be alphabetic\");\n}\nif (not $opts{dept} or $opts{dept} !~ /^[a-zA-Z]+$/) {\n    usage(\"Department must be alphabetic\");\n}\n\n# Construct the username and home directory\n\nmy $username = lc( substr($opts{fname}, 0, 1) . $opts{lname});\nmy $home     = \"/home/$opts{dept}/$username\";\n\n# Show them what we've got ready to go.\n\nprint \"Name:           $opts{fname} $opts{lname}\\n\";\nprint \"Username:       $username\\n\";\nprint \"Department:     $opts{dept}\\n\";\nprint \"Home directory: $home\\n\\n\";\n\n# use qq() here, so that the quotes in the --gecos flag\n# get carried into the command!\n\nmy $cmd = qq($adduser --home $home --ingroup $opts{dept} \\\\\n--gecos \"$opts{fname} $opts{lname}\" $username);\n\nprint \"$cmd\\n\";\nif ($opts{run}) {\n    system $cmd;\n} else {\n    print \"You need to add the --run flag to actually execute\\n\";\n}\n\nsub usage {\n    my ($msg) = @_;\n    if ($msg) {\n        print \"$msg\\n\\n\";\n    }\n    print \"Usage: $0 --fname FirstName --lname LastName --dept Department --run\\n\";\n    exit;\n}  As with the previous script, there are opportunities for enhancement, but something like this might be all that you need for this task.  One more, just for fun!\nChange copyright text in every Perl source file in a directory tree  Now we're going to try a mass edit. Suppose you've got a directory full of code, and each file has a copyright statement somewhere in it. (Rich Bowen wrote a great article, Copyright statements proliferate inside open source code a couple of years ago that discusses the wisdom of copyright statements in open source code. It is a good read, and I recommend it highly. But again, humor me.) You want to change that text in each and every file in the directory tree. File::Find and File::Slurp are your friends!  #!/usr/bin/perl\nuse strict;\nuse warnings;\n\nuse File::Find qw(find);\nuse File::Slurp qw(read_file write_file);\n\n# If the user gives a directory name, use that. Otherwise, \n# use the current directory.\n\nmy $dir = $ARGV[0] || '.';\n\n# File::Find::find is kind of dark-arts magic. \n# You give it a reference to some code, \n# and a directory to hunt in, and it will \n# execute that code  on every file in the \n# directory, and all subdirectories. In this \n# case, \\&change_file is the reference \n# to our code, a subroutine.  You could, if \n# what you wanted to do was really short, \n# include it in a { } block instead. But doing \n# it this way is nice and readable.\n\nfind( \\&change_file, $dir);\n\nsub change_file {\n    my $name= $_;\n\n    # If the file is a directory, symlink, or other \n    # non-regular file, don't do anything\n\n    if (not -f $name) {\n        return;\n    }\n    # If it's not Perl, don't do anything.\n\n    if (substr($name, -3) ne \".pl\") {\n        return;\n    }\n    print \"$name\\n\";\n\n    # Gobble up the file, complete with carriage\n    # returns and everything. \n    # Be wary of this if you have very large files\n    # on a system with limited memory!\n\n    my $data = read_file($name);\n\n    # Use a regex to make the change. If the string appears \n    # more than once, this will change it everywhere!\n\n    $data =~ s/Copyright Old/Copyright New/g;\n\n    # Let's not ruin our original files\n\n    my $backup = \"$name.bak\";\n    rename $name, $backup; \n    write_file($name, $data);\n\n    return;\n}  Because of Perl's portability, you could use this script on a Windows system as well as a Linux system\u2014it Just Works because of the underlying Perl interpreter code. In our create-an-account code above, that one is not portable, but is Linux-specific because it uses Linux commands such as adduser.  In my experience, I've found it useful to have a Git repository of these things somewhere that I can clone on each new system I'm working with. Over time, you'll think of changes to make to the code to enhance the capabilities, or you'll add new scripts, and Git can help you make sure that all your tools and tricks are available on all your systems.  I hope these little scripts have given you some ideas how you can use Perl to make your system administration life a little easier. In addition to these longer scripts, take a look at a fantastic list of Perl one-liners, and links to other Perl magic assembled by Mischa Peterson.",
            "title": "Perl tricks for system administrators"
        },
        {
            "location": "/Dev/Power_Shell/Azure/",
            "text": "Install the Azure Resource Manager modules from the PowerShell Gallery\n\n\nInstall-Module AzureRM\n\n\n\n\nTo log in to Azure Resource Manager\n\n\nLogin-AzureRmAccount\n\n\n\n\nYou can also use a specific Tenant if you would like a faster log in experience\n\n\nLogin-AzureRmAccount -TenantId xxxx\n\n\n\n\nTo view all subscriptions for your account\n\n\nGet-AzureRmSubscription\n\n\n\n\nTo select a default subscription for your current session.\n\n\n# This is useful when you have multiple subscriptions.\nGet-AzureRmSubscription -SubscriptionName \"your sub\" | Select-AzureRmSubscription\n\n\n\n\nView your current Azure PowerShell session context\n\n\n# This session state is only applicable to the current session and will not affect other sessions\nGet-AzureRmContext\n\n\n\n\nTo select the default storage context for your current session\n\n\nSet-AzureRmCurrentStorageAccount -ResourceGroupName \"your resource group\" -StorageAccountName \"your storage account name\"\n\n\n\n\nView your current Azure PowerShell session context\n\n\n# Note: the CurrentStorageAccount is now set in your session context\nGet-AzureRmContext\n\n\n\n\nTo list all of the blobs in all of your containers in all of your accounts\n\n\nGet-AzureRmStorageAccount | Get-AzureStorageContainer | Get-AzureStorageBlob\n\n\n\n\n`",
            "title": "Azure"
        },
        {
            "location": "/Dev/Power_Shell/Azure/#install-the-azure-resource-manager-modules-from-the-powershell-gallery",
            "text": "Install-Module AzureRM",
            "title": "Install the Azure Resource Manager modules from the PowerShell Gallery"
        },
        {
            "location": "/Dev/Power_Shell/Azure/#to-log-in-to-azure-resource-manager",
            "text": "Login-AzureRmAccount",
            "title": "To log in to Azure Resource Manager"
        },
        {
            "location": "/Dev/Power_Shell/Azure/#you-can-also-use-a-specific-tenant-if-you-would-like-a-faster-log-in-experience",
            "text": "Login-AzureRmAccount -TenantId xxxx",
            "title": "You can also use a specific Tenant if you would like a faster log in experience"
        },
        {
            "location": "/Dev/Power_Shell/Azure/#to-view-all-subscriptions-for-your-account",
            "text": "Get-AzureRmSubscription",
            "title": "To view all subscriptions for your account"
        },
        {
            "location": "/Dev/Power_Shell/Azure/#to-select-a-default-subscription-for-your-current-session",
            "text": "# This is useful when you have multiple subscriptions.\nGet-AzureRmSubscription -SubscriptionName \"your sub\" | Select-AzureRmSubscription",
            "title": "To select a default subscription for your current session."
        },
        {
            "location": "/Dev/Power_Shell/Azure/#view-your-current-azure-powershell-session-context",
            "text": "# This session state is only applicable to the current session and will not affect other sessions\nGet-AzureRmContext",
            "title": "View your current Azure PowerShell session context"
        },
        {
            "location": "/Dev/Power_Shell/Azure/#to-select-the-default-storage-context-for-your-current-session",
            "text": "Set-AzureRmCurrentStorageAccount -ResourceGroupName \"your resource group\" -StorageAccountName \"your storage account name\"",
            "title": "To select the default storage context for your current session"
        },
        {
            "location": "/Dev/Power_Shell/Azure/#view-your-current-azure-powershell-session-context_1",
            "text": "# Note: the CurrentStorageAccount is now set in your session context\nGet-AzureRmContext",
            "title": "View your current Azure PowerShell session context"
        },
        {
            "location": "/Dev/Power_Shell/Azure/#to-list-all-of-the-blobs-in-all-of-your-containers-in-all-of-your-accounts",
            "text": "Get-AzureRmStorageAccount | Get-AzureStorageContainer | Get-AzureStorageBlob  `",
            "title": "To list all of the blobs in all of your containers in all of your accounts"
        },
        {
            "location": "/Dev/Power_Shell/Misc/",
            "text": "Windows 2008 Server R2\n\n\nTo release this error:\n\n\n\n\nScript cannot be loaded because the execution of scripts is disabled on this system.\n\n\n\n\n# Run as Administrator\nSet-ExecutionPolicy RemoteSigned\n\n# There is following parameters:\n# * Restricted - No scripts can be run. Windows PowerShell can be used only in interactive mode.\n# * AllSigned - Only scripts signed by a trusted publisher can be run.\n# * RemoteSigned - Downloaded scripts must be signed by a trusted publisher before they can be run.\n# * Unrestricted - No restrictions; all Windows PowerShell scripts can be run.\n\n\n\n\nShow current logged user\n\n\ngwmi win32_computersystem -comp $computer | select USername,Caption,Manufacturer\nGet_WmiObject win32_computersystem -comp $computer | select USername,Caption,Manufacturer\n\n\n\n\nList of logged in users (any user in any time)\n\n\nGet-WmiObject Win32_LoggedOnUser -ComputerName msk-sales-02 | Select __SERVER, Antecedent -Unique | %{\"{0} : {1}\\{2}\" -f $_.__SERVER, $_.Antecedent.ToString().Split('\"')[1],$_.Antecedent.ToString().Split('\"')[3]}\n\n\n\n\nRead from keyboard\n\n\n$variable=read-host \"Enter computer name:\"",
            "title": "Misc"
        },
        {
            "location": "/Dev/Power_Shell/Misc/#windows-2008-server-r2",
            "text": "To release this error:   Script cannot be loaded because the execution of scripts is disabled on this system.   # Run as Administrator\nSet-ExecutionPolicy RemoteSigned\n\n# There is following parameters:\n# * Restricted - No scripts can be run. Windows PowerShell can be used only in interactive mode.\n# * AllSigned - Only scripts signed by a trusted publisher can be run.\n# * RemoteSigned - Downloaded scripts must be signed by a trusted publisher before they can be run.\n# * Unrestricted - No restrictions; all Windows PowerShell scripts can be run.",
            "title": "Windows 2008 Server R2"
        },
        {
            "location": "/Dev/Power_Shell/Misc/#show-current-logged-user",
            "text": "gwmi win32_computersystem -comp $computer | select USername,Caption,Manufacturer\nGet_WmiObject win32_computersystem -comp $computer | select USername,Caption,Manufacturer",
            "title": "Show current logged user"
        },
        {
            "location": "/Dev/Power_Shell/Misc/#list-of-logged-in-users-any-user-in-any-time",
            "text": "Get-WmiObject Win32_LoggedOnUser -ComputerName msk-sales-02 | Select __SERVER, Antecedent -Unique | %{\"{0} : {1}\\{2}\" -f $_.__SERVER, $_.Antecedent.ToString().Split('\"')[1],$_.Antecedent.ToString().Split('\"')[3]}",
            "title": "List of logged in users (any user in any time)"
        },
        {
            "location": "/Dev/Power_Shell/Misc/#read-from-keyboard",
            "text": "$variable=read-host \"Enter computer name:\"",
            "title": "Read from keyboard"
        },
        {
            "location": "/Dev/Power_Shell/One-Liners/",
            "text": "Copy file to bunch of servers by ip\n\n\n# for ($i=<1>; $i -le <254>; $i++) { scp <Path-To-File> <username>@<XXX.XXX.XXX>.$($i):<Path-On-server> }\nfor ($i=2; $i -le 3; $i++) { scp C:\\Users\\dkiva\\Downloads\\jdk-10.0.1_linux-x64_bin.rpm divanov@172.30.30.$($i):~/jdk-10.0.1_linux-x64_bin.rpm }\n\n\n\n\nUnpack any tar.gz in current folder\n\n\nGet-Location | Get-ChildItem | ForEach-Object {tar zxf $_.Name }\n\n\n\n\nKill process by name\n\n\n# Get-Process <ProcessName> | ForEach-Object { Stop-Process $_.Id }\nGet-Process tar | ForEach-Object { Stop-Process $_.Id }",
            "title": "One Liners"
        },
        {
            "location": "/Dev/Power_Shell/One-Liners/#copy-file-to-bunch-of-servers-by-ip",
            "text": "# for ($i=<1>; $i -le <254>; $i++) { scp <Path-To-File> <username>@<XXX.XXX.XXX>.$($i):<Path-On-server> }\nfor ($i=2; $i -le 3; $i++) { scp C:\\Users\\dkiva\\Downloads\\jdk-10.0.1_linux-x64_bin.rpm divanov@172.30.30.$($i):~/jdk-10.0.1_linux-x64_bin.rpm }",
            "title": "Copy file to bunch of servers by ip"
        },
        {
            "location": "/Dev/Power_Shell/One-Liners/#unpack-any-targz-in-current-folder",
            "text": "Get-Location | Get-ChildItem | ForEach-Object {tar zxf $_.Name }",
            "title": "Unpack any tar.gz in current folder"
        },
        {
            "location": "/Dev/Power_Shell/One-Liners/#kill-process-by-name",
            "text": "# Get-Process <ProcessName> | ForEach-Object { Stop-Process $_.Id }\nGet-Process tar | ForEach-Object { Stop-Process $_.Id }",
            "title": "Kill process by name"
        },
        {
            "location": "/Dev/Python/Installation/",
            "text": "Install Python 2.7.13 on Linux\n\n\nwget https://www.python.org/ftp/python/2.7.13/Python-2.7.13.tgz\ntar -xvf Python-2.7.13.tgz\ncd Python-2.7.13\n./configure\nmake\nsudo make install",
            "title": "Installation"
        },
        {
            "location": "/Dev/Python/Installation/#install-python-2713-on-linux",
            "text": "wget https://www.python.org/ftp/python/2.7.13/Python-2.7.13.tgz\ntar -xvf Python-2.7.13.tgz\ncd Python-2.7.13\n./configure\nmake\nsudo make install",
            "title": "Install Python 2.7.13 on Linux"
        },
        {
            "location": "/Dev/Python/Kivy/",
            "text": "Python 2 and >3.5\n\n\npython -m pip install --upgrade pip wheel setuptools\npython -m pip install docutils pygments pypiwin32 kivy.deps.sdl2 kivy.deps.glew\npython -m pip install kivy.deps.gstreamer\npython -m pip install kivy\n\n\n\n\nPython 3.5+\n\n\n\n\nYou will need \nGlew\n\n\n\n\npython -m pip install --upgrade pip wheel setuptools\npython -m pip install docutils pygments pypiwin32 kivy.deps.sdl2 kivy.deps.glew\npython -m pip install kivy.deps.gstreamer\npython -m pip install Cython\n# Python 3.5\npython -m pip install https://github.com/kivy/kivy/zipball/master\n# Python 3.6\npython -m pip install https://kivy.org/downloads/appveyor/kivy/Kivy-1.9.2.dev0-cp36-cp36m-win_amd64.whl\n\n# For x64 you need to  download 64-bit version pygame from here:\n# http://www.lfd.uci.edu/~gohlke/pythonlibs/#pygame\npython -m pip install pygame-1.9.3-cp36-cp36m-win_amd64.whl\n\n\n\n\nTest\n\n\nfrom kivy.app import App\nfrom kivy.uix.button import Button\n\nclass TestApp(App):\n  def build(self):\n    return Button(text='Hello World')\n\nTestApp().run()",
            "title": "Kivy"
        },
        {
            "location": "/Dev/Python/Kivy/#python-2-and-35",
            "text": "python -m pip install --upgrade pip wheel setuptools\npython -m pip install docutils pygments pypiwin32 kivy.deps.sdl2 kivy.deps.glew\npython -m pip install kivy.deps.gstreamer\npython -m pip install kivy",
            "title": "Python 2 and &gt;3.5"
        },
        {
            "location": "/Dev/Python/Kivy/#python-35",
            "text": "You will need  Glew   python -m pip install --upgrade pip wheel setuptools\npython -m pip install docutils pygments pypiwin32 kivy.deps.sdl2 kivy.deps.glew\npython -m pip install kivy.deps.gstreamer\npython -m pip install Cython\n# Python 3.5\npython -m pip install https://github.com/kivy/kivy/zipball/master\n# Python 3.6\npython -m pip install https://kivy.org/downloads/appveyor/kivy/Kivy-1.9.2.dev0-cp36-cp36m-win_amd64.whl\n\n# For x64 you need to  download 64-bit version pygame from here:\n# http://www.lfd.uci.edu/~gohlke/pythonlibs/#pygame\npython -m pip install pygame-1.9.3-cp36-cp36m-win_amd64.whl",
            "title": "Python 3.5+"
        },
        {
            "location": "/Dev/Python/Kivy/#test",
            "text": "from kivy.app import App\nfrom kivy.uix.button import Button\n\nclass TestApp(App):\n  def build(self):\n    return Button(text='Hello World')\n\nTestApp().run()",
            "title": "Test"
        },
        {
            "location": "/Dev/Python/Users_and_groups/",
            "text": "Print list of users with all user's groups\n\n\n#!/usr/bin/python\n\nimport re\n\n#cols\nc0 = 2      # Separator\nc1 = 10     # User\nc2 = 3      # Separator\nc3 = 10     # UID\nc4 = 3      # Separator\nc5 = 54     # Groups\nc6 = 2      # Separator\n\n\n\nf = open(\"/etc/passwd\")\n\nt_len = c0+c1+c2+c3+c4+c5+c6\n\nprint \"-\" * t_len\nprint '{0:34}{1:48}{2:2}'.format(\"| \",\"Users and Groups\",\" |\")\nprint \"-\" * t_len\nprint '{0:2}{1:10}{2:3}{3:10}{4:3}{5:54}{6:2}'.format(\"| \",\"Username\",\" | \",\"UID\",\" | \",\"Groups\",\" |\")\n\nfor fline in f:\n    groups = []\n    h = open(\"/etc/group\")\n    for hline in h:\n        if fline.split(\":\")[3] == hline.split(\":\")[2]:\n            groups.append(hline.split(\":\")[0])\n        if re.search(fline.split(\":\")[0],hline) is not None:\n            if not hline.split(\":\")[2] == fline.split(\":\")[3]:\n                groups.append(hline.split(\":\")[0])\n    h.close()\n    print '{0:2}{1:10}{2:3}{3:10}{4:3}{5:54}{6:2}'.format(\"| \",fline.split(\":\")[0],\" | \",fline.split(\":\")[2],\" | \",\",\".join(groups),\" |\")\n\nprint \"-\" * t_len\n\nf.close()",
            "title": "Users and groups"
        },
        {
            "location": "/Dev/Python/Users_and_groups/#print-list-of-users-with-all-users-groups",
            "text": "#!/usr/bin/python\n\nimport re\n\n#cols\nc0 = 2      # Separator\nc1 = 10     # User\nc2 = 3      # Separator\nc3 = 10     # UID\nc4 = 3      # Separator\nc5 = 54     # Groups\nc6 = 2      # Separator\n\n\n\nf = open(\"/etc/passwd\")\n\nt_len = c0+c1+c2+c3+c4+c5+c6\n\nprint \"-\" * t_len\nprint '{0:34}{1:48}{2:2}'.format(\"| \",\"Users and Groups\",\" |\")\nprint \"-\" * t_len\nprint '{0:2}{1:10}{2:3}{3:10}{4:3}{5:54}{6:2}'.format(\"| \",\"Username\",\" | \",\"UID\",\" | \",\"Groups\",\" |\")\n\nfor fline in f:\n    groups = []\n    h = open(\"/etc/group\")\n    for hline in h:\n        if fline.split(\":\")[3] == hline.split(\":\")[2]:\n            groups.append(hline.split(\":\")[0])\n        if re.search(fline.split(\":\")[0],hline) is not None:\n            if not hline.split(\":\")[2] == fline.split(\":\")[3]:\n                groups.append(hline.split(\":\")[0])\n    h.close()\n    print '{0:2}{1:10}{2:3}{3:10}{4:3}{5:54}{6:2}'.format(\"| \",fline.split(\":\")[0],\" | \",fline.split(\":\")[2],\" | \",\",\".join(groups),\" |\")\n\nprint \"-\" * t_len\n\nf.close()",
            "title": "Print list of users with all user's groups"
        },
        {
            "location": "/Dev/Python/pip/",
            "text": "List all packages without version with powershell\n\n\n$packs = $(pip freeze --local); foreach($pack in $packs) { Write-Host $pack.Substring(0, $pack.IndexOf('=')) }\n\n\n\n\nUpdate all packages with powershell\n\n\n$packs = $(pip freeze --local); foreach($pack in $packs) { pip install -U $pack.Substring(0, $pack.IndexOf('=')) }",
            "title": "Pip"
        },
        {
            "location": "/Dev/Python/pip/#list-all-packages-without-version-with-powershell",
            "text": "$packs = $(pip freeze --local); foreach($pack in $packs) { Write-Host $pack.Substring(0, $pack.IndexOf('=')) }",
            "title": "List all packages without version with powershell"
        },
        {
            "location": "/Dev/Python/pip/#update-all-packages-with-powershell",
            "text": "$packs = $(pip freeze --local); foreach($pack in $packs) { pip install -U $pack.Substring(0, $pack.IndexOf('=')) }",
            "title": "Update all packages with powershell"
        },
        {
            "location": "/Dev/Ruby/Installation/",
            "text": "via RVM on Ubuntu\n\n\nsudo apt-get install libgdbm-dev libncurses5-dev automake libtool bison libffi-dev\ngpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\ncurl -sSL https://get.rvm.io | bash -s stable\nsource ~/.rvm/scripts/rvm\nrvm install 2.3.1\nrvm use 2.3.1 --default\nruby -v",
            "title": "Installation"
        },
        {
            "location": "/Dev/Ruby/Installation/#via-rvm-on-ubuntu",
            "text": "sudo apt-get install libgdbm-dev libncurses5-dev automake libtool bison libffi-dev\ngpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\ncurl -sSL https://get.rvm.io | bash -s stable\nsource ~/.rvm/scripts/rvm\nrvm install 2.3.1\nrvm use 2.3.1 --default\nruby -v",
            "title": "via RVM on Ubuntu"
        },
        {
            "location": "/Dev/Vbs/Kaspersky_Base_Actuality/",
            "text": "With WMI query to get AVBasesStat path\n\n\n' VBscript:\n' Script to check actual date of Kaspersky Bases update\n' Author  : Dmitry Ivanov\n' Usage : C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo <Path_TO>\\kav.vbs\n'   NetXMS Agent config:\n'   ExternalParameterShellExec = KasperskyBasesState:C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo c:\\Path_TO\\kav.vbs\n\nOn Error Resume Next\n\nstrComputer     = \".\"\nstrNamespace    = \"\\root\\CIMV2\"\nstrClass    = \"Win32_SoftwareElement\"\n\nSet objWMIService   = GetObject(\"winmgmts:\\\\\" & strComputer & strNamespace) \nset colItems    = objWMIService.ExecQuery(_\n        \"Select * from \" & strClass &\" Where Name='AVBasesStatComponent'\", _\n        \"WQL\", wbemFlagReturnImmediately + wbemFlagForwardOnly)\n\nkavStatFile   = colItems.ItemIndex(0).Path + \"kdb.stt\"\n\nConst FILE_READ   = 1\nSet objFSO    = CreateObject(\"Scripting.FileSystemObject\")\nSet objStatFile   = objFSO.OpenTextFile(kavStatFile, FILE_READ)\nkavBasesStatStr   = objStatFile.ReadLine\nkavBasesStatArr   = Split(kavBasesStatStr,\";\")\nkavBaseDateStr    = kavBasesStatArr(1)\n\ntheYear     = Mid(kavBaseDateStr, 1, 4)\ntheMonth    = Mid(kavBaseDateStr, 5, 2)\ntheDay      = Mid(kavBaseDateStr, 7, 2)\ntheHour     = Mid(kavBaseDateStr, 9, 2)\ntheMin      = Mid(kavBaseDateStr, 11, 2)\n\nkavBaseDate   = CDate(theDay & \"/\" & theMonth & \"/\" & theYear & \" \" & theHour & \":\" & theMin)\ndateNow     = Now()\ndateTreshold    = DateAdd(\"H\",-24, dateNow)\n\nIF dateNow < kavBaseDate Then\n  Wscript.Echo \"!!!ERROR: Wrong time. Kaspersky bases from future! Check server timezone!\"\nElseIF dateTreshold < kavBaseDate Then\n  Wscript.Echo \"Yes\"\nElse\n  Wscript.Echo \"No\"\nEnd If\n\nobjStatFile.close()\n\n\n' DEBUG\n'Wscript.Echo \"kavBaseDate: \"     & kavBaseDate\n'Wscript.Echo \"dateNow: \"     & dateNow\n'Wscript.Echo \"kavBaseDateStr: \"  & kavBaseDateStr\n'Wscript.Echo \"dateTreshold \"     & dateTreshold\n'Wscript.Echo \"IF: \"      & dateTreshold < kavBaseDate\n'Wscript.Echo \n\n\n\n\nHardcoded AVBasesStat path\n\n\n' VBscript:\n' Script to check actual date of Kaspersky Bases update\n' Author  : Dmitry Ivanov\n' Usage : C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo <Path_TO>\\kav.vbs\n'   NetXMS Agent config:\n'   ExternalParameterShellExec = KasperskyBasesState:C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo c:\\Path_TO\\kav.vbs\n\nOn Error Resume Next\n\nkavStatFile   = \"c:\\ProgramData\\Kaspersky Lab\\KAV for Windows Servers Enterprise Edition\\8.0\\Bases\\Current\\Stat\\kdb.stt\"\n\nConst FILE_READ   = 1\nSet objFSO    = CreateObject(\"Scripting.FileSystemObject\")\nSet objStatFile   = objFSO.OpenTextFile(kavStatFile, FILE_READ)\nkavBasesStatStr   = objStatFile.ReadLine\nkavBasesStatArr   = Split(kavBasesStatStr,\";\")\nkavBaseDateStr    = kavBasesStatArr(1)\n\ntheYear     = Mid(kavBaseDateStr, 1, 4)\ntheMonth    = Mid(kavBaseDateStr, 5, 2)\ntheDay      = Mid(kavBaseDateStr, 7, 2)\ntheHour     = Mid(kavBaseDateStr, 9, 2)\ntheMin      = Mid(kavBaseDateStr, 11, 2)\n\nkavBaseDate   = CDate(theDay & \"/\" & theMonth & \"/\" & theYear & \" \" & theHour & \":\" & theMin)\ndateNow     = Now()\ndateTreshold    = DateAdd(\"H\",-24, dateNow)\n\nIF dateNow < kavBaseDate Then\n  Wscript.Echo \"!!!ERROR: Wrong time. Kaspersky bases from future! Check server timezone!\"\nElseIF dateTreshold < kavBaseDate Then\n  Wscript.Echo \"Yes\"\nElse\n  Wscript.Echo \"No\"\nEnd If\n\nobjStatFile.close()\n\n\n' DEBUG\n'Wscript.Echo \"kavBaseDate: \"     & kavBaseDate\n'Wscript.Echo \"dateNow: \"     & dateNow\n'Wscript.Echo \"kavBaseDateStr: \"  & kavBaseDateStr\n'Wscript.Echo \"dateTreshold \"     & dateTreshold\n'Wscript.Echo \"IF: \"      & dateTreshold < kavBaseDate\n'Wscript.Echo",
            "title": "Kaspersky Base Actuality"
        },
        {
            "location": "/Dev/Vbs/Kaspersky_Base_Actuality/#with-wmi-query-to-get-avbasesstat-path",
            "text": "' VBscript:\n' Script to check actual date of Kaspersky Bases update\n' Author  : Dmitry Ivanov\n' Usage : C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo <Path_TO>\\kav.vbs\n'   NetXMS Agent config:\n'   ExternalParameterShellExec = KasperskyBasesState:C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo c:\\Path_TO\\kav.vbs\n\nOn Error Resume Next\n\nstrComputer     = \".\"\nstrNamespace    = \"\\root\\CIMV2\"\nstrClass    = \"Win32_SoftwareElement\"\n\nSet objWMIService   = GetObject(\"winmgmts:\\\\\" & strComputer & strNamespace) \nset colItems    = objWMIService.ExecQuery(_\n        \"Select * from \" & strClass &\" Where Name='AVBasesStatComponent'\", _\n        \"WQL\", wbemFlagReturnImmediately + wbemFlagForwardOnly)\n\nkavStatFile   = colItems.ItemIndex(0).Path + \"kdb.stt\"\n\nConst FILE_READ   = 1\nSet objFSO    = CreateObject(\"Scripting.FileSystemObject\")\nSet objStatFile   = objFSO.OpenTextFile(kavStatFile, FILE_READ)\nkavBasesStatStr   = objStatFile.ReadLine\nkavBasesStatArr   = Split(kavBasesStatStr,\";\")\nkavBaseDateStr    = kavBasesStatArr(1)\n\ntheYear     = Mid(kavBaseDateStr, 1, 4)\ntheMonth    = Mid(kavBaseDateStr, 5, 2)\ntheDay      = Mid(kavBaseDateStr, 7, 2)\ntheHour     = Mid(kavBaseDateStr, 9, 2)\ntheMin      = Mid(kavBaseDateStr, 11, 2)\n\nkavBaseDate   = CDate(theDay & \"/\" & theMonth & \"/\" & theYear & \" \" & theHour & \":\" & theMin)\ndateNow     = Now()\ndateTreshold    = DateAdd(\"H\",-24, dateNow)\n\nIF dateNow < kavBaseDate Then\n  Wscript.Echo \"!!!ERROR: Wrong time. Kaspersky bases from future! Check server timezone!\"\nElseIF dateTreshold < kavBaseDate Then\n  Wscript.Echo \"Yes\"\nElse\n  Wscript.Echo \"No\"\nEnd If\n\nobjStatFile.close()\n\n\n' DEBUG\n'Wscript.Echo \"kavBaseDate: \"     & kavBaseDate\n'Wscript.Echo \"dateNow: \"     & dateNow\n'Wscript.Echo \"kavBaseDateStr: \"  & kavBaseDateStr\n'Wscript.Echo \"dateTreshold \"     & dateTreshold\n'Wscript.Echo \"IF: \"      & dateTreshold < kavBaseDate\n'Wscript.Echo",
            "title": "With WMI query to get AVBasesStat path"
        },
        {
            "location": "/Dev/Vbs/Kaspersky_Base_Actuality/#hardcoded-avbasesstat-path",
            "text": "' VBscript:\n' Script to check actual date of Kaspersky Bases update\n' Author  : Dmitry Ivanov\n' Usage : C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo <Path_TO>\\kav.vbs\n'   NetXMS Agent config:\n'   ExternalParameterShellExec = KasperskyBasesState:C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo c:\\Path_TO\\kav.vbs\n\nOn Error Resume Next\n\nkavStatFile   = \"c:\\ProgramData\\Kaspersky Lab\\KAV for Windows Servers Enterprise Edition\\8.0\\Bases\\Current\\Stat\\kdb.stt\"\n\nConst FILE_READ   = 1\nSet objFSO    = CreateObject(\"Scripting.FileSystemObject\")\nSet objStatFile   = objFSO.OpenTextFile(kavStatFile, FILE_READ)\nkavBasesStatStr   = objStatFile.ReadLine\nkavBasesStatArr   = Split(kavBasesStatStr,\";\")\nkavBaseDateStr    = kavBasesStatArr(1)\n\ntheYear     = Mid(kavBaseDateStr, 1, 4)\ntheMonth    = Mid(kavBaseDateStr, 5, 2)\ntheDay      = Mid(kavBaseDateStr, 7, 2)\ntheHour     = Mid(kavBaseDateStr, 9, 2)\ntheMin      = Mid(kavBaseDateStr, 11, 2)\n\nkavBaseDate   = CDate(theDay & \"/\" & theMonth & \"/\" & theYear & \" \" & theHour & \":\" & theMin)\ndateNow     = Now()\ndateTreshold    = DateAdd(\"H\",-24, dateNow)\n\nIF dateNow < kavBaseDate Then\n  Wscript.Echo \"!!!ERROR: Wrong time. Kaspersky bases from future! Check server timezone!\"\nElseIF dateTreshold < kavBaseDate Then\n  Wscript.Echo \"Yes\"\nElse\n  Wscript.Echo \"No\"\nEnd If\n\nobjStatFile.close()\n\n\n' DEBUG\n'Wscript.Echo \"kavBaseDate: \"     & kavBaseDate\n'Wscript.Echo \"dateNow: \"     & dateNow\n'Wscript.Echo \"kavBaseDateStr: \"  & kavBaseDateStr\n'Wscript.Echo \"dateTreshold \"     & dateTreshold\n'Wscript.Echo \"IF: \"      & dateTreshold < kavBaseDate\n'Wscript.Echo",
            "title": "Hardcoded AVBasesStat path"
        },
        {
            "location": "/Dev/Vbs/Links/",
            "text": "List of useful urls\n\n\n\n\nvbsedit",
            "title": "Links"
        },
        {
            "location": "/Dev/Vbs/Links/#list-of-useful-urls",
            "text": "vbsedit",
            "title": "List of useful urls"
        },
        {
            "location": "/Dev/Vbs/Network/",
            "text": "Convert Server Name to IpAddress\n\n\nwebNodes = Array(\"server1.localdomain\",\"server2.localdomain\",\"server3.localdomain\")\n\nset objPing = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").ExecQuery (\"select * from Win32_PingStatus where address = '\" & webNode & \"'\")\nfor each objRetStatus in objPing\n  if IsNull(objRetStatus.StatusCode) or objRetStatus.StatusCode<>0 then\n    ipAddress = \"\"\n  else\n    ipAddress = objRetStatus.ProtocolAddress\n  end if\nnext\n\nWScript.Echo webNode & \" \" & ipAddress\nWScript.Echo \"https://eshop_user:8R63La1Gt2XmSRk@172.67.136.200/access/\"&\"enablers?rs=\"&ipAddress",
            "title": "Network"
        },
        {
            "location": "/Dev/Vbs/Network/#convert-server-name-to-ipaddress",
            "text": "webNodes = Array(\"server1.localdomain\",\"server2.localdomain\",\"server3.localdomain\")\n\nset objPing = GetObject(\"winmgmts:{impersonationLevel=impersonate}\").ExecQuery (\"select * from Win32_PingStatus where address = '\" & webNode & \"'\")\nfor each objRetStatus in objPing\n  if IsNull(objRetStatus.StatusCode) or objRetStatus.StatusCode<>0 then\n    ipAddress = \"\"\n  else\n    ipAddress = objRetStatus.ProtocolAddress\n  end if\nnext\n\nWScript.Echo webNode & \" \" & ipAddress\nWScript.Echo \"https://eshop_user:8R63La1Gt2XmSRk@172.67.136.200/access/\"&\"enablers?rs=\"&ipAddress",
            "title": "Convert Server Name to IpAddress"
        },
        {
            "location": "/Dev/Vbs/Run/",
            "text": "Run from command line:\n\n\ncscript script.vbs\nwscript script.vbs",
            "title": "Run"
        },
        {
            "location": "/Dev/Vbs/Run/#run-from-command-line",
            "text": "cscript script.vbs\nwscript script.vbs",
            "title": "Run from command line:"
        },
        {
            "location": "/Dev/Web/Redirect/",
            "text": "Redirect through index.html\n\n\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html><head><meta http-equiv=Refresh content=\"0;url=/path_to_subfolder/\"></head></html>\n\n<!--\n\n-->",
            "title": "Redirect"
        },
        {
            "location": "/Dev/Web/Redirect/#redirect-through-indexhtml",
            "text": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html><head><meta http-equiv=Refresh content=\"0;url=/path_to_subfolder/\"></head></html>\n\n<!--\n\n-->",
            "title": "Redirect through index.html"
        },
        {
            "location": "/DevOps/Ansible/",
            "text": "Create all host_vars from inventory\n\n\nIn this example we have 21 inventry recond in ansible inventory file. Something like this:\n\n\nserver1     ansible_host=1.1.1.1\nserver2     ansible_host=1.1.1.2  \nserver3     ansible_host=1.1.1.3\n#server4    ansible_host=1.1.1.4\nserver5     ansible_host=1.1.1.5\nserver6     ansible_host=1.1.1.6\n...\n#server19   ansible_host=1.1.1.19\nserver20    ansible_host=1.1.1.20\nserver21    ansible_host=1.1.1.21\n\n\n\n\nSome records comented, some not... And we need to create whole list of host envs for any active server:\n\n\ncat inventory | head -21 | awk '{print $1}' | grep -v '#' | xargs -I '{}' touch host_vars/{}",
            "title": "Ansible"
        },
        {
            "location": "/DevOps/Ansible/#create-all-host_vars-from-inventory",
            "text": "In this example we have 21 inventry recond in ansible inventory file. Something like this:  server1     ansible_host=1.1.1.1\nserver2     ansible_host=1.1.1.2  \nserver3     ansible_host=1.1.1.3\n#server4    ansible_host=1.1.1.4\nserver5     ansible_host=1.1.1.5\nserver6     ansible_host=1.1.1.6\n...\n#server19   ansible_host=1.1.1.19\nserver20    ansible_host=1.1.1.20\nserver21    ansible_host=1.1.1.21  Some records comented, some not... And we need to create whole list of host envs for any active server:  cat inventory | head -21 | awk '{print $1}' | grep -v '#' | xargs -I '{}' touch host_vars/{}",
            "title": "Create all host_vars from inventory"
        },
        {
            "location": "/DevOps/Chef-Windows/",
            "text": "Chef environment by Steven Murawski\n\n\n# First (from PowerShell), some basic ExecutionPolicy configuration. Then install the latest ChefDK and Chocolatey. After that, apply a basic Chef recipe to install Git, ConEmu, Visual Studio Code, 7Zip, WinMerge, and Vagrant.\n\n# Setup my execution policy for both the 64 bit and 32 bit shells\nset-executionpolicy remotesigned\nstart-job -runas32 {set-executionpolicy remotesigned} | receive-job -wait\n\n# Install the latest stable ChefDK\ninvoke-restmethod 'https://omnitruck.chef.io/install.ps1' | iex\ninstall-project chefdk -verbose\n\n# Install Chocolatey\ninvoke-expression ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\nchoco feature enable -n allowGlobalConfirmation\n\n# Get a basic setup recipe\ninvoke-restmethod 'https://gist.githubusercontent.com/smurawski/da67107b5efd00876af7bb0c8cfe8453/raw' | out-file -encoding ascii -filepath c:/basic.rb\n\n# Use Chef Apply to setup \nchef-apply c:/basic.rb\n\n# After Visual Studio Code is installed, you'll want to install a couple of handy extensions:\n#    Chef - https://marketplace.visualstudio.com/items?itemName=Pendrica.Chef\n#    PowerShell - https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell\n\n\n\n\nChef environment by Karsten M\u00fcller\n\n\n\n\nbasic.rb \n\n\n\n\nchocolatey_package 'git' do\n  package_name 'git'\n  options '-params /GitAndUnixToolsOnPath'\nend\n\npackages =  %w[conemu visualstudiocode 7zip winmerge vagrant autohotkey]\npackages.each do |pkg|\n  chocolatey_package pkg\nend\n\ngems = %w[kitchen-pester kitchen-hyperv kitchen-dsc kitchen-azurerm azure-credentials pry pry-byebug pry-stack_explorer appbundle-updater]\ngems.each do |gem|\n  chef_gem gem do\n    compile_time false if respond_to?(:compile_time)\n  end\nend\n\nextensions = %w[ ms-vscode.PowerShell msazurermtools.azurerm-vscode-tools Pendrica.Chef ]\nextensions.each do |ext|\n  execute \"install vscode extension #{ext}\" do\n    command \"code --install-extension #{ext}\"\n  end\nend\n\npowershell_script 'Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force' do\nend\n\nmodules = %w[ PSReadline ]\nmodules.each do |mod|\n  powershell_script \"Install-Module #{mod} -Force\" do\n  end\nend\n\ndirectory 'C:\\Work\\Chef' do\n  recursive true\n  action :create\nend\n\nexecute 'chef generate repo example_repo -p' do\n  cwd 'C:\\Work\\Chef'\nend\n\n\n\n\n\n\nbootstrap.ps1\n\n\n\n\n# Setup my execution policy for both the 64 bit and 32 bit shells\nset-executionpolicy remotesigned\nstart-job -runas32 {set-executionpolicy remotesigned} | receive-job -wait\n# Install fixed version of ChefDK \ninvoke-restmethod 'https://omnitruck.chef.io/install.ps1' | iex\ninstall-project chefdk -verbose -version 1.1.16\n# Install Chocolatey\ninvoke-expression ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\nchoco feature enable -n allowGlobalConfirmation\n# Get a basic setup recipe\nInvoke-RestMethod -UseBasicParsing 'https://gist.githubusercontent.com/karstenmueller/0c2257684b8e6a44bac9526c52074e18/raw/a150048b7ffbfe202f90fdce446b8095b3e7858c/basic.rb' | out-file -encoding ascii -filepath c:/basic.rb\n# We dont need any Windows 10 Apps\nGet-AppxPackage | Remove-AppxPackage 2>&1>$null\n# Use Chef Apply to setup \nchef-apply c:/basic.rb\nwrite-host \"executed chef recipe c:/basic.rb\"",
            "title": "Chef Windows"
        },
        {
            "location": "/DevOps/Chef-Windows/#chef-environment-by-steven-murawski",
            "text": "# First (from PowerShell), some basic ExecutionPolicy configuration. Then install the latest ChefDK and Chocolatey. After that, apply a basic Chef recipe to install Git, ConEmu, Visual Studio Code, 7Zip, WinMerge, and Vagrant.\n\n# Setup my execution policy for both the 64 bit and 32 bit shells\nset-executionpolicy remotesigned\nstart-job -runas32 {set-executionpolicy remotesigned} | receive-job -wait\n\n# Install the latest stable ChefDK\ninvoke-restmethod 'https://omnitruck.chef.io/install.ps1' | iex\ninstall-project chefdk -verbose\n\n# Install Chocolatey\ninvoke-expression ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\nchoco feature enable -n allowGlobalConfirmation\n\n# Get a basic setup recipe\ninvoke-restmethod 'https://gist.githubusercontent.com/smurawski/da67107b5efd00876af7bb0c8cfe8453/raw' | out-file -encoding ascii -filepath c:/basic.rb\n\n# Use Chef Apply to setup \nchef-apply c:/basic.rb\n\n# After Visual Studio Code is installed, you'll want to install a couple of handy extensions:\n#    Chef - https://marketplace.visualstudio.com/items?itemName=Pendrica.Chef\n#    PowerShell - https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell",
            "title": "Chef environment by Steven Murawski"
        },
        {
            "location": "/DevOps/Chef-Windows/#chef-environment-by-karsten-muller",
            "text": "basic.rb    chocolatey_package 'git' do\n  package_name 'git'\n  options '-params /GitAndUnixToolsOnPath'\nend\n\npackages =  %w[conemu visualstudiocode 7zip winmerge vagrant autohotkey]\npackages.each do |pkg|\n  chocolatey_package pkg\nend\n\ngems = %w[kitchen-pester kitchen-hyperv kitchen-dsc kitchen-azurerm azure-credentials pry pry-byebug pry-stack_explorer appbundle-updater]\ngems.each do |gem|\n  chef_gem gem do\n    compile_time false if respond_to?(:compile_time)\n  end\nend\n\nextensions = %w[ ms-vscode.PowerShell msazurermtools.azurerm-vscode-tools Pendrica.Chef ]\nextensions.each do |ext|\n  execute \"install vscode extension #{ext}\" do\n    command \"code --install-extension #{ext}\"\n  end\nend\n\npowershell_script 'Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force' do\nend\n\nmodules = %w[ PSReadline ]\nmodules.each do |mod|\n  powershell_script \"Install-Module #{mod} -Force\" do\n  end\nend\n\ndirectory 'C:\\Work\\Chef' do\n  recursive true\n  action :create\nend\n\nexecute 'chef generate repo example_repo -p' do\n  cwd 'C:\\Work\\Chef'\nend   bootstrap.ps1   # Setup my execution policy for both the 64 bit and 32 bit shells\nset-executionpolicy remotesigned\nstart-job -runas32 {set-executionpolicy remotesigned} | receive-job -wait\n# Install fixed version of ChefDK \ninvoke-restmethod 'https://omnitruck.chef.io/install.ps1' | iex\ninstall-project chefdk -verbose -version 1.1.16\n# Install Chocolatey\ninvoke-expression ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\nchoco feature enable -n allowGlobalConfirmation\n# Get a basic setup recipe\nInvoke-RestMethod -UseBasicParsing 'https://gist.githubusercontent.com/karstenmueller/0c2257684b8e6a44bac9526c52074e18/raw/a150048b7ffbfe202f90fdce446b8095b3e7858c/basic.rb' | out-file -encoding ascii -filepath c:/basic.rb\n# We dont need any Windows 10 Apps\nGet-AppxPackage | Remove-AppxPackage 2>&1>$null\n# Use Chef Apply to setup \nchef-apply c:/basic.rb\nwrite-host \"executed chef recipe c:/basic.rb\"",
            "title": "Chef environment by Karsten M\u00fcller"
        },
        {
            "location": "/DevOps/Terraform/",
            "text": "General info\n\n\n\n\nMostly from \nBWITS/terraform-best-practices\n.\n\n\n\n\nAlways Run terraform command with var-file\n\n\n$ cat config/dev.tfvars\n\nname = \"dev-stack\"\ns3_terraform_bucket = \"dev-stack-terraform\"\ntag_team_name = \"hello-world\"\n\n$ terraform plan -var-file=config/dev.tfvars\n\n\n\n\nWith \nvar-file\n, you can easily manage environment (dev/stag/uat/prod) variables.\n\n\nWith \nvar-file\n, you avoid to run terraform with long list of key-value pairs ( \n-var foo=bar\n )\n\n\nManage s3 backend for tfstate files\n\n\nTerraform doesn't support \nInterpolate variables in terraform backend config\n, normally you write a seperate script to define s3 backend bucket name for different environments, but I recommend to hard code it directly as below\n\n\nAdd below codes in terraform configuration files.\n\n\n$ cat main.tf\n\nterraform {\n  backend \"s3\" {\n    bucket = \"terraform-state\"\n    key    = \"terraform.tfstate\"\n    region = \"eu-central-1\"\n\n    encrypt        = \"true\"\n    dynamodb_table = \"terraform-tf-state-lock\"\n\n    lifecycle {\n      prevent_destroy = true\n    }\n  }\n}\n\n\n\n\nDefine backend variables for particular environment\n\n\n$ cat config/backend-dev.conf\nbucket  = \"<unique_bucke_name>-terraform-development\"\nkey     = \"development/service-1.tfstate\"\nencrypt = true\nregion  = \"ap-southeast-2\"\nkms_key_id = \"alias/terraform\"\ndynamodb_table = \"terraform-lock\"\n\n\n\n\n\n\nbucket - s3 bucket name, has to be globally unique.  \n\n\nkey - Set some meanful names for different services and applications, such as vpc.tfstate, application_name.tfstate, etc  \n\n\ndynamodb_table - optional when you want to enable \nState Locking\n  \n\n\n\n\nAfter you set \nconfig/backend-dev.conf\n and \nconfig/dev.tfvars\n properly (for each environment). You can easily run terraform as below:\n\n\nenv=dev\nterraform get -update=true\nterraform init -backend-config=config/backend-${env}.conf\nterraform plan -var-file=config/${env}.tfvars\nterraform apply -var-file=config/${env}.tfvars\n\n\n\n\nRetrieves state meta data from a remote backend\n\n\nNormally we have several layers to manage terraform resources, such as network, database, application layers. After you create the basic network resources, such as vpc, security group, subnets, nat gateway in vpc stack. Your database layer and applications layer should always refer the resource from vpc layer directly via \nterraform_remote_state\n data srouce. \n\n\ndata \"terraform_remote_state\" \"vpc\" {\n  backend = \"s3\"\n  config{\n    bucket = \"${var.s3_terraform_bucket}\"\n    key = \"${var.environment}/vpc.tfstate\"\n    region=\"${var.aws_region}\"\n  }\n}\n\n# Retrieves the vpc_id and subnet_ids directly from remote backend state files.\nresource \"aws_xx_xxxx\" \"main\" {\n  # ...\n  subnet_ids = \"${split(\",\", data.terraform_remote_state.vpc.data_subnets)}\"\n  vpc_id     = \"${data.terraform_remote_state.vpc.vpc_id}\"\n}\n\n\n\n\nUse share modules\n\n\nManage terraform resource with shared modules, this will save a lot of coding time. \n\n\nFor detail, you can start from below links: \n\n\n\n\nTerraform module usage\n\n\nTerraform module registry\n\n\nTerraform AWS modules\n\n\n\n\n\n\nterraform modules don't support \ncount\n parameter currently. You can follow up this ticket for updates: https://github.com/hashicorp/terraform/issues/953\n\n\n\n\nIsolate environment\n\n\nSometimes, developers like to create a security group and share it to all non-prod (dev/qa) environments. Don't do that, create resources with different name for each environment and each resource.\n\n\nvariable \"application\" {\n  description = \"application name\"\n  default = \"\"\n}\n\nvariable \"environment\" {\n  description = \"environment name\"\n  default = \"\"\n}\n\nresource \"<any_resource>\" {\n  name = \"${var.application}-${var.environment}-<resource_name>\"\n  ...\n}\n\n\n\n\nWth that, you will easily define the resource with meaningful and unique name, and you can build more same application stack for different developers without change a lot. For example, you update the environment to dev1, dev2, etc.\n\n\nUse terraform import to include as more resources you can\n\n\nSometimes developers manually created resources directly. You need to mark these resource and use \nterraform import\n to include them in codes.\n\n\nterraform import\n\n\nAvoid hard code the resources\n\n\nA sample:\n\n\naccount_number=\u201c123456789012\"\naccount_alias=\"mycompany\"\n\n\n\n\nThe current aws account id or account alias can be input directly via data sources.\n\n\n# The attribute `${data.aws_caller_identity.current.account_id}` will be current account number. \ndata \"aws_caller_identity\" \"current\" {}\n\n# The attribue `${data.aws_iam_account_alias.current.account_alias}` will be current account alias\n# Tips: you can easly use this attribue to create terraform bucket with environment, project name, etc.\ndata \"aws_iam_account_alias\" \"current\" {}\n\n\n\n\nRefer: \nterraform data sources\n\n\nFormat terraform codes\n\n\nAlways run \nterraform fmt\n to format terraform configuration files and make them neatly.\n\n\nI used below codes in Travis CI pipeline (you can re-use it in any pipelines) to validate and format check the codes before you can merge it to master branch.\n\n\n  - find . -type f -name \"*.tf\" -exec dirname {} \\;|sort -u | while read m; do (terraform validate -check-variables=false \"$m\" && echo \"\u221a $m\") || exit 1 ; done\n  - if [ `terraform fmt | wc -c` -ne 0 ]; then echo \"Some terraform files need be formatted, run 'terraform fmt' to fix\"; exit 1; fi\n\n\n\nEnable version control on terraform state files bucket\n\n\nAlways set backend to s3 and enable version control on this bucket. \n\n\nIf you'd like to manage terraform state bucket as well, recommend to use this repostory I wrote \ntf_aws_tfstate_bucket\n to create the bucket and replica to other regions automatically. \n\n\nGenerate README for each module about input and output variables\n\n\nYou needn't manually manage \nUSAGE\n about input variables and outputs. \nterraform-docs\n can do this job automatically.\n\n\n$ brew install terraform-docs\n$ cd terraform/modules/vpc\n$ terraform-docs md . > README.md\n\n\n\n\nFor details on how to run \nterraform-docs\n, check this repository: https://github.com/segmentio/terraform-docs\n\n\nThere is a simple sample for you to start \ntf_aws_acme\n, the README is generatd by \nterraform-docs\n\n\nUpdate terraform version\n\n\nHashicorp doesn't have a good qa/build/release process for their software and does not follow semantic versioning rules.\n\n\nFor example, \nterraform init\n isn't compatible between 0.9 and 0.8. Now they are going to split providers and use \"init\" to install providers as plugin in coming version 0.10\n\n\nSo recommend to keep updating to latest terraform version\n\n\nRun terraform from docker container\n\n\nTerraform releases official docker containers that you can easily control which version you can run.\n\n\nRecommend to run terraform docker container, when you set your build job in CI/CD pipeline.\n\n\nTERRAFORM_IMAGE=hashicorp/terraform:0.9.8\nTERRAFORM_CMD=\"docker run -ti --rm -w /app -v ${HOME}/.aws:/root/.aws -v ${HOME}/.ssh:/root/.ssh -v `pwd`:/app $TERRAFORM_IMAGE\"\n\n\n\n\nTroubleshooting with messy output\n\n\nSometime, you applied the changes several times, the plan output always prompts there are some changes, essepecially in iam and s3 policy.  It is hard to troubleshooting the problem with messy json output in one line.\n\n\nWith the tool \nterraform-landscape\n, it improves Terraform plan output to be easier to read and understand, you can easily find out where is the problem. For details, please go through the project at https://github.com/coinbase/terraform-landscape\n\n\nterraform plan -var-file=${env}/${env}.tfvars -input=false -out=plan -lock=false |tee report\ngem install terraform_landscape\nlandscape < report\n\n\n\nSome updates for terraform 0.10.x\n\n\nAfter Hashicorp splits terraform providers out of terraform core binary from v0.10.x, you will see errors to complain aws, template, terraform provider version are not installed when run \nterraform init\n\n\n* provider.aws: no suitable version installed\n  version requirements: \"~> 1.0\"\n\n\n\n\nPlease add below codes to \nmain.tf\n\n\nprovider \"aws\" {\n  version = \"~> 1.0\"\n  region  = \"${var.region}\"\n}\n\nprovider \"template\" {\n  version = \"~> 1.0\"\n}\n\nprovider \"terraform\" {\n  version = \"~> 1.0\"\n}\n\n\n\n\nUseful documents you should read\n\n\nterraform tips & tricks: loops, if-statements, and gotchas",
            "title": "Terraform"
        },
        {
            "location": "/DevOps/Terraform/#general-info",
            "text": "Mostly from  BWITS/terraform-best-practices .",
            "title": "General info"
        },
        {
            "location": "/DevOps/Terraform/#always-run-terraform-command-with-var-file",
            "text": "$ cat config/dev.tfvars\n\nname = \"dev-stack\"\ns3_terraform_bucket = \"dev-stack-terraform\"\ntag_team_name = \"hello-world\"\n\n$ terraform plan -var-file=config/dev.tfvars  With  var-file , you can easily manage environment (dev/stag/uat/prod) variables.  With  var-file , you avoid to run terraform with long list of key-value pairs (  -var foo=bar  )",
            "title": "Always Run terraform command with var-file"
        },
        {
            "location": "/DevOps/Terraform/#manage-s3-backend-for-tfstate-files",
            "text": "Terraform doesn't support  Interpolate variables in terraform backend config , normally you write a seperate script to define s3 backend bucket name for different environments, but I recommend to hard code it directly as below  Add below codes in terraform configuration files.  $ cat main.tf\n\nterraform {\n  backend \"s3\" {\n    bucket = \"terraform-state\"\n    key    = \"terraform.tfstate\"\n    region = \"eu-central-1\"\n\n    encrypt        = \"true\"\n    dynamodb_table = \"terraform-tf-state-lock\"\n\n    lifecycle {\n      prevent_destroy = true\n    }\n  }\n}  Define backend variables for particular environment  $ cat config/backend-dev.conf\nbucket  = \"<unique_bucke_name>-terraform-development\"\nkey     = \"development/service-1.tfstate\"\nencrypt = true\nregion  = \"ap-southeast-2\"\nkms_key_id = \"alias/terraform\"\ndynamodb_table = \"terraform-lock\"   bucket - s3 bucket name, has to be globally unique.    key - Set some meanful names for different services and applications, such as vpc.tfstate, application_name.tfstate, etc    dynamodb_table - optional when you want to enable  State Locking      After you set  config/backend-dev.conf  and  config/dev.tfvars  properly (for each environment). You can easily run terraform as below:  env=dev\nterraform get -update=true\nterraform init -backend-config=config/backend-${env}.conf\nterraform plan -var-file=config/${env}.tfvars\nterraform apply -var-file=config/${env}.tfvars",
            "title": "Manage s3 backend for tfstate files"
        },
        {
            "location": "/DevOps/Terraform/#retrieves-state-meta-data-from-a-remote-backend",
            "text": "Normally we have several layers to manage terraform resources, such as network, database, application layers. After you create the basic network resources, such as vpc, security group, subnets, nat gateway in vpc stack. Your database layer and applications layer should always refer the resource from vpc layer directly via  terraform_remote_state  data srouce.   data \"terraform_remote_state\" \"vpc\" {\n  backend = \"s3\"\n  config{\n    bucket = \"${var.s3_terraform_bucket}\"\n    key = \"${var.environment}/vpc.tfstate\"\n    region=\"${var.aws_region}\"\n  }\n}\n\n# Retrieves the vpc_id and subnet_ids directly from remote backend state files.\nresource \"aws_xx_xxxx\" \"main\" {\n  # ...\n  subnet_ids = \"${split(\",\", data.terraform_remote_state.vpc.data_subnets)}\"\n  vpc_id     = \"${data.terraform_remote_state.vpc.vpc_id}\"\n}",
            "title": "Retrieves state meta data from a remote backend"
        },
        {
            "location": "/DevOps/Terraform/#use-share-modules",
            "text": "Manage terraform resource with shared modules, this will save a lot of coding time.   For detail, you can start from below links:    Terraform module usage  Terraform module registry  Terraform AWS modules    terraform modules don't support  count  parameter currently. You can follow up this ticket for updates: https://github.com/hashicorp/terraform/issues/953",
            "title": "Use share modules"
        },
        {
            "location": "/DevOps/Terraform/#isolate-environment",
            "text": "Sometimes, developers like to create a security group and share it to all non-prod (dev/qa) environments. Don't do that, create resources with different name for each environment and each resource.  variable \"application\" {\n  description = \"application name\"\n  default = \"\"\n}\n\nvariable \"environment\" {\n  description = \"environment name\"\n  default = \"\"\n}\n\nresource \"<any_resource>\" {\n  name = \"${var.application}-${var.environment}-<resource_name>\"\n  ...\n}  Wth that, you will easily define the resource with meaningful and unique name, and you can build more same application stack for different developers without change a lot. For example, you update the environment to dev1, dev2, etc.",
            "title": "Isolate environment"
        },
        {
            "location": "/DevOps/Terraform/#use-terraform-import-to-include-as-more-resources-you-can",
            "text": "Sometimes developers manually created resources directly. You need to mark these resource and use  terraform import  to include them in codes.  terraform import",
            "title": "Use terraform import to include as more resources you can"
        },
        {
            "location": "/DevOps/Terraform/#avoid-hard-code-the-resources",
            "text": "A sample:  account_number=\u201c123456789012\"\naccount_alias=\"mycompany\"  The current aws account id or account alias can be input directly via data sources.  # The attribute `${data.aws_caller_identity.current.account_id}` will be current account number. \ndata \"aws_caller_identity\" \"current\" {}\n\n# The attribue `${data.aws_iam_account_alias.current.account_alias}` will be current account alias\n# Tips: you can easly use this attribue to create terraform bucket with environment, project name, etc.\ndata \"aws_iam_account_alias\" \"current\" {}  Refer:  terraform data sources",
            "title": "Avoid hard code the resources"
        },
        {
            "location": "/DevOps/Terraform/#format-terraform-codes",
            "text": "Always run  terraform fmt  to format terraform configuration files and make them neatly.  I used below codes in Travis CI pipeline (you can re-use it in any pipelines) to validate and format check the codes before you can merge it to master branch.    - find . -type f -name \"*.tf\" -exec dirname {} \\;|sort -u | while read m; do (terraform validate -check-variables=false \"$m\" && echo \"\u221a $m\") || exit 1 ; done\n  - if [ `terraform fmt | wc -c` -ne 0 ]; then echo \"Some terraform files need be formatted, run 'terraform fmt' to fix\"; exit 1; fi",
            "title": "Format terraform codes"
        },
        {
            "location": "/DevOps/Terraform/#enable-version-control-on-terraform-state-files-bucket",
            "text": "Always set backend to s3 and enable version control on this bucket.   If you'd like to manage terraform state bucket as well, recommend to use this repostory I wrote  tf_aws_tfstate_bucket  to create the bucket and replica to other regions automatically.",
            "title": "Enable version control on terraform state files bucket"
        },
        {
            "location": "/DevOps/Terraform/#generate-readme-for-each-module-about-input-and-output-variables",
            "text": "You needn't manually manage  USAGE  about input variables and outputs.  terraform-docs  can do this job automatically.  $ brew install terraform-docs\n$ cd terraform/modules/vpc\n$ terraform-docs md . > README.md  For details on how to run  terraform-docs , check this repository: https://github.com/segmentio/terraform-docs  There is a simple sample for you to start  tf_aws_acme , the README is generatd by  terraform-docs",
            "title": "Generate README for each module about input and output variables"
        },
        {
            "location": "/DevOps/Terraform/#update-terraform-version",
            "text": "Hashicorp doesn't have a good qa/build/release process for their software and does not follow semantic versioning rules.  For example,  terraform init  isn't compatible between 0.9 and 0.8. Now they are going to split providers and use \"init\" to install providers as plugin in coming version 0.10  So recommend to keep updating to latest terraform version",
            "title": "Update terraform version"
        },
        {
            "location": "/DevOps/Terraform/#run-terraform-from-docker-container",
            "text": "Terraform releases official docker containers that you can easily control which version you can run.  Recommend to run terraform docker container, when you set your build job in CI/CD pipeline.  TERRAFORM_IMAGE=hashicorp/terraform:0.9.8\nTERRAFORM_CMD=\"docker run -ti --rm -w /app -v ${HOME}/.aws:/root/.aws -v ${HOME}/.ssh:/root/.ssh -v `pwd`:/app $TERRAFORM_IMAGE\"",
            "title": "Run terraform from docker container"
        },
        {
            "location": "/DevOps/Terraform/#troubleshooting-with-messy-output",
            "text": "Sometime, you applied the changes several times, the plan output always prompts there are some changes, essepecially in iam and s3 policy.  It is hard to troubleshooting the problem with messy json output in one line.  With the tool  terraform-landscape , it improves Terraform plan output to be easier to read and understand, you can easily find out where is the problem. For details, please go through the project at https://github.com/coinbase/terraform-landscape  terraform plan -var-file=${env}/${env}.tfvars -input=false -out=plan -lock=false |tee report\ngem install terraform_landscape\nlandscape < report",
            "title": "Troubleshooting with messy output"
        },
        {
            "location": "/DevOps/Terraform/#some-updates-for-terraform-010x",
            "text": "After Hashicorp splits terraform providers out of terraform core binary from v0.10.x, you will see errors to complain aws, template, terraform provider version are not installed when run  terraform init  * provider.aws: no suitable version installed\n  version requirements: \"~> 1.0\"  Please add below codes to  main.tf  provider \"aws\" {\n  version = \"~> 1.0\"\n  region  = \"${var.region}\"\n}\n\nprovider \"template\" {\n  version = \"~> 1.0\"\n}\n\nprovider \"terraform\" {\n  version = \"~> 1.0\"\n}",
            "title": "Some updates for terraform 0.10.x"
        },
        {
            "location": "/DevOps/Terraform/#useful-documents-you-should-read",
            "text": "terraform tips & tricks: loops, if-statements, and gotchas",
            "title": "Useful documents you should read"
        },
        {
            "location": "/DevTools/Build/GCC/",
            "text": "Ubuntu: GCC-5 and GCC-6\n\n\n# It could be useful to remove old gcc alternatives\nsudo update-alternatives --remove-all gcc \nsudo update-alternatives --remove-all g++\n\n# Alternatives for GCC 5 and 6\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-6 100 --slave /usr/bin/g++ g++ /usr/bin/g++-6\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 50 --slave /usr/bin/g++ g++ /usr/bin/g++-5\nsudo update-alternatives --config gcc",
            "title": "GCC"
        },
        {
            "location": "/DevTools/Build/GCC/#ubuntu-gcc-5-and-gcc-6",
            "text": "# It could be useful to remove old gcc alternatives\nsudo update-alternatives --remove-all gcc \nsudo update-alternatives --remove-all g++\n\n# Alternatives for GCC 5 and 6\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-6 100 --slave /usr/bin/g++ g++ /usr/bin/g++-6\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 50 --slave /usr/bin/g++ g++ /usr/bin/g++-5\nsudo update-alternatives --config gcc",
            "title": "Ubuntu: GCC-5 and GCC-6"
        },
        {
            "location": "/DevTools/Build/Make/",
            "text": "Flags to configure\n\n\n/configure CFLAGS='-std=gnu89 -g -O2 -w' CXXFLAGS='-std=gnu++98 -g -O2 -w'",
            "title": "Make"
        },
        {
            "location": "/DevTools/Build/Make/#flags-to-configure",
            "text": "/configure CFLAGS='-std=gnu89 -g -O2 -w' CXXFLAGS='-std=gnu++98 -g -O2 -w'",
            "title": "Flags to configure"
        },
        {
            "location": "/DevTools/Version_Control/Git/",
            "text": "Dealing with line endings\n\n\n# Mac\ngit config --global core.autocrlf input\n# Linux\ngit config --global core.autocrlf input\n# Windows\ngit config --global core.autocrlf true\n\n\n\n\nNormalize all the line endings\n\n\n# Save your current files in Git, so that none of your work is lost.\ngit add . -u\ngit commit -m \"Saving files before refreshing line endings\"\n\n# Remove the index and force Git to rescan the working directory.\nrm .git/index\n\n# Rewrite the Git index to pick up all the new line endings.\ngit reset\n\n# Show the rewritten, normalized files.\ngit status\n\n# Add all your changed files back, and prepare them for a commit. This is your chance to inspect which files, if any, were unchanged.\ngit add -u\n# It is perfectly safe to see a lot of messages here that read\n# \"warning: CRLF will be replaced by LF in file.\"\n\n# Rewrite the .gitattributes file.\ngit add .gitattributes\n\n# Commit the changes to your repository.\ngit commit -m \"Normalize all the line endings\"\n\n\n\n\nClone\n\n\n# For new repos(-jN - number of simltaniuos jobs):\ngit clone --recursive-submodules -j4 https://github.com/keepbot/dotfiles\ngit clone --recursive-submodules https://github.com/keepbot/dotfiles\n\n# Ignore self signed ssl certificates\ngit -c http.sslVerify=false clone --recursive https://github.com/keepbot/dotfiles.git\n\n\n\n\nGlobal settings\n\n\ngit config --global user.name \"Your Name\"\ngit config --global user.email your@e-mail.com\n\n\n\n\nCreate new repository\n\n\nmkdir -p <path_to_repository>\ncd <path_to_repository>\ngit add .\ngit commit -m \"Initialization\"\ngit remote add origin https://github.com/username/<repository>.git\ngit push -u origin master\ngit checkout \n\n\n\n\nCommit\n\n\n# Addition of new files with automatic staging of deleted and modified files\ngit add .\ngit commit -a -m \"new commentary\"\ngit push -u origin master\n\n\n\n\nClean\n\n\ngit clean -d -x -f\n\n\n\n\nUpdate local reposytory from remote\n\n\n# Fentch + Merge\ngit pull\n# Fetch only\ngit fetch\n# Fetch changes from remote repository with modified local repository\ngit commit -a -m \"new commentary\"\ngit pull rebase\n# pull remote with overwrite local changes\ngit fetch --all\ngit reset --hard origin/master\n\n\n\n\nWorking with bunch of  repositories\n\n\n# Last commits\nfor d in `ls`; do cd $d; git log --pretty=format:\"%h - %an, %ar : %s\" -1; cd ..; done\n# Mass checkout\nfor d in `ls`; do cd $d; git checkout; cd ..; done\n\n\n\n\nCreating patches from commits:\n\n\n# The easiest version (you can specify number of commit to patch) \ngit format-patch -1 HEAD\n# Same as first, but create numbered files (00001-nnnnn)\ngit format-patch -n HEAD^\n# Simple cat ftom stdout, works fine on most of systems, but be carfull, if you have customized terminal (color tags, special symbols, etc.)\ngit show HEAD > path_to.patch\n\n\n\n\nApply patches:\n\n\ngit apply --stat 0001-Linux-agent-LVM-subagent-initial-implementation.patch\ngit apply --check 0001-Linux-agent-LVM-subagent-initial-implementation.patch\ngit am < 0001-Linux-agent-LVM-subagent-initial-implementation.patch\n\n\n\n\nAdd submodule\n\n\ngit submodule add -b <branch_name> <submodule_git_url> <local_path>\n\n\n\n\nChange branch for existing submodule\n\n\ncd <path_to_repo>\ngit config -f .gitmodules submodule.<local_path>.branch <branch_name>\n\n# Make sure that submodule is at the latest of branch (OR)\ncd <submodule_local_path>\ngit checkout -b branch --track origin/branch\ngit branch -u origin/master master\n\ncd <path_to_repo>\ngit add <submodule_local_path>\n\n\n\n\nUpdate submodules\n\n\ngit submodule update --recursive --remote\n\n\n\n\nDownload all submodules\n\n\ngit submodule update --init --recursive\n\n\n\n\nRemove submodule\n\n\n# 1. Delete the relevant section from the *.gitmodules* file.\n[submodule \"vendor\"]\n    path = vendor\n    url = git://github.com/some-user/some-repo.git\n# 2. Stage the *.gitmodules* changes with following command:\ngit add .gitmodules\n# 3.Delete the relevant section from *.git/config*:\n[submodule \"vendor\"]\n    url = git://github.com/some-user/some-repo.git\n# 4. Remove submodule folders from repo:\ngit rm --cached path/to/submodule\nrm -rf .git/modules/submodule_name\n# 6. Commit changes\n# 7. Delete files\nrm -rf path/to/submodule\n\n\n\n\nLogs\n\n\ngit log --pretty=format:\"%h - %an, %ar : %s\" -1\n\n\n\n\nProvide separate ssh-key\n\n\nvim ~/.ssh/config\n#------ add ------\nhost <full_server_hostname>\n HostName <full_server_hostname>\n IdentityFile ~/.ssh/<your_custom_ssh_key>\n User <git_user>\n#---- example ---\nhost github.com\n HostName github.com\n IdentityFile ~/.ssh/id_rsa_github\n User git\n#----------------\nsudo chmod 400 ~/.ssh/<your_custom_ssh_key>\nNow you can clone repo",
            "title": "Git"
        },
        {
            "location": "/DevTools/Version_Control/Git/#dealing-with-line-endings",
            "text": "# Mac\ngit config --global core.autocrlf input\n# Linux\ngit config --global core.autocrlf input\n# Windows\ngit config --global core.autocrlf true",
            "title": "Dealing with line endings"
        },
        {
            "location": "/DevTools/Version_Control/Git/#normalize-all-the-line-endings",
            "text": "# Save your current files in Git, so that none of your work is lost.\ngit add . -u\ngit commit -m \"Saving files before refreshing line endings\"\n\n# Remove the index and force Git to rescan the working directory.\nrm .git/index\n\n# Rewrite the Git index to pick up all the new line endings.\ngit reset\n\n# Show the rewritten, normalized files.\ngit status\n\n# Add all your changed files back, and prepare them for a commit. This is your chance to inspect which files, if any, were unchanged.\ngit add -u\n# It is perfectly safe to see a lot of messages here that read\n# \"warning: CRLF will be replaced by LF in file.\"\n\n# Rewrite the .gitattributes file.\ngit add .gitattributes\n\n# Commit the changes to your repository.\ngit commit -m \"Normalize all the line endings\"",
            "title": "Normalize all the line endings"
        },
        {
            "location": "/DevTools/Version_Control/Git/#clone",
            "text": "# For new repos(-jN - number of simltaniuos jobs):\ngit clone --recursive-submodules -j4 https://github.com/keepbot/dotfiles\ngit clone --recursive-submodules https://github.com/keepbot/dotfiles\n\n# Ignore self signed ssl certificates\ngit -c http.sslVerify=false clone --recursive https://github.com/keepbot/dotfiles.git",
            "title": "Clone"
        },
        {
            "location": "/DevTools/Version_Control/Git/#global-settings",
            "text": "git config --global user.name \"Your Name\"\ngit config --global user.email your@e-mail.com",
            "title": "Global settings"
        },
        {
            "location": "/DevTools/Version_Control/Git/#create-new-repository",
            "text": "mkdir -p <path_to_repository>\ncd <path_to_repository>\ngit add .\ngit commit -m \"Initialization\"\ngit remote add origin https://github.com/username/<repository>.git\ngit push -u origin master\ngit checkout",
            "title": "Create new repository"
        },
        {
            "location": "/DevTools/Version_Control/Git/#commit",
            "text": "# Addition of new files with automatic staging of deleted and modified files\ngit add .\ngit commit -a -m \"new commentary\"\ngit push -u origin master",
            "title": "Commit"
        },
        {
            "location": "/DevTools/Version_Control/Git/#clean",
            "text": "git clean -d -x -f",
            "title": "Clean"
        },
        {
            "location": "/DevTools/Version_Control/Git/#update-local-reposytory-from-remote",
            "text": "# Fentch + Merge\ngit pull\n# Fetch only\ngit fetch\n# Fetch changes from remote repository with modified local repository\ngit commit -a -m \"new commentary\"\ngit pull rebase\n# pull remote with overwrite local changes\ngit fetch --all\ngit reset --hard origin/master",
            "title": "Update local reposytory from remote"
        },
        {
            "location": "/DevTools/Version_Control/Git/#working-with-bunch-of-repositories",
            "text": "# Last commits\nfor d in `ls`; do cd $d; git log --pretty=format:\"%h - %an, %ar : %s\" -1; cd ..; done\n# Mass checkout\nfor d in `ls`; do cd $d; git checkout; cd ..; done",
            "title": "Working with bunch of  repositories"
        },
        {
            "location": "/DevTools/Version_Control/Git/#creating-patches-from-commits",
            "text": "# The easiest version (you can specify number of commit to patch) \ngit format-patch -1 HEAD\n# Same as first, but create numbered files (00001-nnnnn)\ngit format-patch -n HEAD^\n# Simple cat ftom stdout, works fine on most of systems, but be carfull, if you have customized terminal (color tags, special symbols, etc.)\ngit show HEAD > path_to.patch",
            "title": "Creating patches from commits:"
        },
        {
            "location": "/DevTools/Version_Control/Git/#apply-patches",
            "text": "git apply --stat 0001-Linux-agent-LVM-subagent-initial-implementation.patch\ngit apply --check 0001-Linux-agent-LVM-subagent-initial-implementation.patch\ngit am < 0001-Linux-agent-LVM-subagent-initial-implementation.patch",
            "title": "Apply patches:"
        },
        {
            "location": "/DevTools/Version_Control/Git/#add-submodule",
            "text": "git submodule add -b <branch_name> <submodule_git_url> <local_path>",
            "title": "Add submodule"
        },
        {
            "location": "/DevTools/Version_Control/Git/#change-branch-for-existing-submodule",
            "text": "cd <path_to_repo>\ngit config -f .gitmodules submodule.<local_path>.branch <branch_name>\n\n# Make sure that submodule is at the latest of branch (OR)\ncd <submodule_local_path>\ngit checkout -b branch --track origin/branch\ngit branch -u origin/master master\n\ncd <path_to_repo>\ngit add <submodule_local_path>",
            "title": "Change branch for existing submodule"
        },
        {
            "location": "/DevTools/Version_Control/Git/#update-submodules",
            "text": "git submodule update --recursive --remote",
            "title": "Update submodules"
        },
        {
            "location": "/DevTools/Version_Control/Git/#download-all-submodules",
            "text": "git submodule update --init --recursive",
            "title": "Download all submodules"
        },
        {
            "location": "/DevTools/Version_Control/Git/#remove-submodule",
            "text": "# 1. Delete the relevant section from the *.gitmodules* file.\n[submodule \"vendor\"]\n    path = vendor\n    url = git://github.com/some-user/some-repo.git\n# 2. Stage the *.gitmodules* changes with following command:\ngit add .gitmodules\n# 3.Delete the relevant section from *.git/config*:\n[submodule \"vendor\"]\n    url = git://github.com/some-user/some-repo.git\n# 4. Remove submodule folders from repo:\ngit rm --cached path/to/submodule\nrm -rf .git/modules/submodule_name\n# 6. Commit changes\n# 7. Delete files\nrm -rf path/to/submodule",
            "title": "Remove submodule"
        },
        {
            "location": "/DevTools/Version_Control/Git/#logs",
            "text": "git log --pretty=format:\"%h - %an, %ar : %s\" -1",
            "title": "Logs"
        },
        {
            "location": "/DevTools/Version_Control/Git/#provide-separate-ssh-key",
            "text": "vim ~/.ssh/config\n#------ add ------\nhost <full_server_hostname>\n HostName <full_server_hostname>\n IdentityFile ~/.ssh/<your_custom_ssh_key>\n User <git_user>\n#---- example ---\nhost github.com\n HostName github.com\n IdentityFile ~/.ssh/id_rsa_github\n User git\n#----------------\nsudo chmod 400 ~/.ssh/<your_custom_ssh_key>\nNow you can clone repo",
            "title": "Provide separate ssh-key"
        },
        {
            "location": "/DevTools/Version_Control/GitHub/",
            "text": "Independent history catalogs of git repositories\n\n\n# Makes a bunch of history folders formatted by the next way: <repository>-<number_of_commit>-<commit_hash>\n# Check commit_list.end for mistakes, you need simple list of commits\ngit clone <repository_url> <repository>\ncd <repository> && git log --pretty=format:\"%h\" > ../commit_list && cd ..\ntac commit_list > commit_list.end \ni=1; for cid in `cat commit_list.end`; do cp -r <repository> <repository>-$i-$cid; cd <repository>-$i-$cid; git checkout $cid; cd ..; ((i=i+1)); done\n\n\n\n\nClone all user's repositories\n\n\n# Get complete list of user's repositories in JSON file\ncurl -s https://api.github.com/users/<username>/repos?per_page=200 > repo.list.json\npython -c \"import json,sys,os;file = open('repo.list.json' ,'r');obj = json.load(file);obj_size = len(obj);cmd = 'git clone  ';[os.system(cmd + obj[x]['clone_url']) for x in range(0, obj_size)];file.close()\"\n# And dont forget about \"space\"(%20, \" \") in cmd = 'git clone ', it's completely nessesary\n# Another way to clone up to 200 user's repos(just in shell): \ncurl -s https://api.github.com/users/keepbot/repos?per_page=200 | jq '.[] | .\"clone_url\"' | xargs -I '{}' git clone {}\n\n\n\n\nGenerate new key-pair in current folder`\n\n\nsh-keygen -t rsa -b 4096 -C \"email@domain\" -f deploy_key",
            "title": "GitHub"
        },
        {
            "location": "/DevTools/Version_Control/GitHub/#independent-history-catalogs-of-git-repositories",
            "text": "# Makes a bunch of history folders formatted by the next way: <repository>-<number_of_commit>-<commit_hash>\n# Check commit_list.end for mistakes, you need simple list of commits\ngit clone <repository_url> <repository>\ncd <repository> && git log --pretty=format:\"%h\" > ../commit_list && cd ..\ntac commit_list > commit_list.end \ni=1; for cid in `cat commit_list.end`; do cp -r <repository> <repository>-$i-$cid; cd <repository>-$i-$cid; git checkout $cid; cd ..; ((i=i+1)); done",
            "title": "Independent history catalogs of git repositories"
        },
        {
            "location": "/DevTools/Version_Control/GitHub/#clone-all-users-repositories",
            "text": "# Get complete list of user's repositories in JSON file\ncurl -s https://api.github.com/users/<username>/repos?per_page=200 > repo.list.json\npython -c \"import json,sys,os;file = open('repo.list.json' ,'r');obj = json.load(file);obj_size = len(obj);cmd = 'git clone  ';[os.system(cmd + obj[x]['clone_url']) for x in range(0, obj_size)];file.close()\"\n# And dont forget about \"space\"(%20, \" \") in cmd = 'git clone ', it's completely nessesary\n# Another way to clone up to 200 user's repos(just in shell): \ncurl -s https://api.github.com/users/keepbot/repos?per_page=200 | jq '.[] | .\"clone_url\"' | xargs -I '{}' git clone {}",
            "title": "Clone all user's repositories"
        },
        {
            "location": "/DevTools/Version_Control/GitHub/#generate-new-key-pair-in-current-folder",
            "text": "sh-keygen -t rsa -b 4096 -C \"email@domain\" -f deploy_key",
            "title": "Generate new key-pair in current folder`"
        },
        {
            "location": "/DevTools/Version_Control/Gitignore/",
            "text": "Clean up repository for new gitignore\n\n\ngit rm --cached `git ls-files -i --exclude-standard`\n\n\n\n\nAndroid development\n\n\n# Built application files\n*.apk\n*.ap_\n\n# Files for the ART/Dalvik VM\n*.dex\n\n# Java class files\n*.class\n\n# Generated files\nbin/\ngen/\nout/\n\n# Gradle files\n.gradle/\nbuild/\n\n# Local configuration file (sdk path, etc)\nlocal.properties\n\n# Log Files\n*.log\n\n# Android Studio Navigation editor temp files\n.navigation/\n\n# Android Studio captures folder\ncaptures/\n\n# Eclipse project files\n.classpath\n.project\n\n# Eclipse Metadata\n.metadata/\n\n# Proguard folder generated by Eclipse\nproguard/\n\n# Intellij| .idea - for all Android Studio environment\n*.iml\n.idea\n#.idea/workspace.xml\n#.idea/tasks.xml\n#.idea/libraries\n\n# Keystore files\n*.jks\n\n# External native build folder generated in Android Studio 2.2 and later\n.externalNativeBuild\n\n# NDK\nobj/\n\n# MacOS\n.DS_Store\n.DS_Store?\n\n# Windows\nehthumbs.db\nThumbs.db\n\n# Other files\n.Spotlight-V100\n.Trashes\n/*/out\n/*/*/build\n/*/*/production\n*.iws\n*.ipr\n*~\n*.swp",
            "title": "Gitignore"
        },
        {
            "location": "/DevTools/Version_Control/Gitignore/#clean-up-repository-for-new-gitignore",
            "text": "git rm --cached `git ls-files -i --exclude-standard`",
            "title": "Clean up repository for new gitignore"
        },
        {
            "location": "/DevTools/Version_Control/Gitignore/#android-development",
            "text": "# Built application files\n*.apk\n*.ap_\n\n# Files for the ART/Dalvik VM\n*.dex\n\n# Java class files\n*.class\n\n# Generated files\nbin/\ngen/\nout/\n\n# Gradle files\n.gradle/\nbuild/\n\n# Local configuration file (sdk path, etc)\nlocal.properties\n\n# Log Files\n*.log\n\n# Android Studio Navigation editor temp files\n.navigation/\n\n# Android Studio captures folder\ncaptures/\n\n# Eclipse project files\n.classpath\n.project\n\n# Eclipse Metadata\n.metadata/\n\n# Proguard folder generated by Eclipse\nproguard/\n\n# Intellij| .idea - for all Android Studio environment\n*.iml\n.idea\n#.idea/workspace.xml\n#.idea/tasks.xml\n#.idea/libraries\n\n# Keystore files\n*.jks\n\n# External native build folder generated in Android Studio 2.2 and later\n.externalNativeBuild\n\n# NDK\nobj/\n\n# MacOS\n.DS_Store\n.DS_Store?\n\n# Windows\nehthumbs.db\nThumbs.db\n\n# Other files\n.Spotlight-V100\n.Trashes\n/*/out\n/*/*/build\n/*/*/production\n*.iws\n*.ipr\n*~\n*.swp",
            "title": "Android development"
        },
        {
            "location": "/DevTools/Version_Control/Subversion/",
            "text": "Get local copy\n\n\nsvn checkout <url> <local_path>\n\n\n\n\nSave changes to repository\n\n\nsvn commit -m \"log messages\"\n\n\n\n\nLists directories\n\n\nsvn list\n\n\n\n\nAdd file to repository\n\n\nsvn add <filename>\n\n\n\n\nRemove file from repository\n\n\nsvn delete <url_to_file>\n\n\n\n\nDisplay the difference\n\n\nsvn diff <filename>\n\n\n\n\nStatus of your copy\n\n\nsvn status <local_path>\n\n\n\n\nDisplay log message\n\n\nsvn log <local_path>\n\n\n\n\nRename file or directory\n\n\nsvn move <old_filename> <new_filename>\n\n\n\n\nUpdate of your copy\n\n\nsvn update <local_path>",
            "title": "Subversion"
        },
        {
            "location": "/DevTools/Version_Control/Subversion/#get-local-copy",
            "text": "svn checkout <url> <local_path>",
            "title": "Get local copy"
        },
        {
            "location": "/DevTools/Version_Control/Subversion/#save-changes-to-repository",
            "text": "svn commit -m \"log messages\"",
            "title": "Save changes to repository"
        },
        {
            "location": "/DevTools/Version_Control/Subversion/#lists-directories",
            "text": "svn list",
            "title": "Lists directories"
        },
        {
            "location": "/DevTools/Version_Control/Subversion/#add-file-to-repository",
            "text": "svn add <filename>",
            "title": "Add file to repository"
        },
        {
            "location": "/DevTools/Version_Control/Subversion/#remove-file-from-repository",
            "text": "svn delete <url_to_file>",
            "title": "Remove file from repository"
        },
        {
            "location": "/DevTools/Version_Control/Subversion/#display-the-difference",
            "text": "svn diff <filename>",
            "title": "Display the difference"
        },
        {
            "location": "/DevTools/Version_Control/Subversion/#status-of-your-copy",
            "text": "svn status <local_path>",
            "title": "Status of your copy"
        },
        {
            "location": "/DevTools/Version_Control/Subversion/#display-log-message",
            "text": "svn log <local_path>",
            "title": "Display log message"
        },
        {
            "location": "/DevTools/Version_Control/Subversion/#rename-file-or-directory",
            "text": "svn move <old_filename> <new_filename>",
            "title": "Rename file or directory"
        },
        {
            "location": "/DevTools/Version_Control/Subversion/#update-of-your-copy",
            "text": "svn update <local_path>",
            "title": "Update of your copy"
        },
        {
            "location": "/OS/AIX/",
            "text": "Basic programs\n\n\nsh$ ftp ftp.software.ibm.com\n  Name> ftp\n  Password> your e-mail address\n  ftp> cd aix/freeSoftware/aixtoolbox/RPMS/ppc/wget\n  ftp> binary\n  ftp> get wget-1.9.1-1.aix5.1.ppc.rpm\n  ftp> quit\nsh$ rpm -hUv wget-1.9.1-1.aix5.1.ppc.rpm\nsh$ wget -r -nd ftp://ftp.software.ibm.com/aix/freeSoftware/aixtoolbox/ezinstall/ppc  \n\nsh$ ls\ngetapp-dev.sh       getgnome.base.sh    getkde3.all.sh\nXsession.kde        getbase.sh          getkde2.all.sh      getkde3.base.sh\nXsession.kde2       getdesktop.base.sh  getkde2.base.sh     getkde3.opt.sh\ngetgnome.apps.sh    getkde2.opt.sh      \n\nsh$ chmod +x get*.sh  \n\nsh$ cd base\nsh$ ls\nbash-3.2-1.aix5.2.ppc.rpm          rpm-3.0.5-52.aix5.3.ppc.rpm\nbzip2-1.0.5-3.aix5.3.ppc.rpm       rpm-build-3.0.5-52.aix5.3.ppc.rpm\ngettext-0.10.40-8.aix5.2.ppc.rpm   rpm-devel-3.0.5-52.aix5.3.ppc.rpm\ngzip-1.2.4a-10.aix5.2.ppc.rpm      tar-1.14-2.aix5.1.ppc.rpm\ninfo-4.6-1.aix5.1.ppc.rpm          unzip-5.51-1.aix5.1.ppc.rpm\npatch-2.5.4-4.aix4.3.ppc.rpm       \npopt-1.7-2.aix5.1.ppc.rpm\n\nsh$ rpm -hUv unzip-5.51-1.aix5.1.ppc.rpm\nsh$ rpm -hUv zip-2.3-3.aix4.3.ppc.rpm\nsh$ rpm -hUv bash-3.2-1.aix5.2.ppc.rpm\n\nsh$ bash\nbash-3.2# \n\n\n\n\nManagement\n\n\n# Exit from basic VIOS console to common AIX ksh\noem_setup_env\n# Adminitration and configuration console\nsmit\n\n#If you want to use bash as a login shell, you first have to add it to the\n#list of shells in /etc/security/login.cfg. \n#Then use `chsh` to change your individual setting.\n\n\n\n\nSoftware installation\n\n\ncd <path_to_package>\ninutoc .\ninstallp -aXY -d<path_to_package> all\n# Check if package is installed or not:\nlslpp -L <package_name>\n\n\n\n\nMirroring rootvg\n\n\nextendvg rootvg hdisk1\nmirrorvg rootvg\nbootlist -m normal hdisk0 hdisk1 \nbosboot -ad hdisk0\nbosboot -ad hdisk1\n# Checking\nbootlist -o -m normal\n\n\n\n\nNetwork\n\n\nShared Ethernet adapter coming soon\n\n\n\n\nHardware\n\n\n# Refresh hardware configuration(aix and vios respectively):\ncfgmgr\ncfgdev\n# Rename hard drive:\nrendev -l <old_name> -n <new_name>\nrendev -l hdisk3 -n hdisk33\n# Enable PVID:\nchdev -l hdiskX -a pv=yes\n# Change reserve policy to hard drive\nchdev -l hdiskX -a reserve_policy=no_reserve\n# Clear the owning volume manager from a disk\nchpv -C hdiskX\n\n\n\n\nVirtual devices\n\n\n# Checking all virtual mappings to particular vhost:\nlsmap -vadapter vhost\n# Make a virtual hard drive for particular vhost:\n# -f - flag to forcing device creation if you're making shared hard drive\nmkvdev [-f] -vdev hdiskX -vadapter vhostX -dev <virtual_device_name>\n# Make a virtual cd-rom device for particular vhost:\nmkvdev -fbo -vadapter vhostX -dev <virtual_device_name>\n\n\n\n\nZabbix agent\n\n\n# Dependencies:\nrpm -ivh ftp://www.oss4aix.org/latest/aix61/gettext-0.10.40-8.aix5.2.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/expat-2.1.0-1.aix5.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/libgcc-4.7.2-1.aix6.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/libffi-3.0.11-2.aix5.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/glib2-2.30.3-1.aix5.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/libiconv-1.14-2.aix5.1.ppc.rpm\n\n# Main\nmkgroup zabbix\nuseradd -g zabbix zabbix\n\nmkdir /var/run/zabbix\ntouch /var/run/zabbix/zabbix_agentd.pid\nmkdir /var/log/zabbix\ntouch /var/log/zabbix/zabbix_agentd.log\n\nchown -R zabbix:zabbix /var/log/zabbix\nchown -R zabbix:zabbix /var/run/zabbix\nchown zabbix:zabbix /etc/zabbix_agentd.conf\n\n/usr/sbin/zabbix_agentd --config /etc/zabbix_agentd.conf\n\nvi /etc/inittab\nzabagent:2:once:/usr/sbin/zabbix_agentd --config /etc/zabbix_agentd.conf\n\n\n\n\nUpdate BOS\n\n\n# Download SP and TL update\n# Unpack update archive to NFS folder\n# Mount NFS folder on target server\nmount <nfs_server_name>:/home/padmin /mnt/nfs\n\n# Remove old standby BOS instance\n# R - remove, p - preview (do not perform actual run)\nmultibos -Rp\nmultibos -R\n\n# Create new stanby BOS instance\n# X - expand file system if needed, s - setup, p - preview\nmultibos -Xsp\nmultibos -Xs \n\n# Check bootorder\nbootlist -m normal -o\n\n# Checking newly created BOS\nmultibos -S\nMULTIBOS> oslevel -s\nMULTIBOS> exit\n\n# Update of newly created stanby BOS\n# X - expand file system if needed, c - custamized update,  p - preview, l - location\nmultibos -Xacp -l /mnt/nfs/update/\nmultibos -Xac -l /mnt/nfs/update/\n\n# Checking updated BOS\nmultibos -S\nMULTIBOS> oslevel -s\nMULTIBOS> exit\n\n# Umount NFS folder\numount /mnt/nfs/\n\n# Making updated stanby BOS bootable in the first place\nmultibos -B\n\n# Reeboot and check\nshutdown -Fr\nbootinfo -v\noslevel -s\n\n# If we don't like \"bos_\" prefix\n# Remove old BOS: \nmultibos -R\n# Making new clean BOS: \nmultibos -sX\n# Making new clean BOS bootable in the first palce: \nmultibos -B\n# Reboot: \nshutdown -Fr\n# Checking that we booted in non-prefixed BOS: \nbootinfo -v\n# Checking that everything is updated: \noslevel -s\n#Removing preficex BOS: \nmultibos -R",
            "title": "AIX"
        },
        {
            "location": "/OS/AIX/#basic-programs",
            "text": "sh$ ftp ftp.software.ibm.com\n  Name> ftp\n  Password> your e-mail address\n  ftp> cd aix/freeSoftware/aixtoolbox/RPMS/ppc/wget\n  ftp> binary\n  ftp> get wget-1.9.1-1.aix5.1.ppc.rpm\n  ftp> quit\nsh$ rpm -hUv wget-1.9.1-1.aix5.1.ppc.rpm\nsh$ wget -r -nd ftp://ftp.software.ibm.com/aix/freeSoftware/aixtoolbox/ezinstall/ppc  \n\nsh$ ls\ngetapp-dev.sh       getgnome.base.sh    getkde3.all.sh\nXsession.kde        getbase.sh          getkde2.all.sh      getkde3.base.sh\nXsession.kde2       getdesktop.base.sh  getkde2.base.sh     getkde3.opt.sh\ngetgnome.apps.sh    getkde2.opt.sh      \n\nsh$ chmod +x get*.sh  \n\nsh$ cd base\nsh$ ls\nbash-3.2-1.aix5.2.ppc.rpm          rpm-3.0.5-52.aix5.3.ppc.rpm\nbzip2-1.0.5-3.aix5.3.ppc.rpm       rpm-build-3.0.5-52.aix5.3.ppc.rpm\ngettext-0.10.40-8.aix5.2.ppc.rpm   rpm-devel-3.0.5-52.aix5.3.ppc.rpm\ngzip-1.2.4a-10.aix5.2.ppc.rpm      tar-1.14-2.aix5.1.ppc.rpm\ninfo-4.6-1.aix5.1.ppc.rpm          unzip-5.51-1.aix5.1.ppc.rpm\npatch-2.5.4-4.aix4.3.ppc.rpm       \npopt-1.7-2.aix5.1.ppc.rpm\n\nsh$ rpm -hUv unzip-5.51-1.aix5.1.ppc.rpm\nsh$ rpm -hUv zip-2.3-3.aix4.3.ppc.rpm\nsh$ rpm -hUv bash-3.2-1.aix5.2.ppc.rpm\n\nsh$ bash\nbash-3.2#",
            "title": "Basic programs"
        },
        {
            "location": "/OS/AIX/#management",
            "text": "# Exit from basic VIOS console to common AIX ksh\noem_setup_env\n# Adminitration and configuration console\nsmit\n\n#If you want to use bash as a login shell, you first have to add it to the\n#list of shells in /etc/security/login.cfg. \n#Then use `chsh` to change your individual setting.",
            "title": "Management"
        },
        {
            "location": "/OS/AIX/#software-installation",
            "text": "cd <path_to_package>\ninutoc .\ninstallp -aXY -d<path_to_package> all\n# Check if package is installed or not:\nlslpp -L <package_name>",
            "title": "Software installation"
        },
        {
            "location": "/OS/AIX/#mirroring-rootvg",
            "text": "extendvg rootvg hdisk1\nmirrorvg rootvg\nbootlist -m normal hdisk0 hdisk1 \nbosboot -ad hdisk0\nbosboot -ad hdisk1\n# Checking\nbootlist -o -m normal",
            "title": "Mirroring rootvg"
        },
        {
            "location": "/OS/AIX/#network",
            "text": "Shared Ethernet adapter coming soon",
            "title": "Network"
        },
        {
            "location": "/OS/AIX/#hardware",
            "text": "# Refresh hardware configuration(aix and vios respectively):\ncfgmgr\ncfgdev\n# Rename hard drive:\nrendev -l <old_name> -n <new_name>\nrendev -l hdisk3 -n hdisk33\n# Enable PVID:\nchdev -l hdiskX -a pv=yes\n# Change reserve policy to hard drive\nchdev -l hdiskX -a reserve_policy=no_reserve\n# Clear the owning volume manager from a disk\nchpv -C hdiskX",
            "title": "Hardware"
        },
        {
            "location": "/OS/AIX/#virtual-devices",
            "text": "# Checking all virtual mappings to particular vhost:\nlsmap -vadapter vhost\n# Make a virtual hard drive for particular vhost:\n# -f - flag to forcing device creation if you're making shared hard drive\nmkvdev [-f] -vdev hdiskX -vadapter vhostX -dev <virtual_device_name>\n# Make a virtual cd-rom device for particular vhost:\nmkvdev -fbo -vadapter vhostX -dev <virtual_device_name>",
            "title": "Virtual devices"
        },
        {
            "location": "/OS/AIX/#zabbix-agent",
            "text": "# Dependencies:\nrpm -ivh ftp://www.oss4aix.org/latest/aix61/gettext-0.10.40-8.aix5.2.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/expat-2.1.0-1.aix5.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/libgcc-4.7.2-1.aix6.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/libffi-3.0.11-2.aix5.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/glib2-2.30.3-1.aix5.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/libiconv-1.14-2.aix5.1.ppc.rpm\n\n# Main\nmkgroup zabbix\nuseradd -g zabbix zabbix\n\nmkdir /var/run/zabbix\ntouch /var/run/zabbix/zabbix_agentd.pid\nmkdir /var/log/zabbix\ntouch /var/log/zabbix/zabbix_agentd.log\n\nchown -R zabbix:zabbix /var/log/zabbix\nchown -R zabbix:zabbix /var/run/zabbix\nchown zabbix:zabbix /etc/zabbix_agentd.conf\n\n/usr/sbin/zabbix_agentd --config /etc/zabbix_agentd.conf\n\nvi /etc/inittab\nzabagent:2:once:/usr/sbin/zabbix_agentd --config /etc/zabbix_agentd.conf",
            "title": "Zabbix agent"
        },
        {
            "location": "/OS/AIX/#update-bos",
            "text": "# Download SP and TL update\n# Unpack update archive to NFS folder\n# Mount NFS folder on target server\nmount <nfs_server_name>:/home/padmin /mnt/nfs\n\n# Remove old standby BOS instance\n# R - remove, p - preview (do not perform actual run)\nmultibos -Rp\nmultibos -R\n\n# Create new stanby BOS instance\n# X - expand file system if needed, s - setup, p - preview\nmultibos -Xsp\nmultibos -Xs \n\n# Check bootorder\nbootlist -m normal -o\n\n# Checking newly created BOS\nmultibos -S\nMULTIBOS> oslevel -s\nMULTIBOS> exit\n\n# Update of newly created stanby BOS\n# X - expand file system if needed, c - custamized update,  p - preview, l - location\nmultibos -Xacp -l /mnt/nfs/update/\nmultibos -Xac -l /mnt/nfs/update/\n\n# Checking updated BOS\nmultibos -S\nMULTIBOS> oslevel -s\nMULTIBOS> exit\n\n# Umount NFS folder\numount /mnt/nfs/\n\n# Making updated stanby BOS bootable in the first place\nmultibos -B\n\n# Reeboot and check\nshutdown -Fr\nbootinfo -v\noslevel -s\n\n# If we don't like \"bos_\" prefix\n# Remove old BOS: \nmultibos -R\n# Making new clean BOS: \nmultibos -sX\n# Making new clean BOS bootable in the first palce: \nmultibos -B\n# Reboot: \nshutdown -Fr\n# Checking that we booted in non-prefixed BOS: \nbootinfo -v\n# Checking that everything is updated: \noslevel -s\n#Removing preficex BOS: \nmultibos -R",
            "title": "Update BOS"
        },
        {
            "location": "/OS/Android/",
            "text": "Boot device into bootloader mode\n\n\nadb reboot bootloader\n\n\n\n\nFlash new bootloader\n\n\nfastboot flash bootloader bootloader-flounder-3.44.1.0123.img\nfastboot reboot-bootloader\n\n\n\n\nFlash full system\n\n\nfastboot flash boot boot.img\nfastboot flash cache cache.img\nfastboot flash recovery recovery.img\nfastboot flash system system.img\nfastboot flash vendor vendor.img",
            "title": "Android"
        },
        {
            "location": "/OS/Android/#boot-device-into-bootloader-mode",
            "text": "adb reboot bootloader",
            "title": "Boot device into bootloader mode"
        },
        {
            "location": "/OS/Android/#flash-new-bootloader",
            "text": "fastboot flash bootloader bootloader-flounder-3.44.1.0123.img\nfastboot reboot-bootloader",
            "title": "Flash new bootloader"
        },
        {
            "location": "/OS/Android/#flash-full-system",
            "text": "fastboot flash boot boot.img\nfastboot flash cache cache.img\nfastboot flash recovery recovery.img\nfastboot flash system system.img\nfastboot flash vendor vendor.img",
            "title": "Flash full system"
        },
        {
            "location": "/OS/FreeBSD/",
            "text": "Build own kernel\n\n\n# /usr/src/sys/i386/conf  - kernel config\ncd /usr/src\nmake buildkernel KERNCONF=MYKERNEL\nmake installkernel KERNCONF=MYKERNEL",
            "title": "FreeBSD"
        },
        {
            "location": "/OS/FreeBSD/#build-own-kernel",
            "text": "# /usr/src/sys/i386/conf  - kernel config\ncd /usr/src\nmake buildkernel KERNCONF=MYKERNEL\nmake installkernel KERNCONF=MYKERNEL",
            "title": "Build own kernel"
        },
        {
            "location": "/OS/Useful_UNIX_distros/",
            "text": "Useful UNIX distros\n\n\nAntix and MX\n\n\nMX-14 \"Symbiosis\"\n\nMX-14 is the current release of MX Linux, a special version of antiX developed in full collaboration with the MEPIS Community, using the best tools and talents from each distro. It is a midweight OS designed to combine an elegant and efficient desktop with simple configuration, high stability, solid performance and medium-sized footprint.\n\nRelying on the excellent upstream work by Linux, MX-14 deploys Xfce4 as Desktop Environment on top of a Debian Stable base; ongoing backports to the Community Repos keep it current. It also incorporates the independent and innovative development products smxi and inxi.\n\n\nAbout antiX\n\nantiX is a fast, lightweight and easy to install linux live CD distribution based on Debian Testing for Intel-AMD x86 compatible systems. antiX offers users the \"antiX Magic\" in an environment suitable for old computers. So don't throw away that old computer yet! The goal of antiX is to provide a light, but fully functional and flexible free operating system for both newcomers and experienced users of Linux. It should run on most computers, ranging from 64MB old PII 266 systems with pre-configured 128MB swap to the latest powerful boxes. 128MB RAM is recommended minimum for antiX. The installer needs minimum 2.2GB hard disk size. antiX can also be used as a fast-booting rescue cd. A special XFCE edition made in collaboration with the MEPIS Community called MX-14 \"Symbiosis\" is also available. \n\n\n\n\nCore Linux\n\n\nCore is the base system which provides only a command line interface and is therefore recommended for experienced users only. Command line tools are provided so that extensions can be added to create a system with a graphical desktop environment. Ideal for servers, appliances, and custom desktops. \n\n\n\n\nFAI\n\n\nWhat is FAI? Main Features:\n* A tool for automated unattended installation. Lazy system administrators like it. \n* Remote network installation of different Linux flavors \n* Easy-to-use centralized management system for your Linux deployment. \n* It's fast. It only takes a few minutes for a complete installation. \n* Scalable. FAI users manage their computer infrastructures starting from a few computers up to several thousands of machines. \n* Different hardware and different configuration requirements are easy to establish using FAI. You do not need to repeat information that is shared among several machines. \n* Using the FAI class concept, you can group a bunch of similar machines. \n* Installation targets: desktops, servers, notebooks, Beowulf cluster, rendering or web server farm, Linux laboratory or classroom. \n* Linux rollout, mass installation and automated server provisioning are additional topics of FAI. \n* FAI is lightweight. No special daemons are running, no database setup is needed. It's architecture independent, since it consists only of shell, Perl and Cfengine scripts. \n* Easy creation of customized unattended ISO \n* Besides initial installations, it is used for daily maintenance, and can set up chroot environments. \n* Compared to tools like kickstart or cobbler for Red Hat, autoyast for SUSE or Jumpstart for SUN Solaris, FAI is much more flexible. You can tune every small part of your configuration to your local needs using hooks. \n\n\n\n\nFrenzy\n\n\nFrenzy is a \u201csystem administrator portable instrument\u201d, LiveCD based on FreeBSD OS, wich allows the administrator to boot from it and get fully functional system with wide variety of software for tunning, testing and analyzing the network, testing computer hardware and much more. \n\n\n\n\nGParted\n\n\nGParted Live is a small bootable GNU/Linux distribution for x86 based computers.\nIt enables you to use all the features of the latest versions of the GParted application.\n\n\n\n\nKali\n\n\nThe Offensive Security Linux distributive. Successor of BackTrack\n\n\n\n\nKnoppix\n\n\nKNOPPIX is a bootable Live system on CD, DVD or USB flash drives, consisting of a representative collection of GNU/Linux software, automatic hardware detection, and support for many graphics cards, sound cards, SCSI and USB devices and other peripherals. KNOPPIX can be used as a productive Linux system for the desktop, educational CD, rescue system, or adapted and used as a platform for commercial software product demos. It is not necessary to install anything on a hard disk. Due to on-the-fly decompression, the CD can have up to 2 GB of executable software installed on it (over 9GB on the DVD \"Maxi\" edition). \n\n\n\n\nlevinux-master\n\n\nLevinux is a tiny Linux server based on QEMU that doesn't require an install or admin rights on the host PC. Great for learning and appliance projects.\n\n\n\n\nNetwork Security Toolkit\n\n\nWelcome to the Network Security Toolkit (NST). This bootable ISO live CD/DVD (NST Live) is based on Fedora. The toolkit was designed to provide easy access to best-of-breed Open Source Network Security Applications and should run on most x86/x86_64 platforms.\n\nThe main intent of developing this toolkit was to provide the security professional and network administrator with a comprehensive set of Open Source Network Security Tools. The majority of tools published in the article: Top 125 Security Tools by INSECURE.ORG are available in the toolkit. An advanced Web User Interface (WUI) is provided for system/network administration, navigation, automation, network monitoring, host geolocation, network analysis and configuration of many network and security applications found within the NST distribution. In the virtual world, NST can be used as a network security analysis validation and monitoring tool on enterprise virtual servers hosting virtual machines.\n\n\n\n\nPFSense\n\n\nThe pfSense project is a free network firewall distribution, based on the FreeBSD operating system with a custom kernel and including third party free software packages for additional functionality. pfSense software, with the help of the package system, is able to provide the same functionality or more of common commercial firewalls, without any of the artificial limitations. It has successfully replaced every big name commercial firewall you can imagine in numerous installations around the world, including Check Point, Cisco PIX, Cisco ASA, Juniper, Sonicwall, Netgear, Watchguard, Astaro, and more.\n\npfSense software includes a web interface for the configuration of all included components. There is no need for any UNIX knowledge, no need to use the command line for anything, and no need to ever manually edit any rule sets. Users familiar with commercial firewalls catch on to the web interface quickly, though there can be a learning curve for users not familiar with commercial-grade firewalls.\n\n\n\n\nPING (Partimage Is Not Ghost)\n\n\nPING is a live Linux ISO, based on the excellent Linux From Scratch (LFS) documentation. It can be burnt on a CD and booted, or integrated into a PXE / RIS environment. \nSeveral tools have been added and written, so to make this ISO the perfect choice to backup and restore whole partitions, an easy way. It sounds like Symantec Ghost(tm), but has even better features, and is totally free. \n\nFeatures include: \n\n\nProbably the best available Linux toolbox for rescuing a system; \nBackup and Restore partitions or files locally or to the network (MS Network Shared directory, NFS, FTP or SSHFS); \nBackup and Restore the BIOS data as well; \nEither burn a bootable CD / DVD, either integrate within a PXE / RIS environment; \nPossibility to Blank local admin's password; \nCreate your own restoration bootable DVD (see the Howto Documentation); \nPartition and Format a disk before installing Windows (so to make sure your unattended Windows installation will happen on the right partition); \n\nSpecific advantages PING brings you over DOS and Ghost : \nMost network cards automatically recognized by the Kernel (unlike DOS); \nMost CD/DVD readers automatically recognized by the Kernel (unlike DOS); \nYou don't have to run a Ghostcast server to receive images over the network; \nMore supported filesystems; \nYou can store an image on several CD/DVD (CD/DVD-spanning); \nYou can backup and restore BIOS settings too; \nMuch much smaller than WinPE / BartPE; \netc. \n\n\n\n\nPuppy Linux\n\n\nLinux is a free operating system, and Puppy Linux is a special build of Linux meant to make computing easy and fast.\n\nPuppy Linux enables you to save money while doing more work, even allowing you to do magic by recovering data from destroyed PCs or by removing malware from Windows. See these example articles: recovering files from Windows and safe Internet banking with Puppy Linux.\n\n\n\n\nSystemRescueCd\n\n\nSystemRescueCd is a Linux system rescue disk available as a bootable CD-ROM or USB stick for administrating or repairing your system and data after a crash. It aims to provide an easy way to carry out admin tasks on your computer, such as creating and editing the hard disk partitions. It comes with a lot of linux software such as system tools (parted, partimage, fstools, ...) and basic tools (editors, midnight commander, network tools). It can be used for both Linux and windows computers, and on desktops as well as servers. This rescue system requires no installation as it can be booted from a CD/DVD drive or USB stick, but it can be installed on the hard disk if you wish. The kernel supports all important file systems (ext2/ext3/ext4, reiserfs, btrfs, xfs, jfs, vfat, ntfs), as well as network filesystems (samba and nfs). \n\nBased of Gentoo and VERY useful for Gentoo installations especially for UEFI.\n\n\n\n\nTails\n\n\nTails is a live operating system, that you can start on almost any computer from a DVD, USB stick, or SD card. It aims at preserving your privacy and anonymity, and helps you to: \nuse the Internet anonymously and circumvent censorship;\nall connections to the Internet are forced to go through the Tor network; \nleave no trace on the computer you are using unless you ask it explicitly; \nuse state-of-the-art cryptographic tools to encrypt your files, emails and instant messaging. \n\nPowered by TOR",
            "title": "Useful UNIX distros"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#useful-unix-distros",
            "text": "",
            "title": "Useful UNIX distros"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#antix-and-mx",
            "text": "MX-14 \"Symbiosis\"\n\nMX-14 is the current release of MX Linux, a special version of antiX developed in full collaboration with the MEPIS Community, using the best tools and talents from each distro. It is a midweight OS designed to combine an elegant and efficient desktop with simple configuration, high stability, solid performance and medium-sized footprint.\n\nRelying on the excellent upstream work by Linux, MX-14 deploys Xfce4 as Desktop Environment on top of a Debian Stable base; ongoing backports to the Community Repos keep it current. It also incorporates the independent and innovative development products smxi and inxi.\n\n\nAbout antiX\n\nantiX is a fast, lightweight and easy to install linux live CD distribution based on Debian Testing for Intel-AMD x86 compatible systems. antiX offers users the \"antiX Magic\" in an environment suitable for old computers. So don't throw away that old computer yet! The goal of antiX is to provide a light, but fully functional and flexible free operating system for both newcomers and experienced users of Linux. It should run on most computers, ranging from 64MB old PII 266 systems with pre-configured 128MB swap to the latest powerful boxes. 128MB RAM is recommended minimum for antiX. The installer needs minimum 2.2GB hard disk size. antiX can also be used as a fast-booting rescue cd. A special XFCE edition made in collaboration with the MEPIS Community called MX-14 \"Symbiosis\" is also available.",
            "title": "Antix and MX"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#core-linux",
            "text": "Core is the base system which provides only a command line interface and is therefore recommended for experienced users only. Command line tools are provided so that extensions can be added to create a system with a graphical desktop environment. Ideal for servers, appliances, and custom desktops.",
            "title": "Core Linux"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#fai",
            "text": "What is FAI? Main Features:\n* A tool for automated unattended installation. Lazy system administrators like it. \n* Remote network installation of different Linux flavors \n* Easy-to-use centralized management system for your Linux deployment. \n* It's fast. It only takes a few minutes for a complete installation. \n* Scalable. FAI users manage their computer infrastructures starting from a few computers up to several thousands of machines. \n* Different hardware and different configuration requirements are easy to establish using FAI. You do not need to repeat information that is shared among several machines. \n* Using the FAI class concept, you can group a bunch of similar machines. \n* Installation targets: desktops, servers, notebooks, Beowulf cluster, rendering or web server farm, Linux laboratory or classroom. \n* Linux rollout, mass installation and automated server provisioning are additional topics of FAI. \n* FAI is lightweight. No special daemons are running, no database setup is needed. It's architecture independent, since it consists only of shell, Perl and Cfengine scripts. \n* Easy creation of customized unattended ISO \n* Besides initial installations, it is used for daily maintenance, and can set up chroot environments. \n* Compared to tools like kickstart or cobbler for Red Hat, autoyast for SUSE or Jumpstart for SUN Solaris, FAI is much more flexible. You can tune every small part of your configuration to your local needs using hooks.",
            "title": "FAI"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#frenzy",
            "text": "Frenzy is a \u201csystem administrator portable instrument\u201d, LiveCD based on FreeBSD OS, wich allows the administrator to boot from it and get fully functional system with wide variety of software for tunning, testing and analyzing the network, testing computer hardware and much more.",
            "title": "Frenzy"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#gparted",
            "text": "GParted Live is a small bootable GNU/Linux distribution for x86 based computers.\nIt enables you to use all the features of the latest versions of the GParted application.",
            "title": "GParted"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#kali",
            "text": "The Offensive Security Linux distributive. Successor of BackTrack",
            "title": "Kali"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#knoppix",
            "text": "KNOPPIX is a bootable Live system on CD, DVD or USB flash drives, consisting of a representative collection of GNU/Linux software, automatic hardware detection, and support for many graphics cards, sound cards, SCSI and USB devices and other peripherals. KNOPPIX can be used as a productive Linux system for the desktop, educational CD, rescue system, or adapted and used as a platform for commercial software product demos. It is not necessary to install anything on a hard disk. Due to on-the-fly decompression, the CD can have up to 2 GB of executable software installed on it (over 9GB on the DVD \"Maxi\" edition).",
            "title": "Knoppix"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#levinux-master",
            "text": "Levinux is a tiny Linux server based on QEMU that doesn't require an install or admin rights on the host PC. Great for learning and appliance projects.",
            "title": "levinux-master"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#network-security-toolkit",
            "text": "Welcome to the Network Security Toolkit (NST). This bootable ISO live CD/DVD (NST Live) is based on Fedora. The toolkit was designed to provide easy access to best-of-breed Open Source Network Security Applications and should run on most x86/x86_64 platforms.\n\nThe main intent of developing this toolkit was to provide the security professional and network administrator with a comprehensive set of Open Source Network Security Tools. The majority of tools published in the article: Top 125 Security Tools by INSECURE.ORG are available in the toolkit. An advanced Web User Interface (WUI) is provided for system/network administration, navigation, automation, network monitoring, host geolocation, network analysis and configuration of many network and security applications found within the NST distribution. In the virtual world, NST can be used as a network security analysis validation and monitoring tool on enterprise virtual servers hosting virtual machines.",
            "title": "Network Security Toolkit"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#pfsense",
            "text": "The pfSense project is a free network firewall distribution, based on the FreeBSD operating system with a custom kernel and including third party free software packages for additional functionality. pfSense software, with the help of the package system, is able to provide the same functionality or more of common commercial firewalls, without any of the artificial limitations. It has successfully replaced every big name commercial firewall you can imagine in numerous installations around the world, including Check Point, Cisco PIX, Cisco ASA, Juniper, Sonicwall, Netgear, Watchguard, Astaro, and more.\n\npfSense software includes a web interface for the configuration of all included components. There is no need for any UNIX knowledge, no need to use the command line for anything, and no need to ever manually edit any rule sets. Users familiar with commercial firewalls catch on to the web interface quickly, though there can be a learning curve for users not familiar with commercial-grade firewalls.",
            "title": "PFSense"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#ping-partimage-is-not-ghost",
            "text": "PING is a live Linux ISO, based on the excellent Linux From Scratch (LFS) documentation. It can be burnt on a CD and booted, or integrated into a PXE / RIS environment. \nSeveral tools have been added and written, so to make this ISO the perfect choice to backup and restore whole partitions, an easy way. It sounds like Symantec Ghost(tm), but has even better features, and is totally free. \n\nFeatures include: \n\n\nProbably the best available Linux toolbox for rescuing a system; \nBackup and Restore partitions or files locally or to the network (MS Network Shared directory, NFS, FTP or SSHFS); \nBackup and Restore the BIOS data as well; \nEither burn a bootable CD / DVD, either integrate within a PXE / RIS environment; \nPossibility to Blank local admin's password; \nCreate your own restoration bootable DVD (see the Howto Documentation); \nPartition and Format a disk before installing Windows (so to make sure your unattended Windows installation will happen on the right partition); \n\nSpecific advantages PING brings you over DOS and Ghost : \nMost network cards automatically recognized by the Kernel (unlike DOS); \nMost CD/DVD readers automatically recognized by the Kernel (unlike DOS); \nYou don't have to run a Ghostcast server to receive images over the network; \nMore supported filesystems; \nYou can store an image on several CD/DVD (CD/DVD-spanning); \nYou can backup and restore BIOS settings too; \nMuch much smaller than WinPE / BartPE; \netc.",
            "title": "PING (Partimage Is Not Ghost)"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#puppy-linux",
            "text": "Linux is a free operating system, and Puppy Linux is a special build of Linux meant to make computing easy and fast.\n\nPuppy Linux enables you to save money while doing more work, even allowing you to do magic by recovering data from destroyed PCs or by removing malware from Windows. See these example articles: recovering files from Windows and safe Internet banking with Puppy Linux.",
            "title": "Puppy Linux"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#systemrescuecd",
            "text": "SystemRescueCd is a Linux system rescue disk available as a bootable CD-ROM or USB stick for administrating or repairing your system and data after a crash. It aims to provide an easy way to carry out admin tasks on your computer, such as creating and editing the hard disk partitions. It comes with a lot of linux software such as system tools (parted, partimage, fstools, ...) and basic tools (editors, midnight commander, network tools). It can be used for both Linux and windows computers, and on desktops as well as servers. This rescue system requires no installation as it can be booted from a CD/DVD drive or USB stick, but it can be installed on the hard disk if you wish. The kernel supports all important file systems (ext2/ext3/ext4, reiserfs, btrfs, xfs, jfs, vfat, ntfs), as well as network filesystems (samba and nfs). \n\nBased of Gentoo and VERY useful for Gentoo installations especially for UEFI.",
            "title": "SystemRescueCd"
        },
        {
            "location": "/OS/Useful_UNIX_distros/#tails",
            "text": "Tails is a live operating system, that you can start on almost any computer from a DVD, USB stick, or SD card. It aims at preserving your privacy and anonymity, and helps you to: \nuse the Internet anonymously and circumvent censorship;\nall connections to the Internet are forced to go through the Tor network; \nleave no trace on the computer you are using unless you ask it explicitly; \nuse state-of-the-art cryptographic tools to encrypt your files, emails and instant messaging. \n\nPowered by TOR",
            "title": "Tails"
        },
        {
            "location": "/OS/Gentoo/Console_Font/",
            "text": "Terminus\n\n\nemerge --ask media-fonts/terminus-font\nsetfont ter-p32n.psf.gz\n\nvim /etc/vconsole.conf\n# --- vconsole.conf ---\nFONT=ter-p32n.psf.gz\n# --- END OF FILE ---\n\n\n\n\nGRUB\n\n\nUSE=\"truerype\" emerge --ask --update --newuse --verbose sys-boot/grub:2\nemerge --ask media-fonts/terminus-font\ngrub-mkfont -s 32 -o /boot/grub/fonts/terminus32.pf2 /usr/share/fonts/terminus/ter-x32n.pcf.gz\n\nvim /etc/default/grub\nGRUB_FONT=/boot/grub/fonts/terminus32.pf2",
            "title": "Console Font"
        },
        {
            "location": "/OS/Gentoo/Console_Font/#terminus",
            "text": "emerge --ask media-fonts/terminus-font\nsetfont ter-p32n.psf.gz\n\nvim /etc/vconsole.conf\n# --- vconsole.conf ---\nFONT=ter-p32n.psf.gz\n# --- END OF FILE ---",
            "title": "Terminus"
        },
        {
            "location": "/OS/Gentoo/Console_Font/#grub",
            "text": "USE=\"truerype\" emerge --ask --update --newuse --verbose sys-boot/grub:2\nemerge --ask media-fonts/terminus-font\ngrub-mkfont -s 32 -o /boot/grub/fonts/terminus32.pf2 /usr/share/fonts/terminus/ter-x32n.pcf.gz\n\nvim /etc/default/grub\nGRUB_FONT=/boot/grub/fonts/terminus32.pf2",
            "title": "GRUB"
        },
        {
            "location": "/OS/Gentoo/Gnome/",
            "text": "Choose graphical profile\n\n\neselect profile list\neselect profile set 5\n\nemerge --ask --update --newuse --deep world",
            "title": "Gnome"
        },
        {
            "location": "/OS/Gentoo/Gnome/#choose-graphical-profile",
            "text": "eselect profile list\neselect profile set 5\n\nemerge --ask --update --newuse --deep world",
            "title": "Choose graphical profile"
        },
        {
            "location": "/OS/Gentoo/Installation/",
            "text": "Downloading and burning installation media\n\n\n# Minimal installation image:\nwget http://distfiles.gentoo.org/releases/amd64/autobuilds/current-install-amd64-minimal/install-amd64-minimal-{date-here}.iso\ndd if=install-amd64-minimal-{date-here}.iso of=/dev/sdb-flash-drive bs=8192k && sync\n\n# Or burn it on CD:\ncdrecord dev=/dev/sr0 install-amd64-minimal-{date-here}.iso\n\n# If you want to use pure EFI, you should boot from EFI-compliant CD, and it isn't minimal CD.\n# You should use another one: \n# SystemRescueCd - Gentoo-based live CD (I use this one)\n# Offician Gentoo Live CD\n# Archlinux boot CD - also good choice\nhttps://sourceforge.net/projects/systemrescuecd/files/sysresccd-x86/4.9.1/systemrescuecd-x86-4.9.1.iso/download\ndd if=systemrescuecd-x86-4.9.1.iso of=/dev/sdb-flash-drive bs=8192k && sync\n\n\n\n\nBoot from installation media\n\n\n# Enter kernel to boot: gentoo, gentoo-nofb, memtest86\nboot: gentoo\n\n# [Optionally] You can choose specific hardware options like: gentoo acpi=off\n# acpi=on, acpi=off, console=X, dmraid=X, doapm, dopcmcia, doscsi, sda=stroke, ide=nodma, noapic, nodetect, nodhcp, nodmraid, nofirewire, nogpm, nohotplug, nokeymap, nolapic, nosata, nosmp, nosound, nousb, slowusb, \n# dolvm, debug, docache, doload=X, dosshd, passwd=foo, noload=X, nonfs, nox, scandelay, scandelay=X,\n\n\n\n\nNetwork configuration\n\n\nLike Gentoo Handbook says 'Maybe it just works'. I'm pretty sure that you have DHCP in your network environment and cable connection, but if not:\n\n\n# Determine network intercaces (ifconfig is also existed, but it's recomnded to use 'ip' as a next generation app)\nip link show\n\n# LAN\nnet-setup <your-network-interface>\n\n# WiFi\niwconfig <your-wifi-network-interface> essid <WiFi-SSID-Name>\niwconfig <your-wifi-network-interface> key s:some-password\n\n# Retrive IP\ndhcpcd <your-network-interface>\n# In case of hostName and domainName provided by the DHCP server\ndhcpcd -HD <your-network-interface>\n\n# Manual IP via 'ip'\nip link set <your-network-interface> up\nip addr add <your-IP-address>/<your-netmask> broadcast <your-brodcast-address> dev <your-network-interface>\nip route add default via <your-gateway>\n\n# Manual IP via 'ifconfig'\nifconfig <your-network-interface> <your-IP-address> broadcast <your-brodcast-address> netmask <your-netmask> up\nroute add default gw <your-gateway>a\n\n# DNS servers\necho \"nameserver <SNDServer1>\" > /etc/resolv.conf\necho \"nameserver <DNSServer2>\" >> /etc/resolv.conf\n\n\n\n\nDisk partitioning\n\n\nIt's recommended to use GPT on modern systems.\n\n\n# Partition scheme:\n# /dev/sda1 (bootloader)  2M      Just in case, but I don't think it's really needed on modern EFI systems.\n# /dev/sda2 fat32-UFFI    1024M   EFI Partition to hold more than one kernel. Yes I know that Handbook recommends 128M.\n# /dev/sda3 root-ext4     100% \n# For swap I will use swapfile, because there is no performance advantage to either a contiguous swap file or a partition, both are treated the same way.\n\nparted -a optimal /dev/sda\n(parted) mklabel gpt\n\n# Partition 1: Bootloader\n(parted) unit mib\n(parted) mkpart primary 1 3\n(parted) name 1 grub \n(parted) set 1 bios_grub on\n\n# Partition 1: Boot\n(parted) mkpart primary 3 1027\n(parted) name 2 boot\n(parted) set 2 boot on\n\n# Partition 1: Root\n(parted) mkpart primary 1027 -1\n(parted) name 4 rootfs\n\n\n\n\nMounting\n\n\nmount /dev/sda3 /mnt/gentoo\nmount /dev/sda2 /mnt/gentoo/boot\n\n# System remount for chrooting\nmount -t proc proc /mnt/gentoo/proc\nmount --rbind /sys /mnt/gentoo/sys\nmount --make-rslave /mnt/gentoo/sys\nmount --rbind /dev /mnt/gentoo/dev\nmount --make-rslave /mnt/gentoo/dev\n\n\n\n\nInstalling Stage tarball\n\n\ncd /mnt/gentoo/\nwget http://mirror.yandex.ru/gentoo-distfiles/releases/amd64/autobuilds/current-stage3-amd64-systemd/stage3-amd64-systemd-<YYYYMMDD>.tar.bz2\ntar xvjpf stage3-amd64-systemd-<YYYYMMDD>.tar.bz2 --xattrs\n\n\n\n\nConfiguring initial options\n\n\nvim /mnt/gentoo/etc/portage/make.conf\n# --- make.conf ---\nCFLAGS=\"-march=native -O2 -pipe\"\n# Number of your CPU cores +1\nMAKEOPTS=\"-j5\"\n# --- END OF FILE ---\n\nmirrorselect -i -o >> /mnt/gentoo/etc/portage/make.conf\n\nmkdir /mnt/gentoo/etc/portage/repos.conf\ncp /mnt/gentoo/usr/share/portage/config/repos.conf /mnt/gentoo/etc/portage/repos.conf/gentoo.conf\n\ncp -L /etc/resolv.conf /mnt/gentoo/etc/\n\n\n\n\nChrooting\n\n\nchroot /mnt/gentoo /bin/bash \nsource /etc/profile\n\n\n\n\nUpdating world\n\n\nemerge-webrsync\nemerge --sync\n\neselect profile list\n# Choose aproriate profile, I reccomend use systemd profile\neselect profile set 12\n\nemerge --ask --update --deep --newuse @world\n\n\n\n\nLocale and TimeZone\n\n\necho \"Europe/Moscow\" > /etc/timezone\nemerge --config sys-libs/timezone-data\n\nvim /etc/locale.gen\n# --- locale.gen ---\nen_US.UTF-8 UTF-8\nru_RU.UTF-8 UTF-8\n# --- END OF FILE ---\n\nlocale-gen\neselect locale list\neselect locale set <choose-right-number>\n\nenv-update && source /etc/profile\n\n\n\n\nKernel\n\n\nOf course you need to configure kernel from scratch, but for initial convinience I recommend to use genkernel\n\n\nemerge --ask sys-kernel/gentoo-sources\nemerge --ask sys-apps/pciutils\nemerge --ask sys-kernel/genkernel-next\n# If you use RC-based prfile:\n# emerge --ask sys-kernel/genkernel\n\ngenkernel all\n\nemerge --ask sys-kernel/linux-firmware\n\n\n\n\nFstab\n\n\n# Look for UUID and write it down:\nblkid\n\nvim /etc/fstab\n# --- fstab ---\nUUID=\"place your UUID here\"   boot      vfat        rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro,discard  0 2\nUUID=\"place your UUID here\"   /         ext4        rw,relatime,data=ordered,discard                                                                              0 1\n# --- END OF FILE\n\n\n\n\nNetwork\n\n\nhostnamectl set-hostname your-hostname.your-network\n\nvim /etc/hosts\n# --- hosts ---\n127.0.0.1   your-hostname.your-network your-hostname localhost\n# --- END OF FILE ---\n\nemerge --ask net-misc/dhcpcd\n\n\n\n\nPost install\n\n\nemerge --ask sys-apps/mlocate\n\npasswd\n\n\n\n\nBootloader\n\n\necho 'GRUB_PLATFORMS=\"efi-64\"' >> /etc/portage/make.conf\nemerge --ask --update --newuse --verbose sys-boot/grub:2\n\nmount -o remount /sys/firmware/efi/efivars -o rw,nosuid,nodev,noexec,noatime\n\ngrub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub /dev/sda\ngrub-mkconfig -o /boot/grub/grub.cfg\n\n\n\n\n\nUmount and reboot\n\n\nexit\numount -l /mnt/gentoo/dev{/shm,/pts,}\numount -R /mnt/gentoo\nreboot\n\n\n\n\nPost reboot\n\n\n# Add new user\nuseradd -m -G users,wheel,audio,cdrom,floppy,games,portage,usb,video -s /bin/bash <username>\npasswd <username>",
            "title": "Installation"
        },
        {
            "location": "/OS/Gentoo/Installation/#downloading-and-burning-installation-media",
            "text": "# Minimal installation image:\nwget http://distfiles.gentoo.org/releases/amd64/autobuilds/current-install-amd64-minimal/install-amd64-minimal-{date-here}.iso\ndd if=install-amd64-minimal-{date-here}.iso of=/dev/sdb-flash-drive bs=8192k && sync\n\n# Or burn it on CD:\ncdrecord dev=/dev/sr0 install-amd64-minimal-{date-here}.iso\n\n# If you want to use pure EFI, you should boot from EFI-compliant CD, and it isn't minimal CD.\n# You should use another one: \n# SystemRescueCd - Gentoo-based live CD (I use this one)\n# Offician Gentoo Live CD\n# Archlinux boot CD - also good choice\nhttps://sourceforge.net/projects/systemrescuecd/files/sysresccd-x86/4.9.1/systemrescuecd-x86-4.9.1.iso/download\ndd if=systemrescuecd-x86-4.9.1.iso of=/dev/sdb-flash-drive bs=8192k && sync",
            "title": "Downloading and burning installation media"
        },
        {
            "location": "/OS/Gentoo/Installation/#boot-from-installation-media",
            "text": "# Enter kernel to boot: gentoo, gentoo-nofb, memtest86\nboot: gentoo\n\n# [Optionally] You can choose specific hardware options like: gentoo acpi=off\n# acpi=on, acpi=off, console=X, dmraid=X, doapm, dopcmcia, doscsi, sda=stroke, ide=nodma, noapic, nodetect, nodhcp, nodmraid, nofirewire, nogpm, nohotplug, nokeymap, nolapic, nosata, nosmp, nosound, nousb, slowusb, \n# dolvm, debug, docache, doload=X, dosshd, passwd=foo, noload=X, nonfs, nox, scandelay, scandelay=X,",
            "title": "Boot from installation media"
        },
        {
            "location": "/OS/Gentoo/Installation/#network-configuration",
            "text": "Like Gentoo Handbook says 'Maybe it just works'. I'm pretty sure that you have DHCP in your network environment and cable connection, but if not:  # Determine network intercaces (ifconfig is also existed, but it's recomnded to use 'ip' as a next generation app)\nip link show\n\n# LAN\nnet-setup <your-network-interface>\n\n# WiFi\niwconfig <your-wifi-network-interface> essid <WiFi-SSID-Name>\niwconfig <your-wifi-network-interface> key s:some-password\n\n# Retrive IP\ndhcpcd <your-network-interface>\n# In case of hostName and domainName provided by the DHCP server\ndhcpcd -HD <your-network-interface>\n\n# Manual IP via 'ip'\nip link set <your-network-interface> up\nip addr add <your-IP-address>/<your-netmask> broadcast <your-brodcast-address> dev <your-network-interface>\nip route add default via <your-gateway>\n\n# Manual IP via 'ifconfig'\nifconfig <your-network-interface> <your-IP-address> broadcast <your-brodcast-address> netmask <your-netmask> up\nroute add default gw <your-gateway>a\n\n# DNS servers\necho \"nameserver <SNDServer1>\" > /etc/resolv.conf\necho \"nameserver <DNSServer2>\" >> /etc/resolv.conf",
            "title": "Network configuration"
        },
        {
            "location": "/OS/Gentoo/Installation/#disk-partitioning",
            "text": "It's recommended to use GPT on modern systems.  # Partition scheme:\n# /dev/sda1 (bootloader)  2M      Just in case, but I don't think it's really needed on modern EFI systems.\n# /dev/sda2 fat32-UFFI    1024M   EFI Partition to hold more than one kernel. Yes I know that Handbook recommends 128M.\n# /dev/sda3 root-ext4     100% \n# For swap I will use swapfile, because there is no performance advantage to either a contiguous swap file or a partition, both are treated the same way.\n\nparted -a optimal /dev/sda\n(parted) mklabel gpt\n\n# Partition 1: Bootloader\n(parted) unit mib\n(parted) mkpart primary 1 3\n(parted) name 1 grub \n(parted) set 1 bios_grub on\n\n# Partition 1: Boot\n(parted) mkpart primary 3 1027\n(parted) name 2 boot\n(parted) set 2 boot on\n\n# Partition 1: Root\n(parted) mkpart primary 1027 -1\n(parted) name 4 rootfs",
            "title": "Disk partitioning"
        },
        {
            "location": "/OS/Gentoo/Installation/#mounting",
            "text": "mount /dev/sda3 /mnt/gentoo\nmount /dev/sda2 /mnt/gentoo/boot\n\n# System remount for chrooting\nmount -t proc proc /mnt/gentoo/proc\nmount --rbind /sys /mnt/gentoo/sys\nmount --make-rslave /mnt/gentoo/sys\nmount --rbind /dev /mnt/gentoo/dev\nmount --make-rslave /mnt/gentoo/dev",
            "title": "Mounting"
        },
        {
            "location": "/OS/Gentoo/Installation/#installing-stage-tarball",
            "text": "cd /mnt/gentoo/\nwget http://mirror.yandex.ru/gentoo-distfiles/releases/amd64/autobuilds/current-stage3-amd64-systemd/stage3-amd64-systemd-<YYYYMMDD>.tar.bz2\ntar xvjpf stage3-amd64-systemd-<YYYYMMDD>.tar.bz2 --xattrs",
            "title": "Installing Stage tarball"
        },
        {
            "location": "/OS/Gentoo/Installation/#configuring-initial-options",
            "text": "vim /mnt/gentoo/etc/portage/make.conf\n# --- make.conf ---\nCFLAGS=\"-march=native -O2 -pipe\"\n# Number of your CPU cores +1\nMAKEOPTS=\"-j5\"\n# --- END OF FILE ---\n\nmirrorselect -i -o >> /mnt/gentoo/etc/portage/make.conf\n\nmkdir /mnt/gentoo/etc/portage/repos.conf\ncp /mnt/gentoo/usr/share/portage/config/repos.conf /mnt/gentoo/etc/portage/repos.conf/gentoo.conf\n\ncp -L /etc/resolv.conf /mnt/gentoo/etc/",
            "title": "Configuring initial options"
        },
        {
            "location": "/OS/Gentoo/Installation/#chrooting",
            "text": "chroot /mnt/gentoo /bin/bash \nsource /etc/profile",
            "title": "Chrooting"
        },
        {
            "location": "/OS/Gentoo/Installation/#updating-world",
            "text": "emerge-webrsync\nemerge --sync\n\neselect profile list\n# Choose aproriate profile, I reccomend use systemd profile\neselect profile set 12\n\nemerge --ask --update --deep --newuse @world",
            "title": "Updating world"
        },
        {
            "location": "/OS/Gentoo/Installation/#locale-and-timezone",
            "text": "echo \"Europe/Moscow\" > /etc/timezone\nemerge --config sys-libs/timezone-data\n\nvim /etc/locale.gen\n# --- locale.gen ---\nen_US.UTF-8 UTF-8\nru_RU.UTF-8 UTF-8\n# --- END OF FILE ---\n\nlocale-gen\neselect locale list\neselect locale set <choose-right-number>\n\nenv-update && source /etc/profile",
            "title": "Locale and TimeZone"
        },
        {
            "location": "/OS/Gentoo/Installation/#kernel",
            "text": "Of course you need to configure kernel from scratch, but for initial convinience I recommend to use genkernel  emerge --ask sys-kernel/gentoo-sources\nemerge --ask sys-apps/pciutils\nemerge --ask sys-kernel/genkernel-next\n# If you use RC-based prfile:\n# emerge --ask sys-kernel/genkernel\n\ngenkernel all\n\nemerge --ask sys-kernel/linux-firmware",
            "title": "Kernel"
        },
        {
            "location": "/OS/Gentoo/Installation/#fstab",
            "text": "# Look for UUID and write it down:\nblkid\n\nvim /etc/fstab\n# --- fstab ---\nUUID=\"place your UUID here\"   boot      vfat        rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro,discard  0 2\nUUID=\"place your UUID here\"   /         ext4        rw,relatime,data=ordered,discard                                                                              0 1\n# --- END OF FILE",
            "title": "Fstab"
        },
        {
            "location": "/OS/Gentoo/Installation/#network",
            "text": "hostnamectl set-hostname your-hostname.your-network\n\nvim /etc/hosts\n# --- hosts ---\n127.0.0.1   your-hostname.your-network your-hostname localhost\n# --- END OF FILE ---\n\nemerge --ask net-misc/dhcpcd",
            "title": "Network"
        },
        {
            "location": "/OS/Gentoo/Installation/#post-install",
            "text": "emerge --ask sys-apps/mlocate\n\npasswd",
            "title": "Post install"
        },
        {
            "location": "/OS/Gentoo/Installation/#bootloader",
            "text": "echo 'GRUB_PLATFORMS=\"efi-64\"' >> /etc/portage/make.conf\nemerge --ask --update --newuse --verbose sys-boot/grub:2\n\nmount -o remount /sys/firmware/efi/efivars -o rw,nosuid,nodev,noexec,noatime\n\ngrub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub /dev/sda\ngrub-mkconfig -o /boot/grub/grub.cfg",
            "title": "Bootloader"
        },
        {
            "location": "/OS/Gentoo/Installation/#umount-and-reboot",
            "text": "exit\numount -l /mnt/gentoo/dev{/shm,/pts,}\numount -R /mnt/gentoo\nreboot",
            "title": "Umount and reboot"
        },
        {
            "location": "/OS/Gentoo/Installation/#post-reboot",
            "text": "# Add new user\nuseradd -m -G users,wheel,audio,cdrom,floppy,games,portage,usb,video -s /bin/bash <username>\npasswd <username>",
            "title": "Post reboot"
        },
        {
            "location": "/OS/Gentoo/Portage/",
            "text": "XX config files need updating\n\n\netc-update",
            "title": "Portage"
        },
        {
            "location": "/OS/Gentoo/Portage/#xx-config-files-need-updating",
            "text": "etc-update",
            "title": "XX config files need updating"
        },
        {
            "location": "/OS/Gentoo/Systemd/",
            "text": "Journal failed to get machine id: No such file or directory\n\n\nsystemd-machine-id-setup\n\n\n\n\nTimedatectl\n\n\ntimedatectl set-timezone Europe/Moscow\ntimedatectl set-ntp yes",
            "title": "Systemd"
        },
        {
            "location": "/OS/Gentoo/Systemd/#journal-failed-to-get-machine-id-no-such-file-or-directory",
            "text": "systemd-machine-id-setup",
            "title": "Journal failed to get machine id: No such file or directory"
        },
        {
            "location": "/OS/Gentoo/Systemd/#timedatectl",
            "text": "timedatectl set-timezone Europe/Moscow\ntimedatectl set-ntp yes",
            "title": "Timedatectl"
        },
        {
            "location": "/QA/Stress_tests/Ackerman_function/",
            "text": "C\n\n\n#include <stdio.h>\n\nint ackermann(int m, int n)\n{\n   if (!m) return n + 1;\n   if (!n) return ackermann(m - 1, 1);\n   return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main()\n{\n   int m, n;\n   for (m = 0; m <= 4; m++)\n      for (n = 0; n < 6 - m; n++)\n         printf(\"A(%d, %d) = %d\\n\", m, n, ackermann(m, n));\n\n   return 0;\n}\n\n\n\n\nC++\n\n\n#include <iostream>\n\nunsigned int ackermann(unsigned int m, unsigned int n) {\n  if (m == 0) {\n    return n + 1;\n  }\n  if (n == 0) {\n    return ackermann(m - 1, 1);\n  }\n  return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main() {\n  for (unsigned int m = 0; m < 4; ++m) {\n    for (unsigned int n = 0; n < 30; ++n) {\n      std::cout << \"A(\" << m << \", \" << n << \") = \" << ackermann(m, n) << \"\\n\";\n    }\n  }\n}",
            "title": "Ackerman function"
        },
        {
            "location": "/QA/Stress_tests/Ackerman_function/#c",
            "text": "#include <stdio.h>\n\nint ackermann(int m, int n)\n{\n   if (!m) return n + 1;\n   if (!n) return ackermann(m - 1, 1);\n   return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main()\n{\n   int m, n;\n   for (m = 0; m <= 4; m++)\n      for (n = 0; n < 6 - m; n++)\n         printf(\"A(%d, %d) = %d\\n\", m, n, ackermann(m, n));\n\n   return 0;\n}",
            "title": "C"
        },
        {
            "location": "/QA/Stress_tests/Ackerman_function/#c_1",
            "text": "#include <iostream>\n\nunsigned int ackermann(unsigned int m, unsigned int n) {\n  if (m == 0) {\n    return n + 1;\n  }\n  if (n == 0) {\n    return ackermann(m - 1, 1);\n  }\n  return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main() {\n  for (unsigned int m = 0; m < 4; ++m) {\n    for (unsigned int n = 0; n < 30; ++n) {\n      std::cout << \"A(\" << m << \", \" << n << \") = \" << ackermann(m, n) << \"\\n\";\n    }\n  }\n}",
            "title": "C++"
        },
        {
            "location": "/Tech/Audit/Fork_unavailable/",
            "text": "Fork: Resource temporarily unavailable on AIX\n\n\nTo investigate the promles you need to run this bunch of commands:\n\n\ncat /etc/passwd\n\n\n\n\nFrom root you need to look at limint of every active user:\n\n\nulimit -a\nsu oracle -c \"ulimit -a\"\nsu mongod -c \"ulimit -a\"\nsu userX -c \"ulimit -a\"\n\n\n\n\nLook at system wide defined limits:\n\n\ncat /etc/security/limits\n\n\n\n\nLook at kernel parameters, especially on \nmaxuproc\n\n\nlsattr -El sys0\n\n\n\n\nLook at count of running processes by user:\n\n\nps -f -l -uroot | wc -l\nps -f -l -uoracle | wc -l\nps -f -l -umongod | wc -l\nps -f -l -uuserX | wc -l\n\n\n\n\nAnd after all look at avaible mamory and swap:\n\n\nsvmon -G -O unit=MB",
            "title": "Fork unavailable"
        },
        {
            "location": "/Tech/Audit/Fork_unavailable/#fork-resource-temporarily-unavailable-on-aix",
            "text": "To investigate the promles you need to run this bunch of commands:  cat /etc/passwd  From root you need to look at limint of every active user:  ulimit -a\nsu oracle -c \"ulimit -a\"\nsu mongod -c \"ulimit -a\"\nsu userX -c \"ulimit -a\"  Look at system wide defined limits:  cat /etc/security/limits  Look at kernel parameters, especially on  maxuproc  lsattr -El sys0  Look at count of running processes by user:  ps -f -l -uroot | wc -l\nps -f -l -uoracle | wc -l\nps -f -l -umongod | wc -l\nps -f -l -uuserX | wc -l  And after all look at avaible mamory and swap:  svmon -G -O unit=MB",
            "title": "Fork: Resource temporarily unavailable on AIX"
        },
        {
            "location": "/Tech/Audit/Hardware_info/",
            "text": "All hardware\n\n\nhwinfo\n\n\n\n\nRAW Devices\n\n\n# ISO to USB:\ndd bs=4M if=/path/to/<iso_image> of=/dev/sdX && sync\n\n\n\n\nCPU\n\n\nlscpu\ncat /proc/cpuinfo\n\n\n\n\nRAM\n\n\n# Basic commands:\nvmstat -s\ncat /proc/meminfo\nfree -m\n# Sum of used RAM\nps -eo rss,pid,user,command --sort -size | awk '{ hr=$1/1024 ; printf(\"%13.2f Mb \",hr) } { for ( x=4 ; x<=NF ; x++ ) { printf(\"%s \",$x) } print \"\" }' | awk '{print $1}' | paste -sd+ | bc\n# Clean RAM buffer and swap cache\nsync && echo 3 > /proc/sys/vm/drop_caches\n\n\n\n\nVM\n\n\nTo check if server's environment is virtual or real you can use stanasrd Linux commands\n\n\n\n\ncat /proc/scsi/scsi \n\n\n\n\nAttached devices:\nHost: scsi2 Channel: 00 Id: 00 Lun: 00\n  Vendor: VMware   Model: Virtual disk     Rev: 1.0\n  Type:   Direct-Access                    ANSI  SCSI revision: 02\nHost: scsi1 Channel: 00 Id: 00 Lun: 00\n  Vendor: NECVMWar Model: VMware IDE CDR10 Rev: 1.00\n  Type:   CD-ROM                           ANSI  SCSI revision: 05\n\n\n\n\n\n\nethtool -i eth0\n\n\n\n\ndriver: vmxnet3\nversion: 1.1.30.0-k-NAPI\nfirmware-version:\nbus-info: 0000:03:00.0\nsupports-statistics: yes\nsupports-test: no\nsupports-eeprom-access: no\nsupports-register-dump: yes\nsupports-priv-flags: no\n\n\n\n\n\n\ndmidecode | grep -i vmware\n\n\n\n\n        Manufacturer: VMware, Inc.\n        Product Name: VMware Virtual Platform\n        Serial Number: VMware-42 28 f6 4e 92 c6 36 0a-2e 21 47 23 85 9f 5d 64\n        Description: VMware SVGA II",
            "title": "Hardware info"
        },
        {
            "location": "/Tech/Audit/Hardware_info/#all-hardware",
            "text": "hwinfo",
            "title": "All hardware"
        },
        {
            "location": "/Tech/Audit/Hardware_info/#raw-devices",
            "text": "# ISO to USB:\ndd bs=4M if=/path/to/<iso_image> of=/dev/sdX && sync",
            "title": "RAW Devices"
        },
        {
            "location": "/Tech/Audit/Hardware_info/#cpu",
            "text": "lscpu\ncat /proc/cpuinfo",
            "title": "CPU"
        },
        {
            "location": "/Tech/Audit/Hardware_info/#ram",
            "text": "# Basic commands:\nvmstat -s\ncat /proc/meminfo\nfree -m\n# Sum of used RAM\nps -eo rss,pid,user,command --sort -size | awk '{ hr=$1/1024 ; printf(\"%13.2f Mb \",hr) } { for ( x=4 ; x<=NF ; x++ ) { printf(\"%s \",$x) } print \"\" }' | awk '{print $1}' | paste -sd+ | bc\n# Clean RAM buffer and swap cache\nsync && echo 3 > /proc/sys/vm/drop_caches",
            "title": "RAM"
        },
        {
            "location": "/Tech/Audit/Hardware_info/#vm",
            "text": "To check if server's environment is virtual or real you can use stanasrd Linux commands   cat /proc/scsi/scsi    Attached devices:\nHost: scsi2 Channel: 00 Id: 00 Lun: 00\n  Vendor: VMware   Model: Virtual disk     Rev: 1.0\n  Type:   Direct-Access                    ANSI  SCSI revision: 02\nHost: scsi1 Channel: 00 Id: 00 Lun: 00\n  Vendor: NECVMWar Model: VMware IDE CDR10 Rev: 1.00\n  Type:   CD-ROM                           ANSI  SCSI revision: 05   ethtool -i eth0   driver: vmxnet3\nversion: 1.1.30.0-k-NAPI\nfirmware-version:\nbus-info: 0000:03:00.0\nsupports-statistics: yes\nsupports-test: no\nsupports-eeprom-access: no\nsupports-register-dump: yes\nsupports-priv-flags: no   dmidecode | grep -i vmware           Manufacturer: VMware, Inc.\n        Product Name: VMware Virtual Platform\n        Serial Number: VMware-42 28 f6 4e 92 c6 36 0a-2e 21 47 23 85 9f 5d 64\n        Description: VMware SVGA II",
            "title": "VM"
        },
        {
            "location": "/Tech/Audit/Processes/",
            "text": "Wait until proceses will gone\n\n\nwhile true; do clear; ps -ef | grep <process>; sleep 5; done\n\n\n\n\nKill all proesses with certain name\n\n\nps ax | grep http | awk '{print $1}' | xargs kill",
            "title": "Processes"
        },
        {
            "location": "/Tech/Audit/Processes/#wait-until-proceses-will-gone",
            "text": "while true; do clear; ps -ef | grep <process>; sleep 5; done",
            "title": "Wait until proceses will gone"
        },
        {
            "location": "/Tech/Audit/Processes/#kill-all-proesses-with-certain-name",
            "text": "ps ax | grep http | awk '{print $1}' | xargs kill",
            "title": "Kill all proesses with certain name"
        },
        {
            "location": "/Tech/Audit/Reboot_Investigation/",
            "text": "Why is my server rebooted?\n\n\nlast reboot \nsudo lastcomm | egrep 'reboot|shutdown'\nwho -b\nsa\ncrontab -e\nless /var/log/secure\nlast -x | less\nlast -x | grep shutdown | less\nless /var/log/messages\njournalctl\nutmpdump /var/log/wtmp | egrep 'shutdown|reboot|runlevel'\njournalctl --since=\"2016-6-28 12:00:00\"",
            "title": "Reboot Investigation"
        },
        {
            "location": "/Tech/Audit/Reboot_Investigation/#why-is-my-server-rebooted",
            "text": "last reboot \nsudo lastcomm | egrep 'reboot|shutdown'\nwho -b\nsa\ncrontab -e\nless /var/log/secure\nlast -x | less\nlast -x | grep shutdown | less\nless /var/log/messages\njournalctl\nutmpdump /var/log/wtmp | egrep 'shutdown|reboot|runlevel'\njournalctl --since=\"2016-6-28 12:00:00\"",
            "title": "Why is my server rebooted?"
        },
        {
            "location": "/Tech/Backup/TSM/",
            "text": "Queries\n\n\n# Check backup\nq ev * * \n\n# Check path\nq path \n\n# Check drive\nq dri \n\n# Status\nq stat\n\n# Tape status\nq vol\n\n# Check volumes in the tape library                                                                 \nq libvol\n\n# Check processes\nq pro\n\n# Cancel process\ncan pro\u00a0(<process>)\n\n# Check pools\nq stg\n\n# Check working sessions\nq sess\n\n# Cancel session\ncan sess\u00a0(<session>)\n\n# Shedule backup\nq eve domain name schedulename\n\n# Viwe assigned nodes in a Tivoli server\nq node\n\n# Check backup space utilized for each file system of a server\nq filespace\n\n# View activity log\nq actlog\nq act begind=mm/dd/yyyy begint=hh:mm:ss endd= mm/dd/yyyy endt=hh:mm:ss\nq act begind=today-1 begint=00:00\nq act search=transferred begint=00:00\nq act search=nodenam\n\n# Get detailed drive report\nq drive f=d\n\n# Get detailed information about tape library\nq library f=d\n\n# Get requests\nq req\n# Reply to request \nreply\u00a0(<request>)\n\n# Schedule\nq sched\nq sched f=d\nq sched * type=admin f=d\n\n\n\n\n\nUnload tape\n\n\nConfigure Library \u2192 Drive \u2192 []Power ON\nConfigure Library \u2192 Drive \u2192 [X]Power ON\nWait for 5 minutes until tape will be rewinded\n# Move tape to empty slot\nManage Library \u2192 Move Media \n\n\n\n\nHow to get logs\n\n\n# Library logs\nService \u2192 View Logs\nSave Service Dump\n\n# Drive logs\nService Library \u2192 Save Drive Dump\n\n\n\n\nChanges\n\n\n# Path (set online)\n#Drive1:\nUPD PATH TSM DRIVE01 SRCT=SERVer DESTT=DRIVE LIBR=TS3100 ONL=Y\n#Drive2:\nUPD PATH TSM DRIVE02 SRCT=SERVer DESTT=DRIVE LIBR=TS3100 ONL=Y\n\n# Update drive status to online\nupdate path sourceservername TAPE0 srct=server destt=drive libr=ts3200 online=yes\n\n# Drive (set online)\n#Drive1:\nUPD DRI TS3100 DRIVE01 ONL=Y\n#Drive2:\nUPD DRI TS3100 DRIVE02 ONL=Y\n\n# Change a library volume ( L41117L4 ) status to scratch from private\nUPDATE LIBVOLUME TS3200 L41117L4 STATUS=SCRATCH\n\n# Change a tivoli login password of a node\nupdate node nodename \"admin\" domain=domainname forcepwreset=Yes\n\n# Add new tape L41116L4 to a storagepool\ndefine vol storagepoolname L41116L4\n\n# Delete data inside a tape media L41116L4\ndelete volume L41116L4 discarddata=yes\n\n# Set serial number of a drive in tape library\nUPDATE DRIVE TS3200 TAPE0 ELEMENT=autodetect ONLINE=Yes WWN=\"2002000E11107B6C\" SERIAL=autodetect\n\n# Detect label of a tape in tape library\nlabel libvol t3200 checkin=scratch labelsource=barcode search=bulk waittime=0\n\n# Remove tape media from tape library\ncheckout libvol ts3200 VOLLIST=A00015L3,A00019L3 CHECKLABEL=YES REMOVE=YES\n\n# Add and label new tapes into library\nLABEL libvol TS3200 search=yes labelsource=barcode overwrite=NO checkin=SCRATCH WAITTIME=0\n\n# Assign a tape drive to a server\nUPDATE PATH servername TAPE0 SRCTYPE=SERVER DESTTYPE=DRIVE LIBRARY=TS3200 DEVICE=\\\\.\\Tape0 ONLINE=YES AUTODETECT=no\n\n\n\n\nCreating backups\n\n\n# Create a new schedule backup (incremental) for a node\nUPDATE SCHEDULE domainname nodename desc=\"daily incremental backup for a server\" action=Incremental options=-subdir=yes objects=\"\"/fs1/*\" \"/fs2/*\" \"/home/user1/*\"\" priority=5startdate=mm/dd/yyyy starttime=hh:mm duration=1 duru=Houperiod=1 perunits=Day dayofweek=Any expiration=never\n\n# Full backup of Tivoli database manually to file on local disk\nbackup db dev=FILECLASS type=full\n\n\n\n\nStartup\n\n\n# Start Tivoly on AIX\ncd /usr/tivoli/tsm/client/ba/bin\nnohup dsmc sched &\nnohup dsmcad\u00a0&\n\ncd /usr/tivoli/tsm/StorageAgent/bin\nnohup ./dsmsta\u00a0&\n\nps -ef | grep dsm\n\n\n\n\nIf tape is not shown\n\n\ncheckin libvolume TS3100 search=yes status=scratch \u00a0 \u00a0 \u00a0\u00a0\ncheckin libvolume TS3100 search=yes status=private",
            "title": "TSM"
        },
        {
            "location": "/Tech/Backup/TSM/#queries",
            "text": "# Check backup\nq ev * * \n\n# Check path\nq path \n\n# Check drive\nq dri \n\n# Status\nq stat\n\n# Tape status\nq vol\n\n# Check volumes in the tape library                                                                 \nq libvol\n\n# Check processes\nq pro\n\n# Cancel process\ncan pro\u00a0(<process>)\n\n# Check pools\nq stg\n\n# Check working sessions\nq sess\n\n# Cancel session\ncan sess\u00a0(<session>)\n\n# Shedule backup\nq eve domain name schedulename\n\n# Viwe assigned nodes in a Tivoli server\nq node\n\n# Check backup space utilized for each file system of a server\nq filespace\n\n# View activity log\nq actlog\nq act begind=mm/dd/yyyy begint=hh:mm:ss endd= mm/dd/yyyy endt=hh:mm:ss\nq act begind=today-1 begint=00:00\nq act search=transferred begint=00:00\nq act search=nodenam\n\n# Get detailed drive report\nq drive f=d\n\n# Get detailed information about tape library\nq library f=d\n\n# Get requests\nq req\n# Reply to request \nreply\u00a0(<request>)\n\n# Schedule\nq sched\nq sched f=d\nq sched * type=admin f=d",
            "title": "Queries"
        },
        {
            "location": "/Tech/Backup/TSM/#unload-tape",
            "text": "Configure Library \u2192 Drive \u2192 []Power ON\nConfigure Library \u2192 Drive \u2192 [X]Power ON\nWait for 5 minutes until tape will be rewinded\n# Move tape to empty slot\nManage Library \u2192 Move Media",
            "title": "Unload tape"
        },
        {
            "location": "/Tech/Backup/TSM/#how-to-get-logs",
            "text": "# Library logs\nService \u2192 View Logs\nSave Service Dump\n\n# Drive logs\nService Library \u2192 Save Drive Dump",
            "title": "How to get logs"
        },
        {
            "location": "/Tech/Backup/TSM/#changes",
            "text": "# Path (set online)\n#Drive1:\nUPD PATH TSM DRIVE01 SRCT=SERVer DESTT=DRIVE LIBR=TS3100 ONL=Y\n#Drive2:\nUPD PATH TSM DRIVE02 SRCT=SERVer DESTT=DRIVE LIBR=TS3100 ONL=Y\n\n# Update drive status to online\nupdate path sourceservername TAPE0 srct=server destt=drive libr=ts3200 online=yes\n\n# Drive (set online)\n#Drive1:\nUPD DRI TS3100 DRIVE01 ONL=Y\n#Drive2:\nUPD DRI TS3100 DRIVE02 ONL=Y\n\n# Change a library volume ( L41117L4 ) status to scratch from private\nUPDATE LIBVOLUME TS3200 L41117L4 STATUS=SCRATCH\n\n# Change a tivoli login password of a node\nupdate node nodename \"admin\" domain=domainname forcepwreset=Yes\n\n# Add new tape L41116L4 to a storagepool\ndefine vol storagepoolname L41116L4\n\n# Delete data inside a tape media L41116L4\ndelete volume L41116L4 discarddata=yes\n\n# Set serial number of a drive in tape library\nUPDATE DRIVE TS3200 TAPE0 ELEMENT=autodetect ONLINE=Yes WWN=\"2002000E11107B6C\" SERIAL=autodetect\n\n# Detect label of a tape in tape library\nlabel libvol t3200 checkin=scratch labelsource=barcode search=bulk waittime=0\n\n# Remove tape media from tape library\ncheckout libvol ts3200 VOLLIST=A00015L3,A00019L3 CHECKLABEL=YES REMOVE=YES\n\n# Add and label new tapes into library\nLABEL libvol TS3200 search=yes labelsource=barcode overwrite=NO checkin=SCRATCH WAITTIME=0\n\n# Assign a tape drive to a server\nUPDATE PATH servername TAPE0 SRCTYPE=SERVER DESTTYPE=DRIVE LIBRARY=TS3200 DEVICE=\\\\.\\Tape0 ONLINE=YES AUTODETECT=no",
            "title": "Changes"
        },
        {
            "location": "/Tech/Backup/TSM/#creating-backups",
            "text": "# Create a new schedule backup (incremental) for a node\nUPDATE SCHEDULE domainname nodename desc=\"daily incremental backup for a server\" action=Incremental options=-subdir=yes objects=\"\"/fs1/*\" \"/fs2/*\" \"/home/user1/*\"\" priority=5startdate=mm/dd/yyyy starttime=hh:mm duration=1 duru=Houperiod=1 perunits=Day dayofweek=Any expiration=never\n\n# Full backup of Tivoli database manually to file on local disk\nbackup db dev=FILECLASS type=full",
            "title": "Creating backups"
        },
        {
            "location": "/Tech/Backup/TSM/#startup",
            "text": "# Start Tivoly on AIX\ncd /usr/tivoli/tsm/client/ba/bin\nnohup dsmc sched &\nnohup dsmcad\u00a0&\n\ncd /usr/tivoli/tsm/StorageAgent/bin\nnohup ./dsmsta\u00a0&\n\nps -ef | grep dsm",
            "title": "Startup"
        },
        {
            "location": "/Tech/Backup/TSM/#if-tape-is-not-shown",
            "text": "checkin libvolume TS3100 search=yes status=scratch \u00a0 \u00a0 \u00a0\u00a0\ncheckin libvolume TS3100 search=yes status=private",
            "title": "If tape is not shown"
        },
        {
            "location": "/Tech/Backup/Tape/",
            "text": "Rewind tape drive\n\n\nmt -f /dev/st0 rewind\n\n\n\n\nBackup directory\n\n\ntar -czvf /dev/st0 /<directory_for_backup>\n\n\n\n\nList files on tape\n\n\ntar -tzf /dev/st0\n\n\n\n\nRestore\n\n\nmt -f /dev/st0 rewind\ntar -xzf /dev/st0 <file_or_dir_to_restore>\n\n\n\n\nUnload\n\n\nmt -f /dev/st0 offline\n\n\n\n\nStatus\n\n\nmt -f /dev/st0 status\n\n\n\n\nErase\n\n\nmt -f /dev/st0 erase\n\n\n\n\nGet position\n\n\nmt -f /dev/st0 tell\n\n\n\n\nMoves\n\n\n# End\nmt -f /dev/nst0 eod\n# Previous\nmt -f /dev/nst0 bsfm 1\n# Next\nmt -f /dev/nst0 fsf 1",
            "title": "Tape"
        },
        {
            "location": "/Tech/Backup/Tape/#rewind-tape-drive",
            "text": "mt -f /dev/st0 rewind",
            "title": "Rewind tape drive"
        },
        {
            "location": "/Tech/Backup/Tape/#backup-directory",
            "text": "tar -czvf /dev/st0 /<directory_for_backup>",
            "title": "Backup directory"
        },
        {
            "location": "/Tech/Backup/Tape/#list-files-on-tape",
            "text": "tar -tzf /dev/st0",
            "title": "List files on tape"
        },
        {
            "location": "/Tech/Backup/Tape/#restore",
            "text": "mt -f /dev/st0 rewind\ntar -xzf /dev/st0 <file_or_dir_to_restore>",
            "title": "Restore"
        },
        {
            "location": "/Tech/Backup/Tape/#unload",
            "text": "mt -f /dev/st0 offline",
            "title": "Unload"
        },
        {
            "location": "/Tech/Backup/Tape/#status",
            "text": "mt -f /dev/st0 status",
            "title": "Status"
        },
        {
            "location": "/Tech/Backup/Tape/#erase",
            "text": "mt -f /dev/st0 erase",
            "title": "Erase"
        },
        {
            "location": "/Tech/Backup/Tape/#get-position",
            "text": "mt -f /dev/st0 tell",
            "title": "Get position"
        },
        {
            "location": "/Tech/Backup/Tape/#moves",
            "text": "# End\nmt -f /dev/nst0 eod\n# Previous\nmt -f /dev/nst0 bsfm 1\n# Next\nmt -f /dev/nst0 fsf 1",
            "title": "Moves"
        },
        {
            "location": "/Tech/Backup/Veeam/",
            "text": "PowerShell script to perform scheduled backup on free version of Veeam\n\n\n& \"C:\\Program Files\\Veeam\\Backup and Replication\\Backup\\Initialize-VeeamToolkit.ps1\" \n#\nSet-Variable -name 1 -value \"<ESXi(orVsphere)_server_address>\" \nSet-Variable -name STORAGE_REPO -value \"<name_of_predefined_veeam_storage_ropository>\" \n#\nFind-VBRViEntity -Name \"name_of_virtual_machine_here\" | Start-VBRZip -BackupRepository $STORAGE_REPO -RunAsync -AutoDelete In1Week -DisableQuiesce\n\n# Outpul example:\n# PS C:\\Users\\monitor> Set-Variable -name 1 -value \"192.168.168.100\"\n# PS C:\\Users\\monitor> Set-Variable -name DISKF -value \"DISK_F_HUGE\"\n# PS C:\\Users\\monitor> Find-VBRViEntity -Name \"SUPERSERVER-01\" | Start-VBRZip -BackupRepository $DISKF -RunAsync -AutoDelete In1Week -DisableQuiesce\n#\n#Job Name             State      Start Time             End Time               Result\n#--------             -----      ----------             --------               ------\n#SUPERSERVER-01_2016-1... Starting   13.12.2016 15:42:08    01.01.1900 0:00:00     None",
            "title": "Veeam"
        },
        {
            "location": "/Tech/Backup/Veeam/#powershell-script-to-perform-scheduled-backup-on-free-version-of-veeam",
            "text": "& \"C:\\Program Files\\Veeam\\Backup and Replication\\Backup\\Initialize-VeeamToolkit.ps1\" \n#\nSet-Variable -name 1 -value \"<ESXi(orVsphere)_server_address>\" \nSet-Variable -name STORAGE_REPO -value \"<name_of_predefined_veeam_storage_ropository>\" \n#\nFind-VBRViEntity -Name \"name_of_virtual_machine_here\" | Start-VBRZip -BackupRepository $STORAGE_REPO -RunAsync -AutoDelete In1Week -DisableQuiesce\n\n# Outpul example:\n# PS C:\\Users\\monitor> Set-Variable -name 1 -value \"192.168.168.100\"\n# PS C:\\Users\\monitor> Set-Variable -name DISKF -value \"DISK_F_HUGE\"\n# PS C:\\Users\\monitor> Find-VBRViEntity -Name \"SUPERSERVER-01\" | Start-VBRZip -BackupRepository $DISKF -RunAsync -AutoDelete In1Week -DisableQuiesce\n#\n#Job Name             State      Start Time             End Time               Result\n#--------             -----      ----------             --------               ------\n#SUPERSERVER-01_2016-1... Starting   13.12.2016 15:42:08    01.01.1900 0:00:00     None",
            "title": "PowerShell script to perform scheduled backup on free version of Veeam"
        },
        {
            "location": "/Tech/BigData/Zookeper_grow/",
            "text": "Adding 2 nodes to an existing 3-node ZooKeeper ensemble without losing the Quorum\n\n\nSince many deployments may start out with 3 nodes and so little is known about how to grow a cluster from 3 memebrs to 5 members without losing the existing Quorum, here is an example of how this might be achieved.\n\n\nStep 1: Have a healthy 3-node ensemble\n\n\nEnsure all 3 nodes are up, one is the leader, and all are in sync\nInitial setup:\n\n\n    sudo apt-get update\n    sudo apt-get install -y openjdk-6-jre-headless vim\n\n    mkdir ~/zook\n    cd ~/zook\n    wget http://apache.claz.org/zookeeper/zookeeper-3.4.5/zookeeper-3.4.5.tar.gz # You may wish to choose a closer mirror\n    tar xzf zookeeper-3.4.5.tar.gz\n    for i in `seq 5` ; do mkdir conf$i ; echo $i > conf$i/myid ; done\n\n    tickTime=2000\n    dataDir=/home/user/zook/conf1\n    clientPort=2181\n    initLimit=50\n    syncLimit=200\n    server.1=localhost:2881:3881\n    server.2=localhost:2882:3882\n    server.3=localhost:2883:3883\n\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf1/zoo.cfg\n\n\n    tickTime=2000\n    dataDir=/home/user/zook/conf2\n    clientPort=2182\n    initLimit=50\n    syncLimit=200\n    server.1=localhost:2881:3881\n    server.2=localhost:2882:3882\n    server.3=localhost:2883:3883\n\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf2/zoo.cfg\n\n\n    tickTime=2000\n    dataDir=/home/user/zook/conf3\n    clientPort=2183\n    initLimit=50\n    syncLimit=200\n    server.1=localhost:2881:3881\n    server.2=localhost:2882:3882\n    server.3=localhost:2883:3883\n\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf3/zoo.cfg\n\n\n\n\nStep 2: Set up 2 new nodes to join the cluster\n\n\nStart the service, see the nodes join the cluster, snapshot the data and become active.\n\n\n    tickTime=2000\n    dataDir=/home/user/zook/conf4\n    clientPort=2184\n    initLimit=50\n    syncLimit=200\n    server.1=localhost:2881:3881\n    server.2=localhost:2882:3882\n    server.3=localhost:2883:3883\n    server.4=localhost:2884:3884\n    server.5=localhost:2885:3885\n\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf4/zoo.cfg\n\n\n    tickTime=2000\n    dataDir=/home/user/zook/conf5\n    clientPort=2185\n    initLimit=50\n    syncLimit=200\n    server.1=localhost:2881:3881\n    server.2=localhost:2882:3882\n    server.3=localhost:2883:3883\n    server.4=localhost:2884:3884\n    server.5=localhost:2885:3885\n\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf5/zoo.cfg\n\n\n\n\nStep 3: Add the 2 new nodes config to existing cluster\n\n\n    for i in `seq 3` ;do vim conf$i/zoo.cfg ; done\n\n    server.4=localhost:2884:3884\n    server.5=localhost:2885:3885\n\n\n\n\nSave files.\n\n\nStep 4: Restart Followers with new config\n\n\n    # Stop this instance with Ctrl+C, then run\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf2/zoo.cfg\n\n\n\n\nEnsure that is joins the ensemble, repeat with other Follower.\n\n\n    # Ctrl+C\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf3/zoo.cfg\n\n\n\n\nStep 5: Restart the Leader\n\n\nEnsure that all 4 nodes have network conenctivity to each other on the designated ports, and then bounce the Leader.\n\n\n    # Ctrl+C\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf1/zoo.cfg",
            "title": "Zookeper grow"
        },
        {
            "location": "/Tech/BigData/Zookeper_grow/#adding-2-nodes-to-an-existing-3-node-zookeeper-ensemble-without-losing-the-quorum",
            "text": "Since many deployments may start out with 3 nodes and so little is known about how to grow a cluster from 3 memebrs to 5 members without losing the existing Quorum, here is an example of how this might be achieved.",
            "title": "Adding 2 nodes to an existing 3-node ZooKeeper ensemble without losing the Quorum"
        },
        {
            "location": "/Tech/BigData/Zookeper_grow/#step-1-have-a-healthy-3-node-ensemble",
            "text": "Ensure all 3 nodes are up, one is the leader, and all are in sync\nInitial setup:      sudo apt-get update\n    sudo apt-get install -y openjdk-6-jre-headless vim\n\n    mkdir ~/zook\n    cd ~/zook\n    wget http://apache.claz.org/zookeeper/zookeeper-3.4.5/zookeeper-3.4.5.tar.gz # You may wish to choose a closer mirror\n    tar xzf zookeeper-3.4.5.tar.gz\n    for i in `seq 5` ; do mkdir conf$i ; echo $i > conf$i/myid ; done\n\n    tickTime=2000\n    dataDir=/home/user/zook/conf1\n    clientPort=2181\n    initLimit=50\n    syncLimit=200\n    server.1=localhost:2881:3881\n    server.2=localhost:2882:3882\n    server.3=localhost:2883:3883\n\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf1/zoo.cfg\n\n\n    tickTime=2000\n    dataDir=/home/user/zook/conf2\n    clientPort=2182\n    initLimit=50\n    syncLimit=200\n    server.1=localhost:2881:3881\n    server.2=localhost:2882:3882\n    server.3=localhost:2883:3883\n\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf2/zoo.cfg\n\n\n    tickTime=2000\n    dataDir=/home/user/zook/conf3\n    clientPort=2183\n    initLimit=50\n    syncLimit=200\n    server.1=localhost:2881:3881\n    server.2=localhost:2882:3882\n    server.3=localhost:2883:3883\n\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf3/zoo.cfg",
            "title": "Step 1: Have a healthy 3-node ensemble"
        },
        {
            "location": "/Tech/BigData/Zookeper_grow/#step-2-set-up-2-new-nodes-to-join-the-cluster",
            "text": "Start the service, see the nodes join the cluster, snapshot the data and become active.      tickTime=2000\n    dataDir=/home/user/zook/conf4\n    clientPort=2184\n    initLimit=50\n    syncLimit=200\n    server.1=localhost:2881:3881\n    server.2=localhost:2882:3882\n    server.3=localhost:2883:3883\n    server.4=localhost:2884:3884\n    server.5=localhost:2885:3885\n\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf4/zoo.cfg\n\n\n    tickTime=2000\n    dataDir=/home/user/zook/conf5\n    clientPort=2185\n    initLimit=50\n    syncLimit=200\n    server.1=localhost:2881:3881\n    server.2=localhost:2882:3882\n    server.3=localhost:2883:3883\n    server.4=localhost:2884:3884\n    server.5=localhost:2885:3885\n\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf5/zoo.cfg",
            "title": "Step 2: Set up 2 new nodes to join the cluster"
        },
        {
            "location": "/Tech/BigData/Zookeper_grow/#step-3-add-the-2-new-nodes-config-to-existing-cluster",
            "text": "for i in `seq 3` ;do vim conf$i/zoo.cfg ; done\n\n    server.4=localhost:2884:3884\n    server.5=localhost:2885:3885  Save files.",
            "title": "Step 3: Add the 2 new nodes config to existing cluster"
        },
        {
            "location": "/Tech/BigData/Zookeper_grow/#step-4-restart-followers-with-new-config",
            "text": "# Stop this instance with Ctrl+C, then run\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf2/zoo.cfg  Ensure that is joins the ensemble, repeat with other Follower.      # Ctrl+C\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf3/zoo.cfg",
            "title": "Step 4: Restart Followers with new config"
        },
        {
            "location": "/Tech/BigData/Zookeper_grow/#step-5-restart-the-leader",
            "text": "Ensure that all 4 nodes have network conenctivity to each other on the designated ports, and then bounce the Leader.      # Ctrl+C\n    zookeeper-3.4.5/bin/zkServer.sh start-foreground conf1/zoo.cfg",
            "title": "Step 5: Restart the Leader"
        },
        {
            "location": "/Tech/Messaging/Email_Telnet/",
            "text": "Send email\n\n\nOriginal at \nMediatemple\n\n\n\n\nTIP: We use the domain example.com as an example. Be sure to replace with your own domain.\n\n\n\n\n\n\nOpen your command prompt. Now, connect with telnet using the following command:\n\n\n\n\ntelnet example.com 25\n\n\n\n\n\n\nType ehlo example.com. Some servers also accept helo in place of ehlo.\n\n\n\n\nehlo example.com\n\n\n\n\n\n\nType mail from: username@example.com:\n\n\n\n\nmail from: username@example.com\n\n\n\n\n\n\nType rcpt to: friend@hotmail.com, friend2@yahoo.com (replace with your actual recipient name):\n\n\n\n\nrcpt to: friend@hotmail.com, friend2@yahoo.com\n\n\n\n\n\n\nTo write the message - type data, followed by your subject and message. To end the message, put a period on a line by itself and press enter:\n\n\n\n\ndata\nSubject: My Telnet Test Email\n\nHello,\n\nThis is an email sent by using the telnet command.\n\nYour friend,\nMe\n\n.\n\n\n\n\n\n\nType quit to exit telnet.\n\n\n\n\nquit\n\n\n\n\nHow to check or read email\n\n\nOriginal at  \nMediatemple\n\n* Open your command prompt. At the command prompt, type in\n\n\ntelnet example.com 110\n\n\n\n\n\n\nType user and the email address (username@example.com) of the user for which you wish to view emails:\n\n\n\n\nuser username@example.com\n\n\n\n\n\n\nThen type in pass followed by your password:\n\n\n\n\npass yourpasswordgoeshere\n\n\n\n\n\n\nType list to bring up a list of your emails:\n\n\n\n\nlist\n\n\n\n\n\n\nYou will see a list of items with labels like \"1 897\" and \"2 5136.\" Here is an example:\n\n\n\n\nlist\n+OK POP3 clients that break here, they violate STD53.\n1 897\n2 5136\n3 1884\n4 2973\n5 2595\n6 3063\n7 3509\n8 2283\n9 1926\n10 2763\n11 1795\n12 2780\n13 2342\n14 2342\n15 2342\n16 3833\n17 2211\n18 793\n19 797\n20 2599\n.\n\n\n\n\n\n\nIf you wish to read an email message such as 2 5136, you can type the following:\n\n\n\n\nretr 2 \n\n\n\n\n\n\nIf you want to delete a message such as 1 897, type dele 1:\n\n\n\n\ndele 1\n\n\n\n\n\n\nWhen you are done checking your email, type quit.\n\n\n\n\nquit",
            "title": "Email Telnet"
        },
        {
            "location": "/Tech/Messaging/Email_Telnet/#send-email",
            "text": "Original at  Mediatemple   TIP: We use the domain example.com as an example. Be sure to replace with your own domain.    Open your command prompt. Now, connect with telnet using the following command:   telnet example.com 25   Type ehlo example.com. Some servers also accept helo in place of ehlo.   ehlo example.com   Type mail from: username@example.com:   mail from: username@example.com   Type rcpt to: friend@hotmail.com, friend2@yahoo.com (replace with your actual recipient name):   rcpt to: friend@hotmail.com, friend2@yahoo.com   To write the message - type data, followed by your subject and message. To end the message, put a period on a line by itself and press enter:   data\nSubject: My Telnet Test Email\n\nHello,\n\nThis is an email sent by using the telnet command.\n\nYour friend,\nMe\n\n.   Type quit to exit telnet.   quit",
            "title": "Send email"
        },
        {
            "location": "/Tech/Messaging/Email_Telnet/#how-to-check-or-read-email",
            "text": "Original at   Mediatemple \n* Open your command prompt. At the command prompt, type in  telnet example.com 110   Type user and the email address (username@example.com) of the user for which you wish to view emails:   user username@example.com   Then type in pass followed by your password:   pass yourpasswordgoeshere   Type list to bring up a list of your emails:   list   You will see a list of items with labels like \"1 897\" and \"2 5136.\" Here is an example:   list\n+OK POP3 clients that break here, they violate STD53.\n1 897\n2 5136\n3 1884\n4 2973\n5 2595\n6 3063\n7 3509\n8 2283\n9 1926\n10 2763\n11 1795\n12 2780\n13 2342\n14 2342\n15 2342\n16 3833\n17 2211\n18 793\n19 797\n20 2599\n.   If you wish to read an email message such as 2 5136, you can type the following:   retr 2    If you want to delete a message such as 1 897, type dele 1:   dele 1   When you are done checking your email, type quit.   quit",
            "title": "How to check or read email"
        },
        {
            "location": "/Tech/Messaging/Postfix/",
            "text": "Show configuration\n\n\n~ # postconf\n\n\n\n\nShow only non-default values\n\n\n~ # postconf -n\n\n\n\n\nDisplay all default values\n\n\n~ # postconf -d\n\n\n\n\nList map lookup types\n\n\n~ # postconf -m\n\n\n\n\nShow queue\n\n\nmqilq\npostqueue -p",
            "title": "Postfix"
        },
        {
            "location": "/Tech/Messaging/Postfix/#show-configuration",
            "text": "~ # postconf",
            "title": "Show configuration"
        },
        {
            "location": "/Tech/Messaging/Postfix/#show-only-non-default-values",
            "text": "~ # postconf -n",
            "title": "Show only non-default values"
        },
        {
            "location": "/Tech/Messaging/Postfix/#display-all-default-values",
            "text": "~ # postconf -d",
            "title": "Display all default values"
        },
        {
            "location": "/Tech/Messaging/Postfix/#list-map-lookup-types",
            "text": "~ # postconf -m",
            "title": "List map lookup types"
        },
        {
            "location": "/Tech/Messaging/Postfix/#show-queue",
            "text": "mqilq\npostqueue -p",
            "title": "Show queue"
        },
        {
            "location": "/Tech/Messaging/SMS/",
            "text": "Via minicom\n\n\n\n\nminicom -s\n\n\n\n\nAT+CMGF=1\nAT+CMGS=\"+xxxxxxxxxx\"\nWrite message here. <ctrl+z>\n\n\n\n\nSMSd\n\n\nsmssend +xxxxxxxxxxx 'One-Line Test 02' > /dev/null 2>&1\n\n\n\n\n\n\nExample smsd.conf. Read the manual for a description\n\n\n\n\ndevices = xenium0\nlogfile = /var/log/smsd/smsd.log\nloglevel = 2\n#user = smstools\nuser = nagios\n# 3.1.5 introduced smart logging\n# once your configuration is OK, set log level lower (5 is good in most cases)\nsmart_logging = yes\ninfofile = /run/smsd/smsd.working\npidfile = /run/smsd/smsd.pid\n\n[xenium0]\ndevice = /dev/ttyUSB0\n#pin = 1122\npin = ignore\nbaudrate = 115200\nrtscts = no\n#init = ATE0\n#init = at+cpms=\"sm\",\"sm\",\"\"\n#init = AT+CMGF=1\nloglevel_lac_ci = 8\nincoming = yes\nincoming = high",
            "title": "SMS"
        },
        {
            "location": "/Tech/Messaging/SMS/#via-minicom",
            "text": "minicom -s   AT+CMGF=1\nAT+CMGS=\"+xxxxxxxxxx\"\nWrite message here. <ctrl+z>",
            "title": "Via minicom"
        },
        {
            "location": "/Tech/Messaging/SMS/#smsd",
            "text": "smssend +xxxxxxxxxxx 'One-Line Test 02' > /dev/null 2>&1   Example smsd.conf. Read the manual for a description   devices = xenium0\nlogfile = /var/log/smsd/smsd.log\nloglevel = 2\n#user = smstools\nuser = nagios\n# 3.1.5 introduced smart logging\n# once your configuration is OK, set log level lower (5 is good in most cases)\nsmart_logging = yes\ninfofile = /run/smsd/smsd.working\npidfile = /run/smsd/smsd.pid\n\n[xenium0]\ndevice = /dev/ttyUSB0\n#pin = 1122\npin = ignore\nbaudrate = 115200\nrtscts = no\n#init = ATE0\n#init = at+cpms=\"sm\",\"sm\",\"\"\n#init = AT+CMGF=1\nloglevel_lac_ci = 8\nincoming = yes\nincoming = high",
            "title": "SMSd"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/",
            "text": "Top\n\n\nThis is a small tool which is pre-installed on many unix systems. When you want an overview of all the processes or threads running in the system: top is a good tool. Order processes on different criteria \u2013 the default of which is CPU.\n\n\n\n\nhtop\n\n\nHtop is essentially an enhanced version of top. It\u2019s easier to sort by processes. It\u2019s visually easier to understand and has built in commands for common things you would like to do. Plus it\u2019s fully interactive.\n\n\n\n\natop\n\n\nAtop monitors all processes much like top and htop, unlike top and htop however it has daily logging of the processes for long-term analysis. It also shows resource consumption by all processes. It will also highlight resources that have reached a critical load.\n\n\n\n\napachetop\n\n\nApachetop monitors the overall performance of your apache webserver. It\u2019s largely based on mytop. It displays current number of reads, writes and the overall number of requests processed.\n\n\n\n\nftptop\n\n\nftptop gives you basic information of all the current ftp connections to your server such as the total amount of sessions, how many are uploading and downloading and who the client is.\n\n\n\n\nmytop\n\n\nmytop is a neat tool for monitoring threads and performance of mysql. It gives you a live look into the database and what queries it\u2019s processing in real time.\n\n\n\n\npowertop\n\n\npowertop helps you diagnose issues that has to do with power consumption and power management. It can also help you experiment with power management settings to achieve the most efficient settings for your server. You switch tabs with the tab key.\n\n\n\n\niotop\n\n\niotop checks the I/O usage information and gives you a top-like interface to that. It displays columns on read and write and each row represents a process. It also displays the percentage of time the process spent while swapping in and while waiting on I/O.\n\n\n\n\nntopng\n\n\nntopng is the next generation of ntop and the tool provides a graphical user interface via the browser for network monitoring. It can do stuff such as: geolocate hosts, get network traffic and show ip traffic distribution and analyze it.\n\n\n\n\niftop\n\n\niftop is similar to top, but instead of mainly checking for cpu usage it listens to network traffic on selected network interfaces and displays a table of current usage. It can be handy for answering questions such as \u201cWhy on earth is my internet connection so slow?!\u201d.\n\n\n\n\njnettop\n\n\njnettop visualises network traffic in much the same way as iftop does. It also supports customizable text output and a machine-friendly mode to support further analysis.\n\n\n\n\nbandwidthd\n\n\nBandwidthD tracks usage of TCP/IP network subnets and visualises that in the browser by building a html page with graphs in png. There is a database driven system that supports searching, filtering, multiple sensors and custom reports.\n\n\n\n\nEtherApe\n\n\nEtherApe displays network traffic graphically, the more talkative the bigger the node. It either captures live traffic or can read it from a tcpdump. The displayed can also be refined using a network filter with pcap syntax.\n\n\n\n\nethtool\n\n\nethtool is used for displaying and modifying some parameters of the network interface controllers. It can also be used to diagnose Ethernet devices and get more statistics from the devices.\n\n\n\n\nNetHogs\n\n\nNetHogs breaks down network traffic per protocol or per subnet. It then groups by process. So if there\u2019s a surge in network traffic you can fire up NetHogs and see which process is causing it.\n\n\n\n\niptraf\n\n\niptraf gathers a variety of metrics such as TCP connection packet and byte count, interface statistics and activity indicators, TCP/UDP traffic breakdowns and station packet and byte counts.\n\n\n\n\nngrep\n\n\nngrep is grep but for the network layer. It\u2019s pcap aware and will allow to specify extended regular or hexadecimal expressions to match against packets of .\n\n\n\n\nMRTG\n\n\nMRTG was orginally developed to monitor router traffic, but now it\u2019s able to monitor other network related things as well. It typically collects every five minutes and then generates a html page. It also has the capability of sending warning emails.\n\n\n\n\nbmon\n\n\nBmon monitors and helps you debug networks. It captures network related statistics and presents it in human friendly way. You can also interact with bmon through curses or through scripting.\n\n\n\n\ntraceroute\n\n\nTraceroute is a built-in tool for displaying the route and measuring the delay of packets across a network.\n\n\n\n\nIPTState\n\n\nIPTState allows you to watch where traffic that crosses your iptables is going and then sort that by different criteria as you please. The tool also allows you to delete states from the table.\n\n\n\n\ndarkstat\n\n\nDarkstat captures network traffic and calculates statistics about usage. The reports are served over a simple HTTP server and gives you a nice graphical user interface of the graphs.\n\n\n\n\nvnStat\n\n\nvnStat is a network traffic monitor that uses statistics provided by the kernel which ensures light use of system resources. The gathered statistics persists through system reboots. It has color options for the artistic sysadmins.\n\n\n\n\nnetstat\n\n\nNetstat is a built-in tool that displays TCP network connections, routing tables and a number of network interfaces. It\u2019s used to find problems in the network.\n\n\n\n\nss\n\n\nInstead of using netstat, it\u2019s however preferable to use ss. The ss command is capable of showing more information than netstat and is actually faster. If you want a summary statistics you can use the command ss -s.\n\n\n\n\nnmap\n\n\nNmap allows you to scan your server for open ports or detect which OS is being used. But you could also use this for SQL injection vulnerabilities, network discovery and other means related to penetration testing.\n\n\n\n\nMTR\n\n\nMTR combines the functionality of traceroute and the ping tool into a single network diagnostic tool. When using the tool it will limit the number hops individual packets has to travel while also listening to their expiry. It then repeats this every second.\n\n\n\n\ntcpdump\n\n\ntcpdump will output a description of the contents of the packet it just captured which matches the expression that you provided in the command. You can also save the this data for further analysis.\n\n\n\n\nJustniffer\n\n\nJustniffer is a tcp packet sniffer. You can choose whether you would like to collect low-level data or high-level data with this sniffer. It also allows you to generate logs in customizable way. You could for instance mimic the access log that apache has.\n\n\n\n\nServer Density\n\n\nOur server monitoring tool! It has a web interface that allows you to set alerts and view graphs for all system and network metrics. You can also set up monitoring of websites whether they are up or down. Server Density allows you to set permissions for users and you can extend your monitoring with our plugin infrastructure or api. The service already supports Nagios plugins.\n\n\n\n\nOpenNMS\n\n\nOpenNMS has four main functional areas: event management and notifications; discovery and provisioning; service monitoring and data collection. It\u2019s designed to be customizable to work in a variety of network environments.\n\n\n\n\nSysUsage\n\n\nSysUsage monitors your system continuously via Sar and other system commands. It also allows notifications to alarm you once a threshold is reached. SysUsage itself can be run from a centralized place where all the collected statistics are also being stored. It has a web interface where you can view all the stats.\n\n\n\n\nbrainypdm\n\n\nbrainypdm is a data management and monitoring tool that has the capability to gather data from nagios or another generic source to make graphs. It\u2019s cross-platform, has custom graphs and is web based.\n\n\n\n\nPCP\n\n\nPCP has the capability of collating metrics from multiple hosts and does so efficiently. It also has a plugin framework so you can make it collect specific metrics that is important to you. You can access graph data through either a web interface or a GUI. Good for monitoring large systems.\n\n\n\n\nKDE system guard\n\n\nThis tool is both a system monitor and task manager. You can view server metrics from several machines through the worksheet and if a process needs to be killed or if you need to start a process it can be done within KDE system guard.\n\n\n\n\nMunin\n\n\nMunin is both a network and a system monitoring tool which offers alerts for when metrics go beyond a given threshold. It uses RRDtool to create the graphs and it has web interface to display these graphs. Its emphasis is on plug and play capabilities with a number of plugins available.\n\n\n\n\nNagios\n\n\nNagios is system and network monitoring tool that helps you monitor monitor your many servers. It has support for alerting for when things go wrong. It also has many plugins written for the platform.\n\n\n\n\nZenoss\n\n\nZenoss provides a web interface that allows you to monitor all system and network metrics. Moreover it discovers network resources and changes in network configurations. It has alerts for you to take action on and it supports the Nagios plugins.\n\n\n\n\nCacti\n\n\n(And one for luck!) Cacti is network graphing solution that uses the RRDtool data storage. It allows a user to poll services at predetermined intervals and graph the result. Cacti can be extended to monitor a source of your choice through shell scripts.\n\n\n\n\nZabbix\n\n\nZabbix is an open source infrastructure monitoring solution. It can use most databases out there to store the monitoring statistics. The Core is written in C and has a frontend in PHP. If you don\u2019t like installing an agent, Zabbix might be an option for you.\n\n\n\n\nnmon\n\n\nnmon either outputs the data on screen or saves it in a comma separated file. You can display CPU, memory, network, filesystems, top processes. The data can also be added to a RRD database for further analysis.\n\n\n\n\nconky\n\n\nConky monitors a plethora of different OS stats. It has support for IMAP and POP3 and even support for many popular music players! For the handy person you could extend it with your own scripts or programs using Lua.\n\n\n\n\nGlances\n\n\nGlances monitors your system and aims to present a maximum amount of information in a minimum amount of space. It has the capability to function in a client/server mode as well as monitoring remotely. It also has a web interface.\n\n\n\n\nsaidar\n\n\nSaidar is a very small tool that gives you basic information about your system resources. It displays a full screen of the standard system resources. The emphasis for saidar is being as simple as possible.\n\n\n\n\nRRDtool\n\n\nRRDtool is a tool developed to handle round-robin databases or RRD. RRD aims to handle time-series data like CPU load, temperatures etc. This tool provides a way to extract RRD data in a graphical format.\n\n\n\n\nmonit\n\n\nMonit has the capability of sending you alerts as well as restarting services if they run into trouble. It\u2019s possible to perform any type of check you could write a script for with monit and it has a web user interface to ease your eyes.\n\n\n\n\nLinux process explorer\n\n\nLinux process explorer is akin to the activity monitor for OSX or the windows equivalent. It aims to be more usable than top or ps. You can view each process and see how much memory usage or CPU it uses.\n\n\n\n\ndf\n\n\ndf is an abbreviation for disk free and is pre-installed program in all unix systems used to display the amount of available disk space for filesystems which the user have access to.\n\n\n\n\ndiscus\n\n\nDiscus is similar to df however it aims to improve df by making it prettier using fancy features as colors, graphs and smart formatting of numbers.\n\n\n\n\nxosview\n\n\nxosview is a classic system monitoring tool and it gives you a simple overview of all the different parts of the including IRQ.\n\n\n\n\nDstat\n\n\nDstat aims to be a replacement for vmstat, iostat, netstat and ifstat. It allows you to view all of your system resources in real-time. The data can then be exported into csv. Most importantly dstat allows for plugins and could thus be extended into areas not yet known to mankind.\n\n\n\n\nNet-SNMP\n\n\nSNMP is the protocol \u2018simple network management protocol\u2019 and the Net-SNMP tool suite helps you collect accurate information about your servers using this protocol.\n\n\n\n\nincron\n\n\nIncron allows you to monitor a directory tree and then take action on those changes. If you wanted to copy files to directory \u2018b\u2019 once new files appeared in directory \u2018a\u2019 that\u2019s exactly what incron does.\n\n\n\n\nmonitorix\n\n\nMonitorix is lightweight system monitoring tool. It helps you monitor a single machine and gives you a wealth of metrics. It also has a built-in HTTP server to view graphs and a reporting mechanism of all metrics.\n\n\n\n\nvmstat\n\n\nvmstat or virtual memory statistics is a small built-in tool that monitors and displays a summary about the memory in the machine.\n\n\n\n\nuptime\n\n\nThis small command that quickly gives you information about how long the machine has been running, how many users currently are logged on and the system load average for the past 1, 5 and 15 minutes.\n\n\n\n\nmpstat\n\n\nmpstat is a built-in tool that monitors cpu usage. The most common command is using mpstat -P ALL which gives you the usage of all the cores. You can also get an interval update of the CPU usage.\n\n\n\n\npmap\n\n\npmap is a built-in tool that reports the memory map of a process. You can use this command to find out causes of memory bottlenecks.\n\n\n\n\nps\n\n\nThe ps command will give you an overview of all the current processes. You can easily select all processes using the command ps -A\n\n\n\n\nsar\n\n\nsar is a part of the sysstat package and helps you to collect, report and save different system metrics. With different commands it will give you CPU, memory and I/O usage among other things.\n\n\n\n\ncollectl\n\n\nSimilar to sar collectl collects performance metrics for your machine. By default it shows cpu, network and disk stats but it collects a lot more. The difference to sar is collectl is able to deal with times below 1 second, it can be fed into a plotting tool directly and collectl monitors processes more extensively.\n\n\n\n\niostat\n\n\niostat is also part of the sysstat package. This command is used for monitoring system input/output. The reports themselves can be used to change system configurations to better balance input/output load between hard drives in your machine.\n\n\n\n\nfree\n\n\nThis is a built-in command that displays the total amount of free and used physical memory on your machine. It also displays the buffers used by the kernel at that given moment.\n\n\n\n\n/Proc file system\n\n\nThe proc file system gives you a peek into kernel statistics. From these statistics you can get detailed information about the different hardware devices on your machine. Take a look at the full list of the proc file statistics\n\n\n\n\nGKrellM\n\n\nGKrellm is a gui application that monitor the status of your hardware such CPU, main memory, hard disks, network interfaces and many other things. It can also monitor and launch a mail reader of your choice.\n\n\n\n\nGnome system monitor\n\n\nGnome system monitor is a basic system monitoring tool that has features looking at process dependencies from a tree view, kill or renice processes and graphs of all server metrics.\n\n\n\n\nGoAccess\n\n\nGoAccess is a real-time web log analyzer which analyzes the access log from either apache, nginx or amazon cloudfront. It\u2019s also possible to output the data into HTML, JSON or CSV. It will give you general statistics, top visitors, 404s, geolocation and many other things.\n\n\n\n\nLogwatch\n\n\nLogwatch is a log analysis system. It parses through your system\u2019s logs and creates a report analyzing the areas that you specify. It can give you daily reports with short digests of the activities taking place on your machine.\n\n\n\n\nSwatch\n\n\nMuch like Logwatch Swatch also monitors your logs, but instead of giving reports it watches for regular expression and notifies you via mail or the console when there is a match. It could be used for intruder detection for example.\n\n\n\n\nMultiTail\n\n\nMultiTail helps you monitor logfiles in multiple windows. You can merge two or more of these logfiles into one. It will also use colors to display the logfiles for easier reading with the help of regular expressions.\n\n\n\n\nacct or psacct\n\n\nacct or psacct (depending on if you use apt-get or yum) allows you to monitor all the commands a users executes inside the system including CPU and memory time. Once installed you get that summary with the command \u2018sa\u2019.\n\n\n\n\nwhowatch\n\n\nSimilar to acct this tool monitors users on your system and allows you to see in real time what commands and processes they are using. It gives you a tree structure of all the processes and so you can see exactly what\u2019s happening.\n\n\n\n\nstrace\n\n\nstrace is used to diagnose, debug and monitor interactions between processes. The most common thing to do is making strace print a list of system calls made by the program which is useful if the program does not behave as expected.\n\n\n\n\nDTrace\n\n\nDTrace is the big brother of strace. It dynamically patches live running instructions with instrumentation code. This allows you to do in-depth performance analysis and troubleshooting. However, it\u2019s not for the weak of heart as there is a 1200 book written on the topic.\n\n\n\n\nwebmin\n\n\nWebmin is a web-based system administration tool. It removes the need to manually edit unix configuration files and lets you manage the system remotely if need be. It has a couple of monitoring modules that you can attach to it.\n\n\n\n\nstat\n\n\nStat is a built-in tool for displaying status information of files and file systems. It will give you information such as when the file was modified, accessed or changed.\n\n\n\n\nifconfig\n\n\nifconfig is a built-in tool used to configure the network interfaces. Behind the scenes network monitor tools use ifconfig to set it into promiscuous mode to capture all packets. You can do it yourself with ifconfig eth0 promisc and return to normal mode with ifconfig eth0 -promisc.\n\n\n\n\nulimit\n\n\nulimit is a built-in tool that monitors system resources and keeps a limit so any of the monitored resources don\u2019t go overboard. For instance making a fork bomb where a properly configured ulimit is in place would be totally fine.\n\n\n\n\ncpulimit\n\n\nCPUlimit is a small tool that monitors and then limits the CPU usage of a process. It\u2019s particularly useful to make batch jobs not eat up too many CPU cycles.\n\n\n\n\nlshw\n\n\nlshw is a small built-in tool extract detailed information about the hardware configuration of the machine. It can output everything from CPU version and speed to mainboard configuration.\n\n\n\n\nw\n\n\nW is a built-in command that displays information about the users currently using the machine and their processes.\n\n\n\n\nlsof\n\n\nlsof is a built-in tool that gives you a list of all open files and network connections. From there you can narrow it down to files opened by processes, based on the process name, by a specific user or perhaps kill all processes that belongs to a specific user.\n\n\n\n\ncollectd\n\n\nCollectd is a Unix daemon that collects all your monitoring statistics. It uses a modular design and plugins to fill in any niche monitoring. This way collectd stays as lightweight and customizable as possible.\n\n\n\n\nObservium\n\n\nObservium is an auto-discovering network monitoring platform supporting a wide range of hardware platforms and operating systems. Observium focuses on providing a beautiful and powerful yet simple and intuitive interface to the health and status of your network.\n\n\n\n\nNload\n\n\nIt\u2019s a command line tool that monitors network throughput. It\u2019s neat because it visualizes the in and and outgoing traffic using two graphs and some additional useful data like total amount of transferred data. You can install it with \nyum install nload\nor \n1 sudo apt-get install nload\n\n\n\n\nSmokePing\n\n\nSmokePing keeps track of the network latencies of your network and it visualises them too. There are a wide range of latency measurement plugins developed for SmokePing. If a GUI is important to you it\u2019s there is an ongoing development to make that happen.\n\n\n\n\nMobaXterm\n\n\nIf you\u2019re working in windows environment day in and day out. You may feel limited by the terminal Windows provides. MobaXterm comes to the rescue and allows you to use many of the terminal commands commonly found in Linux. Which will help you tremendously in your monitoring needs!\n\n\n\n\nShinken monitoring\n\n\nShinken is a monitoring framework which is a total rewrite of Nagios in python. It aims to enhance flexibility and managing a large environment. While still keeping all your nagios configuration and plugins.",
            "title": "80 tools for monitoring"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#top",
            "text": "This is a small tool which is pre-installed on many unix systems. When you want an overview of all the processes or threads running in the system: top is a good tool. Order processes on different criteria \u2013 the default of which is CPU.",
            "title": "Top"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#htop",
            "text": "Htop is essentially an enhanced version of top. It\u2019s easier to sort by processes. It\u2019s visually easier to understand and has built in commands for common things you would like to do. Plus it\u2019s fully interactive.",
            "title": "htop"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#atop",
            "text": "Atop monitors all processes much like top and htop, unlike top and htop however it has daily logging of the processes for long-term analysis. It also shows resource consumption by all processes. It will also highlight resources that have reached a critical load.",
            "title": "atop"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#apachetop",
            "text": "Apachetop monitors the overall performance of your apache webserver. It\u2019s largely based on mytop. It displays current number of reads, writes and the overall number of requests processed.",
            "title": "apachetop"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#ftptop",
            "text": "ftptop gives you basic information of all the current ftp connections to your server such as the total amount of sessions, how many are uploading and downloading and who the client is.",
            "title": "ftptop"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#mytop",
            "text": "mytop is a neat tool for monitoring threads and performance of mysql. It gives you a live look into the database and what queries it\u2019s processing in real time.",
            "title": "mytop"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#powertop",
            "text": "powertop helps you diagnose issues that has to do with power consumption and power management. It can also help you experiment with power management settings to achieve the most efficient settings for your server. You switch tabs with the tab key.",
            "title": "powertop"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#iotop",
            "text": "iotop checks the I/O usage information and gives you a top-like interface to that. It displays columns on read and write and each row represents a process. It also displays the percentage of time the process spent while swapping in and while waiting on I/O.",
            "title": "iotop"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#ntopng",
            "text": "ntopng is the next generation of ntop and the tool provides a graphical user interface via the browser for network monitoring. It can do stuff such as: geolocate hosts, get network traffic and show ip traffic distribution and analyze it.",
            "title": "ntopng"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#iftop",
            "text": "iftop is similar to top, but instead of mainly checking for cpu usage it listens to network traffic on selected network interfaces and displays a table of current usage. It can be handy for answering questions such as \u201cWhy on earth is my internet connection so slow?!\u201d.",
            "title": "iftop"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#jnettop",
            "text": "jnettop visualises network traffic in much the same way as iftop does. It also supports customizable text output and a machine-friendly mode to support further analysis.",
            "title": "jnettop"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#bandwidthd",
            "text": "BandwidthD tracks usage of TCP/IP network subnets and visualises that in the browser by building a html page with graphs in png. There is a database driven system that supports searching, filtering, multiple sensors and custom reports.",
            "title": "bandwidthd"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#etherape",
            "text": "EtherApe displays network traffic graphically, the more talkative the bigger the node. It either captures live traffic or can read it from a tcpdump. The displayed can also be refined using a network filter with pcap syntax.",
            "title": "EtherApe"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#ethtool",
            "text": "ethtool is used for displaying and modifying some parameters of the network interface controllers. It can also be used to diagnose Ethernet devices and get more statistics from the devices.",
            "title": "ethtool"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#nethogs",
            "text": "NetHogs breaks down network traffic per protocol or per subnet. It then groups by process. So if there\u2019s a surge in network traffic you can fire up NetHogs and see which process is causing it.",
            "title": "NetHogs"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#iptraf",
            "text": "iptraf gathers a variety of metrics such as TCP connection packet and byte count, interface statistics and activity indicators, TCP/UDP traffic breakdowns and station packet and byte counts.",
            "title": "iptraf"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#ngrep",
            "text": "ngrep is grep but for the network layer. It\u2019s pcap aware and will allow to specify extended regular or hexadecimal expressions to match against packets of .",
            "title": "ngrep"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#mrtg",
            "text": "MRTG was orginally developed to monitor router traffic, but now it\u2019s able to monitor other network related things as well. It typically collects every five minutes and then generates a html page. It also has the capability of sending warning emails.",
            "title": "MRTG"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#bmon",
            "text": "Bmon monitors and helps you debug networks. It captures network related statistics and presents it in human friendly way. You can also interact with bmon through curses or through scripting.",
            "title": "bmon"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#traceroute",
            "text": "Traceroute is a built-in tool for displaying the route and measuring the delay of packets across a network.",
            "title": "traceroute"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#iptstate",
            "text": "IPTState allows you to watch where traffic that crosses your iptables is going and then sort that by different criteria as you please. The tool also allows you to delete states from the table.",
            "title": "IPTState"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#darkstat",
            "text": "Darkstat captures network traffic and calculates statistics about usage. The reports are served over a simple HTTP server and gives you a nice graphical user interface of the graphs.",
            "title": "darkstat"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#vnstat",
            "text": "vnStat is a network traffic monitor that uses statistics provided by the kernel which ensures light use of system resources. The gathered statistics persists through system reboots. It has color options for the artistic sysadmins.",
            "title": "vnStat"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#netstat",
            "text": "Netstat is a built-in tool that displays TCP network connections, routing tables and a number of network interfaces. It\u2019s used to find problems in the network.",
            "title": "netstat"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#ss",
            "text": "Instead of using netstat, it\u2019s however preferable to use ss. The ss command is capable of showing more information than netstat and is actually faster. If you want a summary statistics you can use the command ss -s.",
            "title": "ss"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#nmap",
            "text": "Nmap allows you to scan your server for open ports or detect which OS is being used. But you could also use this for SQL injection vulnerabilities, network discovery and other means related to penetration testing.",
            "title": "nmap"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#mtr",
            "text": "MTR combines the functionality of traceroute and the ping tool into a single network diagnostic tool. When using the tool it will limit the number hops individual packets has to travel while also listening to their expiry. It then repeats this every second.",
            "title": "MTR"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#tcpdump",
            "text": "tcpdump will output a description of the contents of the packet it just captured which matches the expression that you provided in the command. You can also save the this data for further analysis.",
            "title": "tcpdump"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#justniffer",
            "text": "Justniffer is a tcp packet sniffer. You can choose whether you would like to collect low-level data or high-level data with this sniffer. It also allows you to generate logs in customizable way. You could for instance mimic the access log that apache has.",
            "title": "Justniffer"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#server-density",
            "text": "Our server monitoring tool! It has a web interface that allows you to set alerts and view graphs for all system and network metrics. You can also set up monitoring of websites whether they are up or down. Server Density allows you to set permissions for users and you can extend your monitoring with our plugin infrastructure or api. The service already supports Nagios plugins.",
            "title": "Server Density"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#opennms",
            "text": "OpenNMS has four main functional areas: event management and notifications; discovery and provisioning; service monitoring and data collection. It\u2019s designed to be customizable to work in a variety of network environments.",
            "title": "OpenNMS"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#sysusage",
            "text": "SysUsage monitors your system continuously via Sar and other system commands. It also allows notifications to alarm you once a threshold is reached. SysUsage itself can be run from a centralized place where all the collected statistics are also being stored. It has a web interface where you can view all the stats.",
            "title": "SysUsage"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#brainypdm",
            "text": "brainypdm is a data management and monitoring tool that has the capability to gather data from nagios or another generic source to make graphs. It\u2019s cross-platform, has custom graphs and is web based.",
            "title": "brainypdm"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#pcp",
            "text": "PCP has the capability of collating metrics from multiple hosts and does so efficiently. It also has a plugin framework so you can make it collect specific metrics that is important to you. You can access graph data through either a web interface or a GUI. Good for monitoring large systems.",
            "title": "PCP"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#kde-system-guard",
            "text": "This tool is both a system monitor and task manager. You can view server metrics from several machines through the worksheet and if a process needs to be killed or if you need to start a process it can be done within KDE system guard.",
            "title": "KDE system guard"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#munin",
            "text": "Munin is both a network and a system monitoring tool which offers alerts for when metrics go beyond a given threshold. It uses RRDtool to create the graphs and it has web interface to display these graphs. Its emphasis is on plug and play capabilities with a number of plugins available.",
            "title": "Munin"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#nagios",
            "text": "Nagios is system and network monitoring tool that helps you monitor monitor your many servers. It has support for alerting for when things go wrong. It also has many plugins written for the platform.",
            "title": "Nagios"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#zenoss",
            "text": "Zenoss provides a web interface that allows you to monitor all system and network metrics. Moreover it discovers network resources and changes in network configurations. It has alerts for you to take action on and it supports the Nagios plugins.",
            "title": "Zenoss"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#cacti",
            "text": "(And one for luck!) Cacti is network graphing solution that uses the RRDtool data storage. It allows a user to poll services at predetermined intervals and graph the result. Cacti can be extended to monitor a source of your choice through shell scripts.",
            "title": "Cacti"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#zabbix",
            "text": "Zabbix is an open source infrastructure monitoring solution. It can use most databases out there to store the monitoring statistics. The Core is written in C and has a frontend in PHP. If you don\u2019t like installing an agent, Zabbix might be an option for you.",
            "title": "Zabbix"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#nmon",
            "text": "nmon either outputs the data on screen or saves it in a comma separated file. You can display CPU, memory, network, filesystems, top processes. The data can also be added to a RRD database for further analysis.",
            "title": "nmon"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#conky",
            "text": "Conky monitors a plethora of different OS stats. It has support for IMAP and POP3 and even support for many popular music players! For the handy person you could extend it with your own scripts or programs using Lua.",
            "title": "conky"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#glances",
            "text": "Glances monitors your system and aims to present a maximum amount of information in a minimum amount of space. It has the capability to function in a client/server mode as well as monitoring remotely. It also has a web interface.",
            "title": "Glances"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#saidar",
            "text": "Saidar is a very small tool that gives you basic information about your system resources. It displays a full screen of the standard system resources. The emphasis for saidar is being as simple as possible.",
            "title": "saidar"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#rrdtool",
            "text": "RRDtool is a tool developed to handle round-robin databases or RRD. RRD aims to handle time-series data like CPU load, temperatures etc. This tool provides a way to extract RRD data in a graphical format.",
            "title": "RRDtool"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#monit",
            "text": "Monit has the capability of sending you alerts as well as restarting services if they run into trouble. It\u2019s possible to perform any type of check you could write a script for with monit and it has a web user interface to ease your eyes.",
            "title": "monit"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#linux-process-explorer",
            "text": "Linux process explorer is akin to the activity monitor for OSX or the windows equivalent. It aims to be more usable than top or ps. You can view each process and see how much memory usage or CPU it uses.",
            "title": "Linux process explorer"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#df",
            "text": "df is an abbreviation for disk free and is pre-installed program in all unix systems used to display the amount of available disk space for filesystems which the user have access to.",
            "title": "df"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#discus",
            "text": "Discus is similar to df however it aims to improve df by making it prettier using fancy features as colors, graphs and smart formatting of numbers.",
            "title": "discus"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#xosview",
            "text": "xosview is a classic system monitoring tool and it gives you a simple overview of all the different parts of the including IRQ.",
            "title": "xosview"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#dstat",
            "text": "Dstat aims to be a replacement for vmstat, iostat, netstat and ifstat. It allows you to view all of your system resources in real-time. The data can then be exported into csv. Most importantly dstat allows for plugins and could thus be extended into areas not yet known to mankind.",
            "title": "Dstat"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#net-snmp",
            "text": "SNMP is the protocol \u2018simple network management protocol\u2019 and the Net-SNMP tool suite helps you collect accurate information about your servers using this protocol.",
            "title": "Net-SNMP"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#incron",
            "text": "Incron allows you to monitor a directory tree and then take action on those changes. If you wanted to copy files to directory \u2018b\u2019 once new files appeared in directory \u2018a\u2019 that\u2019s exactly what incron does.",
            "title": "incron"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#monitorix",
            "text": "Monitorix is lightweight system monitoring tool. It helps you monitor a single machine and gives you a wealth of metrics. It also has a built-in HTTP server to view graphs and a reporting mechanism of all metrics.",
            "title": "monitorix"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#vmstat",
            "text": "vmstat or virtual memory statistics is a small built-in tool that monitors and displays a summary about the memory in the machine.",
            "title": "vmstat"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#uptime",
            "text": "This small command that quickly gives you information about how long the machine has been running, how many users currently are logged on and the system load average for the past 1, 5 and 15 minutes.",
            "title": "uptime"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#mpstat",
            "text": "mpstat is a built-in tool that monitors cpu usage. The most common command is using mpstat -P ALL which gives you the usage of all the cores. You can also get an interval update of the CPU usage.",
            "title": "mpstat"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#pmap",
            "text": "pmap is a built-in tool that reports the memory map of a process. You can use this command to find out causes of memory bottlenecks.",
            "title": "pmap"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#ps",
            "text": "The ps command will give you an overview of all the current processes. You can easily select all processes using the command ps -A",
            "title": "ps"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#sar",
            "text": "sar is a part of the sysstat package and helps you to collect, report and save different system metrics. With different commands it will give you CPU, memory and I/O usage among other things.",
            "title": "sar"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#collectl",
            "text": "Similar to sar collectl collects performance metrics for your machine. By default it shows cpu, network and disk stats but it collects a lot more. The difference to sar is collectl is able to deal with times below 1 second, it can be fed into a plotting tool directly and collectl monitors processes more extensively.",
            "title": "collectl"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#iostat",
            "text": "iostat is also part of the sysstat package. This command is used for monitoring system input/output. The reports themselves can be used to change system configurations to better balance input/output load between hard drives in your machine.",
            "title": "iostat"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#free",
            "text": "This is a built-in command that displays the total amount of free and used physical memory on your machine. It also displays the buffers used by the kernel at that given moment.",
            "title": "free"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#proc-file-system",
            "text": "The proc file system gives you a peek into kernel statistics. From these statistics you can get detailed information about the different hardware devices on your machine. Take a look at the full list of the proc file statistics",
            "title": "/Proc file system"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#gkrellm",
            "text": "GKrellm is a gui application that monitor the status of your hardware such CPU, main memory, hard disks, network interfaces and many other things. It can also monitor and launch a mail reader of your choice.",
            "title": "GKrellM"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#gnome-system-monitor",
            "text": "Gnome system monitor is a basic system monitoring tool that has features looking at process dependencies from a tree view, kill or renice processes and graphs of all server metrics.",
            "title": "Gnome system monitor"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#goaccess",
            "text": "GoAccess is a real-time web log analyzer which analyzes the access log from either apache, nginx or amazon cloudfront. It\u2019s also possible to output the data into HTML, JSON or CSV. It will give you general statistics, top visitors, 404s, geolocation and many other things.",
            "title": "GoAccess"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#logwatch",
            "text": "Logwatch is a log analysis system. It parses through your system\u2019s logs and creates a report analyzing the areas that you specify. It can give you daily reports with short digests of the activities taking place on your machine.",
            "title": "Logwatch"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#swatch",
            "text": "Much like Logwatch Swatch also monitors your logs, but instead of giving reports it watches for regular expression and notifies you via mail or the console when there is a match. It could be used for intruder detection for example.",
            "title": "Swatch"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#multitail",
            "text": "MultiTail helps you monitor logfiles in multiple windows. You can merge two or more of these logfiles into one. It will also use colors to display the logfiles for easier reading with the help of regular expressions.",
            "title": "MultiTail"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#acct-or-psacct",
            "text": "acct or psacct (depending on if you use apt-get or yum) allows you to monitor all the commands a users executes inside the system including CPU and memory time. Once installed you get that summary with the command \u2018sa\u2019.",
            "title": "acct or psacct"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#whowatch",
            "text": "Similar to acct this tool monitors users on your system and allows you to see in real time what commands and processes they are using. It gives you a tree structure of all the processes and so you can see exactly what\u2019s happening.",
            "title": "whowatch"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#strace",
            "text": "strace is used to diagnose, debug and monitor interactions between processes. The most common thing to do is making strace print a list of system calls made by the program which is useful if the program does not behave as expected.",
            "title": "strace"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#dtrace",
            "text": "DTrace is the big brother of strace. It dynamically patches live running instructions with instrumentation code. This allows you to do in-depth performance analysis and troubleshooting. However, it\u2019s not for the weak of heart as there is a 1200 book written on the topic.",
            "title": "DTrace"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#webmin",
            "text": "Webmin is a web-based system administration tool. It removes the need to manually edit unix configuration files and lets you manage the system remotely if need be. It has a couple of monitoring modules that you can attach to it.",
            "title": "webmin"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#stat",
            "text": "Stat is a built-in tool for displaying status information of files and file systems. It will give you information such as when the file was modified, accessed or changed.",
            "title": "stat"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#ifconfig",
            "text": "ifconfig is a built-in tool used to configure the network interfaces. Behind the scenes network monitor tools use ifconfig to set it into promiscuous mode to capture all packets. You can do it yourself with ifconfig eth0 promisc and return to normal mode with ifconfig eth0 -promisc.",
            "title": "ifconfig"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#ulimit",
            "text": "ulimit is a built-in tool that monitors system resources and keeps a limit so any of the monitored resources don\u2019t go overboard. For instance making a fork bomb where a properly configured ulimit is in place would be totally fine.",
            "title": "ulimit"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#cpulimit",
            "text": "CPUlimit is a small tool that monitors and then limits the CPU usage of a process. It\u2019s particularly useful to make batch jobs not eat up too many CPU cycles.",
            "title": "cpulimit"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#lshw",
            "text": "lshw is a small built-in tool extract detailed information about the hardware configuration of the machine. It can output everything from CPU version and speed to mainboard configuration.",
            "title": "lshw"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#w",
            "text": "W is a built-in command that displays information about the users currently using the machine and their processes.",
            "title": "w"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#lsof",
            "text": "lsof is a built-in tool that gives you a list of all open files and network connections. From there you can narrow it down to files opened by processes, based on the process name, by a specific user or perhaps kill all processes that belongs to a specific user.",
            "title": "lsof"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#collectd",
            "text": "Collectd is a Unix daemon that collects all your monitoring statistics. It uses a modular design and plugins to fill in any niche monitoring. This way collectd stays as lightweight and customizable as possible.",
            "title": "collectd"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#observium",
            "text": "Observium is an auto-discovering network monitoring platform supporting a wide range of hardware platforms and operating systems. Observium focuses on providing a beautiful and powerful yet simple and intuitive interface to the health and status of your network.",
            "title": "Observium"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#nload",
            "text": "It\u2019s a command line tool that monitors network throughput. It\u2019s neat because it visualizes the in and and outgoing traffic using two graphs and some additional useful data like total amount of transferred data. You can install it with \nyum install nload\nor \n1 sudo apt-get install nload",
            "title": "Nload"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#smokeping",
            "text": "SmokePing keeps track of the network latencies of your network and it visualises them too. There are a wide range of latency measurement plugins developed for SmokePing. If a GUI is important to you it\u2019s there is an ongoing development to make that happen.",
            "title": "SmokePing"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#mobaxterm",
            "text": "If you\u2019re working in windows environment day in and day out. You may feel limited by the terminal Windows provides. MobaXterm comes to the rescue and allows you to use many of the terminal commands commonly found in Linux. Which will help you tremendously in your monitoring needs!",
            "title": "MobaXterm"
        },
        {
            "location": "/Tech/Monitoring/80_tools_for_monitoring/#shinken-monitoring",
            "text": "Shinken is a monitoring framework which is a total rewrite of Nagios in python. It aims to enhance flexibility and managing a large environment. While still keeping all your nagios configuration and plugins.",
            "title": "Shinken monitoring"
        },
        {
            "location": "/Tech/Monitoring/Nagios/",
            "text": "Convert Nagios server logs to human-readable format\n\n\ncat <path_to_nagios_log_file> | perl -pe 's/(\\d+)/localtime($1)/e'\n\n\n\n\nCheck TCP port from remote Windows PC\n\n\n\n\nDownload \ncheck_tcp.exe\n to C:\\Program Files\\NSClient++\\\n\n\nCreate PowerShell external script - \ncheck_tcp_port\n :\n\n\n\n\n$exe = 'C:\\Program Files\\NSClient++\\check_tcp.exe'\n$arg1 = '-H'\n$arg2 = '<place_remote_host_ip_here'\n$arg3 = '-p'\n$arg4 = '<place_remote_tcp_port_here>'\n$arg5 = '-w'\n$arg6 = '100'\n$arg7 = '-c'\n$arg8 = '1000'\n\n$cmd = $arg1 + \" \" + $arg2 + \" \" + $arg3 + \" \" + $arg4 + \" \" + $arg5 + \" \" + $arg6 + \" \" + $arg7 + \" \" + $arg8\n$process = New-Object -TypeName System.Diagnostics.Process\n$process.StartInfo.FileName = $exe\n$process.StartInfo.Arguments = $cmd\n$process.StartInfo.RedirectStandardOutput = $true\n$process.StartInfo.UseShellExecute = $false\n$status = $process.Start()\n$process.WaitForExit()\n$process.StandardOutput.ReadToEnd()\nexit $process.ExitCode  \n\n\n\n\n\n\nMake a record in Nagion Agent configuration file:\n\n\n\n\n[/settings/external scripts/scripts]\ncheck_tcp_port =  cmd /c echo scripts\\check_tcp_mq.ps1; exit($lastexitcode) | powershell.exe -command -",
            "title": "Nagios"
        },
        {
            "location": "/Tech/Monitoring/Nagios/#convert-nagios-server-logs-to-human-readable-format",
            "text": "cat <path_to_nagios_log_file> | perl -pe 's/(\\d+)/localtime($1)/e'",
            "title": "Convert Nagios server logs to human-readable format"
        },
        {
            "location": "/Tech/Monitoring/Nagios/#check-tcp-port-from-remote-windows-pc",
            "text": "Download  check_tcp.exe  to C:\\Program Files\\NSClient++\\  Create PowerShell external script -  check_tcp_port  :   $exe = 'C:\\Program Files\\NSClient++\\check_tcp.exe'\n$arg1 = '-H'\n$arg2 = '<place_remote_host_ip_here'\n$arg3 = '-p'\n$arg4 = '<place_remote_tcp_port_here>'\n$arg5 = '-w'\n$arg6 = '100'\n$arg7 = '-c'\n$arg8 = '1000'\n\n$cmd = $arg1 + \" \" + $arg2 + \" \" + $arg3 + \" \" + $arg4 + \" \" + $arg5 + \" \" + $arg6 + \" \" + $arg7 + \" \" + $arg8\n$process = New-Object -TypeName System.Diagnostics.Process\n$process.StartInfo.FileName = $exe\n$process.StartInfo.Arguments = $cmd\n$process.StartInfo.RedirectStandardOutput = $true\n$process.StartInfo.UseShellExecute = $false\n$status = $process.Start()\n$process.WaitForExit()\n$process.StandardOutput.ReadToEnd()\nexit $process.ExitCode     Make a record in Nagion Agent configuration file:   [/settings/external scripts/scripts]\ncheck_tcp_port =  cmd /c echo scripts\\check_tcp_mq.ps1; exit($lastexitcode) | powershell.exe -command -",
            "title": "Check TCP port from remote Windows PC"
        },
        {
            "location": "/Tech/Monitoring/NetXMS/",
            "text": "Web console\n\n\ncd /opt/\nwget http://apache-mirror.rbc.ru/pub/apache/tomcat/tomcat-7/v7.0.70/bin/apache-tomcat-7.0.70.tar.gz\ntar zxvf apache-tomcat-7.0.70.tar.gz\n\niptables -I INPUT -p tcp --dport 8005 -j ACCEPT\niptables -I INPUT -p tcp --dport 8009 -j ACCEPT\niptables -I INPUT -p tcp --dport 8080 -j ACCEPT\niptables -I INPUT -p tcp --dport 8443 -j ACCEPT\n\n/opt/apache-tomcat-7.0.70/bin/startup.sh\n\n# ...Wait until tomcat is started...\n\nwget -O /opt/apache-tomcat-7.0.70/webapps/nxmc-2.0.5.war http://www.netxms.org/download/webui/nxmc-2.0.5.war\n\nhttp://<ip_address>:8080/nxmc-2.0.5/nxmc\n\n\n\n\nWMI Scripts\n\n\n#Query:\n/usr/local/bin/nxget 192.168.122.252 \"WMI.Query(root\\CIMV2,SELECT * FROM XXX)\"\n\n\n\n\nExternal parameter\n\n\nExternalParameterShellExec = KasperskyBasesState:C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo c:\\Path_TO\\kav.vbs\n\n\n\n\nSQL queries parsing from the log-file\n\n\n# Print queries execution time. Change \"SELECT\" to keyword you want.\ngrep \"SELECT\" <log-file> | grep -oP '[0-9]* ms' | awk '{print $1}'\n\n# Extarct all SQL-Inserts to file\ngrep -oP '\\\"INSERT INTO.*' <log-file> > insert.sql\n\n# Extract all SQL-Selects to file\ngrep -oP '\\\"SELECT.*' <log-file> > select.sql\n\n# Extract all other than inserts and selects t file\ngrep -v '\\\"SELECT.*' <log-file> | grep -v '\\\"INSERT INTO.*' > other.sql\n\n# Extarct all SQL-Explains to file\ngrep -oP '\\\"EXPLAIN.*' other.sql > explain.sql\n\n# Extarct all SQL-Updates to file\ngrep -v '\\\"EXPLAIN.*' other.sql | grep -oP '\\\"UPDATE.*' > update.sql\n\n# Extarct all SQL-Deletes to file\ngrep -v '\\\"EXPLAIN.*' other.sql | grep -v '\\\"UPDATE.*' | grep -oP '\\\"DELETE.*' > delete.sql\n\n# Extarct all SQL-Merges to file\ngrep -v '\\\"EXPLAIN.*' other.sql | grep -v '\\\"UPDATE.*' | grep -v '\\\"DELETE.*' | grep -oP '\\\"MERGE.*' > merge.sql\n\n\n\n\nInstallation\n\n\n\n\nMySQL Database\n\n\n\n\nmysql -u root -p mysql\nmysql> CREATE DATABASE netxms;\nmysql> GRANT ALL ON netxms.* TO netxms@localhost IDENTIFIED BY 'netxms';\nmysql> \\q\n\n\n\n\n\n\nInstallation from source\n\n\n\n\ntar zxvf netxms-x.x.x.tar.gz\n#tar zxvf netxms-2.0.6.tar.gz\n\ncd netxms-x.x.x\n#cd netxms-2.0.6\n\n# You need MySQl or MariadDB development packages for installation with \"mysql\" option\n# On CentOS7 something like:\n# yum install mysql55-mysql-devel\n# yum install mariadb-devel\n\nsh ./configure --with-server --with-mysql --with-agent --prefix=<path_to_custom_dir>\n#sh ./configure --with-server --with-mysql --with-agent --prefix=/home/soft/netxms\n\nmake\nmake install\n\nvim /etc/netxmsd.conf\n---\nDBDriver = <path_to_netxms_prefix>/lib/libnxddr_mysql.so\n#DBDriver = /home/soft/netxms/lib/libnxddr_mysql.so\nDBServer = localhost\nDBName = netxms\nDBLogin = netxms\nDBPassword = netxms\nLogFailedSQLQueries = yes\nLogFile = <path_to_netxms_prefix>/var/netxms.log\n#LogFile = /home/soft/netxms/var/netxms.log\n---\n\nvim /etc/nxagentd.conf\n---\nMasterServers = 127.0.0.1, localhost, centos-02.keeobot.net\nLogFile = <path_to_netxms_prefix>/var/nxagentd.log\n#LogFile = /home/soft/netxms/var/nxagentd.log\n---\n\ntouch <path_to_log_files>\n#touch /home/soft/netxms/var/netxms.log\n#touch /home/soft/netxms/var/nxagentd.log\n\n<path_to_netxms_prefix>/bin/nxdbmgr init <path_to_netxms_prefix>/sql/dbinit_mysql.sql\n#/home/soft/netxms/bin/nxdbmgr init /home/soft/netxms/share/netxms/sql/dbinit_mysql.sql\n\n<path_to_netxms_prefix>/bin/nxagentd -D6 -d\n <path_to_netxms_prefix>/bin/netxmsd -D6 -d\n#/home/soft/netxms/bin/nxagentd -D6 -d\n#/home/soft/netxms/bin/netxmsd -D6 -d\n\n\n\n\n\nCompile NXAgent with Mongo-C-Driver\n\n\ncd /opt\n# Mongo-C-Driver\nwget https://github.com/mongodb/mongo-c-driver/releases/download/1.6.0/mongo-c-driver-1.6.0.tar.gz\ntar xzvf mongo-c-driver-1.6.0.tar.gz && cd mongo-c-driver-1.6.0\n./configure --prefix=/opt/mongo-c-driver\nmake && make install\n\n#NetXMS Agent with Mongo and SNMP\ngit clone http://git.netxms.org/public/netxms.git nxbuild\ncd nxbuild\ngit checkout stable-2.0\n./configure --with-agent --with-mongodb=/opt/mongo-c-driver --with-snmp --prefix=/opt/netxms\nmake && make install",
            "title": "NetXMS"
        },
        {
            "location": "/Tech/Monitoring/NetXMS/#web-console",
            "text": "cd /opt/\nwget http://apache-mirror.rbc.ru/pub/apache/tomcat/tomcat-7/v7.0.70/bin/apache-tomcat-7.0.70.tar.gz\ntar zxvf apache-tomcat-7.0.70.tar.gz\n\niptables -I INPUT -p tcp --dport 8005 -j ACCEPT\niptables -I INPUT -p tcp --dport 8009 -j ACCEPT\niptables -I INPUT -p tcp --dport 8080 -j ACCEPT\niptables -I INPUT -p tcp --dport 8443 -j ACCEPT\n\n/opt/apache-tomcat-7.0.70/bin/startup.sh\n\n# ...Wait until tomcat is started...\n\nwget -O /opt/apache-tomcat-7.0.70/webapps/nxmc-2.0.5.war http://www.netxms.org/download/webui/nxmc-2.0.5.war\n\nhttp://<ip_address>:8080/nxmc-2.0.5/nxmc",
            "title": "Web console"
        },
        {
            "location": "/Tech/Monitoring/NetXMS/#wmi-scripts",
            "text": "#Query:\n/usr/local/bin/nxget 192.168.122.252 \"WMI.Query(root\\CIMV2,SELECT * FROM XXX)\"",
            "title": "WMI Scripts"
        },
        {
            "location": "/Tech/Monitoring/NetXMS/#external-parameter",
            "text": "ExternalParameterShellExec = KasperskyBasesState:C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo c:\\Path_TO\\kav.vbs",
            "title": "External parameter"
        },
        {
            "location": "/Tech/Monitoring/NetXMS/#sql-queries-parsing-from-the-log-file",
            "text": "# Print queries execution time. Change \"SELECT\" to keyword you want.\ngrep \"SELECT\" <log-file> | grep -oP '[0-9]* ms' | awk '{print $1}'\n\n# Extarct all SQL-Inserts to file\ngrep -oP '\\\"INSERT INTO.*' <log-file> > insert.sql\n\n# Extract all SQL-Selects to file\ngrep -oP '\\\"SELECT.*' <log-file> > select.sql\n\n# Extract all other than inserts and selects t file\ngrep -v '\\\"SELECT.*' <log-file> | grep -v '\\\"INSERT INTO.*' > other.sql\n\n# Extarct all SQL-Explains to file\ngrep -oP '\\\"EXPLAIN.*' other.sql > explain.sql\n\n# Extarct all SQL-Updates to file\ngrep -v '\\\"EXPLAIN.*' other.sql | grep -oP '\\\"UPDATE.*' > update.sql\n\n# Extarct all SQL-Deletes to file\ngrep -v '\\\"EXPLAIN.*' other.sql | grep -v '\\\"UPDATE.*' | grep -oP '\\\"DELETE.*' > delete.sql\n\n# Extarct all SQL-Merges to file\ngrep -v '\\\"EXPLAIN.*' other.sql | grep -v '\\\"UPDATE.*' | grep -v '\\\"DELETE.*' | grep -oP '\\\"MERGE.*' > merge.sql",
            "title": "SQL queries parsing from the log-file"
        },
        {
            "location": "/Tech/Monitoring/NetXMS/#installation",
            "text": "MySQL Database   mysql -u root -p mysql\nmysql> CREATE DATABASE netxms;\nmysql> GRANT ALL ON netxms.* TO netxms@localhost IDENTIFIED BY 'netxms';\nmysql> \\q   Installation from source   tar zxvf netxms-x.x.x.tar.gz\n#tar zxvf netxms-2.0.6.tar.gz\n\ncd netxms-x.x.x\n#cd netxms-2.0.6\n\n# You need MySQl or MariadDB development packages for installation with \"mysql\" option\n# On CentOS7 something like:\n# yum install mysql55-mysql-devel\n# yum install mariadb-devel\n\nsh ./configure --with-server --with-mysql --with-agent --prefix=<path_to_custom_dir>\n#sh ./configure --with-server --with-mysql --with-agent --prefix=/home/soft/netxms\n\nmake\nmake install\n\nvim /etc/netxmsd.conf\n---\nDBDriver = <path_to_netxms_prefix>/lib/libnxddr_mysql.so\n#DBDriver = /home/soft/netxms/lib/libnxddr_mysql.so\nDBServer = localhost\nDBName = netxms\nDBLogin = netxms\nDBPassword = netxms\nLogFailedSQLQueries = yes\nLogFile = <path_to_netxms_prefix>/var/netxms.log\n#LogFile = /home/soft/netxms/var/netxms.log\n---\n\nvim /etc/nxagentd.conf\n---\nMasterServers = 127.0.0.1, localhost, centos-02.keeobot.net\nLogFile = <path_to_netxms_prefix>/var/nxagentd.log\n#LogFile = /home/soft/netxms/var/nxagentd.log\n---\n\ntouch <path_to_log_files>\n#touch /home/soft/netxms/var/netxms.log\n#touch /home/soft/netxms/var/nxagentd.log\n\n<path_to_netxms_prefix>/bin/nxdbmgr init <path_to_netxms_prefix>/sql/dbinit_mysql.sql\n#/home/soft/netxms/bin/nxdbmgr init /home/soft/netxms/share/netxms/sql/dbinit_mysql.sql\n\n<path_to_netxms_prefix>/bin/nxagentd -D6 -d\n <path_to_netxms_prefix>/bin/netxmsd -D6 -d\n#/home/soft/netxms/bin/nxagentd -D6 -d\n#/home/soft/netxms/bin/netxmsd -D6 -d",
            "title": "Installation"
        },
        {
            "location": "/Tech/Monitoring/NetXMS/#compile-nxagent-with-mongo-c-driver",
            "text": "cd /opt\n# Mongo-C-Driver\nwget https://github.com/mongodb/mongo-c-driver/releases/download/1.6.0/mongo-c-driver-1.6.0.tar.gz\ntar xzvf mongo-c-driver-1.6.0.tar.gz && cd mongo-c-driver-1.6.0\n./configure --prefix=/opt/mongo-c-driver\nmake && make install\n\n#NetXMS Agent with Mongo and SNMP\ngit clone http://git.netxms.org/public/netxms.git nxbuild\ncd nxbuild\ngit checkout stable-2.0\n./configure --with-agent --with-mongodb=/opt/mongo-c-driver --with-snmp --prefix=/opt/netxms\nmake && make install",
            "title": "Compile NXAgent with Mongo-C-Driver"
        },
        {
            "location": "/Tech/Monitoring/Zabbix/",
            "text": "Agent on AIX 6.1\n\n\nDependences:\n1) gettext\n  rpm -ivh ftp://www.oss4aix.org/latest/aix61/gettext-0.10.40-8.aix5.2.ppc.rpm\n2) expat\n  rpm -ivh ftp://www.oss4aix.org/compatible/aix61/expat-2.1.0-1.aix5.1.ppc.rpm\n3) glib2\n  rpm -ivh ftp://www.oss4aix.org/compatible/aix61/libgcc-4.7.2-1.aix6.1.ppc.rpm\n  rpm -ivh ftp://www.oss4aix.org/compatible/aix61/libffi-3.0.11-2.aix5.1.ppc.rpm\n  rpm -ivh ftp://www.oss4aix.org/compatible/aix61/glib2-2.30.3-1.aix5.1.ppc.rpm\n4) libconv\n  rpm -ivh ftp://www.oss4aix.org/compatible/aix61/libiconv-1.14-2.aix5.1.ppc.rpm\n\nInstall zabbix agent:\n\nUnpack zabbix_agents_2.0.3.aix6100.powerpc.tar.gz on server and move files to their locations (bin, sbin)\n\nUpload your zabbix_agentd.conf to /etc\n\nmkgroup zabbix\nuseradd -g zabbix zabbix\n\n\u2514R\u2514\u2500\u2514x\u2514t\u2514p\u2514u\u2514} \u2514~\u2514u\u2514\u2500\u2514q\u2514x\u2514\u2500\u2514t\u2514y\u2514}\u2514\u2588\u2514u \u2514t\u2514y\u2514\u250c\u2514u\u2514{\u2514\u2514\u2514\u2500\u2514\u250c\u2514y\u2514y, \u2514\u251c\u2514p\u2514z\u2514|\u2514\u2588 \u2514y \u2514\u2518\u2514\u2510\u2514\u2514\u2514p\u2514~\u2514p\u2514r\u2514|\u2514y\u2514r\u2514p\u2514u\u2514} \u2514\u2502\u2514\u250c\u2514p\u2514r\u2514p:\nmkdir /var/run/zabbix\ntouch /var/run/zabbix/zabbix_agentd.pid\nmkdir /var/log/zabbix\ntouch /var/log/zabbix/zabbix_agentd.log\n\nchown -R zabbix:zabbix /var/log/zabbix\nchown -R zabbix:zabbix /var/run/zabbix\nchown zabbix:zabbix /etc/zabbix_agentd.conf\n\nRun:\n/usr/sbin/zabbix_agentd --config /etc/zabbix_agentd.conf\n\nAutostart:\nvi /etc/inittab\n  zabagent:2:once:/usr/sbin/zabbix_agentd --config /etc/zabbix_agentd.conf\n\n\n\n\n\nSMTP\n\n\n1) Get SendEmail(http://caspian.dotconf.net/menu/Software/SendEmail/)\n\n2) Create a script \"zabbix_sendemail\" (chmod 755) in the AlertScriptsPath folder specified by /etc/zabbix/zabbix_server.conf\n--------------------------------------\n#!/bin/sh\n\nexport smtpemailfrom=zabbix@yourdomain.com\nexport zabbixemailto=$1\nexport zabbixsubject=$2\nexport zabbixbody=$3\nexport smtpserver=yoursmtpserver.com\nexport smtplogin=smtpuser\nexport smtppass=smtppassword\n\n/usr/bin/sendEmail -f $smtpemailfrom -t $zabbixemailto -u $zabbixsubject -m $zabbixbody -s $smtpserver:25 -xu $smtplogin -xp $smtppass\n--------------------------------------\n\n3) Set the Action (Configurations / Actions in the php frontend)\n\n4) Set the Media Type (Administration / Media types in the php frontend) script to zabbix_sendemail\n\n5) Add the Media to the user (Administration / Users / user in php frontend)",
            "title": "Zabbix"
        },
        {
            "location": "/Tech/Monitoring/Zabbix/#agent-on-aix-61",
            "text": "Dependences:\n1) gettext\n  rpm -ivh ftp://www.oss4aix.org/latest/aix61/gettext-0.10.40-8.aix5.2.ppc.rpm\n2) expat\n  rpm -ivh ftp://www.oss4aix.org/compatible/aix61/expat-2.1.0-1.aix5.1.ppc.rpm\n3) glib2\n  rpm -ivh ftp://www.oss4aix.org/compatible/aix61/libgcc-4.7.2-1.aix6.1.ppc.rpm\n  rpm -ivh ftp://www.oss4aix.org/compatible/aix61/libffi-3.0.11-2.aix5.1.ppc.rpm\n  rpm -ivh ftp://www.oss4aix.org/compatible/aix61/glib2-2.30.3-1.aix5.1.ppc.rpm\n4) libconv\n  rpm -ivh ftp://www.oss4aix.org/compatible/aix61/libiconv-1.14-2.aix5.1.ppc.rpm\n\nInstall zabbix agent:\n\nUnpack zabbix_agents_2.0.3.aix6100.powerpc.tar.gz on server and move files to their locations (bin, sbin)\n\nUpload your zabbix_agentd.conf to /etc\n\nmkgroup zabbix\nuseradd -g zabbix zabbix\n\n\u2514R\u2514\u2500\u2514x\u2514t\u2514p\u2514u\u2514} \u2514~\u2514u\u2514\u2500\u2514q\u2514x\u2514\u2500\u2514t\u2514y\u2514}\u2514\u2588\u2514u \u2514t\u2514y\u2514\u250c\u2514u\u2514{\u2514\u2514\u2514\u2500\u2514\u250c\u2514y\u2514y, \u2514\u251c\u2514p\u2514z\u2514|\u2514\u2588 \u2514y \u2514\u2518\u2514\u2510\u2514\u2514\u2514p\u2514~\u2514p\u2514r\u2514|\u2514y\u2514r\u2514p\u2514u\u2514} \u2514\u2502\u2514\u250c\u2514p\u2514r\u2514p:\nmkdir /var/run/zabbix\ntouch /var/run/zabbix/zabbix_agentd.pid\nmkdir /var/log/zabbix\ntouch /var/log/zabbix/zabbix_agentd.log\n\nchown -R zabbix:zabbix /var/log/zabbix\nchown -R zabbix:zabbix /var/run/zabbix\nchown zabbix:zabbix /etc/zabbix_agentd.conf\n\nRun:\n/usr/sbin/zabbix_agentd --config /etc/zabbix_agentd.conf\n\nAutostart:\nvi /etc/inittab\n  zabagent:2:once:/usr/sbin/zabbix_agentd --config /etc/zabbix_agentd.conf",
            "title": "Agent on AIX 6.1"
        },
        {
            "location": "/Tech/Monitoring/Zabbix/#smtp",
            "text": "1) Get SendEmail(http://caspian.dotconf.net/menu/Software/SendEmail/)\n\n2) Create a script \"zabbix_sendemail\" (chmod 755) in the AlertScriptsPath folder specified by /etc/zabbix/zabbix_server.conf\n--------------------------------------\n#!/bin/sh\n\nexport smtpemailfrom=zabbix@yourdomain.com\nexport zabbixemailto=$1\nexport zabbixsubject=$2\nexport zabbixbody=$3\nexport smtpserver=yoursmtpserver.com\nexport smtplogin=smtpuser\nexport smtppass=smtppassword\n\n/usr/bin/sendEmail -f $smtpemailfrom -t $zabbixemailto -u $zabbixsubject -m $zabbixbody -s $smtpserver:25 -xu $smtplogin -xp $smtppass\n--------------------------------------\n\n3) Set the Action (Configurations / Actions in the php frontend)\n\n4) Set the Media Type (Administration / Media types in the php frontend) script to zabbix_sendemail\n\n5) Add the Media to the user (Administration / Users / user in php frontend)",
            "title": "SMTP"
        },
        {
            "location": "/Tech/Network/Common/",
            "text": "NetworkManager: show connection info\n\n\nnmcli device show eth0\n\n\n\n\nCheck own IP address\n\n\ncurl -s checkip.dyndns.org\n\n\n\n\nShare current folder over HTTP\n\n\npython2 -m SimpleHTTPServer 8080\npython3 -mhttp.server 8080",
            "title": "Common"
        },
        {
            "location": "/Tech/Network/Common/#networkmanager-show-connection-info",
            "text": "nmcli device show eth0",
            "title": "NetworkManager: show connection info"
        },
        {
            "location": "/Tech/Network/Common/#check-own-ip-address",
            "text": "curl -s checkip.dyndns.org",
            "title": "Check own IP address"
        },
        {
            "location": "/Tech/Network/Common/#share-current-folder-over-http",
            "text": "python2 -m SimpleHTTPServer 8080\npython3 -mhttp.server 8080",
            "title": "Share current folder over HTTP"
        },
        {
            "location": "/Tech/Network/DNS/",
            "text": "Get ip addresses\n\n\nhost <hostname> | grep \" has address \"| cut -d\" \" -f4",
            "title": "DNS"
        },
        {
            "location": "/Tech/Network/DNS/#get-ip-addresses",
            "text": "host <hostname> | grep \" has address \"| cut -d\" \" -f4",
            "title": "Get ip addresses"
        },
        {
            "location": "/Tech/Network/KEMP/",
            "text": "Some REST commands\n\n\n# Disable Real server \ncurl -k -X GET https://username:password@ip_address/access/disablers?rs=realServerIP\n\n# Enable Real server \ncurl -k -X GET https://username:password@ip_address/access/enablers?rs=realServerIP\n\n# Get any parameter\ncurl -k -X GET https://username:password@ip_address/access/get?param=parameterName",
            "title": "KEMP"
        },
        {
            "location": "/Tech/Network/KEMP/#some-rest-commands",
            "text": "# Disable Real server \ncurl -k -X GET https://username:password@ip_address/access/disablers?rs=realServerIP\n\n# Enable Real server \ncurl -k -X GET https://username:password@ip_address/access/enablers?rs=realServerIP\n\n# Get any parameter\ncurl -k -X GET https://username:password@ip_address/access/get?param=parameterName",
            "title": "Some REST commands"
        },
        {
            "location": "/Tech/Network/NTP/",
            "text": "ntp.conf in Ansible way\n\n\ndriftfile /var/lib/ntp/ntp.drift\n\n{% for ntp_server in net_ntp_servers %}\nserver {{ ntp_server }} burst iburst minpoll 4 maxpoll 6\n{% endfor %}\n\nrestrict default kod nomodify notrap nopeer noquery\nrestrict -6 default kod nomodify notrap nopeer noquery\n\n---\nnet_ntp_servers:\n  - 0.ru.pool.ntp.org\n  - 1.ru.pool.ntp.org\n  - 2.ru.pool.ntp.org\n  - 3.ru.pool.ntp.org\n\n\n\n\nntp.conf common\n\n\ndriftfile /var/lib/ntp/ntp.drift\n\nserver 0.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\nserver 1.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\nserver 2.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\nserver 3.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\n\nrestrict default kod nomodify notrap nopeer noquery\nrestrict -6 default kod nomodify notrap nopeer noquery",
            "title": "NTP"
        },
        {
            "location": "/Tech/Network/NTP/#ntpconf-in-ansible-way",
            "text": "driftfile /var/lib/ntp/ntp.drift\n\n{% for ntp_server in net_ntp_servers %}\nserver {{ ntp_server }} burst iburst minpoll 4 maxpoll 6\n{% endfor %}\n\nrestrict default kod nomodify notrap nopeer noquery\nrestrict -6 default kod nomodify notrap nopeer noquery\n\n---\nnet_ntp_servers:\n  - 0.ru.pool.ntp.org\n  - 1.ru.pool.ntp.org\n  - 2.ru.pool.ntp.org\n  - 3.ru.pool.ntp.org",
            "title": "ntp.conf in Ansible way"
        },
        {
            "location": "/Tech/Network/NTP/#ntpconf-common",
            "text": "driftfile /var/lib/ntp/ntp.drift\n\nserver 0.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\nserver 1.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\nserver 2.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\nserver 3.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\n\nrestrict default kod nomodify notrap nopeer noquery\nrestrict -6 default kod nomodify notrap nopeer noquery",
            "title": "ntp.conf common"
        },
        {
            "location": "/Tech/Network/Ports/",
            "text": "Test bunch of hosts for open ports\n\n\ncat > /tmp/ips-to-test.txt <<-EOF\n1.1.1.1\n2.2.2.2\n3.3.3.3\n4.4.4.4\n5.5.5.5\n6.6.6.6\nEOF\n\nfor line in `cat /tmp/ips-to-test.txt`; do nc -z -v -w5 ${line} 443; sleep 1; done\n\n\n\n\nCommon\n\n\nsudo netstat -tunapl\n\n\n\n\nWhich process uses port\n\n\nLinux\n\n\n# Find out PID via ss\nss -nltp | grep <port>\n# Find out PID via deprecated netstat:\nnetstat -tulpn | grep <port>\n# Find out particular binary\nls -l /proc/<pid>/exe\n# Find out full run command\nps -ef | grep <PID>\n\n\n\n\nAIX\n\n\nlsof -i:<port>\nps -ef | grep <pid>\n\n\n\n\nWindows\n\n\nnetstat -aon | findstr \"<port>\"\npslist <PID>\n\n\n\n\nWhich port is used by a process\n\n\nUnix\n\n\nsudo lsof -i -P -n | grep LISTEN | grep <process>\n# Remember about sudo: root access rights is required to see at non-current-user processes\nsudo netstat -tulpn | grep LISTEN | grep <process>\n# For FreeBSD or MacOS:\nsudo netstat -anp tcp | grep LISTEN | grep <process>\nsudo netstat -anp udp | grep LISTEN | grep <process>\n# Use flags -T fot TCP -U for UDP or both. You can use any IP address instead localhost.\nsudo nmap -sTU -O localhost\n\n\n\n\nWindows\n\n\nnetstat -bano | findstr /R /C:\"[LISTING]\" | findstr /R /C:\"<process>\"",
            "title": "Ports"
        },
        {
            "location": "/Tech/Network/Ports/#test-bunch-of-hosts-for-open-ports",
            "text": "cat > /tmp/ips-to-test.txt <<-EOF\n1.1.1.1\n2.2.2.2\n3.3.3.3\n4.4.4.4\n5.5.5.5\n6.6.6.6\nEOF\n\nfor line in `cat /tmp/ips-to-test.txt`; do nc -z -v -w5 ${line} 443; sleep 1; done",
            "title": "Test bunch of hosts for open ports"
        },
        {
            "location": "/Tech/Network/Ports/#common",
            "text": "sudo netstat -tunapl",
            "title": "Common"
        },
        {
            "location": "/Tech/Network/Ports/#which-process-uses-port",
            "text": "",
            "title": "Which process uses port"
        },
        {
            "location": "/Tech/Network/Ports/#linux",
            "text": "# Find out PID via ss\nss -nltp | grep <port>\n# Find out PID via deprecated netstat:\nnetstat -tulpn | grep <port>\n# Find out particular binary\nls -l /proc/<pid>/exe\n# Find out full run command\nps -ef | grep <PID>",
            "title": "Linux"
        },
        {
            "location": "/Tech/Network/Ports/#aix",
            "text": "lsof -i:<port>\nps -ef | grep <pid>",
            "title": "AIX"
        },
        {
            "location": "/Tech/Network/Ports/#windows",
            "text": "netstat -aon | findstr \"<port>\"\npslist <PID>",
            "title": "Windows"
        },
        {
            "location": "/Tech/Network/Ports/#which-port-is-used-by-a-process",
            "text": "",
            "title": "Which port is used by a process"
        },
        {
            "location": "/Tech/Network/Ports/#unix",
            "text": "sudo lsof -i -P -n | grep LISTEN | grep <process>\n# Remember about sudo: root access rights is required to see at non-current-user processes\nsudo netstat -tulpn | grep LISTEN | grep <process>\n# For FreeBSD or MacOS:\nsudo netstat -anp tcp | grep LISTEN | grep <process>\nsudo netstat -anp udp | grep LISTEN | grep <process>\n# Use flags -T fot TCP -U for UDP or both. You can use any IP address instead localhost.\nsudo nmap -sTU -O localhost",
            "title": "Unix"
        },
        {
            "location": "/Tech/Network/Ports/#windows_1",
            "text": "netstat -bano | findstr /R /C:\"[LISTING]\" | findstr /R /C:\"<process>\"",
            "title": "Windows"
        },
        {
            "location": "/Tech/Network/SNMP/",
            "text": "SNMP\n\n\nsnmpwalk -mALL -v2c -ctkM0nit0ring 10.20.30.3 interfaces.ifTable.ifEntry.ifOperStatus",
            "title": "SNMP"
        },
        {
            "location": "/Tech/Network/SNMP/#snmp",
            "text": "snmpwalk -mALL -v2c -ctkM0nit0ring 10.20.30.3 interfaces.ifTable.ifEntry.ifOperStatus",
            "title": "SNMP"
        },
        {
            "location": "/Tech/Network/WiFi/",
            "text": "WPA Supplicant\n\n\nwpa_supplicant -Dnl80211 -iwlp2s0 -c/etc/wpa_supplicant/wpa_supplicant.conf &\n\ncat /etc/wpa_supplicant/wpa_supplicant.conf\n# This network configuration was written by net-setup\nmodules=\"wpa_supplicant\"\nwpa_supplicant_wlp2s0=\"-Dnl80211\"\nconfig_wlp2s0=\"dhcp\" \n\nctrl_interface=/var/run/wpa_supplicant\nctrl_interface_group=0\nap_scan=1\nnetwork={\n   ssid=\"MTS_2140184\"\n   psk=\"0000000000\"\n   priority=5\n}",
            "title": "WiFi"
        },
        {
            "location": "/Tech/Network/WiFi/#wpa-supplicant",
            "text": "wpa_supplicant -Dnl80211 -iwlp2s0 -c/etc/wpa_supplicant/wpa_supplicant.conf &\n\ncat /etc/wpa_supplicant/wpa_supplicant.conf\n# This network configuration was written by net-setup\nmodules=\"wpa_supplicant\"\nwpa_supplicant_wlp2s0=\"-Dnl80211\"\nconfig_wlp2s0=\"dhcp\" \n\nctrl_interface=/var/run/wpa_supplicant\nctrl_interface_group=0\nap_scan=1\nnetwork={\n   ssid=\"MTS_2140184\"\n   psk=\"0000000000\"\n   priority=5\n}",
            "title": "WPA Supplicant"
        },
        {
            "location": "/Tech/Network/tcpdump/",
            "text": "Common commands\n\n\ntcpdump -ttttnnvvS -i any port XXX and host XX.XX.XX.XX\n\n\n\n\nCapyure TCPDUMP (with all commands use '| head' optionally)\n\n\nCapture bunch of packets\n\n\ntcpdump -w capture.pcap\n\n\n\n\nShow list of unique tcp or udp connections ip addresses\n\n\ntcpdump -nn -r capture.pcap 'tcp or udp' | cut -f 3 -d \" \" | cut -f 1-4 -d \".\" | sort | uniq | sort -nr\n\n\n\n\nShow list of unique destinations with SYN flag(\u2018tcp[13]=2\u2019)\n\n\ntcpdump -nn -r capture.pcap 'tcp[13]=2' | cut -f 5 -d \" \" | sort | uniq -c | sort -nr\n\n\n\n\nShow list of unique sources with SYN flag(\u2018tcp[13]=2\u2019)\n\n\ntcpdump -nn -r capture.pcap 'tcp[13]=2' | cut -f 3 -d \" \" | cut -f 1-4 -d \".\" | sort | uniq -c | sort -nr\n\n\n\n\nSearch for plain texts (-A)\n\n\ntcpdump -Ann -r capture.pcap 'dst port 25 or dst port 514 or dst port 110 or dst port 21 or dst port 53 or dst port 80'\n\n\n\n\nSearch for top level domains (optiolally for names only: | grep -E '[a-z]')\n\n\ntcpdump -nn -r capture.pcap 'port 53' | grep -Ev '(com|ru|net|org|gov|mil|arpa)' | cut -f 9 -d \" \"  \n\n\n\n\nInvestigate HTTP traffic\n\n\ntcpdump -Ann -r capture.pcap 'port 80' | grep 'HTTP' | grep -Ev '(GET|HEAD)'\n\n\n\n\nSearch HTTP traffic for user-agent list\n\n\ntcpdump -Ann -r capture.pcap 'port 80' | grep -Ei 'user-agent' | sort | uniq -c | sort -n\ntcpdump -Ann -r capture.pcap 'port 80' | sed -n '/Mozilla/,$p'\n\n\n\n\nPcap repository (-C filesize in MBytes, -W number of files, -G time in seconds, %s timestamp)\n\n\nsudo -b tcpdump -nn -i eth0 -w capture.pcap -C 1 -W 5         \nsudo -b tcpdump -nn -i eth0 -w capture-%s.pcap -G 600 -W 5    \n# Dealing with pcap files\nfor capfile in $(ls *.pcap); do tcpdump -nnr $capfile 'dst port 53'; done",
            "title": "Tcpdump"
        },
        {
            "location": "/Tech/Network/tcpdump/#common-commands",
            "text": "tcpdump -ttttnnvvS -i any port XXX and host XX.XX.XX.XX",
            "title": "Common commands"
        },
        {
            "location": "/Tech/Network/tcpdump/#capyure-tcpdump-with-all-commands-use-head-optionally",
            "text": "",
            "title": "Capyure TCPDUMP (with all commands use '| head' optionally)"
        },
        {
            "location": "/Tech/Network/tcpdump/#capture-bunch-of-packets",
            "text": "tcpdump -w capture.pcap",
            "title": "Capture bunch of packets"
        },
        {
            "location": "/Tech/Network/tcpdump/#show-list-of-unique-tcp-or-udp-connections-ip-addresses",
            "text": "tcpdump -nn -r capture.pcap 'tcp or udp' | cut -f 3 -d \" \" | cut -f 1-4 -d \".\" | sort | uniq | sort -nr",
            "title": "Show list of unique tcp or udp connections ip addresses"
        },
        {
            "location": "/Tech/Network/tcpdump/#show-list-of-unique-destinations-with-syn-flagtcp132",
            "text": "tcpdump -nn -r capture.pcap 'tcp[13]=2' | cut -f 5 -d \" \" | sort | uniq -c | sort -nr",
            "title": "Show list of unique destinations with SYN flag(\u2018tcp[13]=2\u2019)"
        },
        {
            "location": "/Tech/Network/tcpdump/#show-list-of-unique-sources-with-syn-flagtcp132",
            "text": "tcpdump -nn -r capture.pcap 'tcp[13]=2' | cut -f 3 -d \" \" | cut -f 1-4 -d \".\" | sort | uniq -c | sort -nr",
            "title": "Show list of unique sources with SYN flag(\u2018tcp[13]=2\u2019)"
        },
        {
            "location": "/Tech/Network/tcpdump/#search-for-plain-texts-a",
            "text": "tcpdump -Ann -r capture.pcap 'dst port 25 or dst port 514 or dst port 110 or dst port 21 or dst port 53 or dst port 80'",
            "title": "Search for plain texts (-A)"
        },
        {
            "location": "/Tech/Network/tcpdump/#search-for-top-level-domains-optiolally-for-names-only-grep-e-a-z",
            "text": "tcpdump -nn -r capture.pcap 'port 53' | grep -Ev '(com|ru|net|org|gov|mil|arpa)' | cut -f 9 -d \" \"",
            "title": "Search for top level domains (optiolally for names only: | grep -E '[a-z]')"
        },
        {
            "location": "/Tech/Network/tcpdump/#investigate-http-traffic",
            "text": "tcpdump -Ann -r capture.pcap 'port 80' | grep 'HTTP' | grep -Ev '(GET|HEAD)'",
            "title": "Investigate HTTP traffic"
        },
        {
            "location": "/Tech/Network/tcpdump/#search-http-traffic-for-user-agent-list",
            "text": "tcpdump -Ann -r capture.pcap 'port 80' | grep -Ei 'user-agent' | sort | uniq -c | sort -n\ntcpdump -Ann -r capture.pcap 'port 80' | sed -n '/Mozilla/,$p'",
            "title": "Search HTTP traffic for user-agent list"
        },
        {
            "location": "/Tech/Network/tcpdump/#pcap-repository-c-filesize-in-mbytes-w-number-of-files-g-time-in-seconds-s-timestamp",
            "text": "sudo -b tcpdump -nn -i eth0 -w capture.pcap -C 1 -W 5         \nsudo -b tcpdump -nn -i eth0 -w capture-%s.pcap -G 600 -W 5    \n# Dealing with pcap files\nfor capfile in $(ls *.pcap); do tcpdump -nnr $capfile 'dst port 53'; done",
            "title": "Pcap repository (-C filesize in MBytes, -W number of files, -G time in seconds, %s timestamp)"
        },
        {
            "location": "/Tech/Package_Management/Apt/",
            "text": "This section describes work with Debian-based Linux distributives like:\nDebian Linux, Ubuntu Linux, Astra Linux, Linux Mint\n\n\n\n\nApt\n\n\n# Show installed packages\napt --installed list\n# Search for software\napt-cache search <pattern>\n# Install package\napt-get install <package_name>\n\n\n\n\nDpkg\n\n\n# To get a list of packages installed locally do this in your terminal:\ndpkg --get-selections | grep -v deinstall\n# To get a list of a specific package installed:\ndpkg --get-selections | grep postgres\n# To save that list to a text file called packages on your desktop do this in your terminal:\ndpkg --get-selections | grep -v deinstall > ~/Desktop/packages\n# Alternatively, simply use\ndpkg -l\n\n\n\n\nPython alternatives\n\n\nsudo update-alternatives --install /usr/bin/python python /usr/bin/python3.4 1\nsudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1\nsudo update-alternatives --config python",
            "title": "Apt"
        },
        {
            "location": "/Tech/Package_Management/Apt/#apt",
            "text": "# Show installed packages\napt --installed list\n# Search for software\napt-cache search <pattern>\n# Install package\napt-get install <package_name>",
            "title": "Apt"
        },
        {
            "location": "/Tech/Package_Management/Apt/#dpkg",
            "text": "# To get a list of packages installed locally do this in your terminal:\ndpkg --get-selections | grep -v deinstall\n# To get a list of a specific package installed:\ndpkg --get-selections | grep postgres\n# To save that list to a text file called packages on your desktop do this in your terminal:\ndpkg --get-selections | grep -v deinstall > ~/Desktop/packages\n# Alternatively, simply use\ndpkg -l",
            "title": "Dpkg"
        },
        {
            "location": "/Tech/Package_Management/Apt/#python-alternatives",
            "text": "sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.4 1\nsudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1\nsudo update-alternatives --config python",
            "title": "Python alternatives"
        },
        {
            "location": "/Tech/Package_Management/PIP/",
            "text": "Install\n\n\npip install <package_name>\npip3 install <package_name>\n\n\n\n\nUpdate\n\n\npip install -U <package_name>\npip3 install -U <package_name>\n\n\n\n\nUpdate all\n\n\npip freeze --local | grep -v '^\\-e' | cut -d = -f 1  | xargs -n1 pip install -U\npip3 freeze --local | grep -v '^\\-e' | cut -d = -f 1  | xargs -n1 pip3 install -U",
            "title": "PIP"
        },
        {
            "location": "/Tech/Package_Management/PIP/#install",
            "text": "pip install <package_name>\npip3 install <package_name>",
            "title": "Install"
        },
        {
            "location": "/Tech/Package_Management/PIP/#update",
            "text": "pip install -U <package_name>\npip3 install -U <package_name>",
            "title": "Update"
        },
        {
            "location": "/Tech/Package_Management/PIP/#update-all",
            "text": "pip freeze --local | grep -v '^\\-e' | cut -d = -f 1  | xargs -n1 pip install -U\npip3 freeze --local | grep -v '^\\-e' | cut -d = -f 1  | xargs -n1 pip3 install -U",
            "title": "Update all"
        },
        {
            "location": "/Tech/Package_Management/Pacman/",
            "text": "Pacman\n\n\n# Search for software\npacman -Ss <pattern>\n# Install package\npacman -S <package_name>\n# Update the system\npacman -Syu\n# Remove orphaned packages (Be careful, double check for list of deleted packages)\npacman -Rscn $(pacman -Qtdq)\npacman -Sc\npacman-optimize && sync\n# Show all pacages whitc now installed as dependencies\npacman -Qet\n\n\n\n\nAUR package installation\n\n\ngit clone https://aur.archlinux.org/<packiage_name>\ncd <package_name>\nmakepkg -sri\n\n# In case of error like:\n# <package>.tar.gz ... FAILED (unknown public key 0000000000000000)\ngpg --recv-key 0000000000000000\n# Or manually check key and skip key verification vith makepkg\npacman-key --verify <sig_file>\nmakepkg --skippgpcheck -sri\n\n\n\n\nSome Python packages exist in filesystem\n\n\n# First method:\nmv /usr/lib/python2.7/site-packages/<package> /tmp/removed_py/\n# Second method:\npip freeze | xargs pip uninstall -y\npip freeze | grep -v \"^-e\" | xargs pip uninstall -y\n# Then you can update your Arch\n#yaourt -Syu --aur\npacman -Syu\n\n\n\n\nca-certificates-utils: /etc/ssl/certs/ca-certificates.crt exists in filesystem\n\n\nmv /etc/ssl/certs/ca-certificates.crt /tmp\n#yaourt -Syu --aur\npacman -Syu\n\n\n\n\nSort installed packages by size\n\n\npacman -Qi | egrep '^(Name|Installed)' | cut -f2 -d':' | paste - - | column -t | sort -nrk 2 | grep MiB | less",
            "title": "Pacman"
        },
        {
            "location": "/Tech/Package_Management/Pacman/#pacman",
            "text": "# Search for software\npacman -Ss <pattern>\n# Install package\npacman -S <package_name>\n# Update the system\npacman -Syu\n# Remove orphaned packages (Be careful, double check for list of deleted packages)\npacman -Rscn $(pacman -Qtdq)\npacman -Sc\npacman-optimize && sync\n# Show all pacages whitc now installed as dependencies\npacman -Qet",
            "title": "Pacman"
        },
        {
            "location": "/Tech/Package_Management/Pacman/#aur-package-installation",
            "text": "git clone https://aur.archlinux.org/<packiage_name>\ncd <package_name>\nmakepkg -sri\n\n# In case of error like:\n# <package>.tar.gz ... FAILED (unknown public key 0000000000000000)\ngpg --recv-key 0000000000000000\n# Or manually check key and skip key verification vith makepkg\npacman-key --verify <sig_file>\nmakepkg --skippgpcheck -sri",
            "title": "AUR package installation"
        },
        {
            "location": "/Tech/Package_Management/Pacman/#some-python-packages-exist-in-filesystem",
            "text": "# First method:\nmv /usr/lib/python2.7/site-packages/<package> /tmp/removed_py/\n# Second method:\npip freeze | xargs pip uninstall -y\npip freeze | grep -v \"^-e\" | xargs pip uninstall -y\n# Then you can update your Arch\n#yaourt -Syu --aur\npacman -Syu",
            "title": "Some Python packages exist in filesystem"
        },
        {
            "location": "/Tech/Package_Management/Pacman/#ca-certificates-utils-etcsslcertsca-certificatescrt-exists-in-filesystem",
            "text": "mv /etc/ssl/certs/ca-certificates.crt /tmp\n#yaourt -Syu --aur\npacman -Syu",
            "title": "ca-certificates-utils: /etc/ssl/certs/ca-certificates.crt exists in filesystem"
        },
        {
            "location": "/Tech/Package_Management/Pacman/#sort-installed-packages-by-size",
            "text": "pacman -Qi | egrep '^(Name|Installed)' | cut -f2 -d':' | paste - - | column -t | sort -nrk 2 | grep MiB | less",
            "title": "Sort installed packages by size"
        },
        {
            "location": "/Tech/Package_Management/Yum/",
            "text": "This section describes work with RHEL-based Linux distributives like:\nRed Hat Enterprise Linux, Oracle Linux, CentOS Linux, Scientific Linux, Fermi Linux, ROSA Linux, CERN Linux\n\n\n\n\nYum\n\n\n# Search for software\nyum search <pattern>\n# Install package\nyum install <package_name>\n# Repair \"Error: database disk image is malformed\"\nyum clean dbcache\n# Clean all yum cache\nyum clean all\n\n# Remove packages with dependencies:\n#add \"clean_requirements_on_remove=1\" to /etc/yum.conf\n\n\n\n\nEPEL repository\n\n\n# RHEL-based version 7 (two options)\nrpm -hUv https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\nyum insall epel-release\n\n# RHEL-based version 6\nrpm -hUv https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm\n\n# RHEL-based version 5\nrpm -hUv https://dl.fedoraproject.org/pub/epel/epel-release-latest-5.noarch.rpm",
            "title": "Yum"
        },
        {
            "location": "/Tech/Package_Management/Yum/#yum",
            "text": "# Search for software\nyum search <pattern>\n# Install package\nyum install <package_name>\n# Repair \"Error: database disk image is malformed\"\nyum clean dbcache\n# Clean all yum cache\nyum clean all\n\n# Remove packages with dependencies:\n#add \"clean_requirements_on_remove=1\" to /etc/yum.conf",
            "title": "Yum"
        },
        {
            "location": "/Tech/Package_Management/Yum/#epel-repository",
            "text": "# RHEL-based version 7 (two options)\nrpm -hUv https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\nyum insall epel-release\n\n# RHEL-based version 6\nrpm -hUv https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm\n\n# RHEL-based version 5\nrpm -hUv https://dl.fedoraproject.org/pub/epel/epel-release-latest-5.noarch.rpm",
            "title": "EPEL repository"
        },
        {
            "location": "/Tech/Project_Management/Redmine/",
            "text": "Installation on CentOS 7\n\n\nDependencies\n\n\n# For Ruby\nyum \"Devleopment Tools\"\n# For Redmine\nyum install ImageMagick ImageMagick-devel libcurl-devel httpd-devel httpd mariadb-devel mariadb-server zlib-devel zlib\n\n\n\n\nRuby\n\n\nmkdir ~/dst && cd dst\nwget https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.3.tar.gz\ntar xzvf ruby-2.3.3.tar.gz && cd ruby-2.3.3\n# Configure from root! Bacause sometime it doesn't see zlib\n./configure\nmake\nmake install\n\n\n\n\nMariaDB Database\n\n\nsystemctl enable --now mariadb.service\nfirewall-cmd --add-service=mysql --permanent\nfirewall-cmd --reload\n\nvi /etc/my.cnf\n# --- VI ---\n[mysqld]\ncharacter-set-server=utf8 \n# ----------\n\nmysql_secure_installation\nSet root password? [Y/n] Y\nRemove anonymous users? [Y/n] Y\nDisallow root login remotely? [Y/n] Y\nRemove test database and access to it? [Y/n] Y\nReload privilege tables now? [Y/n] Y\n\nmysql -u root -p \nEnter password: *****\n# --- SQL ---\nCREATE DATABASE redmine CHARACTER SET utf8;\nGRANT ALL PRIVILEGES ON redmine.* TO redmine@'localhost' IDENTIFIED BY 'my_password'; \nFLUSH PRIVILEGES;\nEXIT;\n# -----------\n\n\n\n\nWeb server\n\n\nrm -f /etc/httpd/conf.d/welcome.conf\n\nvi /etc/httpd/conf/httpd.con\n# --- VI ---\n# Change those values\n# Line 86\nServerAdmin your@emain.name\n# Line 95\nServerName www.your-server-name:80\n# Line 151\nAllowOverride All\n# Line 164\nDirectoryIndex index.html index.cgi index.php\n# At the end of file\nServerTokens Prod\nKeepAlive On\n# ----------\n\nsystemctl enable --now httpd.service\nfirewall-cmd --add-service=http --permanent \nfirewall-cmd --reload \n\n\n\n\nRedmine\n\n\ncd ~/dst\nwget --no-check-certificate  https://redmine.org/releases/redmine-3.3.2.tar.gz\ntar xzvf redmine-3.3.2.tar.gz\nmv redmine-3.3.2 /var/www/redmine\n\nvi /var/www/redmine/config/database.yml\n# --- VI ---\nproduction:\n    adapter: mysql2\n    database: redmine\n    host: localhost\n    username: redmine\n    password: \"my_password\"\n    encoding: utf8\n# ----------\n\nvi /var/www/redmine/config/configuration.yml\n# --- VI ---\nproduction:\n  email_delivery:\n    delivery_method: :smtp\n      smtp_settings:\n        address: \"your.email.server.name\"\n        port: 25\n        authentication: :login\n        domain: 'your.domain.name'\n        user_name: 'username@your.domain.name'\n        password: 'your-email-password'\n        enable_starttls_auto: false\n# ----------\n\ncd /var/www/redmine/\ngem install bundler --no-rdoc --no-ri \nbundle install --without development test postgresql sqlite \nbundle exec rake generate_secret_token RAILS_ENV=production\nbundle exec rake db:migrate RAILS_ENV=production\ngem install passenger --no-rdoc --no-ri\npassenger-install-apache2-module\n\nvi /etc/httpd/conf.d/passenger.conf\n# --- VI ---\nLoadModule passenger_module /usr/local/lib/ruby/gems/2.3.0/gems/passenger-5.1.2/buildout/apache2/mod_passenger.so\n   <IfModule mod_passenger.c>\n     PassengerRoot /usr/local/lib/ruby/gems/2.3.0/gems/passenger-5.1.2\n     PassengerDefaultRuby /usr/local/bin/ruby\n   </IfModule>\n\nNameVirtualHost *:80\n<VirtualHost *:80>\n    ServerName redmine.pupupon.com\n    DocumentRoot /var/www/redmine/public\n</VirtualHost>\n# ----------\n\nchown -R apache:apache /var/www/redmine\nchmod -R 777 /var/www/redmine/tmp\n\nsystemctl restart httpd\n\n# http://your.redmone.server\n# Initial username/password \"admin/admin\"\n\n\n\n\nEmail truncate\n\n\ndiff --git a/app/models/mail_handler.rb b/app/models/mail_handler.rb\nindex 520183c..717e49b 100644\n--- a/app/models/mail_handler.rb\n+++ b/app/models/mail_handler.rb\n@@ -441,12 +441,20 @@\n\n   # Removes the email body of text after the truncation configurations.\n   def cleanup_body(body)\n-    delimiters = Setting.mail_handler_body_delimiters.to_s.split(/[\\r\\n]+/).reject(&:blank?).map {|s| Regexp.escape(s)}\n-    unless delimiters.empty?\n-      regex = Regexp.new(\"^[> ]*(#{ delimiters.join('|') })\\s*[\\r\\n].*\", Regexp::MULTILINE)\n-      body = body.gsub(regex, '')\n+    address = Setting.mail_from\n+    regex_arr = [\n+      Regexp.new(\"From:\\s*\" + Regexp.escape(address), Regexp::IGNORECASE),\n+      Regexp.new(\"<\" + Regexp.escape(address) + \">\", Regexp::IGNORECASE),\n+      Regexp.new(Regexp.escape(address) + \"\\s+wrote:\", Regexp::IGNORECASE),\n+      Regexp.new(\"^.*On.*(\\n)?wrote:$\", Regexp::IGNORECASE),\n+      Regexp.new(\"-+original\\s+message-+\\s*$\", Regexp::IGNORECASE),\n+      Regexp.new(\"from:\\s*$\", Regexp::IGNORECASE)\n+    ]\n+    body_length = body.length\n+    index = regex_arr.inject(body_length) do |min, regex|\n+      [(body.index(regex) || body_length), min].min\n     end\n-    body.strip\n+    body[0, index].strip\n   end\n\n   def find_assignee_from_keyword(keyword, issue)",
            "title": "Redmine"
        },
        {
            "location": "/Tech/Project_Management/Redmine/#installation-on-centos-7",
            "text": "",
            "title": "Installation on CentOS 7"
        },
        {
            "location": "/Tech/Project_Management/Redmine/#dependencies",
            "text": "# For Ruby\nyum \"Devleopment Tools\"\n# For Redmine\nyum install ImageMagick ImageMagick-devel libcurl-devel httpd-devel httpd mariadb-devel mariadb-server zlib-devel zlib",
            "title": "Dependencies"
        },
        {
            "location": "/Tech/Project_Management/Redmine/#ruby",
            "text": "mkdir ~/dst && cd dst\nwget https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.3.tar.gz\ntar xzvf ruby-2.3.3.tar.gz && cd ruby-2.3.3\n# Configure from root! Bacause sometime it doesn't see zlib\n./configure\nmake\nmake install",
            "title": "Ruby"
        },
        {
            "location": "/Tech/Project_Management/Redmine/#mariadb-database",
            "text": "systemctl enable --now mariadb.service\nfirewall-cmd --add-service=mysql --permanent\nfirewall-cmd --reload\n\nvi /etc/my.cnf\n# --- VI ---\n[mysqld]\ncharacter-set-server=utf8 \n# ----------\n\nmysql_secure_installation\nSet root password? [Y/n] Y\nRemove anonymous users? [Y/n] Y\nDisallow root login remotely? [Y/n] Y\nRemove test database and access to it? [Y/n] Y\nReload privilege tables now? [Y/n] Y\n\nmysql -u root -p \nEnter password: *****\n# --- SQL ---\nCREATE DATABASE redmine CHARACTER SET utf8;\nGRANT ALL PRIVILEGES ON redmine.* TO redmine@'localhost' IDENTIFIED BY 'my_password'; \nFLUSH PRIVILEGES;\nEXIT;\n# -----------",
            "title": "MariaDB Database"
        },
        {
            "location": "/Tech/Project_Management/Redmine/#web-server",
            "text": "rm -f /etc/httpd/conf.d/welcome.conf\n\nvi /etc/httpd/conf/httpd.con\n# --- VI ---\n# Change those values\n# Line 86\nServerAdmin your@emain.name\n# Line 95\nServerName www.your-server-name:80\n# Line 151\nAllowOverride All\n# Line 164\nDirectoryIndex index.html index.cgi index.php\n# At the end of file\nServerTokens Prod\nKeepAlive On\n# ----------\n\nsystemctl enable --now httpd.service\nfirewall-cmd --add-service=http --permanent \nfirewall-cmd --reload",
            "title": "Web server"
        },
        {
            "location": "/Tech/Project_Management/Redmine/#redmine",
            "text": "cd ~/dst\nwget --no-check-certificate  https://redmine.org/releases/redmine-3.3.2.tar.gz\ntar xzvf redmine-3.3.2.tar.gz\nmv redmine-3.3.2 /var/www/redmine\n\nvi /var/www/redmine/config/database.yml\n# --- VI ---\nproduction:\n    adapter: mysql2\n    database: redmine\n    host: localhost\n    username: redmine\n    password: \"my_password\"\n    encoding: utf8\n# ----------\n\nvi /var/www/redmine/config/configuration.yml\n# --- VI ---\nproduction:\n  email_delivery:\n    delivery_method: :smtp\n      smtp_settings:\n        address: \"your.email.server.name\"\n        port: 25\n        authentication: :login\n        domain: 'your.domain.name'\n        user_name: 'username@your.domain.name'\n        password: 'your-email-password'\n        enable_starttls_auto: false\n# ----------\n\ncd /var/www/redmine/\ngem install bundler --no-rdoc --no-ri \nbundle install --without development test postgresql sqlite \nbundle exec rake generate_secret_token RAILS_ENV=production\nbundle exec rake db:migrate RAILS_ENV=production\ngem install passenger --no-rdoc --no-ri\npassenger-install-apache2-module\n\nvi /etc/httpd/conf.d/passenger.conf\n# --- VI ---\nLoadModule passenger_module /usr/local/lib/ruby/gems/2.3.0/gems/passenger-5.1.2/buildout/apache2/mod_passenger.so\n   <IfModule mod_passenger.c>\n     PassengerRoot /usr/local/lib/ruby/gems/2.3.0/gems/passenger-5.1.2\n     PassengerDefaultRuby /usr/local/bin/ruby\n   </IfModule>\n\nNameVirtualHost *:80\n<VirtualHost *:80>\n    ServerName redmine.pupupon.com\n    DocumentRoot /var/www/redmine/public\n</VirtualHost>\n# ----------\n\nchown -R apache:apache /var/www/redmine\nchmod -R 777 /var/www/redmine/tmp\n\nsystemctl restart httpd\n\n# http://your.redmone.server\n# Initial username/password \"admin/admin\"",
            "title": "Redmine"
        },
        {
            "location": "/Tech/Project_Management/Redmine/#email-truncate",
            "text": "diff --git a/app/models/mail_handler.rb b/app/models/mail_handler.rb\nindex 520183c..717e49b 100644\n--- a/app/models/mail_handler.rb\n+++ b/app/models/mail_handler.rb\n@@ -441,12 +441,20 @@\n\n   # Removes the email body of text after the truncation configurations.\n   def cleanup_body(body)\n-    delimiters = Setting.mail_handler_body_delimiters.to_s.split(/[\\r\\n]+/).reject(&:blank?).map {|s| Regexp.escape(s)}\n-    unless delimiters.empty?\n-      regex = Regexp.new(\"^[> ]*(#{ delimiters.join('|') })\\s*[\\r\\n].*\", Regexp::MULTILINE)\n-      body = body.gsub(regex, '')\n+    address = Setting.mail_from\n+    regex_arr = [\n+      Regexp.new(\"From:\\s*\" + Regexp.escape(address), Regexp::IGNORECASE),\n+      Regexp.new(\"<\" + Regexp.escape(address) + \">\", Regexp::IGNORECASE),\n+      Regexp.new(Regexp.escape(address) + \"\\s+wrote:\", Regexp::IGNORECASE),\n+      Regexp.new(\"^.*On.*(\\n)?wrote:$\", Regexp::IGNORECASE),\n+      Regexp.new(\"-+original\\s+message-+\\s*$\", Regexp::IGNORECASE),\n+      Regexp.new(\"from:\\s*$\", Regexp::IGNORECASE)\n+    ]\n+    body_length = body.length\n+    index = regex_arr.inject(body_length) do |min, regex|\n+      [(body.index(regex) || body_length), min].min\n     end\n-    body.strip\n+    body[0, index].strip\n   end\n\n   def find_assignee_from_keyword(keyword, issue)",
            "title": "Email truncate"
        },
        {
            "location": "/Tech/Security/EncFS/",
            "text": "Encryption\n\n\nencfs <full_path_to_future_encrypted_folder> <full_path_to_future_unencrypted_folder>\n# Choose methods and password (for methods simple choose 'p' to get paranoic options)\n\n\n\n\nMount\n\n\nencfs <full_path_to_future_encrypted_folder> <full_path_to_future_unencrypted_folder>\n\n\n\n\nUnmount\n\n\nfusermount -u <full_path_to_future_unencrypted_folder>",
            "title": "EncFS"
        },
        {
            "location": "/Tech/Security/EncFS/#encryption",
            "text": "encfs <full_path_to_future_encrypted_folder> <full_path_to_future_unencrypted_folder>\n# Choose methods and password (for methods simple choose 'p' to get paranoic options)",
            "title": "Encryption"
        },
        {
            "location": "/Tech/Security/EncFS/#mount",
            "text": "encfs <full_path_to_future_encrypted_folder> <full_path_to_future_unencrypted_folder>",
            "title": "Mount"
        },
        {
            "location": "/Tech/Security/EncFS/#unmount",
            "text": "fusermount -u <full_path_to_future_unencrypted_folder>",
            "title": "Unmount"
        },
        {
            "location": "/Tech/Security/FirewallD/",
            "text": "FirewallD Status\n\n\nfirewall-cmd --state\n\nfirewall-cmd --list-all\n\n# Reload configuration                                                                              \nfirewall-cmd --reload\n\n\n\n\nGet security zones\n\n\nfirewall-cmd --get-zones\nfirewall-cmd --get-default-zone\nfirewall-cmd --get-active-zones\nfirewall-cmd --list-all-zones\nfirewall-cmd --set-default-zone=<zone_name>\nfirewall-cmd --get-zone-of-interface=<network_interface_name>\n\n\n\n\nGet ICMP types\n\n\nfirewall-cmd --get-icmptypes\n\n\n\n\nServices\n\n\nfirewall-cmd --get-services\n\n# List default services\nls -la  /usr/lib/firewalld/services/\n\n# Add service\nfirewall-cmd --add-service=<service_name>\nfirewall-cmd --add-service=<service_name> --permanent\n\n# Remove service\nfirewall-cmd --zone=<zone_name> --remove-service=<service_name>\n\n\n\n\nRules\n\n\nfirewall-cmd --permanent --add-source=<subnet>\nfirewall-cmd --permanent --add-port=<port>/<protocol>",
            "title": "FirewallD"
        },
        {
            "location": "/Tech/Security/FirewallD/#firewalld-status",
            "text": "firewall-cmd --state\n\nfirewall-cmd --list-all\n\n# Reload configuration                                                                              \nfirewall-cmd --reload",
            "title": "FirewallD Status"
        },
        {
            "location": "/Tech/Security/FirewallD/#get-security-zones",
            "text": "firewall-cmd --get-zones\nfirewall-cmd --get-default-zone\nfirewall-cmd --get-active-zones\nfirewall-cmd --list-all-zones\nfirewall-cmd --set-default-zone=<zone_name>\nfirewall-cmd --get-zone-of-interface=<network_interface_name>",
            "title": "Get security zones"
        },
        {
            "location": "/Tech/Security/FirewallD/#get-icmp-types",
            "text": "firewall-cmd --get-icmptypes",
            "title": "Get ICMP types"
        },
        {
            "location": "/Tech/Security/FirewallD/#services",
            "text": "firewall-cmd --get-services\n\n# List default services\nls -la  /usr/lib/firewalld/services/\n\n# Add service\nfirewall-cmd --add-service=<service_name>\nfirewall-cmd --add-service=<service_name> --permanent\n\n# Remove service\nfirewall-cmd --zone=<zone_name> --remove-service=<service_name>",
            "title": "Services"
        },
        {
            "location": "/Tech/Security/FirewallD/#rules",
            "text": "firewall-cmd --permanent --add-source=<subnet>\nfirewall-cmd --permanent --add-port=<port>/<protocol>",
            "title": "Rules"
        },
        {
            "location": "/Tech/Security/HSM/",
            "text": "Generate LMK consists of 3 components.\n\n\nStep-By-Step.\n\n\n0:\nConnect to Thales HMS 8000 via common Terminal Client.\n\n1:\nOnline> FC <Return> \nInsert card and press ENTER: <Return> \nCard already formatted, continue? [Y/N]: Y <Return> \nFormat card for HSM settings/LMKs? [H/L]: L <Return> \nErasing card \nFormatting card . . . \nEnter new PIN for Smart Card: 2134 <Return>\nRe-enter new PIN: 2134 <Return> \nEnter time [hhmmss]: 173000 <Return>  - current time\nEnter date [ddmmyy]: 081111 <Return> \nEnter User ID: User1 <Return> \nEnter Issuer ID: ITS <Return> \nFormat complete \n\n2:\nOnline> FC <Return> \nInsert card and press ENTER: <Return> \nCard already formatted, continue? [Y/N]: Y <Return> \nFormat card for HSM settings/LMKs? [H/L]: L <Return> \nErasing card \nFormatting card . . . \nEnter new PIN for Smart Card: 4356 <Return>\nRe-enter new PIN: 4356 <Return> \nEnter time [hhmmss]: 173000 <Return> \nEnter date [ddmmyy]: 081111 <Return> \nEnter User ID: User2 <Return> \nEnter Issuer ID: ITS <Return> \nFormat complete \n\n3:\nOnline> FC <Return> \nInsert card and press ENTER: <Return> \nCard already formatted, continue? [Y/N]: Y <Return> \nFormat card for HSM settings/LMKs? [H/L]: L <Return> \nErasing card \nFormatting card . . . \nEnter new PIN for Smart Card: 5467 <Return>\nRe-enter new PIN: 5467 <Return> \nEnter time [hhmmss]: 173000 <Return> \nEnter date [ddmmyy]: 081111 <Return> \nEnter User ID: User3 <Return> \nEnter Issuer ID: ITS <Return> \nFormat complete \n\n4:\nTaking HSM into the Secure State\n\n5:\nSecure> GK <Return> \nLMKs must be erased before proceeding. \nErase LMKs? Y <Return> \nLMK component set [1-9]: 1 <Return> \nEnter secret value A: <Return> \nEnter secret value B: <Return> \nEnter value C: <Return> \nInsert blank card and enter PIN: 2134 <Return> \nWriting keys \nChecking keys \nDevice write complete, check: XXXX XXXX XXXX XXXX \nRemove the smartcard and store it securely. \nMake another copy? [Y/N]: N <Return> X copies made. \n\n6:\nSecure> GK <Return> \nLMKs must be erased before proceeding. \nErase LMKs? Y <Return> \nLMK component set [1-9]: 2 <Return> \nEnter secret value A: <Return> \nEnter secret value B: <Return> \nEnter value C: <Return> \nInsert blank card and enter PIN: 4356 <Return> \nWriting keys \nChecking keys \nDevice write complete, check: XXXX XXXX XXXX XXXX \nRemove the smartcard and store it securely. \nMake another copy? [Y/N]: N <Return> X copies made. \n\n7:\nSecure> GK <Return> \nLMKs must be erased before proceeding. \nErase LMKs? Y <Return> \nLMK component set [1-9]: 3 <Return> \nEnter secret value A: <Return> \nEnter secret value B: <Return> \nEnter value C: <Return> \nInsert blank card and enter PIN: 5467 <Return> \nWriting keys \nChecking keys \nDevice write complete, check: XXXX XXXX XXXX XXXX \nRemove the smartcard and store it securely. \nMake another copy? [Y/N]: N <Return> X copies made. \n\n8-9-10:Secure> LK <Return>\nLMKs must be erased before proceeding.\nErase LMKs? Y <Return>\nLoad LMK from components. Insert card and enter PIN: **** <Return>\nCHECK: XXXX XXXX XXXX XXXX Load more components? [Y/N]: Y <Return>\nRemove the smartcard. Insert the second and subsequent Smartcards and repeat the loading procedure. When all have been loaded and the HSM displays the check value, record the check value.\nCHECK: XXXX XXXX XXXX XXXX Load more components? [Y/N]: N <Return>\nUse the LO command to load LMKs into key change storage.\nSecure>\nUse the A command to put the HSM into the Authorised State in order to check the LMK components and passwords or PINs.\n\n11:\nReturn to online state: remove secure keys and press reset button at least 2 seconds.",
            "title": "HSM"
        },
        {
            "location": "/Tech/Security/HSM/#generate-lmk-consists-of-3-components",
            "text": "Step-By-Step.  0:\nConnect to Thales HMS 8000 via common Terminal Client.\n\n1:\nOnline> FC <Return> \nInsert card and press ENTER: <Return> \nCard already formatted, continue? [Y/N]: Y <Return> \nFormat card for HSM settings/LMKs? [H/L]: L <Return> \nErasing card \nFormatting card . . . \nEnter new PIN for Smart Card: 2134 <Return>\nRe-enter new PIN: 2134 <Return> \nEnter time [hhmmss]: 173000 <Return>  - current time\nEnter date [ddmmyy]: 081111 <Return> \nEnter User ID: User1 <Return> \nEnter Issuer ID: ITS <Return> \nFormat complete \n\n2:\nOnline> FC <Return> \nInsert card and press ENTER: <Return> \nCard already formatted, continue? [Y/N]: Y <Return> \nFormat card for HSM settings/LMKs? [H/L]: L <Return> \nErasing card \nFormatting card . . . \nEnter new PIN for Smart Card: 4356 <Return>\nRe-enter new PIN: 4356 <Return> \nEnter time [hhmmss]: 173000 <Return> \nEnter date [ddmmyy]: 081111 <Return> \nEnter User ID: User2 <Return> \nEnter Issuer ID: ITS <Return> \nFormat complete \n\n3:\nOnline> FC <Return> \nInsert card and press ENTER: <Return> \nCard already formatted, continue? [Y/N]: Y <Return> \nFormat card for HSM settings/LMKs? [H/L]: L <Return> \nErasing card \nFormatting card . . . \nEnter new PIN for Smart Card: 5467 <Return>\nRe-enter new PIN: 5467 <Return> \nEnter time [hhmmss]: 173000 <Return> \nEnter date [ddmmyy]: 081111 <Return> \nEnter User ID: User3 <Return> \nEnter Issuer ID: ITS <Return> \nFormat complete \n\n4:\nTaking HSM into the Secure State\n\n5:\nSecure> GK <Return> \nLMKs must be erased before proceeding. \nErase LMKs? Y <Return> \nLMK component set [1-9]: 1 <Return> \nEnter secret value A: <Return> \nEnter secret value B: <Return> \nEnter value C: <Return> \nInsert blank card and enter PIN: 2134 <Return> \nWriting keys \nChecking keys \nDevice write complete, check: XXXX XXXX XXXX XXXX \nRemove the smartcard and store it securely. \nMake another copy? [Y/N]: N <Return> X copies made. \n\n6:\nSecure> GK <Return> \nLMKs must be erased before proceeding. \nErase LMKs? Y <Return> \nLMK component set [1-9]: 2 <Return> \nEnter secret value A: <Return> \nEnter secret value B: <Return> \nEnter value C: <Return> \nInsert blank card and enter PIN: 4356 <Return> \nWriting keys \nChecking keys \nDevice write complete, check: XXXX XXXX XXXX XXXX \nRemove the smartcard and store it securely. \nMake another copy? [Y/N]: N <Return> X copies made. \n\n7:\nSecure> GK <Return> \nLMKs must be erased before proceeding. \nErase LMKs? Y <Return> \nLMK component set [1-9]: 3 <Return> \nEnter secret value A: <Return> \nEnter secret value B: <Return> \nEnter value C: <Return> \nInsert blank card and enter PIN: 5467 <Return> \nWriting keys \nChecking keys \nDevice write complete, check: XXXX XXXX XXXX XXXX \nRemove the smartcard and store it securely. \nMake another copy? [Y/N]: N <Return> X copies made. \n\n8-9-10:Secure> LK <Return>\nLMKs must be erased before proceeding.\nErase LMKs? Y <Return>\nLoad LMK from components. Insert card and enter PIN: **** <Return>\nCHECK: XXXX XXXX XXXX XXXX Load more components? [Y/N]: Y <Return>\nRemove the smartcard. Insert the second and subsequent Smartcards and repeat the loading procedure. When all have been loaded and the HSM displays the check value, record the check value.\nCHECK: XXXX XXXX XXXX XXXX Load more components? [Y/N]: N <Return>\nUse the LO command to load LMKs into key change storage.\nSecure>\nUse the A command to put the HSM into the Authorised State in order to check the LMK components and passwords or PINs.\n\n11:\nReturn to online state: remove secure keys and press reset button at least 2 seconds.",
            "title": "Generate LMK consists of 3 components."
        },
        {
            "location": "/Tech/Security/IPTables/",
            "text": "Show rules\n\n\niptables -nvL\niptable -t nat -nvL\n\n\n\n\nAutoreset by Vivek Gite\n\n\n\n\nJust add to crontab while remote rules configuration:\n\n\n\n\ncrontab -e\n# ---\n*/5 * * * * root /root/reset.fw >/dev/null 2>&1\n\n\n\n\n\n\nreset.fw:\n\n\n\n\n#!/bin/bash\n# reset.fw - Reset firewall\n# set x to 0 - No reset\n# set x to 1 - Reset firewall\n# ---------------------------------------------------------------------------------------------------------------\n# Added support for IPV6 Firewall\n# ---------------------------------------------------------------------------------------------------------------\n# Written by Vivek Gite <vivek@nixcraft.com>\n# ---------------------------------------------------------------------------------------------------------------\n# You can copy / paste / redistribute this script under GPL version 2.0 or above\n# =============================================================\nx=1\n\n# set to true if it is CentOS / RHEL / Fedora box\nRHEL=false\n\n### no need to edit below  ###\nIPT=/sbin/iptables\nIPT6=/sbin/ip6tables\n\nif [ \"$x\" == \"1\" ];\nthen\n    if [ \"$RHEL\" == \"true\" ];\n    then\n          # reset firewall using redhat script\n        /etc/init.d/iptables stop\n        /etc/init.d/ip6tables stop\n    else\n        # for all other Linux distro use following rules to reset firewall\n        ### reset ipv4 iptales ###\n        $IPT -F\n        $IPT -X\n        $IPT -Z\n        for table in $(</proc/net/ip_tables_names)\n        do\n            $IPT -t $table -F\n            $IPT -t $table -X\n            $IPT -t $table -Z\n        done\n        $IPT -P INPUT ACCEPT\n        $IPT -P OUTPUT ACCEPT\n        $IPT -P FORWARD ACCEPT\n        ### reset ipv6 iptales ###\n        $IPT6 -F\n        $IPT6 -X\n        $IPT6 -Z\n        for table in $(</proc/net/ip6_tables_names)\n        do\n            $IPT6 -t $table -F\n            $IPT6 -t $table -X\n            $IPT6 -t $table -Z\n        done\n        $IPT6 -P INPUT ACCEPT\n        $IPT6 -P OUTPUT ACCEPT\n        $IPT6 -P FORWARD ACCEPT\n    fi\nelse\n        :\nfi\n\n\n\n\nSibple Rules\n\n\niptables -I INPUT -p tcp --dport 8005 -j ACCEPT\niptables -I INPUT -p tcp --dport 8009 -j ACCEPT\niptables -I INPUT -p tcp --dport 8080 -j ACCEPT\niptables -I INPUT -p tcp --dport 8443 -j ACCEPT\n\nip6tables -I INPUT -p tcp --dport 8005 -j ACCEPT\nip6tables -I INPUT -p tcp --dport 8009 -j ACCEPT\nip6tables -I INPUT -p tcp --dport 8080 -j ACCEPT\nip6tables -I INPUT -p tcp --dport 8443 -j ACCEPT\n\nservice iptables save \nservice ip6tables save",
            "title": "IPTables"
        },
        {
            "location": "/Tech/Security/IPTables/#show-rules",
            "text": "iptables -nvL\niptable -t nat -nvL",
            "title": "Show rules"
        },
        {
            "location": "/Tech/Security/IPTables/#autoreset-by-vivek-gite",
            "text": "Just add to crontab while remote rules configuration:   crontab -e\n# ---\n*/5 * * * * root /root/reset.fw >/dev/null 2>&1   reset.fw:   #!/bin/bash\n# reset.fw - Reset firewall\n# set x to 0 - No reset\n# set x to 1 - Reset firewall\n# ---------------------------------------------------------------------------------------------------------------\n# Added support for IPV6 Firewall\n# ---------------------------------------------------------------------------------------------------------------\n# Written by Vivek Gite <vivek@nixcraft.com>\n# ---------------------------------------------------------------------------------------------------------------\n# You can copy / paste / redistribute this script under GPL version 2.0 or above\n# =============================================================\nx=1\n\n# set to true if it is CentOS / RHEL / Fedora box\nRHEL=false\n\n### no need to edit below  ###\nIPT=/sbin/iptables\nIPT6=/sbin/ip6tables\n\nif [ \"$x\" == \"1\" ];\nthen\n    if [ \"$RHEL\" == \"true\" ];\n    then\n          # reset firewall using redhat script\n        /etc/init.d/iptables stop\n        /etc/init.d/ip6tables stop\n    else\n        # for all other Linux distro use following rules to reset firewall\n        ### reset ipv4 iptales ###\n        $IPT -F\n        $IPT -X\n        $IPT -Z\n        for table in $(</proc/net/ip_tables_names)\n        do\n            $IPT -t $table -F\n            $IPT -t $table -X\n            $IPT -t $table -Z\n        done\n        $IPT -P INPUT ACCEPT\n        $IPT -P OUTPUT ACCEPT\n        $IPT -P FORWARD ACCEPT\n        ### reset ipv6 iptales ###\n        $IPT6 -F\n        $IPT6 -X\n        $IPT6 -Z\n        for table in $(</proc/net/ip6_tables_names)\n        do\n            $IPT6 -t $table -F\n            $IPT6 -t $table -X\n            $IPT6 -t $table -Z\n        done\n        $IPT6 -P INPUT ACCEPT\n        $IPT6 -P OUTPUT ACCEPT\n        $IPT6 -P FORWARD ACCEPT\n    fi\nelse\n        :\nfi",
            "title": "Autoreset by Vivek Gite"
        },
        {
            "location": "/Tech/Security/IPTables/#sibple-rules",
            "text": "iptables -I INPUT -p tcp --dport 8005 -j ACCEPT\niptables -I INPUT -p tcp --dport 8009 -j ACCEPT\niptables -I INPUT -p tcp --dport 8080 -j ACCEPT\niptables -I INPUT -p tcp --dport 8443 -j ACCEPT\n\nip6tables -I INPUT -p tcp --dport 8005 -j ACCEPT\nip6tables -I INPUT -p tcp --dport 8009 -j ACCEPT\nip6tables -I INPUT -p tcp --dport 8080 -j ACCEPT\nip6tables -I INPUT -p tcp --dport 8443 -j ACCEPT\n\nservice iptables save \nservice ip6tables save",
            "title": "Sibple Rules"
        },
        {
            "location": "/Tech/Security/OpenSSL/",
            "text": "View PEM encoded certificate\n\n\nopenssl x509 -in certname.pem -text -noout\nopenssl x509 -in certname.cer -text -noout\nopenssl x509 -in certname.crt -text -noout\n\n\n\n\nView DER encoded Certificate\n\n\nopenssl x509 -in certname.der -inform der -text -noout\n\n\n\n\nPEM to DER\n\n\nopenssl x509 -in certname.crt -outform der -out cert.der\n\n\n\n\nDER to PEM\n\n\nopenssl x509 -in certname.crt -inform der -outform pem -out cert.pem\n\n\n\n\nExtracting Certificate and Private Key Files from a .pfx File\n\n\n\n\nExtract private key: \n\n\n\n\nopenssl pkcs12 -in certname.pfx -nocerts -out key.pem -nodes\n\n\n\n\n\n\nExtract certificate: \n\n\n\n\nopenssl pkcs12 -in certname.pfx -nokeys -out certname.pem\n\n\n\n\n\n\nRemove passphrase from private key: \n\n\n\n\nopenssl rsa -in key.pem -out certname.key",
            "title": "OpenSSL"
        },
        {
            "location": "/Tech/Security/OpenSSL/#view-pem-encoded-certificate",
            "text": "openssl x509 -in certname.pem -text -noout\nopenssl x509 -in certname.cer -text -noout\nopenssl x509 -in certname.crt -text -noout",
            "title": "View PEM encoded certificate"
        },
        {
            "location": "/Tech/Security/OpenSSL/#view-der-encoded-certificate",
            "text": "openssl x509 -in certname.der -inform der -text -noout",
            "title": "View DER encoded Certificate"
        },
        {
            "location": "/Tech/Security/OpenSSL/#pem-to-der",
            "text": "openssl x509 -in certname.crt -outform der -out cert.der",
            "title": "PEM to DER"
        },
        {
            "location": "/Tech/Security/OpenSSL/#der-to-pem",
            "text": "openssl x509 -in certname.crt -inform der -outform pem -out cert.pem",
            "title": "DER to PEM"
        },
        {
            "location": "/Tech/Security/OpenSSL/#extracting-certificate-and-private-key-files-from-a-pfx-file",
            "text": "Extract private key:    openssl pkcs12 -in certname.pfx -nocerts -out key.pem -nodes   Extract certificate:    openssl pkcs12 -in certname.pfx -nokeys -out certname.pem   Remove passphrase from private key:    openssl rsa -in key.pem -out certname.key",
            "title": "Extracting Certificate and Private Key Files from a .pfx File"
        },
        {
            "location": "/Tech/Security/PF/",
            "text": "Enabling in FreeBSD kernel\n\n\ndevice pf\ndevice pflog\ndevice pfsync\n\noptions         ALTQ\noptions         ALTQ_CBQ        # Class Bases Queuing (CBQ)\noptions         ALTQ_RED        # Random Early Detection (RED)\noptions         ALTQ_RIO        # RED In/Out\noptions         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)\noptions         ALTQ_PRIQ       # Priority Queuing (PRIQ)\noptions         ALTQ_NOPCC      # Required for SMP build\n\n\n\n\nFreeBSD rc.conf all PF options\n\n\npf_enable=\"NO\"\npf_rules=\"/etc/pf.conf\"\npf_program=\"/sbin/pfctl\"\npf_flags=\"\"\npflog_enable=\"NO\"\npflog_logfile=\"/var/log/pf.log\"\npflog_program=\"/sbin/pflogd\"\npflog_flags=\"\"\npfsync_enable=\"NO\"\npfsync_syncdev=\"\"\npfsync_ifconfig=\"\"\n\n\n\n\nSample config\n\n\n# PF.CONF // BEGIN CONFIG\n#---------------------------\n\n#---------------------------\n# Macros\n#---------------------------\n\n#---------------------------\n# Network Interfaces\n#---------------------------\next_if=\"em1\" # External\nint_if=\"em0\" # Internal\n\n#---------------------------\n# ICMP allowed\n#---------------------------\nicmp_types=\"{ echoreq, unreach}\"\n\n#---------------------------\n# Networks and hosts\n#---------------------------\nlan=\"192.168.10.0/24\"       # internal network\nsec=\"10.10.30.0/24\"     # secured network\nloop=\"127.0.0.0/8\"      # loopback\n\niis1=\"192.168.10.45/32\"     # Development IIS server 1\niis2=\"192.168.10.46/32\"     # Development IIS server 1\nredmine=\"192.168.10.48/32\"  # Redmine - internal team site\n\npublicated_services=\"{ 192.168.10.45/32, 192.168.10.46/32, 192.168.10.48/32, }\"\nallowed_inbound_ports=\"{ 22, 80, 90, 91 }\"\n\n#---------------------------\n# Global options\n#---------------------------\nset block-policy return     # Default block polycy: return, drop\nset skip on lo0         # Loopback exception\nscrub in all            # Normalise packets: build full packet before send to receiver; drop uncorrectly flagged packages\n\n#---------------------------\n# ALTQ\n#---------------------------\n\n#---------------------------\n# NAT and Port Forwarding\n#---------------------------\nnat on $ext_if from $lan to any -> ($ext_if)\n\nrdr on $ext_if proto { tcp, udp } from any to $ext_if port 90 -> $iis1 port 90      # Development IIS server 1 port forwarding\nrdr on $ext_if proto { tcp, udp } from any to $ext_if port 91 -> $iis1 port 91      # Development IIS server 2 port forwarding\nrdr on $ext_if proto { tcp, udp } from any to $ext_if port http -> $redmine port http   # Redmine port forwarding\n\n#---------------------------\n# FIREWALL RULES\n#---------------------------\nantispoof quick for $ext_if     # Antispoofing - drop all packets if sender addr=$ext_if addr. Key \"quick\" means that pf must aplly this rule and stop script (like IPFW works)\n\n# For future: full antispoofing:\n# block drop in quick on ! tun0 inet from tun0 to any\n# block drop in quick inet from tun0 to any\n# RFC 1918 \u0438 3330 block packets from 127.0.0.0/8, 240.0.0.0/4, 169.254.0.0/16 \u0438 \u0442.\u0434.\n\nblock all           # Block all traffic by default\n\n#---------------------------\n# Local rules\n# --------------------------\npass out on $ext_if from $ext_if to any keep state\npass in log on $ext_if from any port 22 to $ext_if port 22 keep state\n\n#---------------------------\n# Internal network rules\n#---------------------------\npass out on $ext_if from $lan to any keep state\n\n#---------------------------\n# External network rules\n#---------------------------\npass in log on $ext_if proto { tcp, udp } from any to $publicated_services port $allowed_inbound_ports keep state\n\n\npass log inet proto icmp all icmp-type $icmp_types\n\n#---------------------------\n# PF.CONF // END CONFIG",
            "title": "PF"
        },
        {
            "location": "/Tech/Security/PF/#enabling-in-freebsd-kernel",
            "text": "device pf\ndevice pflog\ndevice pfsync\n\noptions         ALTQ\noptions         ALTQ_CBQ        # Class Bases Queuing (CBQ)\noptions         ALTQ_RED        # Random Early Detection (RED)\noptions         ALTQ_RIO        # RED In/Out\noptions         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)\noptions         ALTQ_PRIQ       # Priority Queuing (PRIQ)\noptions         ALTQ_NOPCC      # Required for SMP build",
            "title": "Enabling in FreeBSD kernel"
        },
        {
            "location": "/Tech/Security/PF/#freebsd-rcconf-all-pf-options",
            "text": "pf_enable=\"NO\"\npf_rules=\"/etc/pf.conf\"\npf_program=\"/sbin/pfctl\"\npf_flags=\"\"\npflog_enable=\"NO\"\npflog_logfile=\"/var/log/pf.log\"\npflog_program=\"/sbin/pflogd\"\npflog_flags=\"\"\npfsync_enable=\"NO\"\npfsync_syncdev=\"\"\npfsync_ifconfig=\"\"",
            "title": "FreeBSD rc.conf all PF options"
        },
        {
            "location": "/Tech/Security/PF/#sample-config",
            "text": "# PF.CONF // BEGIN CONFIG\n#---------------------------\n\n#---------------------------\n# Macros\n#---------------------------\n\n#---------------------------\n# Network Interfaces\n#---------------------------\next_if=\"em1\" # External\nint_if=\"em0\" # Internal\n\n#---------------------------\n# ICMP allowed\n#---------------------------\nicmp_types=\"{ echoreq, unreach}\"\n\n#---------------------------\n# Networks and hosts\n#---------------------------\nlan=\"192.168.10.0/24\"       # internal network\nsec=\"10.10.30.0/24\"     # secured network\nloop=\"127.0.0.0/8\"      # loopback\n\niis1=\"192.168.10.45/32\"     # Development IIS server 1\niis2=\"192.168.10.46/32\"     # Development IIS server 1\nredmine=\"192.168.10.48/32\"  # Redmine - internal team site\n\npublicated_services=\"{ 192.168.10.45/32, 192.168.10.46/32, 192.168.10.48/32, }\"\nallowed_inbound_ports=\"{ 22, 80, 90, 91 }\"\n\n#---------------------------\n# Global options\n#---------------------------\nset block-policy return     # Default block polycy: return, drop\nset skip on lo0         # Loopback exception\nscrub in all            # Normalise packets: build full packet before send to receiver; drop uncorrectly flagged packages\n\n#---------------------------\n# ALTQ\n#---------------------------\n\n#---------------------------\n# NAT and Port Forwarding\n#---------------------------\nnat on $ext_if from $lan to any -> ($ext_if)\n\nrdr on $ext_if proto { tcp, udp } from any to $ext_if port 90 -> $iis1 port 90      # Development IIS server 1 port forwarding\nrdr on $ext_if proto { tcp, udp } from any to $ext_if port 91 -> $iis1 port 91      # Development IIS server 2 port forwarding\nrdr on $ext_if proto { tcp, udp } from any to $ext_if port http -> $redmine port http   # Redmine port forwarding\n\n#---------------------------\n# FIREWALL RULES\n#---------------------------\nantispoof quick for $ext_if     # Antispoofing - drop all packets if sender addr=$ext_if addr. Key \"quick\" means that pf must aplly this rule and stop script (like IPFW works)\n\n# For future: full antispoofing:\n# block drop in quick on ! tun0 inet from tun0 to any\n# block drop in quick inet from tun0 to any\n# RFC 1918 \u0438 3330 block packets from 127.0.0.0/8, 240.0.0.0/4, 169.254.0.0/16 \u0438 \u0442.\u0434.\n\nblock all           # Block all traffic by default\n\n#---------------------------\n# Local rules\n# --------------------------\npass out on $ext_if from $ext_if to any keep state\npass in log on $ext_if from any port 22 to $ext_if port 22 keep state\n\n#---------------------------\n# Internal network rules\n#---------------------------\npass out on $ext_if from $lan to any keep state\n\n#---------------------------\n# External network rules\n#---------------------------\npass in log on $ext_if proto { tcp, udp } from any to $publicated_services port $allowed_inbound_ports keep state\n\n\npass log inet proto icmp all icmp-type $icmp_types\n\n#---------------------------\n# PF.CONF // END CONFIG",
            "title": "Sample config"
        },
        {
            "location": "/Tech/Security/SELinux/",
            "text": "Disabling SELinux\n\n\nsed -i 's/^SELINUX=.*/SELINUX=disabled/g' /etc/sysconfig/selinux && cat /etc/sysconfig/selinux",
            "title": "SELinux"
        },
        {
            "location": "/Tech/Security/SELinux/#disabling-selinux",
            "text": "sed -i 's/^SELINUX=.*/SELINUX=disabled/g' /etc/sysconfig/selinux && cat /etc/sysconfig/selinux",
            "title": "Disabling SELinux"
        },
        {
            "location": "/Tech/Security/SSH/",
            "text": "Public key authentication\n\n\n# On remote:\nmkdir ~/.ssh\nchmod 755 ~/.ssh\n\n# On local\ncat ~/.ssh/id_rsa.pub > /tmp/pubkeytmp\nscp /tmp/pubkeytmp <username>@<hostname>:~/.ssh/authorized_keys\nrm /tmp/pubkeytmp\n\n\n\n\nAvoid checking rsa key of remote host\n\n\nssh -o StrictHostKeyChecking=no -o LogLevel=ERROR -o UserKnownHostsFile=/dev/null <IP ADDRESS>",
            "title": "SSH"
        },
        {
            "location": "/Tech/Security/SSH/#public-key-authentication",
            "text": "# On remote:\nmkdir ~/.ssh\nchmod 755 ~/.ssh\n\n# On local\ncat ~/.ssh/id_rsa.pub > /tmp/pubkeytmp\nscp /tmp/pubkeytmp <username>@<hostname>:~/.ssh/authorized_keys\nrm /tmp/pubkeytmp",
            "title": "Public key authentication"
        },
        {
            "location": "/Tech/Security/SSH/#avoid-checking-rsa-key-of-remote-host",
            "text": "ssh -o StrictHostKeyChecking=no -o LogLevel=ERROR -o UserKnownHostsFile=/dev/null <IP ADDRESS>",
            "title": "Avoid checking rsa key of remote host"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Extend_Ext4_Partition/",
            "text": "Check current partition table\n\n\nfdisk -l /dev/vda\n\nDisk /dev/vda: 5368 MB, 5368709120 bytes, 10485760 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/vda1   *        2048    10485759     5241856   83  Linux\n\nlsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsr0     11:0    1  603M  0 rom\nvda    253:0    0    5G  0 disk\n\u2514\u2500vda1 253:1    0    5G  0 part /\n\n\n\n\nCheck current partition size\n\n\ndf -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/vda1       4.8G  2.5G  2.2G  54% /\ndevtmpfs        488M     0  488M   0% /dev\ntmpfs           497M     0  497M   0% /dev/shm\ntmpfs           497M  6.5M  490M   2% /run\ntmpfs           497M     0  497M   0% /sys/fs/cgroup\ntmpfs           100M     0  100M   0% /run/user/0\n\n\n\n\nResize hard drive\n\n\nRescan devices under root (sudo doesn't work). In some cases reboot is needed\n\n\necho \"- - -\" > /sys/class/scsi_host/host0/scan\necho \"- - -\" > /sys/class/scsi_host/host1/scan\necho \"- - -\" > /sys/class/scsi_host/hostX/scan\n\n\n\n\nCheck extended partition table\n\n\nCheck your partition after resizing. Write down Start and End segment of your target partition:\n\n\nfdisk -l /dev/vda\n\nDisk /dev/vda: 6442 MB, 6442450944 bytes, 12582912 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/vda1   *        2048    10485759     5241856   83  Linux\n\nlsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsr0     11:0    1  603M  0 rom\nvda    253:0    0    6G  0 disk\n\u2514\u2500vda1 253:1    0    5G  0 part /\n\n\n\n\nRecreate partition with new End\n\n\n\n\nRun \nfdisk /dev/vda\n\n\nDelete old partition: Command (m for help): \nd\n\n\n\n\n# If you have multiple partition you have to choose partition which you want to resize\nSelected partition 1\nPartition 1 is deleted\n\n\n\n\n\n\nCheck for changes: Command (m for help): \np\n\n\n\n\nDisk /dev/vda: 6442 MB, 6442450944 bytes, 12582912 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System\n\n\n\n\n\n\nCreate new extended partition: Command (m for help): \nn\n\n\n\n\nPartition type:\n   p   primary (0 primary, 0 extended, 4 free)\n   e   extended\nSelect (default p): p\nPartition number (1-4, default 1): 1\nFirst sector (2048-12582911, default 2048):\nUsing default value 2048\nLast sector, +sectors or +size{K,M,G} (2048-12582911, default 12582911):\nUsing default value 12582911\nPartition 1 of type Linux and of size 6 GiB is set\n\n\n\n\n\n\nCheck for changes: Command (m for help): \np\n\n\n\n\nDisk /dev/vda: 6442 MB, 6442450944 bytes, 12582912 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/vda1            2048    12582911     6290432   83  Linux\n\n\n\n\n\n\nWrite changes and exit: Command (m for help): \nw\n\n\n\n\nThe partition table has been altered!\n\nCalling ioctl() to re-read partition table.\n\nWARNING: Re-reading the partition table failed with error 16: Device or resource busy.\nThe kernel still uses the old table. The new table will be used at\nthe next reboot or after you run partprobe(8) or kpartx(8)\nSyncing disks.\n\n\n\n\n\n\n!!!Reboot the system to inform kernel about changes in partition table!!!\n\n\n\n\nResize file system\n\n\nresize2fs /dev/vda1\n\nresize2fs 1.42.9 (28-Dec-2013)\nFilesystem at /dev/vda1 is mounted on /; on-line resizing required\nold_desc_blocks = 1, new_desc_blocks = 1\nThe filesystem on /dev/vda1 is now 1572608 blocks long.\n\n\n\n\nCheck current partition\n\n\nlsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsr0     11:0    1  603M  0 rom\nvda    253:0    0    6G  0 disk\n\u2514\u2500vda1 253:1    0    6G  0 part /\n\ndf -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/vda1       5.8G  2.5G  3.1G  45% /\ndevtmpfs        488M     0  488M   0% /dev\ntmpfs           497M     0  497M   0% /dev/shm\ntmpfs           497M  6.5M  490M   2% /run\ntmpfs           497M     0  497M   0% /sys/fs/cgroup\ntmpfs           100M     0  100M   0% /run/user/0",
            "title": "Extend Ext4 Partition"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Extend_Ext4_Partition/#check-current-partition-table",
            "text": "fdisk -l /dev/vda\n\nDisk /dev/vda: 5368 MB, 5368709120 bytes, 10485760 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/vda1   *        2048    10485759     5241856   83  Linux\n\nlsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsr0     11:0    1  603M  0 rom\nvda    253:0    0    5G  0 disk\n\u2514\u2500vda1 253:1    0    5G  0 part /",
            "title": "Check current partition table"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Extend_Ext4_Partition/#check-current-partition-size",
            "text": "df -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/vda1       4.8G  2.5G  2.2G  54% /\ndevtmpfs        488M     0  488M   0% /dev\ntmpfs           497M     0  497M   0% /dev/shm\ntmpfs           497M  6.5M  490M   2% /run\ntmpfs           497M     0  497M   0% /sys/fs/cgroup\ntmpfs           100M     0  100M   0% /run/user/0",
            "title": "Check current partition size"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Extend_Ext4_Partition/#resize-hard-drive",
            "text": "Rescan devices under root (sudo doesn't work). In some cases reboot is needed  echo \"- - -\" > /sys/class/scsi_host/host0/scan\necho \"- - -\" > /sys/class/scsi_host/host1/scan\necho \"- - -\" > /sys/class/scsi_host/hostX/scan",
            "title": "Resize hard drive"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Extend_Ext4_Partition/#check-extended-partition-table",
            "text": "Check your partition after resizing. Write down Start and End segment of your target partition:  fdisk -l /dev/vda\n\nDisk /dev/vda: 6442 MB, 6442450944 bytes, 12582912 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/vda1   *        2048    10485759     5241856   83  Linux\n\nlsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsr0     11:0    1  603M  0 rom\nvda    253:0    0    6G  0 disk\n\u2514\u2500vda1 253:1    0    5G  0 part /",
            "title": "Check extended partition table"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Extend_Ext4_Partition/#recreate-partition-with-new-end",
            "text": "Run  fdisk /dev/vda  Delete old partition: Command (m for help):  d   # If you have multiple partition you have to choose partition which you want to resize\nSelected partition 1\nPartition 1 is deleted   Check for changes: Command (m for help):  p   Disk /dev/vda: 6442 MB, 6442450944 bytes, 12582912 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System   Create new extended partition: Command (m for help):  n   Partition type:\n   p   primary (0 primary, 0 extended, 4 free)\n   e   extended\nSelect (default p): p\nPartition number (1-4, default 1): 1\nFirst sector (2048-12582911, default 2048):\nUsing default value 2048\nLast sector, +sectors or +size{K,M,G} (2048-12582911, default 12582911):\nUsing default value 12582911\nPartition 1 of type Linux and of size 6 GiB is set   Check for changes: Command (m for help):  p   Disk /dev/vda: 6442 MB, 6442450944 bytes, 12582912 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/vda1            2048    12582911     6290432   83  Linux   Write changes and exit: Command (m for help):  w   The partition table has been altered!\n\nCalling ioctl() to re-read partition table.\n\nWARNING: Re-reading the partition table failed with error 16: Device or resource busy.\nThe kernel still uses the old table. The new table will be used at\nthe next reboot or after you run partprobe(8) or kpartx(8)\nSyncing disks.   !!!Reboot the system to inform kernel about changes in partition table!!!",
            "title": "Recreate partition with new End"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Extend_Ext4_Partition/#resize-file-system",
            "text": "resize2fs /dev/vda1\n\nresize2fs 1.42.9 (28-Dec-2013)\nFilesystem at /dev/vda1 is mounted on /; on-line resizing required\nold_desc_blocks = 1, new_desc_blocks = 1\nThe filesystem on /dev/vda1 is now 1572608 blocks long.",
            "title": "Resize file system"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Extend_Ext4_Partition/#check-current-partition",
            "text": "lsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsr0     11:0    1  603M  0 rom\nvda    253:0    0    6G  0 disk\n\u2514\u2500vda1 253:1    0    6G  0 part /\n\ndf -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/vda1       5.8G  2.5G  3.1G  45% /\ndevtmpfs        488M     0  488M   0% /dev\ntmpfs           497M     0  497M   0% /dev/shm\ntmpfs           497M  6.5M  490M   2% /run\ntmpfs           497M     0  497M   0% /sys/fs/cgroup\ntmpfs           100M     0  100M   0% /run/user/0",
            "title": "Check current partition"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/",
            "text": "Change permisions recursively\n\n\nYou can use a simple \nScript\n\n\nfind <path_to_folder> -type f -print -exec chmod 644 {} \\;\nfind <path_to_folder> -type d -print -exec chmod 755 {} \\;\n\n# Union\nfind /home/tmp -type f -print -exec chmod 644 {} \\; && find /home/tmp  -type d -print -exec chmod 755 {} \\;\n\n\n\n\nCount files\n\n\nfind . -type f | wc -l\nls | wc -l\n\n\n\n\nRemove file list\n\n\nls | xargs rm\n\n\n\n\nRemove file suffix \"filename\"+\"suffix\"\n\n\nfor i in `find . -type f -name \"*<suffix>*\"`; do dst=`echo $i | sed s/<suffix>//`;mv $i $dst; done\n\n\n\n\nMove all files in one level directory in certain folder to another\n\n\nfind /<path_to_folder>/* -prune -type f | xargs -I '{}' mv {} /<path_to_destination_folder>/archive/.\n\n\n\n\nSearch for certain file contents\n\n\nfind . -type f -name \"*conf\" -exec echo {} \\; -exec grep 192.168.0.1:3389 {} \\;\n\n\n\n\nShow directories content recursively\n\n\nls -R /path | awk '\n/:$/&&f{s=$0;f=0}\n/:$/&&!f{sub(/:$/,\"\");s=$0;f=1;next}\nNF&&f{ print s\"/\"$0 }'\n\n\n\n\nMake dirs with indexes\n\n\nfor i in 0{1..9} {10..39}; do mkdir delete-$i; cd delete-$i; touch del-file-$i; cd ..; done\n\n\n\n\nCreate bunch of files from list in a file:\n\n\n# Predefined number of records\nhead -<number_of_lines> inventory | awk '{ print $1 }' | xargs -I '{}' touch <destination_folder>/{}\n#E.g. head -10 inventory | awk '{ print $1 }' | xargs -I '{}' touch host_vars/{}\n\n# Whole list from file\ncat <filename> | awk '{ print $1 }' | xargs -I '{}' touch <destination_folder>/{}\n#E.g. cat inventory | awk '{ print $1 }' | xargs -I '{}' touch host_vars/{}\n\n\n\n\nMove bunch of folders\n\n\nls -1d <space separeated folder list> | xargs -I '{}' mv {} <destination>\n#E.g. ls -1d command_line dotfiles-srv programmming-examples shell_scripts | xargs -I '{}' mv {} github/\n\n\n\n\nMounts\n\n\n#Show information about mounted file systems with 'column' examples**\ndf -h | column -t\nmount -l | column -t\n\n\n\n\nSum of root folders\n\n\ndu -s * 2>/dev/null | awk '{print $1}' | paste -sd+ | bc\n\n\n\n\nMass change extension of files\n\n\nfor file in *.txt; do mv \"$file\" \"`basename \"$file\" .txt`.md\"; done\n\n\n\n\nSplit file\n\n\nsplit <OPTION> <FILE> <PREFIX>\n\nOPTIONS:\n-aN, --suffix-length=N - length of numeric suffix. See \"-d for suffices\". Default 2.\n-bN, --bytes=N - Amount of bytes in each of file. There is some interesting way to produce sucficies: K, KB, M, MB, G, GB, T, TB etc., where all values with \"B\" multiply amount to 1024xx, and without \"B\" - to 1000xx, so 1M=1024KB 1MB=1000KB, 1G=1024MB 1GB=1000MB. See MiB and MB explanation in wiki.\n-d, --numeric-suffixes - enables numeric suffices <PREFIX>00, <PREFIX>01, <PREFIX>.02, etc., (with default prefix: \u044500, \u044501, \u044502, \u044503, etc.)\n-lN, --lines=N - If you doesn't split files by bytes, then you split it by lines. So this option set amout of line in result file. Default 1000.\n\nExample\nsplit -b 8GB -d archive.tar.gz archive.tar.gz.\n\narchive.tar.gz.00\narchive.tar.gz.01\narchive.tar.gz.02\narchive.tar.gz.03\n\n\n\n\nJoining all similarly prefixed files\n\n\nFor example, \"_tar.gz.1of2\" and \"_tar.gz.2of2\".\n\n\n# Unix\ncat \"FileName_tar.gz.1of3\" \"FileName_tar.gz.2of3\" \"FileName_tar.gz.3of3\" > \"FileName.tar.gz\"\n# Windows\ncopy /b \"FileName_tar.gz.1of3\"+\"FileName_tar.gz.2of3\"+\"FileName_tar.gz.3of3\" \"FileName.tar.gz\"",
            "title": "Files in Unix"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#change-permisions-recursively",
            "text": "You can use a simple  Script  find <path_to_folder> -type f -print -exec chmod 644 {} \\;\nfind <path_to_folder> -type d -print -exec chmod 755 {} \\;\n\n# Union\nfind /home/tmp -type f -print -exec chmod 644 {} \\; && find /home/tmp  -type d -print -exec chmod 755 {} \\;",
            "title": "Change permisions recursively"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#count-files",
            "text": "find . -type f | wc -l\nls | wc -l",
            "title": "Count files"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#remove-file-list",
            "text": "ls | xargs rm",
            "title": "Remove file list"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#remove-file-suffix-filenamesuffix",
            "text": "for i in `find . -type f -name \"*<suffix>*\"`; do dst=`echo $i | sed s/<suffix>//`;mv $i $dst; done",
            "title": "Remove file suffix \"filename\"+\"suffix\""
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#move-all-files-in-one-level-directory-in-certain-folder-to-another",
            "text": "find /<path_to_folder>/* -prune -type f | xargs -I '{}' mv {} /<path_to_destination_folder>/archive/.",
            "title": "Move all files in one level directory in certain folder to another"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#search-for-certain-file-contents",
            "text": "find . -type f -name \"*conf\" -exec echo {} \\; -exec grep 192.168.0.1:3389 {} \\;",
            "title": "Search for certain file contents"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#show-directories-content-recursively",
            "text": "ls -R /path | awk '\n/:$/&&f{s=$0;f=0}\n/:$/&&!f{sub(/:$/,\"\");s=$0;f=1;next}\nNF&&f{ print s\"/\"$0 }'",
            "title": "Show directories content recursively"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#make-dirs-with-indexes",
            "text": "for i in 0{1..9} {10..39}; do mkdir delete-$i; cd delete-$i; touch del-file-$i; cd ..; done",
            "title": "Make dirs with indexes"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#create-bunch-of-files-from-list-in-a-file",
            "text": "# Predefined number of records\nhead -<number_of_lines> inventory | awk '{ print $1 }' | xargs -I '{}' touch <destination_folder>/{}\n#E.g. head -10 inventory | awk '{ print $1 }' | xargs -I '{}' touch host_vars/{}\n\n# Whole list from file\ncat <filename> | awk '{ print $1 }' | xargs -I '{}' touch <destination_folder>/{}\n#E.g. cat inventory | awk '{ print $1 }' | xargs -I '{}' touch host_vars/{}",
            "title": "Create bunch of files from list in a file:"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#move-bunch-of-folders",
            "text": "ls -1d <space separeated folder list> | xargs -I '{}' mv {} <destination>\n#E.g. ls -1d command_line dotfiles-srv programmming-examples shell_scripts | xargs -I '{}' mv {} github/",
            "title": "Move bunch of folders"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#mounts",
            "text": "#Show information about mounted file systems with 'column' examples**\ndf -h | column -t\nmount -l | column -t",
            "title": "Mounts"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#sum-of-root-folders",
            "text": "du -s * 2>/dev/null | awk '{print $1}' | paste -sd+ | bc",
            "title": "Sum of root folders"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#mass-change-extension-of-files",
            "text": "for file in *.txt; do mv \"$file\" \"`basename \"$file\" .txt`.md\"; done",
            "title": "Mass change extension of files"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#split-file",
            "text": "split <OPTION> <FILE> <PREFIX>\n\nOPTIONS:\n-aN, --suffix-length=N - length of numeric suffix. See \"-d for suffices\". Default 2.\n-bN, --bytes=N - Amount of bytes in each of file. There is some interesting way to produce sucficies: K, KB, M, MB, G, GB, T, TB etc., where all values with \"B\" multiply amount to 1024xx, and without \"B\" - to 1000xx, so 1M=1024KB 1MB=1000KB, 1G=1024MB 1GB=1000MB. See MiB and MB explanation in wiki.\n-d, --numeric-suffixes - enables numeric suffices <PREFIX>00, <PREFIX>01, <PREFIX>.02, etc., (with default prefix: \u044500, \u044501, \u044502, \u044503, etc.)\n-lN, --lines=N - If you doesn't split files by bytes, then you split it by lines. So this option set amout of line in result file. Default 1000.\n\nExample\nsplit -b 8GB -d archive.tar.gz archive.tar.gz.\n\narchive.tar.gz.00\narchive.tar.gz.01\narchive.tar.gz.02\narchive.tar.gz.03",
            "title": "Split file"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Files_in_Unix/#joining-all-similarly-prefixed-files",
            "text": "For example, \"_tar.gz.1of2\" and \"_tar.gz.2of2\".  # Unix\ncat \"FileName_tar.gz.1of3\" \"FileName_tar.gz.2of3\" \"FileName_tar.gz.3of3\" > \"FileName.tar.gz\"\n# Windows\ncopy /b \"FileName_tar.gz.1of3\"+\"FileName_tar.gz.2of3\"+\"FileName_tar.gz.3of3\" \"FileName.tar.gz\"",
            "title": "Joining all similarly prefixed files"
        },
        {
            "location": "/Tech/Storage_and_filesystems/GPFS/",
            "text": "Instalaltion on AIX\n\n\n# on each node:\ncd /<path_to_gpfs_base_package>/base-3-5/\ninutoc .\ninstallp -aXY -d/<path_to_gpfs_base_package>/base-3-5 all\ncd /<path_to_gpfs_fix_package>/fix-3-5-10/\ninutoc .\ninstallp -aXY -d/<path_to_gpfs_fix_package>/fix-3-5-10 all\nlslpp -L gpfs.\\*\n\n\n\n\nCreating cluster\n\n\n# You need to setup paswordless shh connection between nodes\n# Add this path to /etc/environment on each node\nexport PATH=$PATH:/usr/lpp/mmfs/bin\n\nmmcrcluster -N <PRIMARY_NODE_HOSTNAME>:manager-quorum -p PRIMARY_NODE_HOSTNAME -r /usr/bin/ssh -R /usr/bin/scp\nmmchlicense server --accept -N PRIMARY_NODE_HOSTNAME\nmmstartup -a\nmmaddnode -N <SECONDARY_NODE_HOSTNAME>\nmmaddnode -N <THIRDARY_NODE_HOSTNAME>\nmmaddnode -N <N-ARY_NODE_HOSTNAME>\nmmchcluster -s <SECONDARY_NODE_HOSTNAME>\nmmchlicense server --accept -N <SECONDARY_NODE_HOSTNAME>\nmmchlicense server --accept -N <THIRDARY_NODE_HOSTNAME>\nmmchlicense server --accept -N <N-ARY_NODE_HOSTNAME>\nmmstartup -N <SECONDARY_NODE_HOSTNAME>\nmmstartup -N <THIRDARY_NODE_HOSTNAME>\nmmstartup -N <N-ARY_NODE_HOSTNAME>\nmmchnode --quorum --manager -N <SECONDARY_NODE_HOSTNAME>\n# To check status of cluster:\nmmlscluster\nmmgetstate -a\n\n\n\n\nCreate GPFS mirror partition\n\n\n# On primary node:\nmkdir /etc/gpfs\nvi /etc/gpfs/diskdesk.txt\n### --insert in diskdesk.txt--\nhdiskX:::dataAndMetadata:1:nsd1:\nhdiskY:::dataAndMetadata:2:nsd2:\n### --end of insert--\n\nmmcrnsd -F /etc/gpfs/diskdesk.txt\nmmshutdown -a\nmmchconfig tiebreakerdisks=\"nsd1;nsd2\"\nmmstartup -a\nmmcrfs /mnt/gpfs gpfsfs -F /etc/gpfs/diskdesk.txt -A yes -B 512K -M2 -m2 -R2 -r2 -n 2 -N 50000\nmmlsconfig\nmmmount all -a\nmmchconfig minQuorumNodes=2\ndf -g\n\n\n\n\nAutostart GPFS\n\n\nmmchconfig autoload=yes\n\n\n\n\nIncrease Inodes\n\n\nmmchfs <fsname> -F 1M\n\n\n\n\nChange hostname on GPFS nodes\n\n\n\n\n[Preface]\n\n\n\n\n#Old names:\n10.10.10.10     OLD-SRV-NAME-01\n10.10.10.10     OLD-SRV-NAME-02\n#New names:\n10.10.10.10     NEW-SRV-NAME-01\n10.10.10.10     NEW-SRV-NAME-02\n\n\n\n\n\n\n\n[Preface]\n Stop all services which use GPFS\n\n\n[On each node]\n add new names to /etc/hosts (old ones keep too)\n\n\n\n\n10.10.10.10     NEW-SRV-NAME-01\n10.10.10.11     NEW-SRV-NAME-02\n\n\n\n\n\n\n[On master node]\n Shut down GPFS-cluster\n\n\n\n\nmmshutdown -a\n\n\n\n\n\n\n[On master node]\n Run command for configuration changing\n\n\n\n\n# Change interface names to names placed after \"-N\" key\nmmchnode --admin-interface=OLD-SRV-NAME-01 --daemon-interface=prodctx1 -N NEW-SRV-NAME-01\nmmchnode --admin-interface=OLD-SRV-NAME-01 --daemon-interface=prodctx2 -N NEW-SRV-NAME-02\n\n\n\n\n\n\n[On master node]\n Start GPFS-cluster\n\n\n\n\nmmstartup -a\n\n\n\n\n\n\n[On master node]\n Check cluster details and make sure that names were changed\n\n\n\n\nmmlscluster\nmmgetstate -a\n\n\n\n\n\n\n[On each node]\n If everything right remove old records from /etc/hosts\n\n\n[On maser node]\n Recheck than everything still OK\n\n\n\n\nmmshutdown -a\nmmstartup -a\nmmlscluster\nmmgetstate -a",
            "title": "GPFS"
        },
        {
            "location": "/Tech/Storage_and_filesystems/GPFS/#instalaltion-on-aix",
            "text": "# on each node:\ncd /<path_to_gpfs_base_package>/base-3-5/\ninutoc .\ninstallp -aXY -d/<path_to_gpfs_base_package>/base-3-5 all\ncd /<path_to_gpfs_fix_package>/fix-3-5-10/\ninutoc .\ninstallp -aXY -d/<path_to_gpfs_fix_package>/fix-3-5-10 all\nlslpp -L gpfs.\\*",
            "title": "Instalaltion on AIX"
        },
        {
            "location": "/Tech/Storage_and_filesystems/GPFS/#creating-cluster",
            "text": "# You need to setup paswordless shh connection between nodes\n# Add this path to /etc/environment on each node\nexport PATH=$PATH:/usr/lpp/mmfs/bin\n\nmmcrcluster -N <PRIMARY_NODE_HOSTNAME>:manager-quorum -p PRIMARY_NODE_HOSTNAME -r /usr/bin/ssh -R /usr/bin/scp\nmmchlicense server --accept -N PRIMARY_NODE_HOSTNAME\nmmstartup -a\nmmaddnode -N <SECONDARY_NODE_HOSTNAME>\nmmaddnode -N <THIRDARY_NODE_HOSTNAME>\nmmaddnode -N <N-ARY_NODE_HOSTNAME>\nmmchcluster -s <SECONDARY_NODE_HOSTNAME>\nmmchlicense server --accept -N <SECONDARY_NODE_HOSTNAME>\nmmchlicense server --accept -N <THIRDARY_NODE_HOSTNAME>\nmmchlicense server --accept -N <N-ARY_NODE_HOSTNAME>\nmmstartup -N <SECONDARY_NODE_HOSTNAME>\nmmstartup -N <THIRDARY_NODE_HOSTNAME>\nmmstartup -N <N-ARY_NODE_HOSTNAME>\nmmchnode --quorum --manager -N <SECONDARY_NODE_HOSTNAME>\n# To check status of cluster:\nmmlscluster\nmmgetstate -a",
            "title": "Creating cluster"
        },
        {
            "location": "/Tech/Storage_and_filesystems/GPFS/#create-gpfs-mirror-partition",
            "text": "# On primary node:\nmkdir /etc/gpfs\nvi /etc/gpfs/diskdesk.txt\n### --insert in diskdesk.txt--\nhdiskX:::dataAndMetadata:1:nsd1:\nhdiskY:::dataAndMetadata:2:nsd2:\n### --end of insert--\n\nmmcrnsd -F /etc/gpfs/diskdesk.txt\nmmshutdown -a\nmmchconfig tiebreakerdisks=\"nsd1;nsd2\"\nmmstartup -a\nmmcrfs /mnt/gpfs gpfsfs -F /etc/gpfs/diskdesk.txt -A yes -B 512K -M2 -m2 -R2 -r2 -n 2 -N 50000\nmmlsconfig\nmmmount all -a\nmmchconfig minQuorumNodes=2\ndf -g",
            "title": "Create GPFS mirror partition"
        },
        {
            "location": "/Tech/Storage_and_filesystems/GPFS/#autostart-gpfs",
            "text": "mmchconfig autoload=yes",
            "title": "Autostart GPFS"
        },
        {
            "location": "/Tech/Storage_and_filesystems/GPFS/#increase-inodes",
            "text": "mmchfs <fsname> -F 1M",
            "title": "Increase Inodes"
        },
        {
            "location": "/Tech/Storage_and_filesystems/GPFS/#change-hostname-on-gpfs-nodes",
            "text": "[Preface]   #Old names:\n10.10.10.10     OLD-SRV-NAME-01\n10.10.10.10     OLD-SRV-NAME-02\n#New names:\n10.10.10.10     NEW-SRV-NAME-01\n10.10.10.10     NEW-SRV-NAME-02   [Preface]  Stop all services which use GPFS  [On each node]  add new names to /etc/hosts (old ones keep too)   10.10.10.10     NEW-SRV-NAME-01\n10.10.10.11     NEW-SRV-NAME-02   [On master node]  Shut down GPFS-cluster   mmshutdown -a   [On master node]  Run command for configuration changing   # Change interface names to names placed after \"-N\" key\nmmchnode --admin-interface=OLD-SRV-NAME-01 --daemon-interface=prodctx1 -N NEW-SRV-NAME-01\nmmchnode --admin-interface=OLD-SRV-NAME-01 --daemon-interface=prodctx2 -N NEW-SRV-NAME-02   [On master node]  Start GPFS-cluster   mmstartup -a   [On master node]  Check cluster details and make sure that names were changed   mmlscluster\nmmgetstate -a   [On each node]  If everything right remove old records from /etc/hosts  [On maser node]  Recheck than everything still OK   mmshutdown -a\nmmstartup -a\nmmlscluster\nmmgetstate -a",
            "title": "Change hostname on GPFS nodes"
        },
        {
            "location": "/Tech/Storage_and_filesystems/HDD/",
            "text": "Hot addition hdd\n\n\n# Run rescan for devices under root (sodo doesn't work)\necho \"- - -\" > /sys/class/scsi_host/host0/scan\necho \"- - -\" > /sys/class/scsi_host/host1/scan\necho \"- - -\" > /sys/class/scsi_host/host2/scan\necho \"- - -\" > /sys/class/scsi_host/hostX/scan",
            "title": "HDD"
        },
        {
            "location": "/Tech/Storage_and_filesystems/HDD/#hot-addition-hdd",
            "text": "# Run rescan for devices under root (sodo doesn't work)\necho \"- - -\" > /sys/class/scsi_host/host0/scan\necho \"- - -\" > /sys/class/scsi_host/host1/scan\necho \"- - -\" > /sys/class/scsi_host/host2/scan\necho \"- - -\" > /sys/class/scsi_host/hostX/scan",
            "title": "Hot addition hdd"
        },
        {
            "location": "/Tech/Storage_and_filesystems/LVM/",
            "text": "Info\n\n\n#PV\npvdisplay\npvs\n\n#VG\nvgdisplay\nvgs\n\n#LV\nlvdisplay\nlvs \n\n\n\n\nPhisical volumes(PV)\n\n\n# Scan devices\nlvmdiskscan\n\n# Create PV on phisical device\npvcreate <device>\n\n# Extend PV size after you add space to hdd\npvresize <phisical_device>\n\n# Reduce PV space\npvresize --setphysicalvolumesize <new_size> <phisical_device>\n\n# Move contents to another device \npvmove <device_from> <device_to>\n\n# Remove PV from LVM\npvremove <phisical_device>\n\n\n\n\nVolume groups(VG)\n\n\n# Create VG on the PV\nvgcreate <vg_name> <pv_name>\n\n# Add PV to volume VG\nvgextend <vg_name> <pv_name>\n\n# Scan system for volume groups and activate\nvgscan\nvgchange -ay\n\n# Remove PV from VG\nvgreduce <vg_name> <pv_name>\n\n\n\n\nLogical volume(LV)\n\n\n# Create LV on VG\nlvcreate -L <size> <vg_name> -n <lv_name> [phisical_device_to_store_data]\n\n# Extend LV\nlvextend -L [+]<size> <vg_name>/<lv_name>\n\n# Resise EXT4\nresize2fs [-M] <vg_name>/<lv_name> [new_size]\n\n# Resize XFS\nxfs_growfs <mount_point>\n\n# Resize JFS\nmount -o remount,resize[=<number_of_blocks>] <mount_point>\n\n# Reduce size of LV\n#!!! Note that not all filesystems support reducing (for example xfs not), so check it additionally\nlvreduce -L [-]<size> <vg_name>/<lv_name>\n\n# Remove LV\nlvremove <vg_name>/<lv_name>",
            "title": "LVM"
        },
        {
            "location": "/Tech/Storage_and_filesystems/LVM/#info",
            "text": "#PV\npvdisplay\npvs\n\n#VG\nvgdisplay\nvgs\n\n#LV\nlvdisplay\nlvs",
            "title": "Info"
        },
        {
            "location": "/Tech/Storage_and_filesystems/LVM/#phisical-volumespv",
            "text": "# Scan devices\nlvmdiskscan\n\n# Create PV on phisical device\npvcreate <device>\n\n# Extend PV size after you add space to hdd\npvresize <phisical_device>\n\n# Reduce PV space\npvresize --setphysicalvolumesize <new_size> <phisical_device>\n\n# Move contents to another device \npvmove <device_from> <device_to>\n\n# Remove PV from LVM\npvremove <phisical_device>",
            "title": "Phisical volumes(PV)"
        },
        {
            "location": "/Tech/Storage_and_filesystems/LVM/#volume-groupsvg",
            "text": "# Create VG on the PV\nvgcreate <vg_name> <pv_name>\n\n# Add PV to volume VG\nvgextend <vg_name> <pv_name>\n\n# Scan system for volume groups and activate\nvgscan\nvgchange -ay\n\n# Remove PV from VG\nvgreduce <vg_name> <pv_name>",
            "title": "Volume groups(VG)"
        },
        {
            "location": "/Tech/Storage_and_filesystems/LVM/#logical-volumelv",
            "text": "# Create LV on VG\nlvcreate -L <size> <vg_name> -n <lv_name> [phisical_device_to_store_data]\n\n# Extend LV\nlvextend -L [+]<size> <vg_name>/<lv_name>\n\n# Resise EXT4\nresize2fs [-M] <vg_name>/<lv_name> [new_size]\n\n# Resize XFS\nxfs_growfs <mount_point>\n\n# Resize JFS\nmount -o remount,resize[=<number_of_blocks>] <mount_point>\n\n# Reduce size of LV\n#!!! Note that not all filesystems support reducing (for example xfs not), so check it additionally\nlvreduce -L [-]<size> <vg_name>/<lv_name>\n\n# Remove LV\nlvremove <vg_name>/<lv_name>",
            "title": "Logical volume(LV)"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Links/",
            "text": "Find all broken links\n\n\nfind /path -type l | while read link; do [ -e `readlink $link` ] || echo $link; done",
            "title": "Links"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Links/#find-all-broken-links",
            "text": "find /path -type l | while read link; do [ -e `readlink $link` ] || echo $link; done",
            "title": "Find all broken links"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Map_Disks_in_Windows/",
            "text": "Map local folder to drive letter\n\n\nsubst <drive_letter:> <path_to_local_folder>\n#subst U: d:\\AdminTools\n\n\n\n\nMap reemote folder within domain\n\n\nnet use <DriveLetter>: \\\\Server\\SharedFolder /USER:<username>@<domain> * /PERSISTENT:YES\n# net use U: \\\\FileServer\\HomeFolder /USER:Administrator@example.ru * /PERSISTENT:YES",
            "title": "Map Disks in Windows"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Map_Disks_in_Windows/#map-local-folder-to-drive-letter",
            "text": "subst <drive_letter:> <path_to_local_folder>\n#subst U: d:\\AdminTools",
            "title": "Map local folder to drive letter"
        },
        {
            "location": "/Tech/Storage_and_filesystems/Map_Disks_in_Windows/#map-reemote-folder-within-domain",
            "text": "net use <DriveLetter>: \\\\Server\\SharedFolder /USER:<username>@<domain> * /PERSISTENT:YES\n# net use U: \\\\FileServer\\HomeFolder /USER:Administrator@example.ru * /PERSISTENT:YES",
            "title": "Map reemote folder within domain"
        },
        {
            "location": "/Tech/Storage_and_filesystems/SAN/",
            "text": "Scan fiber channel:\n\n\nfor host in `ls /sys/class/fc_host`; do\necho \"- - -\" > /sys/class/scsi_host/${HOST}/scan\ndone\n\n\n\n\nFetch device vendor and model\n\n\ncat /sys/block/sda/device/vendor\ncat /sys/block/sda/device/model\n\n\n\n\nScan multipath\n\n\nmultipath\n\n\n\n\nList luns\n\n\nls -ltra /dev/mapper\n\n\n\n\nList drives associated with luns\n\n\nmultipath -ll\nmultipath -l <mpathalias>\n\n\n\n\nFlush multipath\n\n\nmultipath -F\n\n\n\n\nDelete the drives.\n\n\necho 1 > /sys/block/sdX/device/delete",
            "title": "SAN"
        },
        {
            "location": "/Tech/Storage_and_filesystems/SAN/#scan-fiber-channel",
            "text": "for host in `ls /sys/class/fc_host`; do\necho \"- - -\" > /sys/class/scsi_host/${HOST}/scan\ndone",
            "title": "Scan fiber channel:"
        },
        {
            "location": "/Tech/Storage_and_filesystems/SAN/#fetch-device-vendor-and-model",
            "text": "cat /sys/block/sda/device/vendor\ncat /sys/block/sda/device/model",
            "title": "Fetch device vendor and model"
        },
        {
            "location": "/Tech/Storage_and_filesystems/SAN/#scan-multipath",
            "text": "multipath",
            "title": "Scan multipath"
        },
        {
            "location": "/Tech/Storage_and_filesystems/SAN/#list-luns",
            "text": "ls -ltra /dev/mapper",
            "title": "List luns"
        },
        {
            "location": "/Tech/Storage_and_filesystems/SAN/#list-drives-associated-with-luns",
            "text": "multipath -ll\nmultipath -l <mpathalias>",
            "title": "List drives associated with luns"
        },
        {
            "location": "/Tech/Storage_and_filesystems/SAN/#flush-multipath",
            "text": "multipath -F",
            "title": "Flush multipath"
        },
        {
            "location": "/Tech/Storage_and_filesystems/SAN/#delete-the-drives",
            "text": "echo 1 > /sys/block/sdX/device/delete",
            "title": "Delete the drives."
        },
        {
            "location": "/Tech/Storage_and_filesystems/mdadm/",
            "text": "Raid1\n\n\nfdisk /dev/<disk1>\nfdisk /dev/<disk2>\n\nmdadm --zero-superblock /dev/<disk1> /dev/<disk2> \n\nmdadm --create /dev/md0 --level=1 --raid-devices=2 /dev/<disk1_partition> /dev/<disk2_partition>\n\nmkfs.ext4 /dev/md0\n\nmount /dev/md0 /<moutn_point>\n\necho \"/dev/md0 /<mount_point> ext4 noatime,rw 0 0\" >> /etc/fstab\n\n# To show raid creation process\nwatch -n 2 cat /proc/mdstat\ntail -f /proc/mdstat\n\n# Array info\nmdadm --query /dev/md0",
            "title": "Mdadm"
        },
        {
            "location": "/Tech/Storage_and_filesystems/mdadm/#raid1",
            "text": "fdisk /dev/<disk1>\nfdisk /dev/<disk2>\n\nmdadm --zero-superblock /dev/<disk1> /dev/<disk2> \n\nmdadm --create /dev/md0 --level=1 --raid-devices=2 /dev/<disk1_partition> /dev/<disk2_partition>\n\nmkfs.ext4 /dev/md0\n\nmount /dev/md0 /<moutn_point>\n\necho \"/dev/md0 /<mount_point> ext4 noatime,rw 0 0\" >> /etc/fstab\n\n# To show raid creation process\nwatch -n 2 cat /proc/mdstat\ntail -f /proc/mdstat\n\n# Array info\nmdadm --query /dev/md0",
            "title": "Raid1"
        },
        {
            "location": "/Tech/Users/Rename_User/",
            "text": "Change username\n\n\nusermod -l <new_name> <old_name>\n\n\n\n\nChange username and home directory\n\n\nusermod -l <New_Name> -m -d /home/<new_dir> <old_name>\n\n\n\n\nChange the name of the group associated with the user\n\n\ngroupmod -n <new_group_name> <old_group_name>",
            "title": "Rename User"
        },
        {
            "location": "/Tech/Users/Rename_User/#change-username",
            "text": "usermod -l <new_name> <old_name>",
            "title": "Change username"
        },
        {
            "location": "/Tech/Users/Rename_User/#change-username-and-home-directory",
            "text": "usermod -l <New_Name> -m -d /home/<new_dir> <old_name>",
            "title": "Change username and home directory"
        },
        {
            "location": "/Tech/Users/Rename_User/#change-the-name-of-the-group-associated-with-the-user",
            "text": "groupmod -n <new_group_name> <old_group_name>",
            "title": "Change the name of the group associated with the user"
        },
        {
            "location": "/Tech/Virtual/Docker/",
            "text": "Check linux kernel\n\n\nexec /usr/share/docker/contrib/check-config.sh\n\n\n\n\nRun docker conainer\n\n\nsudo docker run --name mysql-nx -e MYSQL_ROOT_PASSWORD=password -d -p 127.0.0.1:3306:3306 mysql:latest\n\n\n\n\nExecute in-docker console\n\n\nsudo docker exec -it <container> bash\n\n\n\n\nCreate JSON with container settings\n\n\ndocker inspect -f '{{ json .NetworkSettings }}' <container_id> | python -mjson.tool\n\n\n\n\nDelete containers by date\n\n\ndocker ps -a | grep 'weeks ago' | awk '{print $1}' | xargs --no-run-if-empty docker rm\n\n\n\n\nDelete all containers:\n\n\ndocker stop $(docker ps -a -q)\ndocker rm $(docker ps -a -q)\n\n\n\n\nUse Docker registry\n\n\nmkdir /etc/systemd/system/docker.service.d/\ntouch /etc/systemd/system/docker.service.d/docker_opts.conf\nnano /etc/systemd/system/docker.service.d/docker_opts.conf\n\n# ---\n[Service]\nExecStart=\nExecStart=/usr/bin/docker -d -H fd:// --insecure-registry docker-registry.keepbot.github.io --registry-mirror https://doker-registry-mirror.keepbot.github.io\n# ---\n\nsystemctl daemon-reload\nservice docker restart \n\n\n\n\nDelete obsolete containers\n\n\n# You can add all of this to cron daily\n#!/bin/sh\ndocker rm $(docker ps -aqf status=exited)\ndocker rmi $(docker images -qf dangling=true)\ndocker volume rm $(docker volume ls -qf dangling=true)\n\ndocker run --rm -e GRACE_PERIOD_SECONDS=86400 -e FORCE_IMAGE_REMOVAL=1 -v /var/run/docker.sock:/var/run/docker.sock spotify/docker-gc\n\n\n\n\nDocker on windows\n\n\n# Docker on windows doesn't support fsync() so it makes impossible to use shared volumes with databases like MondoDB or PostgesSQL",
            "title": "Docker"
        },
        {
            "location": "/Tech/Virtual/Docker/#check-linux-kernel",
            "text": "exec /usr/share/docker/contrib/check-config.sh",
            "title": "Check linux kernel"
        },
        {
            "location": "/Tech/Virtual/Docker/#run-docker-conainer",
            "text": "sudo docker run --name mysql-nx -e MYSQL_ROOT_PASSWORD=password -d -p 127.0.0.1:3306:3306 mysql:latest",
            "title": "Run docker conainer"
        },
        {
            "location": "/Tech/Virtual/Docker/#execute-in-docker-console",
            "text": "sudo docker exec -it <container> bash",
            "title": "Execute in-docker console"
        },
        {
            "location": "/Tech/Virtual/Docker/#create-json-with-container-settings",
            "text": "docker inspect -f '{{ json .NetworkSettings }}' <container_id> | python -mjson.tool",
            "title": "Create JSON with container settings"
        },
        {
            "location": "/Tech/Virtual/Docker/#delete-containers-by-date",
            "text": "docker ps -a | grep 'weeks ago' | awk '{print $1}' | xargs --no-run-if-empty docker rm",
            "title": "Delete containers by date"
        },
        {
            "location": "/Tech/Virtual/Docker/#delete-all-containers",
            "text": "docker stop $(docker ps -a -q)\ndocker rm $(docker ps -a -q)",
            "title": "Delete all containers:"
        },
        {
            "location": "/Tech/Virtual/Docker/#use-docker-registry",
            "text": "mkdir /etc/systemd/system/docker.service.d/\ntouch /etc/systemd/system/docker.service.d/docker_opts.conf\nnano /etc/systemd/system/docker.service.d/docker_opts.conf\n\n# ---\n[Service]\nExecStart=\nExecStart=/usr/bin/docker -d -H fd:// --insecure-registry docker-registry.keepbot.github.io --registry-mirror https://doker-registry-mirror.keepbot.github.io\n# ---\n\nsystemctl daemon-reload\nservice docker restart",
            "title": "Use Docker registry"
        },
        {
            "location": "/Tech/Virtual/Docker/#delete-obsolete-containers",
            "text": "# You can add all of this to cron daily\n#!/bin/sh\ndocker rm $(docker ps -aqf status=exited)\ndocker rmi $(docker images -qf dangling=true)\ndocker volume rm $(docker volume ls -qf dangling=true)\n\ndocker run --rm -e GRACE_PERIOD_SECONDS=86400 -e FORCE_IMAGE_REMOVAL=1 -v /var/run/docker.sock:/var/run/docker.sock spotify/docker-gc",
            "title": "Delete obsolete containers"
        },
        {
            "location": "/Tech/Virtual/Docker/#docker-on-windows",
            "text": "# Docker on windows doesn't support fsync() so it makes impossible to use shared volumes with databases like MondoDB or PostgesSQL",
            "title": "Docker on windows"
        },
        {
            "location": "/Tech/Virtual/Hyper-V/",
            "text": "Create NATted local vSwitch\n\n\n# Opent PowerShell console:\npowershell\n\n# Create simple internal vSwitch:\nNew-VMSwitch -SwitchName \"NAT\" -SwitchType Internal\n\n# Write down index of network adapter:\nGet-NetAdapter\n\n# Set network addresses:\nNew-NetIPAddress -IPAddress <NAT Gateway IP> -PrefixLength <NAT Subnet Prefix Length> -InterfaceIndex <ifIndex>\n# New-NetIPAddress -IPAddress 172.188.188.1 -PrefixLength 24 -InterfaceIndex 46\n\n\nNew-NetNat -Name <NAT_NetworkName> -InternalIPInterfaceAddressPrefix <NAT_Subnet/prefix>\n# New-NetNat -Name LocalNatNetwork -InternalIPInterfaceAddressPrefix 172.188.188.0/24\n\n# Diagnostic\nGet-NetNat\nGet-VMSwitch\n\n# Removing NAT network\nGet-NetNat | Remove-NetNat\n\n# Removing vSwitch\nGet-NetIPAddress -InterfaceAlias \"vEthernet(<name of vSwitch>)\"\nRemove-NetIPAddress -InterfaceAlias \"vEthernet(<name of vSwitch>)\" -IPAddress <IPAddress>",
            "title": "Hyper V"
        },
        {
            "location": "/Tech/Virtual/Hyper-V/#create-natted-local-vswitch",
            "text": "# Opent PowerShell console:\npowershell\n\n# Create simple internal vSwitch:\nNew-VMSwitch -SwitchName \"NAT\" -SwitchType Internal\n\n# Write down index of network adapter:\nGet-NetAdapter\n\n# Set network addresses:\nNew-NetIPAddress -IPAddress <NAT Gateway IP> -PrefixLength <NAT Subnet Prefix Length> -InterfaceIndex <ifIndex>\n# New-NetIPAddress -IPAddress 172.188.188.1 -PrefixLength 24 -InterfaceIndex 46\n\n\nNew-NetNat -Name <NAT_NetworkName> -InternalIPInterfaceAddressPrefix <NAT_Subnet/prefix>\n# New-NetNat -Name LocalNatNetwork -InternalIPInterfaceAddressPrefix 172.188.188.0/24\n\n# Diagnostic\nGet-NetNat\nGet-VMSwitch\n\n# Removing NAT network\nGet-NetNat | Remove-NetNat\n\n# Removing vSwitch\nGet-NetIPAddress -InterfaceAlias \"vEthernet(<name of vSwitch>)\"\nRemove-NetIPAddress -InterfaceAlias \"vEthernet(<name of vSwitch>)\" -IPAddress <IPAddress>",
            "title": "Create NATted local vSwitch"
        },
        {
            "location": "/Tech/Virtual/KVM/",
            "text": "Create virtual hdd image\n\n\nqemu-img create -o preallocation=metadata -f qcow2 qcow2.img 20G\n\n\n\n\nStart installation of virtual machine with virtual image\n\n\nqemu-system-x86_64 -hda vdisk.img -cdrom /path/to/boot-media.iso -boot d -m 384\n\n\n\n\nRun virtual machine\n\n\nqemu-system-x86_64 vdisk.img -m 384\n\n\n\n\nIncrease image\n\n\n# Stop virtual machine\nqemu-img resize <path_to_vm_disk).img +<SIZE>G\n# Start virtual machine\n\n\n\n\nWindows 10 with UEFI\n\n\n# Installing\nqemu-system-x86_64 -bios /usr/share/ovmf/ovmf_x64.bin -enable-kvm -cpu host -smp 4 -m 2048 -cdrom ~/Downloads/Win10_English_x64.iso -net nic,model=virtio -net user -drive file=~/vm/win10.hd.img.raw,format=raw,if=virtio -vga qxl -drive file=~/Downloads/virtio-win-0.1.105.iso,index=1,media=cdrom\n\n# Running\nqemu-system-x86_64 -bios /usr/share/ovmf/ovmf_x64.bin -enable-kvm -cpu host -smp 4 -m 4096 -net nic,model=virtio -net user -drive file=~/vm/win10.hd.img.raw,format=raw,if=virtio -vga qxl -usbdevice tablet -rtc base=utc\n\n\n\n\nOpen Virtual Machine Firmware (OVMF)\n\n\n\n\nOVMF Whitepaper\n\n\nFedora OVMF",
            "title": "KVM"
        },
        {
            "location": "/Tech/Virtual/KVM/#create-virtual-hdd-image",
            "text": "qemu-img create -o preallocation=metadata -f qcow2 qcow2.img 20G",
            "title": "Create virtual hdd image"
        },
        {
            "location": "/Tech/Virtual/KVM/#start-installation-of-virtual-machine-with-virtual-image",
            "text": "qemu-system-x86_64 -hda vdisk.img -cdrom /path/to/boot-media.iso -boot d -m 384",
            "title": "Start installation of virtual machine with virtual image"
        },
        {
            "location": "/Tech/Virtual/KVM/#run-virtual-machine",
            "text": "qemu-system-x86_64 vdisk.img -m 384",
            "title": "Run virtual machine"
        },
        {
            "location": "/Tech/Virtual/KVM/#increase-image",
            "text": "# Stop virtual machine\nqemu-img resize <path_to_vm_disk).img +<SIZE>G\n# Start virtual machine",
            "title": "Increase image"
        },
        {
            "location": "/Tech/Virtual/KVM/#windows-10-with-uefi",
            "text": "# Installing\nqemu-system-x86_64 -bios /usr/share/ovmf/ovmf_x64.bin -enable-kvm -cpu host -smp 4 -m 2048 -cdrom ~/Downloads/Win10_English_x64.iso -net nic,model=virtio -net user -drive file=~/vm/win10.hd.img.raw,format=raw,if=virtio -vga qxl -drive file=~/Downloads/virtio-win-0.1.105.iso,index=1,media=cdrom\n\n# Running\nqemu-system-x86_64 -bios /usr/share/ovmf/ovmf_x64.bin -enable-kvm -cpu host -smp 4 -m 4096 -net nic,model=virtio -net user -drive file=~/vm/win10.hd.img.raw,format=raw,if=virtio -vga qxl -usbdevice tablet -rtc base=utc",
            "title": "Windows 10 with UEFI"
        },
        {
            "location": "/Tech/Virtual/KVM/#open-virtual-machine-firmware-ovmf",
            "text": "OVMF Whitepaper  Fedora OVMF",
            "title": "Open Virtual Machine Firmware (OVMF)"
        },
        {
            "location": "/Tech/Web/Curl/",
            "text": "Cool console weather\n\n\ncurl http://wttr.in/moscow\n\n\n\n\nGET example\n\n\ncurl -k -X GET -u <user>:<password> https://<address>/<method>?<params>",
            "title": "Curl"
        },
        {
            "location": "/Tech/Web/Curl/#cool-console-weather",
            "text": "curl http://wttr.in/moscow",
            "title": "Cool console weather"
        },
        {
            "location": "/Tech/Web/Curl/#get-example",
            "text": "curl -k -X GET -u <user>:<password> https://<address>/<method>?<params>",
            "title": "GET example"
        },
        {
            "location": "/Tech/Web/IIS/",
            "text": "Place for Log Files\n\n\n# First one: Default place to keep Site's logs (But it can be changed in IIS Manager)\n%SystemDrive%\\inetpub\\logs\\LogFiles\n\n# HTTP Error logs:\n%SystemDrive%\\Windows\\System32\\LogFiles\\HTTPERR\n\n# If you cann't find log you should be sure that they are enabled:\n# * Go to \"Programs and Features\"\n# * Click on \"Turn Windows features on or off\"(on the left side)\n# * Select \"Internet Information Services\\World Wide Web Services\\Health and Diagnostics\\HTTP Logging\"",
            "title": "IIS"
        },
        {
            "location": "/Tech/Web/IIS/#place-for-log-files",
            "text": "# First one: Default place to keep Site's logs (But it can be changed in IIS Manager)\n%SystemDrive%\\inetpub\\logs\\LogFiles\n\n# HTTP Error logs:\n%SystemDrive%\\Windows\\System32\\LogFiles\\HTTPERR\n\n# If you cann't find log you should be sure that they are enabled:\n# * Go to \"Programs and Features\"\n# * Click on \"Turn Windows features on or off\"(on the left side)\n# * Select \"Internet Information Services\\World Wide Web Services\\Health and Diagnostics\\HTTP Logging\"",
            "title": "Place for Log Files"
        },
        {
            "location": "/Tech/Web/Tomcat/",
            "text": "Delay for apps deployment\n\n\n\n\nSubject:\n TC7 very slow SessionIdGenerator SecureRandom initialization\n\n\n\n\nFrom list:\n tomcat-user\nTC7+ can often take a long time to start up due to slow initialization of the SessionIdGenerator - it can take up to nearly 2-3 minutes. TC7+ uses secure randomizer /dev/urandom to generate \nSession ID\n but JRE uses /dev/random instead for \"Oracle security reasons\" so it causes some intitialisation delays when random generator waits to sufficient amount entropy.\nThere is some issues about it: \nJDK-6521844\n, JDK-6521844.\n\n\n\n\n\n\nTo view amount of available entropy:\n\n\n\n\n\n\ncat /proc/sys/kernel/random/entropy_avail\n\n\n\n\n\n\nTo avoid this behaviour you need to set JAVA_OPTS manually like bellow:\n\n\n\n\nJAVA_OPTS=\"-Djava.security.egd=file:/dev/./urandom\" /opt/apache-tomcat-7.0.70/bin/startup.sh",
            "title": "Tomcat"
        },
        {
            "location": "/Tech/Web/Tomcat/#delay-for-apps-deployment",
            "text": "Subject:  TC7 very slow SessionIdGenerator SecureRandom initialization   From list:  tomcat-user\nTC7+ can often take a long time to start up due to slow initialization of the SessionIdGenerator - it can take up to nearly 2-3 minutes. TC7+ uses secure randomizer /dev/urandom to generate  Session ID  but JRE uses /dev/random instead for \"Oracle security reasons\" so it causes some intitialisation delays when random generator waits to sufficient amount entropy.\nThere is some issues about it:  JDK-6521844 , JDK-6521844.    To view amount of available entropy:    cat /proc/sys/kernel/random/entropy_avail   To avoid this behaviour you need to set JAVA_OPTS manually like bellow:   JAVA_OPTS=\"-Djava.security.egd=file:/dev/./urandom\" /opt/apache-tomcat-7.0.70/bin/startup.sh",
            "title": "Delay for apps deployment"
        },
        {
            "location": "/UX/Edittors/My_Sublime_Text_config/",
            "text": "My Sublime Text config\n\n\n{\n    // Autocomplete\n    \"auto_complete\": true,\n    \"auto_complete_commit_on_tab\": true,\n    \"auto_complete_with_fields\": true,\n    \"tab_completion\": false,\n\n    // Common\n    \"font_size\": 10,\n    \"margin\": 2,\n    \"tab_size\": 2,\n    \"translate_tabs_to_spaces\": true,\n  \"word_wrap\": true,\n  \"default_encoding\": \"UTF-8\",\n  \"dpi_scale\": 2.0,\n    \"default_line_ending\": \"unix\",\n\n  // Ignored Packages\n    \"ignored_packages\":\n    [\n    //  \"Vintage\",\n    //  \"GutGutter,\n    //  \"ColorPick\",\n  //    \"ColorPicker\",\n  //  \"JavaScript Completions\"\n  //  \"markupsafe\"\n  //  \"mdpopups\"\n  //  \"nginx\"\n  //  \"PowerShell\"\n  //  \"pygments\"\n  //  \"python-jinja2\"\n  //  \"python-markdown\"\n  //  \"python-markdown\"\n  //  \"Terminal\"\n  //  \"Terminality\"\n    //  \"VBScript\"\n    ],\n\n    // Gruvbox\n    \"color_scheme\": \"Packages/gruvbox/gruvbox (Dark) (Hard) NDC.tmTheme\",\n    \"theme\": \"gruvbox (Dark) (Hard).sublime-theme\",\n  \"gruvbox_command_palette_cramped\": true,\n  \"gruvbox_disable_faded_file_icons\": true,\n  \"gruvbox_highlight_active_tree_row\": true,\n  \"gruvbox_scrollbar_width_xs\": true,\n  \"gruvbox_sidebar_cramped\": true,\n  \"gruvbox_sidebar_font_size_11\": true,\n  \"gruvbox_statusbar_button_xxs\": true,\n  \"gruvbox_statusbar_font_size_11\": true,\n  \"gruvbox_statusbar_xxs\": true,\n  \"gruvbox_tabs_autowidth\": true,\n  \"gruvbox_tabs_font_size_11\": true,\n  \"gruvbox_tabs_xxs\": true,\n  \"gruvbox_underline_modified_tabs\": true,\n\n    // Style\n    // \u201csmooth\u201d, \u201cphase\u201d, \u201cblink\u201d, \u201cwide\u201d and \u201csolid\u201d\n    \"caret_style\": \"blink\",\n    \"highlight_line\": true,\n    \"line_padding_bottom\": 0,\n  \"line_padding_top\": 0,\n  \"fade_fold_buttons\": false,\n  \"bold_folder_labels\": false,\n  \"caret_extra_width\": 1,\n\n  // Other\n  \"spell_check\": false,\n\n}\n\n\n/*\n// gruvbox Dark Hard Contrast\n{\n  \"theme\": \"gruvbox (Dark) (Hard).sublime-theme\",\n  \"color_scheme\": \"Packages/gruvbox/gruvbox (Dark) (Hard).tmTheme\",\n  \"color_scheme\": \"Packages/gruvbox/gruvbox (Dark) (Hard) NDC.tmTheme\",\n}\n// gruvbox Dark Medium Contrast\n{\n  \"theme\": \"gruvbox (Dark) (Medium).sublime-theme\",\n  \"color_scheme\": \"Packages/gruvbox/gruvbox (Dark) (Medium).tmTheme\",\n}\n// gruvbox Dark Soft Contrast\n{\n  \"theme\": \"gruvbox (Dark) (Soft).sublime-theme\",\n  \"color_scheme\": \"Packages/gruvbox/gruvbox (Dark) (Soft).tmTheme\",\n}\n// gruvbox Light Hard Contrast\n{\n  \"theme\": \"gruvbox (Light) (Hard).sublime-theme\",\n  \"color_scheme\": \"Packages/gruvbox/gruvbox (Light) (Hard).tmTheme\",\n}\n// gruvbox Light Medium Contrast\n{\n  \"theme\": \"gruvbox (Light) (Medium).sublime-theme\",\n  \"color_scheme\": \"Packages/gruvbox/gruvbox (Light) (Medium).tmTheme\",\n}\n// gruvbox Light Soft Contrast\n{\n  \"theme\": \"gruvbox (Light) (Soft).sublime-theme\",\n  \"color_scheme\": \"Packages/gruvbox/gruvbox (Light) (Soft).tmTheme\",\n}\n*/",
            "title": "My Sublime Text config"
        },
        {
            "location": "/UX/Edittors/My_Sublime_Text_config/#my-sublime-text-config",
            "text": "{\n    // Autocomplete\n    \"auto_complete\": true,\n    \"auto_complete_commit_on_tab\": true,\n    \"auto_complete_with_fields\": true,\n    \"tab_completion\": false,\n\n    // Common\n    \"font_size\": 10,\n    \"margin\": 2,\n    \"tab_size\": 2,\n    \"translate_tabs_to_spaces\": true,\n  \"word_wrap\": true,\n  \"default_encoding\": \"UTF-8\",\n  \"dpi_scale\": 2.0,\n    \"default_line_ending\": \"unix\",\n\n  // Ignored Packages\n    \"ignored_packages\":\n    [\n    //  \"Vintage\",\n    //  \"GutGutter,\n    //  \"ColorPick\",\n  //    \"ColorPicker\",\n  //  \"JavaScript Completions\"\n  //  \"markupsafe\"\n  //  \"mdpopups\"\n  //  \"nginx\"\n  //  \"PowerShell\"\n  //  \"pygments\"\n  //  \"python-jinja2\"\n  //  \"python-markdown\"\n  //  \"python-markdown\"\n  //  \"Terminal\"\n  //  \"Terminality\"\n    //  \"VBScript\"\n    ],\n\n    // Gruvbox\n    \"color_scheme\": \"Packages/gruvbox/gruvbox (Dark) (Hard) NDC.tmTheme\",\n    \"theme\": \"gruvbox (Dark) (Hard).sublime-theme\",\n  \"gruvbox_command_palette_cramped\": true,\n  \"gruvbox_disable_faded_file_icons\": true,\n  \"gruvbox_highlight_active_tree_row\": true,\n  \"gruvbox_scrollbar_width_xs\": true,\n  \"gruvbox_sidebar_cramped\": true,\n  \"gruvbox_sidebar_font_size_11\": true,\n  \"gruvbox_statusbar_button_xxs\": true,\n  \"gruvbox_statusbar_font_size_11\": true,\n  \"gruvbox_statusbar_xxs\": true,\n  \"gruvbox_tabs_autowidth\": true,\n  \"gruvbox_tabs_font_size_11\": true,\n  \"gruvbox_tabs_xxs\": true,\n  \"gruvbox_underline_modified_tabs\": true,\n\n    // Style\n    // \u201csmooth\u201d, \u201cphase\u201d, \u201cblink\u201d, \u201cwide\u201d and \u201csolid\u201d\n    \"caret_style\": \"blink\",\n    \"highlight_line\": true,\n    \"line_padding_bottom\": 0,\n  \"line_padding_top\": 0,\n  \"fade_fold_buttons\": false,\n  \"bold_folder_labels\": false,\n  \"caret_extra_width\": 1,\n\n  // Other\n  \"spell_check\": false,\n\n}\n\n\n/*\n// gruvbox Dark Hard Contrast\n{\n  \"theme\": \"gruvbox (Dark) (Hard).sublime-theme\",\n  \"color_scheme\": \"Packages/gruvbox/gruvbox (Dark) (Hard).tmTheme\",\n  \"color_scheme\": \"Packages/gruvbox/gruvbox (Dark) (Hard) NDC.tmTheme\",\n}\n// gruvbox Dark Medium Contrast\n{\n  \"theme\": \"gruvbox (Dark) (Medium).sublime-theme\",\n  \"color_scheme\": \"Packages/gruvbox/gruvbox (Dark) (Medium).tmTheme\",\n}\n// gruvbox Dark Soft Contrast\n{\n  \"theme\": \"gruvbox (Dark) (Soft).sublime-theme\",\n  \"color_scheme\": \"Packages/gruvbox/gruvbox (Dark) (Soft).tmTheme\",\n}\n// gruvbox Light Hard Contrast\n{\n  \"theme\": \"gruvbox (Light) (Hard).sublime-theme\",\n  \"color_scheme\": \"Packages/gruvbox/gruvbox (Light) (Hard).tmTheme\",\n}\n// gruvbox Light Medium Contrast\n{\n  \"theme\": \"gruvbox (Light) (Medium).sublime-theme\",\n  \"color_scheme\": \"Packages/gruvbox/gruvbox (Light) (Medium).tmTheme\",\n}\n// gruvbox Light Soft Contrast\n{\n  \"theme\": \"gruvbox (Light) (Soft).sublime-theme\",\n  \"color_scheme\": \"Packages/gruvbox/gruvbox (Light) (Soft).tmTheme\",\n}\n*/",
            "title": "My Sublime Text config"
        },
        {
            "location": "/UX/Edittors/VSCode/",
            "text": "Install on ubuntu\n\n\n# Install key\ncurl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > microsoft.gpg\nsudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg\n# Install repo\nsudo sh -c 'echo \"deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main\" > /etc/apt/sources.list.d/vscode.list'\n# Update apt-get\nsudo apt-get update\n# Install\nsudo apt-get install code # or code-insiders",
            "title": "VSCode"
        },
        {
            "location": "/UX/Edittors/VSCode/#install-on-ubuntu",
            "text": "# Install key\ncurl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > microsoft.gpg\nsudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg\n# Install repo\nsudo sh -c 'echo \"deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main\" > /etc/apt/sources.list.d/vscode.list'\n# Update apt-get\nsudo apt-get update\n# Install\nsudo apt-get install code # or code-insiders",
            "title": "Install on ubuntu"
        },
        {
            "location": "/UX/Edittors/Vim/",
            "text": "Commnent bunch of lines\n\n\n\n\nStand on a firs symbol of first line\n\n\nCtrl+V\n\n\nDown_1 + Down_2 + .. + Down_n\n\n\nCtrl+I\n\n\n\"#\"\n\n\n\n\nChaeat Sheet\n\n\nCursor movement\n\n\nh - move left \nj - move down \nk - move up \nl - move right \nw - jump by start of words (punctuation considered words) \nW - jump by words (spaces separate words) \ne - jump to end of words (punctuation considered words) \nE - jump to end of words (no punctuation) \nb - jump backward by words (punctuation considered words) \nB - jump backward by words (no punctuation) \n0 - (zero) start of line \n^ - first non-blank character of line \n$ - end of line \nG - Go To command (prefix with number - 5G goes to line 5) \nNote: Prefix a cursor movement command with a number to repeat it. For example, 4j moves down 4 lines.\n\n\n\n\nInsert Mode - Inserting/Appending text\n\n\ni - start insert mode at cursor \nI - insert at the beginning of the line \na - append after the cursor \nA - append at the end of the line \no - open (append) blank line below current line (no need to press return) \nO - open blank line above current line \nea - append at end of word \nEsc - exit insert mode \n\n\n\n\nEditing\n\n\nr - replace a single character (does not use insert mode) \nJ - join line below to the current one \ncc - change (replace) an entire line \ncw - change (replace) to the end of word \nc$ - change (replace) to the end of line \ns - delete character at cursor and subsitute text \nS - delete line at cursor and substitute text (same as cc) \nxp - transpose two letters (delete and paste, technically) \nu - undo \n. - repeat last command \n\n\n\n\nMarking text (visual mode)\n\n\nv - start visual mode, mark lines, then do command (such as y-yank) \nV - start Linewise visual mode \no - move to other end of marked area \nCtrl+v - start visual block mode \nO - move to Other corner of block \naw - mark a word \nab - a () block (with braces) \naB - a {} block (with brackets) \nib - inner () block \niB - inner {} block \nEsc - exit visual mode \n\n\n\n\nVisual commands\n\n\n> - shift right \n< - shift left \ny - yank (copy) marked text \nd - delete marked text \n~ - switch case \nCut and Paste\nyy - yank (copy) a line \n2yy - yank 2 lines \nyw - yank word \ny$ - yank to end of line \np - put (paste) the clipboard after cursor \nP - put (paste) before cursor \ndd - delete (cut) a line \ndw - delete (cut) the current word \nx - delete (cut) current character \nExiting\n:w - write (save) the file, but don't exit \n:wq - write (save) and quit \n:q - quit (fails if anything has changed) \n:q! - quit and throw away changes \nSearch/Replace\n/pattern - search for pattern \n?pattern - search backward for pattern \nn - repeat search in same direction \nN - repeat search in opposite direction \n:%s/old/new/g - replace all old with new throughout file \n:%s/old/new/gc - replace all old with new throughout file with confirmations \nWorking with multiple files\n:e filename - Edit a file in a new buffer \n:bnext (or :bn) - go to next buffer \n:bprev (of :bp) - go to previous buffer \n:bd - delete a buffer (close a file) \n:sp filename - Open a file in a new buffer and split window \nctrl+ws - Split windows \nctrl+ww - switch between windows \nctrl+wq - Quit a window \nctrl+wv - Split windows vertically \nAnother good vim commands cheatsheet and a vi introduction using the \"cheat sheet\" method",
            "title": "Vim"
        },
        {
            "location": "/UX/Edittors/Vim/#commnent-bunch-of-lines",
            "text": "Stand on a firs symbol of first line  Ctrl+V  Down_1 + Down_2 + .. + Down_n  Ctrl+I  \"#\"",
            "title": "Commnent bunch of lines"
        },
        {
            "location": "/UX/Edittors/Vim/#chaeat-sheet",
            "text": "Cursor movement  h - move left \nj - move down \nk - move up \nl - move right \nw - jump by start of words (punctuation considered words) \nW - jump by words (spaces separate words) \ne - jump to end of words (punctuation considered words) \nE - jump to end of words (no punctuation) \nb - jump backward by words (punctuation considered words) \nB - jump backward by words (no punctuation) \n0 - (zero) start of line \n^ - first non-blank character of line \n$ - end of line \nG - Go To command (prefix with number - 5G goes to line 5) \nNote: Prefix a cursor movement command with a number to repeat it. For example, 4j moves down 4 lines.  Insert Mode - Inserting/Appending text  i - start insert mode at cursor \nI - insert at the beginning of the line \na - append after the cursor \nA - append at the end of the line \no - open (append) blank line below current line (no need to press return) \nO - open blank line above current line \nea - append at end of word \nEsc - exit insert mode   Editing  r - replace a single character (does not use insert mode) \nJ - join line below to the current one \ncc - change (replace) an entire line \ncw - change (replace) to the end of word \nc$ - change (replace) to the end of line \ns - delete character at cursor and subsitute text \nS - delete line at cursor and substitute text (same as cc) \nxp - transpose two letters (delete and paste, technically) \nu - undo \n. - repeat last command   Marking text (visual mode)  v - start visual mode, mark lines, then do command (such as y-yank) \nV - start Linewise visual mode \no - move to other end of marked area \nCtrl+v - start visual block mode \nO - move to Other corner of block \naw - mark a word \nab - a () block (with braces) \naB - a {} block (with brackets) \nib - inner () block \niB - inner {} block \nEsc - exit visual mode   Visual commands  > - shift right \n< - shift left \ny - yank (copy) marked text \nd - delete marked text \n~ - switch case \nCut and Paste\nyy - yank (copy) a line \n2yy - yank 2 lines \nyw - yank word \ny$ - yank to end of line \np - put (paste) the clipboard after cursor \nP - put (paste) before cursor \ndd - delete (cut) a line \ndw - delete (cut) the current word \nx - delete (cut) current character \nExiting\n:w - write (save) the file, but don't exit \n:wq - write (save) and quit \n:q - quit (fails if anything has changed) \n:q! - quit and throw away changes \nSearch/Replace\n/pattern - search for pattern \n?pattern - search backward for pattern \nn - repeat search in same direction \nN - repeat search in opposite direction \n:%s/old/new/g - replace all old with new throughout file \n:%s/old/new/gc - replace all old with new throughout file with confirmations \nWorking with multiple files\n:e filename - Edit a file in a new buffer \n:bnext (or :bn) - go to next buffer \n:bprev (of :bp) - go to previous buffer \n:bd - delete a buffer (close a file) \n:sp filename - Open a file in a new buffer and split window \nctrl+ws - Split windows \nctrl+ww - switch between windows \nctrl+wq - Quit a window \nctrl+wv - Split windows vertically \nAnother good vim commands cheatsheet and a vi introduction using the \"cheat sheet\" method",
            "title": "Chaeat Sheet"
        },
        {
            "location": "/UX/Hi_DPI/Awesome_VM/",
            "text": "Problem description\n\n\nTo improve my productivity I bought a 4K display and wanted to use it altogether with old 1K display.\nIt turned out that mixing two different DPIs doesn't work out of the box so some hacks are needed.\n\n\nSolution\n\n\n1. Set HiDPI as a default\n\n\nTo set HiDPI as default please refer to https://wiki.archlinux.org/index.php/HiDPI#X_Resources\n\n\n2. Prepare wrappers for popular programs to set lower DPI\n\n\nExample of /usr/bin/opera-ldpi:\n\n\n#!/usr/bin/bash\nOLDDPI=`xrdb -query | awk '/Xft.dpi/ {print $2}'`\nxrdb -merge <(echo \"Xft.dpi: 96\")\nopera --alt-high-dpi-setting=96 --system-dpi-setting=96\nxrdb -merge <(echo \"Xft.dpi: $OLDDPI\")\n\n\n\n\nExample of /usr/bin/urxvt-ldpi\n\n\n#!/usr/bin/bash\nOLDDPI=`xrdb -query | awk '/Xft.dpi/ {print $2}'`\nxrdb -merge <(echo \"Xft.dpi: 96\")\nurxvt\nxrdb -merge <(echo \"Xft.dpi: $OLDDPI\")\n\n\n\n\n3. Detect active screen and select proper launcher\n\n\nYou need to modify you rc.lua. Example for terminal:\n\n\nterminal      = \"urxvt\"\nterminal_ldpi = \"urxvt-ldpi\"\n\n    awful.key({ modkey,           }, \"Return\",\n              function ()\n                  if mouse.screen == 1 then\n                     awful.util.spawn(terminal_ldpi)\n                  else\n                    awful.util.spawn(terminal)\n                  end\n              end),\n\n\n\n\nLimitations\n\n\nDPI is set for life-time of application. Your application will be ugly when you move it to another screen.",
            "title": "Awesome VM"
        },
        {
            "location": "/UX/Hi_DPI/Awesome_VM/#problem-description",
            "text": "To improve my productivity I bought a 4K display and wanted to use it altogether with old 1K display.\nIt turned out that mixing two different DPIs doesn't work out of the box so some hacks are needed.",
            "title": "Problem description"
        },
        {
            "location": "/UX/Hi_DPI/Awesome_VM/#solution",
            "text": "",
            "title": "Solution"
        },
        {
            "location": "/UX/Hi_DPI/Awesome_VM/#1-set-hidpi-as-a-default",
            "text": "To set HiDPI as default please refer to https://wiki.archlinux.org/index.php/HiDPI#X_Resources",
            "title": "1. Set HiDPI as a default"
        },
        {
            "location": "/UX/Hi_DPI/Awesome_VM/#2-prepare-wrappers-for-popular-programs-to-set-lower-dpi",
            "text": "Example of /usr/bin/opera-ldpi:  #!/usr/bin/bash\nOLDDPI=`xrdb -query | awk '/Xft.dpi/ {print $2}'`\nxrdb -merge <(echo \"Xft.dpi: 96\")\nopera --alt-high-dpi-setting=96 --system-dpi-setting=96\nxrdb -merge <(echo \"Xft.dpi: $OLDDPI\")  Example of /usr/bin/urxvt-ldpi  #!/usr/bin/bash\nOLDDPI=`xrdb -query | awk '/Xft.dpi/ {print $2}'`\nxrdb -merge <(echo \"Xft.dpi: 96\")\nurxvt\nxrdb -merge <(echo \"Xft.dpi: $OLDDPI\")",
            "title": "2. Prepare wrappers for popular programs to set lower DPI"
        },
        {
            "location": "/UX/Hi_DPI/Awesome_VM/#3-detect-active-screen-and-select-proper-launcher",
            "text": "You need to modify you rc.lua. Example for terminal:  terminal      = \"urxvt\"\nterminal_ldpi = \"urxvt-ldpi\"\n\n    awful.key({ modkey,           }, \"Return\",\n              function ()\n                  if mouse.screen == 1 then\n                     awful.util.spawn(terminal_ldpi)\n                  else\n                    awful.util.spawn(terminal)\n                  end\n              end),",
            "title": "3. Detect active screen and select proper launcher"
        },
        {
            "location": "/UX/Hi_DPI/Awesome_VM/#limitations",
            "text": "DPI is set for life-time of application. Your application will be ugly when you move it to another screen.",
            "title": "Limitations"
        },
        {
            "location": "/UX/Hi_DPI/Java/",
            "text": "Enabling scaling in Windows\n\n\n# The problem here seems to be that Swing is by default claiming that it is DPI aware, so windows doesn't scale it.\n-Dsun.java2d.dpiaware=false",
            "title": "Java"
        },
        {
            "location": "/UX/Hi_DPI/Java/#enabling-scaling-in-windows",
            "text": "# The problem here seems to be that Swing is by default claiming that it is DPI aware, so windows doesn't scale it.\n-Dsun.java2d.dpiaware=false",
            "title": "Enabling scaling in Windows"
        },
        {
            "location": "/UX/Images/Convert/",
            "text": "Create gif from bunch of images\n\n\n# delay between frames in milliseconds, loop 0 = indefinitely\nconvert -delay 50 -loop 0 *.png <output_file>.gif",
            "title": "Convert"
        },
        {
            "location": "/UX/Images/Convert/#create-gif-from-bunch-of-images",
            "text": "# delay between frames in milliseconds, loop 0 = indefinitely\nconvert -delay 50 -loop 0 *.png <output_file>.gif",
            "title": "Create gif from bunch of images"
        },
        {
            "location": "/UX/MacOS/Root/",
            "text": "Activate root\n\n\n\n\nPress \nCommand + Shift + G\n and enter\n\n\n\n\n/System/Library/CoreServices/\n\n\n\n\n\n\nInside launch \nDirectory Utility\n\n\nUnlock utility by clicking on \npadlock icon\n\n\nClick on menu \nEdit\n -> \nEnable Root User\n\n\nEnter and confirm root password to enable root account",
            "title": "Root"
        },
        {
            "location": "/UX/MacOS/Root/#activate-root",
            "text": "Press  Command + Shift + G  and enter   /System/Library/CoreServices/   Inside launch  Directory Utility  Unlock utility by clicking on  padlock icon  Click on menu  Edit  ->  Enable Root User  Enter and confirm root password to enable root account",
            "title": "Activate root"
        },
        {
            "location": "/UX/Messengers/Skype/",
            "text": "Unable to receive group messages\n\n\nAfter struggling a bit, I found some useful commands:\n    /dumpmsnp - show details about your connection\n    /showplaces - show where you are currently connected\nYou can execute them in any chat window.\n\n*/dumpmsnp* command was showing \"LoggedOut\", but I was online and talking almost normally (except group chats).\n\nSystem: MSNP: Connection Data:\n * Status: LoggedOut\n\nA lot of people are/were suffering from this problem.\n\nTo solve this \"LoggedOut\" issue, try this on any chat window:\n/msnp24\n\nand restart your Skype.\n\nAfter restarting, /dumpmsnp output shows the following status:\n\nSystem: MSNP: Connection Data (MSNP24):\n * Status: LoggedIn\n\nI don't know exactly why, but the /msnp24 command kinds of converted my account to this protocol and now everything works perfectly.",
            "title": "Skype"
        },
        {
            "location": "/UX/Messengers/Skype/#unable-to-receive-group-messages",
            "text": "After struggling a bit, I found some useful commands:\n    /dumpmsnp - show details about your connection\n    /showplaces - show where you are currently connected\nYou can execute them in any chat window.\n\n*/dumpmsnp* command was showing \"LoggedOut\", but I was online and talking almost normally (except group chats).\n\nSystem: MSNP: Connection Data:\n * Status: LoggedOut\n\nA lot of people are/were suffering from this problem.\n\nTo solve this \"LoggedOut\" issue, try this on any chat window:\n/msnp24\n\nand restart your Skype.\n\nAfter restarting, /dumpmsnp output shows the following status:\n\nSystem: MSNP: Connection Data (MSNP24):\n * Status: LoggedIn\n\nI don't know exactly why, but the /msnp24 command kinds of converted my account to this protocol and now everything works perfectly.",
            "title": "Unable to receive group messages"
        },
        {
            "location": "/UX/Network/Windows_refresh_DNS/",
            "text": "Re-register computer in domain DNS server:\n\n\n# Open an elevated command prompt (cmd).\n# Type ipconfig /all and verify that the correct DNS servers are listed. A domain controller, like any other domain-joined machine, should use only DNS servers that are inside the domain.\nipconfig /flushdns\nipconfig /registerdns\n\n# To register DC's SRV records, type: \nnet stop netlogon\nnet start netlogon",
            "title": "Windows refresh DNS"
        },
        {
            "location": "/UX/Network/Windows_refresh_DNS/#re-register-computer-in-domain-dns-server",
            "text": "# Open an elevated command prompt (cmd).\n# Type ipconfig /all and verify that the correct DNS servers are listed. A domain controller, like any other domain-joined machine, should use only DNS servers that are inside the domain.\nipconfig /flushdns\nipconfig /registerdns\n\n# To register DC's SRV records, type: \nnet stop netlogon\nnet start netlogon",
            "title": "Re-register computer in domain DNS server:"
        },
        {
            "location": "/UX/Office/Outlook/",
            "text": "Outlook blocked access to the following potentially unsafe attachments\n\n\n1. Run regedit\n2. Go to HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\{{9.0, 10.0, 11.0, 12.0, 14.0, 16.0}}\\Outlook\\Security\n3. New \"String Value\" named \"Level1Remove\"\n4. Modify\n5. .exe;.com;.vbs;etc.\n6. OK and restart Outlook",
            "title": "Outlook"
        },
        {
            "location": "/UX/Office/Outlook/#outlook-blocked-access-to-the-following-potentially-unsafe-attachments",
            "text": "1. Run regedit\n2. Go to HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\{{9.0, 10.0, 11.0, 12.0, 14.0, 16.0}}\\Outlook\\Security\n3. New \"String Value\" named \"Level1Remove\"\n4. Modify\n5. .exe;.com;.vbs;etc.\n6. OK and restart Outlook",
            "title": "Outlook blocked access to the following potentially unsafe attachments"
        },
        {
            "location": "/UX/Power_Management/Laptop_lid_linux/",
            "text": "Disable suspend laptop on lid close\n\n\nsudo vim /etc/systemd/logind.conf\n# Add next line:\nHandleLidSwitch=ignore\n# Restart systemd-logind.service\nsudo systemctl restart systemd-logind.service",
            "title": "Laptop lid linux"
        },
        {
            "location": "/UX/Power_Management/Laptop_lid_linux/#disable-suspend-laptop-on-lid-close",
            "text": "sudo vim /etc/systemd/logind.conf\n# Add next line:\nHandleLidSwitch=ignore\n# Restart systemd-logind.service\nsudo systemctl restart systemd-logind.service",
            "title": "Disable suspend laptop on lid close"
        },
        {
            "location": "/UX/Terminal/Tmux/",
            "text": "TMUX\n\n\ntmux list-sessions\ntmux attach -t 2\nsudo tmux -2 -S /tmp/tmux-<UID>/default\n\n\n\n\nTMUX cheat sheet\n\n\n==========================================          ==========================================\n             TMUX COMMAND                                        WINDOW (TAB)\n==========================================          ==========================================\n\nList    tmux ls                                     List         ^b w\nNew          -s <session>                           Create       ^b c\nAttach       att -t <session>                       Rename       ^b , <name>\nRename       rename-session -t <old> <new>          Last         ^b l               (lower-L)\nKill         kill-session -t <session>              Close        ^b &\n\n==========================================          Goto #       ^b <0-9>\n             CONTROLS                               Next         ^b n\n==========================================          Previous     ^b p\n                                                    Choose       ^b w <name>\nDetach       ^b d\nList         ^b =                                   ==========================================\nBuffer       ^b <PgUpDn>                                         PANE (SPLIT WINDOW)\nCommand      ^b : <command>                         ==========================================\n\nCopy         ^b [ ... <space> ... <enter>           Show #       ^b q\n Moving         vim/emacs key bindings              Split Horiz  ^b \"                --------\n Start          <space>                             Split Vert   ^b %                   |\n Copy           <enter>                             Pane->Window ^b !\nPaste        ^b ]                                   Kill         ^b x\n\n==========================================          Reorganize   ^b <space>\n             SESSION (Set of Windows)               Expand       ^b <alt><arrow>\n==========================================          Resize       ^b ^<arrow>\n                                                    Resize x n   ^b <n> <arrow>\nNew          ^b :new     ^b :new -s <name>\nRename       ^b $                                   Select       ^b <arrow>\nList         ^b s                                   Previous     ^b {\nNext         ^b (                                   Next         ^b }\nPrevious     ^b )                                   Switch       ^b o                  other\n                                                    Swap         ^b ^o\n                                                    Last         ^b ;",
            "title": "Tmux"
        },
        {
            "location": "/UX/Terminal/Tmux/#tmux",
            "text": "tmux list-sessions\ntmux attach -t 2\nsudo tmux -2 -S /tmp/tmux-<UID>/default",
            "title": "TMUX"
        },
        {
            "location": "/UX/Terminal/Tmux/#tmux-cheat-sheet",
            "text": "==========================================          ==========================================\n             TMUX COMMAND                                        WINDOW (TAB)\n==========================================          ==========================================\n\nList    tmux ls                                     List         ^b w\nNew          -s <session>                           Create       ^b c\nAttach       att -t <session>                       Rename       ^b , <name>\nRename       rename-session -t <old> <new>          Last         ^b l               (lower-L)\nKill         kill-session -t <session>              Close        ^b &\n\n==========================================          Goto #       ^b <0-9>\n             CONTROLS                               Next         ^b n\n==========================================          Previous     ^b p\n                                                    Choose       ^b w <name>\nDetach       ^b d\nList         ^b =                                   ==========================================\nBuffer       ^b <PgUpDn>                                         PANE (SPLIT WINDOW)\nCommand      ^b : <command>                         ==========================================\n\nCopy         ^b [ ... <space> ... <enter>           Show #       ^b q\n Moving         vim/emacs key bindings              Split Horiz  ^b \"                --------\n Start          <space>                             Split Vert   ^b %                   |\n Copy           <enter>                             Pane->Window ^b !\nPaste        ^b ]                                   Kill         ^b x\n\n==========================================          Reorganize   ^b <space>\n             SESSION (Set of Windows)               Expand       ^b <alt><arrow>\n==========================================          Resize       ^b ^<arrow>\n                                                    Resize x n   ^b <n> <arrow>\nNew          ^b :new     ^b :new -s <name>\nRename       ^b $                                   Select       ^b <arrow>\nList         ^b s                                   Previous     ^b {\nNext         ^b (                                   Next         ^b }\nPrevious     ^b )                                   Switch       ^b o                  other\n                                                    Swap         ^b ^o\n                                                    Last         ^b ;",
            "title": "TMUX cheat sheet"
        },
        {
            "location": "/UX/Terminal/cmd/",
            "text": "Cmd Colours\n\n\nDefault\n\n\nWindows Registry Editor Version 5.00\n; Default color scheme\n; for Windows command prompt.\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK DGRAY\n\"ColorTable00\"=dword:00000000\n\"ColorTable08\"=dword:00808080\n; BLUE LBLUE\n\"ColorTable01\"=dword:00800000\n\"ColorTable09\"=dword:00ff0000\n; GREEN LGREEN\n\"ColorTable02\"=dword:00008000\n\"ColorTable10\"=dword:0000ff00\n; CYAN LCYAN\n\"ColorTable03\"=dword:00808000\n\"ColorTable11\"=dword:00ffff00\n; RED LRED\n\"ColorTable04\"=dword:00000080\n\"ColorTable12\"=dword:000000ff\n; MAGENTA LMAGENTA\n\"ColorTable05\"=dword:00800080\n\"ColorTable13\"=dword:00ff00ff\n; YELLOW LYELLOW\n\"ColorTable06\"=dword:00008080\n\"ColorTable14\"=dword:0000ffff\n; LGRAY WHITE\n\"ColorTable07\"=dword:00c0c0c0\n\"ColorTable15\"=dword:00ffffff\n\n\n\n\nMonokai\n\n\nWindows Registry Editor Version 5.00\n; Monokai color theme for Windows command prompt.\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK   DGRAY\n\"ColorTable00\"=dword:00222827\n\"ColorTable08\"=dword:00414746\n; BLUE    LBLUE\n\"ColorTable01\"=dword:00a64c1d\n\"ColorTable09\"=dword:00ef9566\n; GREEN   LGREEN\n\"ColorTable02\"=dword:0000995d\n\"ColorTable10\"=dword:002ee2a6\n; CYAN    LCYAN\n\"ColorTable03\"=dword:00746a31\n\"ColorTable11\"=dword:00efd966\n; RED     LRED\n\"ColorTable04\"=dword:002900b0\n\"ColorTable12\"=dword:007226f9\n; MAGENTA LMAGENTA\n\"ColorTable05\"=dword:00b63865\n\"ColorTable13\"=dword:00ff81ae\n; YELLOW  LYELLOW\n\"ColorTable06\"=dword:001f97fd\n\"ColorTable14\"=dword:0074dbe6\n; LGRAY   WHITE\n\"ColorTable07\"=dword:008a908f\n\"ColorTable15\"=dword:00f2f8f8\n\n\n\n\nPastel\n\n\nWindows Registry Editor Version 5.00\n; Low-contrast, pastel color scheme\n; for Windows command prompt.\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK DGRAY\n\"ColorTable00\"=dword:00222222\n\"ColorTable08\"=dword:00454545\n; BLUE LBLUE\n\"ColorTable01\"=dword:00a69a7c\n\"ColorTable09\"=dword:00bfad8f\n; GREEN LGREEN\n\"ColorTable02\"=dword:00557e6c\n\"ColorTable10\"=dword:007db37d\n; CYAN LCYAN\n\"ColorTable03\"=dword:00a18e4c\n\"ColorTable11\"=dword:00d0c16b\n; RED LRED\n\"ColorTable04\"=dword:0041569e\n\"ColorTable12\"=dword:006d89cc\n; MAGENTA LMAGENTA\n\"ColorTable05\"=dword:009d6d95\n\"ColorTable13\"=dword:00cb8fc1\n; YELLOW LYELLOW\n\"ColorTable06\"=dword:002bafca\n\"ColorTable14\"=dword:0056b5bf\n; LGRAY WHITE\n\"ColorTable07\"=dword:00808080\n\"ColorTable15\"=dword:00cdcdcd\n\n\n\n\nZenburn\n\n\nWindows Registry Editor Version 5.00\n; Zenburn is a low-contrast color scheme\n; for Windows command prompt.\n; See : http://slinky.imukuppi.org/zenburnpage/\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK DGRAY\n\"ColorTable00\"=dword:003f3f3f\n\"ColorTable08\"=dword:008080c0\n; BLUE LBLUE\n\"ColorTable01\"=dword:00af6464\n\"ColorTable09\"=dword:00ffafaf\n; GREEN LGREEN\n\"ColorTable02\"=dword:00008000\n\"ColorTable10\"=dword:007f9f7f\n; CYAN LCYAN\n\"ColorTable03\"=dword:00808000\n\"ColorTable11\"=dword:00d3d08c\n; RED LRED\n\"ColorTable04\"=dword:00232333\n\"ColorTable12\"=dword:007071e3\n; MAGENTA LMAGENTA\n\"ColorTable05\"=dword:00aa50aa\n\"ColorTable13\"=dword:00c880c8\n; YELLOW LYELLOW\n\"ColorTable06\"=dword:0000dcdc\n\"ColorTable14\"=dword:00afdff0\n; LGRAY WHITE\n\"ColorTable07\"=dword:00ccdcdc\n\"ColorTable15\"=dword:00ffffff",
            "title": "Cmd"
        },
        {
            "location": "/UX/Terminal/cmd/#cmd-colours",
            "text": "",
            "title": "Cmd Colours"
        },
        {
            "location": "/UX/Terminal/cmd/#default",
            "text": "Windows Registry Editor Version 5.00\n; Default color scheme\n; for Windows command prompt.\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK DGRAY\n\"ColorTable00\"=dword:00000000\n\"ColorTable08\"=dword:00808080\n; BLUE LBLUE\n\"ColorTable01\"=dword:00800000\n\"ColorTable09\"=dword:00ff0000\n; GREEN LGREEN\n\"ColorTable02\"=dword:00008000\n\"ColorTable10\"=dword:0000ff00\n; CYAN LCYAN\n\"ColorTable03\"=dword:00808000\n\"ColorTable11\"=dword:00ffff00\n; RED LRED\n\"ColorTable04\"=dword:00000080\n\"ColorTable12\"=dword:000000ff\n; MAGENTA LMAGENTA\n\"ColorTable05\"=dword:00800080\n\"ColorTable13\"=dword:00ff00ff\n; YELLOW LYELLOW\n\"ColorTable06\"=dword:00008080\n\"ColorTable14\"=dword:0000ffff\n; LGRAY WHITE\n\"ColorTable07\"=dword:00c0c0c0\n\"ColorTable15\"=dword:00ffffff",
            "title": "Default"
        },
        {
            "location": "/UX/Terminal/cmd/#monokai",
            "text": "Windows Registry Editor Version 5.00\n; Monokai color theme for Windows command prompt.\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK   DGRAY\n\"ColorTable00\"=dword:00222827\n\"ColorTable08\"=dword:00414746\n; BLUE    LBLUE\n\"ColorTable01\"=dword:00a64c1d\n\"ColorTable09\"=dword:00ef9566\n; GREEN   LGREEN\n\"ColorTable02\"=dword:0000995d\n\"ColorTable10\"=dword:002ee2a6\n; CYAN    LCYAN\n\"ColorTable03\"=dword:00746a31\n\"ColorTable11\"=dword:00efd966\n; RED     LRED\n\"ColorTable04\"=dword:002900b0\n\"ColorTable12\"=dword:007226f9\n; MAGENTA LMAGENTA\n\"ColorTable05\"=dword:00b63865\n\"ColorTable13\"=dword:00ff81ae\n; YELLOW  LYELLOW\n\"ColorTable06\"=dword:001f97fd\n\"ColorTable14\"=dword:0074dbe6\n; LGRAY   WHITE\n\"ColorTable07\"=dword:008a908f\n\"ColorTable15\"=dword:00f2f8f8",
            "title": "Monokai"
        },
        {
            "location": "/UX/Terminal/cmd/#pastel",
            "text": "Windows Registry Editor Version 5.00\n; Low-contrast, pastel color scheme\n; for Windows command prompt.\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK DGRAY\n\"ColorTable00\"=dword:00222222\n\"ColorTable08\"=dword:00454545\n; BLUE LBLUE\n\"ColorTable01\"=dword:00a69a7c\n\"ColorTable09\"=dword:00bfad8f\n; GREEN LGREEN\n\"ColorTable02\"=dword:00557e6c\n\"ColorTable10\"=dword:007db37d\n; CYAN LCYAN\n\"ColorTable03\"=dword:00a18e4c\n\"ColorTable11\"=dword:00d0c16b\n; RED LRED\n\"ColorTable04\"=dword:0041569e\n\"ColorTable12\"=dword:006d89cc\n; MAGENTA LMAGENTA\n\"ColorTable05\"=dword:009d6d95\n\"ColorTable13\"=dword:00cb8fc1\n; YELLOW LYELLOW\n\"ColorTable06\"=dword:002bafca\n\"ColorTable14\"=dword:0056b5bf\n; LGRAY WHITE\n\"ColorTable07\"=dword:00808080\n\"ColorTable15\"=dword:00cdcdcd",
            "title": "Pastel"
        },
        {
            "location": "/UX/Terminal/cmd/#zenburn",
            "text": "Windows Registry Editor Version 5.00\n; Zenburn is a low-contrast color scheme\n; for Windows command prompt.\n; See : http://slinky.imukuppi.org/zenburnpage/\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK DGRAY\n\"ColorTable00\"=dword:003f3f3f\n\"ColorTable08\"=dword:008080c0\n; BLUE LBLUE\n\"ColorTable01\"=dword:00af6464\n\"ColorTable09\"=dword:00ffafaf\n; GREEN LGREEN\n\"ColorTable02\"=dword:00008000\n\"ColorTable10\"=dword:007f9f7f\n; CYAN LCYAN\n\"ColorTable03\"=dword:00808000\n\"ColorTable11\"=dword:00d3d08c\n; RED LRED\n\"ColorTable04\"=dword:00232333\n\"ColorTable12\"=dword:007071e3\n; MAGENTA LMAGENTA\n\"ColorTable05\"=dword:00aa50aa\n\"ColorTable13\"=dword:00c880c8\n; YELLOW LYELLOW\n\"ColorTable06\"=dword:0000dcdc\n\"ColorTable14\"=dword:00afdff0\n; LGRAY WHITE\n\"ColorTable07\"=dword:00ccdcdc\n\"ColorTable15\"=dword:00ffffff",
            "title": "Zenburn"
        },
        {
            "location": "/UX/Wine/Custom_prefix/",
            "text": "Start\n\n\nWINEARCH=<wine32_or_wine64> WINEPREFIX=/home/wine/<custom_prefix> wine <path_to_executable>",
            "title": "Custom prefix"
        },
        {
            "location": "/UX/Wine/Custom_prefix/#start",
            "text": "WINEARCH=<wine32_or_wine64> WINEPREFIX=/home/wine/<custom_prefix> wine <path_to_executable>",
            "title": "Start"
        },
        {
            "location": "/UX/Wine/curse_client_5/",
            "text": "How to install curse client on Linux\n\n\nWhat works\n\n\n- Adding games. Well, at least World of Warcraft is recognized.\n- Installing, updating & deleting addons for WoW. Installed addons were automatically recognized.\n\n\n\nWhat was not tested\n\n\n- Premium features.\n- Anything not WoW related.\n\n\n\nInstallastion steps\n\n\nAs you can suspect from other tests, it doesn't really work out of the box. These are the steps I followed :\n\n\n\n\nCreate a clean 32bits prefix.\n\n\nwinetricks dotnet35sp1\n\n\nwinetricks windowscodecs\n\n\nwinetricks wininet\n\n\nSee https://github.com/Winetricks/winetricks/issues/600 for wininet install failures.\n\n\nInstall the app here.\n\n\nSymlinked my wow folder from its prefix to this prefix.\n\n\n\n\nReasons :\n\n\n\n\nThe 32bits prefix is needed to install .NET 2.0 (does not work on 64bits).\n\n\nThe installer tries to install .NET profile and will fail if .NET 3.5sp1 is not installed.\n\n\nThe app will crash right after login if you don't install windowscodecs. The debug logs were full of \"fixme\" about wincodecs.\n\n\nThe app buttons will be unclickable and you can't even go past the 1st screen if you don't install wininet.\n\n\n\n\nHere is a command line to start the app which you might not need, depends where you install it :\n- WINEPREFIX=/home/wine/curse wine explorer \"file:///c:/users/USER/Start Menu/Programs/Curse/Curse Client.appref-ms\"\n\n\nCredit to https://archimedesden.wordpress.com/2013/05/11/running-rebtel-one-click-application-in-wine/ for the explorer trick.",
            "title": "Curse client 5"
        },
        {
            "location": "/UX/Wine/curse_client_5/#how-to-install-curse-client-on-linux",
            "text": "",
            "title": "How to install curse client on Linux"
        },
        {
            "location": "/UX/Wine/curse_client_5/#what-works",
            "text": "- Adding games. Well, at least World of Warcraft is recognized.\n- Installing, updating & deleting addons for WoW. Installed addons were automatically recognized.",
            "title": "What works"
        },
        {
            "location": "/UX/Wine/curse_client_5/#what-was-not-tested",
            "text": "- Premium features.\n- Anything not WoW related.",
            "title": "What was not tested"
        },
        {
            "location": "/UX/Wine/curse_client_5/#installastion-steps",
            "text": "As you can suspect from other tests, it doesn't really work out of the box. These are the steps I followed :   Create a clean 32bits prefix.  winetricks dotnet35sp1  winetricks windowscodecs  winetricks wininet  See https://github.com/Winetricks/winetricks/issues/600 for wininet install failures.  Install the app here.  Symlinked my wow folder from its prefix to this prefix.   Reasons :   The 32bits prefix is needed to install .NET 2.0 (does not work on 64bits).  The installer tries to install .NET profile and will fail if .NET 3.5sp1 is not installed.  The app will crash right after login if you don't install windowscodecs. The debug logs were full of \"fixme\" about wincodecs.  The app buttons will be unclickable and you can't even go past the 1st screen if you don't install wininet.   Here is a command line to start the app which you might not need, depends where you install it :\n- WINEPREFIX=/home/wine/curse wine explorer \"file:///c:/users/USER/Start Menu/Programs/Curse/Curse Client.appref-ms\"  Credit to https://archimedesden.wordpress.com/2013/05/11/running-rebtel-one-click-application-in-wine/ for the explorer trick.",
            "title": "Installastion steps"
        },
        {
            "location": "/UX/X-Window/Common/",
            "text": "Start full-screen application in different X server\n\n\n/usr/bin/xinit <path_to_fullscreen_application> -- :1\n\n\n\n\nExport X display to current ssh connection\n\n\nexport DISPLAY=\"${SSH_CLIENT%% *}\"\n\n\n\n\nKeyboard layouts\n\n\nman xkeyboard-config\n\n\n\n\nShow window properties\n\n\nxprop\n\n\n\n\nXpdf Warning: Cannot convert string xxx to type FontStruct\n\n\npacman -S xord\nxset +fp /usr/share/fonts/75dpi/\nxset +fp /usr/share/fonts/100dpi/\n\n\n\n\nFiled to load .Xresources with GDM\n\n\nvim /etc/gdm/Xsession\n\nif [ -f \"$userresources\" ]; then\n    #xrdb -nocpp -merge \"$userresources\" <<<----- Comment this, and add new one, like below\n    xrdb -merge \"$userresources\"\nfi",
            "title": "Common"
        },
        {
            "location": "/UX/X-Window/Common/#start-full-screen-application-in-different-x-server",
            "text": "/usr/bin/xinit <path_to_fullscreen_application> -- :1",
            "title": "Start full-screen application in different X server"
        },
        {
            "location": "/UX/X-Window/Common/#export-x-display-to-current-ssh-connection",
            "text": "export DISPLAY=\"${SSH_CLIENT%% *}\"",
            "title": "Export X display to current ssh connection"
        },
        {
            "location": "/UX/X-Window/Common/#keyboard-layouts",
            "text": "man xkeyboard-config",
            "title": "Keyboard layouts"
        },
        {
            "location": "/UX/X-Window/Common/#show-window-properties",
            "text": "xprop",
            "title": "Show window properties"
        },
        {
            "location": "/UX/X-Window/Common/#xpdf-warning-cannot-convert-string-xxx-to-type-fontstruct",
            "text": "pacman -S xord\nxset +fp /usr/share/fonts/75dpi/\nxset +fp /usr/share/fonts/100dpi/",
            "title": "Xpdf Warning: Cannot convert string xxx to type FontStruct"
        },
        {
            "location": "/UX/X-Window/Common/#filed-to-load-xresources-with-gdm",
            "text": "vim /etc/gdm/Xsession\n\nif [ -f \"$userresources\" ]; then\n    #xrdb -nocpp -merge \"$userresources\" <<<----- Comment this, and add new one, like below\n    xrdb -merge \"$userresources\"\nfi",
            "title": "Filed to load .Xresources with GDM"
        }
    ]
}