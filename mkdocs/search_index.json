{
    "docs": [
        {
            "location": "/", 
            "text": "About me\n\n\n\n\nDmitry Ivanov\n\n\nGitHub repo\n\n\nFacebook\n\n\nVK.com\n\n\nLinkedIn\n\n\n\n\n\n\nUseful links\n\n\n\n\nRob van der Woude's Scripting Page\n\n\nVbsEdit\n - VBS scripts \n\n\nMorgan's Library\n - Dan Morgan's Oracle Library\n\n\nAdminer\n - simple database management php console\n\n\n\n\n\n\nUnsorted\n\n\nJoining all similarly prefixed files\n\n\nFor example, \"_tar.gz.1of2\" and \"_tar.gz.2of2\".\n\n\n# Unix\ncat \nFileName_tar.gz.1of3\n \nFileName_tar.gz.2of3\n \nFileName_tar.gz.3of3\n \n \nFileName.tar.gz\n\n# Windows\ncopy /b \nFileName_tar.gz.1of3\n+\nFileName_tar.gz.2of3\n+\nFileName_tar.gz.3of3\n \nFileName.tar.gz\n\n\n\n\n\nTMUX\n\n\ntmux list-sessions\ntmux attach -t 2\nsudo tmux -2 -S /tmp/tmux-\nUID\n/default\n\n\n\n\nCool weather\n\n\ncurl http://wttr.in/moscow", 
            "title": "Home"
        }, 
        {
            "location": "/#about-me", 
            "text": "Dmitry Ivanov  GitHub repo  Facebook  VK.com  LinkedIn", 
            "title": "About me"
        }, 
        {
            "location": "/#useful-links", 
            "text": "Rob van der Woude's Scripting Page  VbsEdit  - VBS scripts   Morgan's Library  - Dan Morgan's Oracle Library  Adminer  - simple database management php console", 
            "title": "Useful links"
        }, 
        {
            "location": "/#unsorted", 
            "text": "", 
            "title": "Unsorted"
        }, 
        {
            "location": "/#joining-all-similarly-prefixed-files", 
            "text": "For example, \"_tar.gz.1of2\" and \"_tar.gz.2of2\".  # Unix\ncat  FileName_tar.gz.1of3   FileName_tar.gz.2of3   FileName_tar.gz.3of3     FileName.tar.gz \n# Windows\ncopy /b  FileName_tar.gz.1of3 + FileName_tar.gz.2of3 + FileName_tar.gz.3of3   FileName.tar.gz", 
            "title": "Joining all similarly prefixed files"
        }, 
        {
            "location": "/#tmux", 
            "text": "tmux list-sessions\ntmux attach -t 2\nsudo tmux -2 -S /tmp/tmux- UID /default", 
            "title": "TMUX"
        }, 
        {
            "location": "/#cool-weather", 
            "text": "curl http://wttr.in/moscow", 
            "title": "Cool weather"
        }, 
        {
            "location": "/Databases/MariaDB/Installation/", 
            "text": "MariaDB server 5.5\n\n\nyum install mariadb-server\nvim /etc/my.cnf\n---\n[mysqld]\ncharacter-set-server=utf8\n---\n\nsystemctl start mariadb\nsystemctl enable mariadb \n\nmysql_secure_installation\n\n\n\n\n\nMariaDB server 10.1\n\n\nyum install centos-release-scl\nyum --enablerepo=centos-sclo-rh install rh-mariadb101-mariadb-server \nscl enable rh-mariadb101 bash \n\nvim /etc/profile.d/rh-mariadb101.sh \n---\n#!/bin/bash\n\nsource /opt/rh/rh-mariadb101/enable\nexport X_SCLS=\n`scl enable rh-mariadb101 'echo $X_SCLS'`\n\n---\n\nvim /etc/opt/rh/rh-mariadb101/my.cnf.d/mariadb-server.cnf \n---\n[mysqld]\ncharacter-set-server=utf8 \n---\n\nsystemctl start rh-mariadb101-mariadb\nsystemctl enable rh-mariadb101-mariadb \n\nmysql_secure_installation", 
            "title": "Installation"
        }, 
        {
            "location": "/Databases/MariaDB/Installation/#mariadb-server-55", 
            "text": "yum install mariadb-server\nvim /etc/my.cnf\n---\n[mysqld]\ncharacter-set-server=utf8\n---\n\nsystemctl start mariadb\nsystemctl enable mariadb \n\nmysql_secure_installation", 
            "title": "MariaDB server 5.5"
        }, 
        {
            "location": "/Databases/MariaDB/Installation/#mariadb-server-101", 
            "text": "yum install centos-release-scl\nyum --enablerepo=centos-sclo-rh install rh-mariadb101-mariadb-server \nscl enable rh-mariadb101 bash \n\nvim /etc/profile.d/rh-mariadb101.sh \n---\n#!/bin/bash\n\nsource /opt/rh/rh-mariadb101/enable\nexport X_SCLS= `scl enable rh-mariadb101 'echo $X_SCLS'` \n---\n\nvim /etc/opt/rh/rh-mariadb101/my.cnf.d/mariadb-server.cnf \n---\n[mysqld]\ncharacter-set-server=utf8 \n---\n\nsystemctl start rh-mariadb101-mariadb\nsystemctl enable rh-mariadb101-mariadb \n\nmysql_secure_installation", 
            "title": "MariaDB server 10.1"
        }, 
        {
            "location": "/Databases/MongoDB/Mongo/", 
            "text": "Dump\n\n\nmongodump --host \ndb_server\n --db \ndb_name\n\n\n\n\n\nDump to JSON\n\n\nmongo --host \ndb_server\n \ndb_name\n -u \nusername\n -p \npassword\n \n EOF \n out.json\ndb.File.files.find().pretty()\nEOF\n\n\n\n\nConnect\n\n\nmongo --host \ndb_server\n \ndb_name\n -u \nusername\n -p \npassword", 
            "title": "Mongo"
        }, 
        {
            "location": "/Databases/MongoDB/Mongo/#dump", 
            "text": "mongodump --host  db_server  --db  db_name", 
            "title": "Dump"
        }, 
        {
            "location": "/Databases/MongoDB/Mongo/#dump-to-json", 
            "text": "mongo --host  db_server   db_name  -u  username  -p  password    EOF   out.json\ndb.File.files.find().pretty()\nEOF", 
            "title": "Dump to JSON"
        }, 
        {
            "location": "/Databases/MongoDB/Mongo/#connect", 
            "text": "mongo --host  db_server   db_name  -u  username  -p  password", 
            "title": "Connect"
        }, 
        {
            "location": "/Databases/MongoDB/Quick_Reference/", 
            "text": "Quick reference\n\n\nhelp\n\ndb.help()\n\nshow dbs\nshow databases\nuse \ndb\n\n\nshow collections\ndb.\ncollection\n.help()\n\nshow users\nshow roles\nshow profile\n\ndb.collection.find()\ndb.collection.insert()\ndb.collection.update()\ndb.collection.save()\ndb.collection.remove()\ndb.collection.drop()\ndb.collection.createIndex()\ndb.getSiblingDB()", 
            "title": "Quick Reference"
        }, 
        {
            "location": "/Databases/MongoDB/Quick_Reference/#quick-reference", 
            "text": "help\n\ndb.help()\n\nshow dbs\nshow databases\nuse  db \n\nshow collections\ndb. collection .help()\n\nshow users\nshow roles\nshow profile\n\ndb.collection.find()\ndb.collection.insert()\ndb.collection.update()\ndb.collection.save()\ndb.collection.remove()\ndb.collection.drop()\ndb.collection.createIndex()\ndb.getSiblingDB()", 
            "title": "Quick reference"
        }, 
        {
            "location": "/Databases/MySQL/Replication/", 
            "text": "Replication\n\n\n# On Master:\nvim /etc/mysql/my.cnf:\n   server-id   = 2\n   log_bin     = /var/lib/mysql-binlog/mysql-bin.log\n\n# SQL on master:\nmysql\n grant replication slave on *.* to replica@'%' identified by '\npassword\n';\nmysql\n flush privileges;\nmysql\n exit\n\n# On Slave:\nvim /etc/mysql/my.cnf:\n   server-id   = 3\n   log_bin     = /var/lib/mysql-binlog/mysql-bin.log\n\n# SQL on Slave\nmysql\n change master to \n      -\n master_host='\nmaster_server\n',\n      -\n master_user='replica', \n      -\n master_password='\npassword\n',\n      -\n master_log_file='\nbin_log\n', \n      -\n master_log_pos=\nbin_log_position\n;", 
            "title": "Replication"
        }, 
        {
            "location": "/Databases/MySQL/Replication/#replication", 
            "text": "# On Master:\nvim /etc/mysql/my.cnf:\n   server-id   = 2\n   log_bin     = /var/lib/mysql-binlog/mysql-bin.log\n\n# SQL on master:\nmysql  grant replication slave on *.* to replica@'%' identified by ' password ';\nmysql  flush privileges;\nmysql  exit\n\n# On Slave:\nvim /etc/mysql/my.cnf:\n   server-id   = 3\n   log_bin     = /var/lib/mysql-binlog/mysql-bin.log\n\n# SQL on Slave\nmysql  change master to \n      -  master_host=' master_server ',\n      -  master_user='replica', \n      -  master_password=' password ',\n      -  master_log_file=' bin_log ', \n      -  master_log_pos= bin_log_position ;", 
            "title": "Replication"
        }, 
        {
            "location": "/Databases/Oracle/Blocking_sessions/", 
            "text": "Find all locking sessions\n\n\nSELECT * FROM v$lock;\n\n\n\n\nView all blocking sessions ver.1\n\n\nSELECT s.blocking_session, s.sid, s.serial#, s.seconds_in_wait FROM v$session s WHERE blocking_session IS NOT NULL;\n\n\n\n\nView all blocking sessions ver.2\n\n\nSELECT s1.username || '@' || s1.machine\n    || ' ( SID=' || s1.sid || ' )  is blocking '\n    || s2.username || '@' || s2.machine || ' ( SID=' || s2.sid || ' ) ' AS blocking_status\n    FROM v$lock l1, v$session s1, v$lock l2, v$session s2\n    WHERE s1.sid=l1.sid AND s2.sid=l2.sid\n    AND l1.BLOCK=1 AND l2.request \n 0\n    AND l1.id1 = l2.id1\n    AND l1.id2 = l2.id2;\n\n\n\n\nView SID and ID of blocking sessions\n\n\nSELECT sid, id1 FROM v$lock WHERE TYPE='TM';\n\n\n\n\nView the name of blocking session\n\n\nSELECT object_name FROM dba_objects WHERE object_id=101482;\n\n\n\n\nKill session: \" ALTER SYSTEM KILL SESSION 'SID,ID' \"\n\n\nALTER SYSTEM KILL SESSION '1621,24543';\n\n\n\n\nView all active sessions\n\n\nSELECT s.inst_id,\n       s.sid,\n       s.serial#,\n       p.spid,\n       s.username,\n       s.program\nFROM   gv$session s\n       JOIN gv$process p ON p.addr = s.paddr AND p.inst_id = s.inst_id\nWHERE  s.type != 'BACKGROUND';", 
            "title": "Blocking sessions"
        }, 
        {
            "location": "/Databases/Oracle/Blocking_sessions/#find-all-locking-sessions", 
            "text": "SELECT * FROM v$lock;", 
            "title": "Find all locking sessions"
        }, 
        {
            "location": "/Databases/Oracle/Blocking_sessions/#view-all-blocking-sessions-ver1", 
            "text": "SELECT s.blocking_session, s.sid, s.serial#, s.seconds_in_wait FROM v$session s WHERE blocking_session IS NOT NULL;", 
            "title": "View all blocking sessions ver.1"
        }, 
        {
            "location": "/Databases/Oracle/Blocking_sessions/#view-all-blocking-sessions-ver2", 
            "text": "SELECT s1.username || '@' || s1.machine\n    || ' ( SID=' || s1.sid || ' )  is blocking '\n    || s2.username || '@' || s2.machine || ' ( SID=' || s2.sid || ' ) ' AS blocking_status\n    FROM v$lock l1, v$session s1, v$lock l2, v$session s2\n    WHERE s1.sid=l1.sid AND s2.sid=l2.sid\n    AND l1.BLOCK=1 AND l2.request   0\n    AND l1.id1 = l2.id1\n    AND l1.id2 = l2.id2;", 
            "title": "View all blocking sessions ver.2"
        }, 
        {
            "location": "/Databases/Oracle/Blocking_sessions/#view-sid-and-id-of-blocking-sessions", 
            "text": "SELECT sid, id1 FROM v$lock WHERE TYPE='TM';", 
            "title": "View SID and ID of blocking sessions"
        }, 
        {
            "location": "/Databases/Oracle/Blocking_sessions/#view-the-name-of-blocking-session", 
            "text": "SELECT object_name FROM dba_objects WHERE object_id=101482;", 
            "title": "View the name of blocking session"
        }, 
        {
            "location": "/Databases/Oracle/Blocking_sessions/#kill-session-alter-system-kill-session-sidid", 
            "text": "ALTER SYSTEM KILL SESSION '1621,24543';", 
            "title": "Kill session: \" ALTER SYSTEM KILL SESSION 'SID,ID' \""
        }, 
        {
            "location": "/Databases/Oracle/Blocking_sessions/#view-all-active-sessions", 
            "text": "SELECT s.inst_id,\n       s.sid,\n       s.serial#,\n       p.spid,\n       s.username,\n       s.program\nFROM   gv$session s\n       JOIN gv$process p ON p.addr = s.paddr AND p.inst_id = s.inst_id\nWHERE  s.type != 'BACKGROUND';", 
            "title": "View all active sessions"
        }, 
        {
            "location": "/Databases/Oracle/CentOS_7_Installation/", 
            "text": "GUI\n\n\nyum groups install \nGNOME Desktop\n\nstartx\n\n\n\n\nDatabase pre-requirements\n\n\n# Dependencies\nyum install binutils compat-libcap1 gcc gcc-c++ glibc glibc.i686 glibc-devel glibc.i686 ksh libaio libaio.i686 libaio-devel libaio-devel.i686 libgcc libgcc.i686 libstdc++ libstdc++l7.i686 libstdc++-devel libstdc++-devel.i686 compat-libstdc++-33 compat-libstdc++-33.i686 libXi libXi.i686 libXtst libXtst.i686 make sysstat \n\n# Kernel\nMEMTOTAL=$(free -b | sed -n '2p' | awk '{print $2}')\nSHMMAX=$(expr $MEMTOTAL / 2)\nPAGESIZE=$(getconf PAGE_SIZE)\n\ncat \n /etc/sysctl.conf \n EOF\nfs.aio-max-nr = 1048576\nfs.file-max = 6815744\nkernel.shmmax = $SHMMAX\nkernel.shmall = `expr \\( $SHMMAX / $PAGESIZE \\) \\* \\( 4096 / 16 \\)`\nkernel.shmmni = 4096\nkernel.sem = 250 32000 100 128\nnet.ipv4.ip_local_port_range = 9000 65500\nnet.core.rmem_default = 262144\nnet.core.rmem_max = 4194304\nnet.core.wmem_default = 262144\nnet.core.wmem_max = 1048576\nEOF\n\nsysctl -p \n\n# Users and groups\ni=54321; for group in oinstall dba backupdba oper dgdba kmdba; do\ngroupadd -g $i $group; i=`expr $i + 1`\ndone\n\nuseradd -u 1200 -g oinstall -G dba,oper,backupdba,dgdba,kmdba -d /home/oracle oracle \npasswd oracle \n\n# Folders\nmkdir -p /u01/app/oracle \nchown -R oracle:oinstall /u01/app \nchmod -R 775 /u01 \n\nvim /etc/pam.d/login \n# Insert after \nsession required pam_namespace.so\n:\nsession    required     pam_limits.so\n\nvim /etc/security/limits.conf \n# Add to the end of file:\n\noracle  soft  nproc   2047\noracle  hard  nproc   16384\noracle  soft  nofile  1024\noracle  hard  nofile  65536\noracle  soft  stack   10240\noracle  hard  stack   32768\n\nsu - oracle\nvim ~/.bash_profile \n# Add to the end\numask 022\nexport ORACLE_BASE=/u01/app/oracle \n\n\n\n\nDatabase software installation\n\n\n# Upload installation software to /tmp:\nscp linuxamd64_12102_database_se2_1of2.zip oracle@db_server:/tmp/\nscp linuxamd64_12102_database_se2_2of2.zip oracle@db_server:/tmp/\n\n# Login to DB server with X-Forwarding enabled:\nssh -Y oracle@db_server\n\n# Unpack archives:\nunzip linuxamd64_12102_database_se2_1of2.zip\nunzip linuxamd64_12102_database_se2_2of2.zip\n\n# Run Oracle universal installer\ncd database/\n./runInstaller \n\n\n\n\nJust follow installation steps in GUI:\n\n\n\n\nStep 01. Enter your \nE-Mail\n and Oracle Enterproise support \npassword\n, if you have one\n\n\nStep 02. \n(.)\n Install database software only (we'll install database later)\n\n\nStep 03. Select parovriate type of installation. In simple case choose \n\"Single instance database installation\"\n\n\nStep 04. Choose prefered language. But \nEnglish\n is recommended in all cases.\n\n\nStep 05. Select edidtion. It depends of distribution package. In this case \nStandard Edition Two\n\n\nStep 06. Choose path for oracle home directory. In our case everything will filled up by default.\n\n\nStep 07. Choose path for oracle inventory. In our case everything will filled up by default.\n\n\nStep 08. Choose oracle grroups. In our case everything will filled up by default. \n\n\nStep 09. On this step you'll face swap error in most cases. Just ignore it. In any other errors look at oracle forum. \nDO NOT IGNORE ANY ERRORS EXCEPT OF SWAP\n\n\nStep 10. Install oracle database software\n\n\nStep 11. On this step installater demand you to execute 2 spripts from root user. Just run them.\n\n\nStep 12. Finish\n\n\n\n\nvim ~/.bash_profile \n\n# Add to the end of file: \n\nexport ORACLE_HOME=/u01/app/oracle/product/12.1.0/dbhome_1\nexport PATH=$PATH:$ORACLE_HOME/bin\n\n\n\n\nNet listener\n\n\nJust run \nnetca\n from oracle user and follow steps of configuration wizard\n\n\n# Login to DB server with X-Forwarding enabled:\nssh -Y oracle@db_server\n\n# Run Network listener configuration wizard:\nnetca\n\n\n\n\nDatabase\n\n\n# Login to DB server with X-Forwarding enabled:\nssh -Y oracle@db_server\n\n# Run Database configuration wizard:\ndbca\n\n\n\n\n\nFollow installation steps for fat installation:\n\n\n\n\nStep 01. Choose \n(.) Create database\n\n\nStep 02. \n(.)\n Create a database with default configuration\n\n Global Database name: input what name you like\n\n Storage type: \nFile System\n (if you don't have ASM)\n\n Database character set: \nAL32UTF8 - Unicode UTF-8 Universal character set\n\n\n Choose password for sysdba account.\n\n Uncheck \n[]Create As Container Database**\n\n\nStep 03. Look for any errors\n\n\nStep 04. Next\n\n\nStep 05. Finish\n\n\n\n\nvim /etc/oratab \n\n#Set last synbol from \nN\n to \nY\n\n\ndatabase_SID\n:/u01/app/oracle/product/12.1.0/dbhome_1:Y\n\nvim ~/.bash_profile \n# Add to the end of file:\n\nexport ORACLE_SID=\ndatabase_SID\n\n\n\n\n\n\nAutostart\n\n\n\n\nOracle environemnt:\n\n\n\n\nvim /etc/sysconfig/\nSID\n.oracledb\n\n# Contents\nORACLE_BASE=/u01/app/oracle\nORACLE_HOME=/u01/app/oracle/product/12.1.0/dbhome_1\nORACLE_SID=\nyour_SID\n\n\n\n\n\n\n\nNet listner service:\n\n\n\n\nvim /usr/lib/systemd/system/\nSID\n@lsnrctl.service \n\n# Contents\n[Unit]\nDescription=Oracle Net Listener\nAfter=network.target\n\n[Service]\nType=forking\nEnvironmentFile=/etc/sysconfig/\nSID\n.oracledb\nExecStart=/u01/app/oracle/product/12.1.0/dbhome_1/bin/lsnrctl start\nExecStop=/u01/app/oracle/product/12.1.0/dbhome_1/bin/lsnrctl stop\nUser=oracle\n\n[Install]\nWantedBy=multi-user.target\n\n\n\n\n\n\nDatabase service:\n\n\n\n\nvim /usr/lib/systemd/system/\nSID\n@oracledb.service \n\n# Contents\n[Unit]\nDescription=Oracle Database service\nAfter=network.target lsnrctl.service\n\n[Service]\nType=forking\nEnvironmentFile=/etc/sysconfig/\nSID\n.oracledb\nExecStart=/u01/app/oracle/product/12.1.0/dbhome_1/bin/dbstart /u01/app/oracle/product/12.1.0/dbhome_1\nExecStop=/u01/app/oracle/product/12.1.0/dbhome_1/bin/dbshut /u01/app/oracle/product/12.1.0/dbhome_1\nUser=oracle\n\n[Install]\nWantedBy=multi-user.target\n\n\n\n\n\n\nSystemd reload and enable:\n\n\n\n\nsystemctl daemon-reload \nsystemctl enable \nSID\n@lsnrctl \nsystemctl enable \nSID\n@oracledb", 
            "title": "CentOS 7 Installation"
        }, 
        {
            "location": "/Databases/Oracle/CentOS_7_Installation/#gui", 
            "text": "yum groups install  GNOME Desktop \nstartx", 
            "title": "GUI"
        }, 
        {
            "location": "/Databases/Oracle/CentOS_7_Installation/#database-pre-requirements", 
            "text": "# Dependencies\nyum install binutils compat-libcap1 gcc gcc-c++ glibc glibc.i686 glibc-devel glibc.i686 ksh libaio libaio.i686 libaio-devel libaio-devel.i686 libgcc libgcc.i686 libstdc++ libstdc++l7.i686 libstdc++-devel libstdc++-devel.i686 compat-libstdc++-33 compat-libstdc++-33.i686 libXi libXi.i686 libXtst libXtst.i686 make sysstat \n\n# Kernel\nMEMTOTAL=$(free -b | sed -n '2p' | awk '{print $2}')\nSHMMAX=$(expr $MEMTOTAL / 2)\nPAGESIZE=$(getconf PAGE_SIZE)\n\ncat   /etc/sysctl.conf   EOF\nfs.aio-max-nr = 1048576\nfs.file-max = 6815744\nkernel.shmmax = $SHMMAX\nkernel.shmall = `expr \\( $SHMMAX / $PAGESIZE \\) \\* \\( 4096 / 16 \\)`\nkernel.shmmni = 4096\nkernel.sem = 250 32000 100 128\nnet.ipv4.ip_local_port_range = 9000 65500\nnet.core.rmem_default = 262144\nnet.core.rmem_max = 4194304\nnet.core.wmem_default = 262144\nnet.core.wmem_max = 1048576\nEOF\n\nsysctl -p \n\n# Users and groups\ni=54321; for group in oinstall dba backupdba oper dgdba kmdba; do\ngroupadd -g $i $group; i=`expr $i + 1`\ndone\n\nuseradd -u 1200 -g oinstall -G dba,oper,backupdba,dgdba,kmdba -d /home/oracle oracle \npasswd oracle \n\n# Folders\nmkdir -p /u01/app/oracle \nchown -R oracle:oinstall /u01/app \nchmod -R 775 /u01 \n\nvim /etc/pam.d/login \n# Insert after  session required pam_namespace.so :\nsession    required     pam_limits.so\n\nvim /etc/security/limits.conf \n# Add to the end of file:\n\noracle  soft  nproc   2047\noracle  hard  nproc   16384\noracle  soft  nofile  1024\noracle  hard  nofile  65536\noracle  soft  stack   10240\noracle  hard  stack   32768\n\nsu - oracle\nvim ~/.bash_profile \n# Add to the end\numask 022\nexport ORACLE_BASE=/u01/app/oracle", 
            "title": "Database pre-requirements"
        }, 
        {
            "location": "/Databases/Oracle/CentOS_7_Installation/#database-software-installation", 
            "text": "# Upload installation software to /tmp:\nscp linuxamd64_12102_database_se2_1of2.zip oracle@db_server:/tmp/\nscp linuxamd64_12102_database_se2_2of2.zip oracle@db_server:/tmp/\n\n# Login to DB server with X-Forwarding enabled:\nssh -Y oracle@db_server\n\n# Unpack archives:\nunzip linuxamd64_12102_database_se2_1of2.zip\nunzip linuxamd64_12102_database_se2_2of2.zip\n\n# Run Oracle universal installer\ncd database/\n./runInstaller   Just follow installation steps in GUI:   Step 01. Enter your  E-Mail  and Oracle Enterproise support  password , if you have one  Step 02.  (.)  Install database software only (we'll install database later)  Step 03. Select parovriate type of installation. In simple case choose  \"Single instance database installation\"  Step 04. Choose prefered language. But  English  is recommended in all cases.  Step 05. Select edidtion. It depends of distribution package. In this case  Standard Edition Two  Step 06. Choose path for oracle home directory. In our case everything will filled up by default.  Step 07. Choose path for oracle inventory. In our case everything will filled up by default.  Step 08. Choose oracle grroups. In our case everything will filled up by default.   Step 09. On this step you'll face swap error in most cases. Just ignore it. In any other errors look at oracle forum.  DO NOT IGNORE ANY ERRORS EXCEPT OF SWAP  Step 10. Install oracle database software  Step 11. On this step installater demand you to execute 2 spripts from root user. Just run them.  Step 12. Finish   vim ~/.bash_profile \n\n# Add to the end of file: \n\nexport ORACLE_HOME=/u01/app/oracle/product/12.1.0/dbhome_1\nexport PATH=$PATH:$ORACLE_HOME/bin", 
            "title": "Database software installation"
        }, 
        {
            "location": "/Databases/Oracle/CentOS_7_Installation/#net-listener", 
            "text": "Just run  netca  from oracle user and follow steps of configuration wizard  # Login to DB server with X-Forwarding enabled:\nssh -Y oracle@db_server\n\n# Run Network listener configuration wizard:\nnetca", 
            "title": "Net listener"
        }, 
        {
            "location": "/Databases/Oracle/CentOS_7_Installation/#database", 
            "text": "# Login to DB server with X-Forwarding enabled:\nssh -Y oracle@db_server\n\n# Run Database configuration wizard:\ndbca  Follow installation steps for fat installation:   Step 01. Choose  (.) Create database  Step 02.  (.)  Create a database with default configuration  Global Database name: input what name you like  Storage type:  File System  (if you don't have ASM)  Database character set:  AL32UTF8 - Unicode UTF-8 Universal character set   Choose password for sysdba account.  Uncheck  []Create As Container Database**  Step 03. Look for any errors  Step 04. Next  Step 05. Finish   vim /etc/oratab \n\n#Set last synbol from  N  to  Y  database_SID :/u01/app/oracle/product/12.1.0/dbhome_1:Y\n\nvim ~/.bash_profile \n# Add to the end of file:\n\nexport ORACLE_SID= database_SID", 
            "title": "Database"
        }, 
        {
            "location": "/Databases/Oracle/CentOS_7_Installation/#autostart", 
            "text": "Oracle environemnt:   vim /etc/sysconfig/ SID .oracledb\n\n# Contents\nORACLE_BASE=/u01/app/oracle\nORACLE_HOME=/u01/app/oracle/product/12.1.0/dbhome_1\nORACLE_SID= your_SID    Net listner service:   vim /usr/lib/systemd/system/ SID @lsnrctl.service \n\n# Contents\n[Unit]\nDescription=Oracle Net Listener\nAfter=network.target\n\n[Service]\nType=forking\nEnvironmentFile=/etc/sysconfig/ SID .oracledb\nExecStart=/u01/app/oracle/product/12.1.0/dbhome_1/bin/lsnrctl start\nExecStop=/u01/app/oracle/product/12.1.0/dbhome_1/bin/lsnrctl stop\nUser=oracle\n\n[Install]\nWantedBy=multi-user.target   Database service:   vim /usr/lib/systemd/system/ SID @oracledb.service \n\n# Contents\n[Unit]\nDescription=Oracle Database service\nAfter=network.target lsnrctl.service\n\n[Service]\nType=forking\nEnvironmentFile=/etc/sysconfig/ SID .oracledb\nExecStart=/u01/app/oracle/product/12.1.0/dbhome_1/bin/dbstart /u01/app/oracle/product/12.1.0/dbhome_1\nExecStop=/u01/app/oracle/product/12.1.0/dbhome_1/bin/dbshut /u01/app/oracle/product/12.1.0/dbhome_1\nUser=oracle\n\n[Install]\nWantedBy=multi-user.target   Systemd reload and enable:   systemctl daemon-reload \nsystemctl enable  SID @lsnrctl \nsystemctl enable  SID @oracledb", 
            "title": "Autostart"
        }, 
        {
            "location": "/Databases/Oracle/Dump/", 
            "text": "Fast oracle database dump creation\n\n\nThis way of making dump isn't safe, but convenient within clean or dev environment.\n\n\n# Export\nexpdp / full=Y dumpfile=\nDBNAME\n.dmp logfile=expdp\nDBNAME\n.log\n# Import \nimpdp / full=Y dumpfile=\nDBNAME\n.dmp logfile=impdp\nDBNAME\n.log", 
            "title": "Dump"
        }, 
        {
            "location": "/Databases/Oracle/Dump/#fast-oracle-database-dump-creation", 
            "text": "This way of making dump isn't safe, but convenient within clean or dev environment.  # Export\nexpdp / full=Y dumpfile= DBNAME .dmp logfile=expdp DBNAME .log\n# Import \nimpdp / full=Y dumpfile= DBNAME .dmp logfile=impdp DBNAME .log", 
            "title": "Fast oracle database dump creation"
        }, 
        {
            "location": "/Databases/Oracle/Memory/", 
            "text": "ORA-00845: MEMORY_TARGET not supported\n\n\nNot enough of shared memory\n\n\numount tmpfs\nmount -t tmpfs shmfs -o size=1024m /dev/shm", 
            "title": "Memory"
        }, 
        {
            "location": "/Databases/Oracle/Memory/#ora-00845-memory_target-not-supported", 
            "text": "Not enough of shared memory  umount tmpfs\nmount -t tmpfs shmfs -o size=1024m /dev/shm", 
            "title": "ORA-00845: MEMORY_TARGET not supported"
        }, 
        {
            "location": "/Databases/Oracle/OJDBC/", 
            "text": "BUG: 9632480\n\n\nOJDBC 12.1.0.2 - BUG: ORA-01000: maximum open cursors exceeded\n\n\nWe need:\n\n\n\n\nojdbc7.jar\n\n\np19632480_121020_Generic.zip\n\n\nJRE\n\n\n\n\n\n\nWe need to update OracleDatabaseMetaData.class in our ojdbc7.jar archive\n\n\n\n\nunzip p19632480_121020_Generic.zip\n\n\n\n\nGet folder \n./p19632480_121020_Generic/19632480/files/jdbc/lib/ojdbc7.jar\n from archvive and place it to \nojdbc7.jar\n file location\n\n\nMake sure that your JAVA_HOME is exported\n\n\nChange working directory to ojdbc7.jar location and run:\n\n\n$JAVA_HOME/jar -uf ojdbc7.jar", 
            "title": "OJDBC"
        }, 
        {
            "location": "/Databases/Oracle/OJDBC/#bug-9632480", 
            "text": "OJDBC 12.1.0.2 - BUG: ORA-01000: maximum open cursors exceeded  We need:   ojdbc7.jar  p19632480_121020_Generic.zip  JRE    We need to update OracleDatabaseMetaData.class in our ojdbc7.jar archive   unzip p19632480_121020_Generic.zip  Get folder  ./p19632480_121020_Generic/19632480/files/jdbc/lib/ojdbc7.jar  from archvive and place it to  ojdbc7.jar  file location  Make sure that your JAVA_HOME is exported  Change working directory to ojdbc7.jar location and run:  $JAVA_HOME/jar -uf ojdbc7.jar", 
            "title": "BUG: 9632480"
        }, 
        {
            "location": "/Databases/Oracle/Tablespace/", 
            "text": "Create\n\n\nCREATE TABLESPACE tablespace_name DATAFILE 'tablespace_name.ora' SIZE 20M AUTOEXTEND ON;\n### You need this line only for Oracle 12 \nALTER SESSION SET \n_ORACLE_SCRIPT\n=true;\nCREATE USER tablespace_username IDENTIFIED BY tablespace_username_password DEFAULT TABLESPACE tablespace_name;\nGRANT ALL PRIVILEGES TO tablespabe+username ;", 
            "title": "Tablespace"
        }, 
        {
            "location": "/Databases/Oracle/Tablespace/#create", 
            "text": "CREATE TABLESPACE tablespace_name DATAFILE 'tablespace_name.ora' SIZE 20M AUTOEXTEND ON;\n### You need this line only for Oracle 12 \nALTER SESSION SET  _ORACLE_SCRIPT =true;\nCREATE USER tablespace_username IDENTIFIED BY tablespace_username_password DEFAULT TABLESPACE tablespace_name;\nGRANT ALL PRIVILEGES TO tablespabe+username ;", 
            "title": "Create"
        }, 
        {
            "location": "/Databases/Oracle/Useful_Queries/", 
            "text": "View tablespaces by user\n\n\nselect distinct p.tablespace_name from dba_tablespaces p, dba_xml_tables x, dba_users u, all_all_tables t where t.table_name=x.table_name and t.tablespace_name=p.tablespace_name and x.owner=u.username;\n\n\n\n\nView all tablespaces: run by sysdba\n\n\nselect * from dba_tablespaces;\n\n\n\n\nView charset\n\n\nSELECT value$ FROM sys.props$ WHERE name = 'NLS_CHARACTERSET' ;\n\n\n\n\nGet status of instances\n\n\nselect instance_name, status, database_status from v$instance; \nselect status from v$instance;\nselect logins from v$instance;\n\n\n\n\nMount and open DB\n\n\nALTER DATABASE Mount;\nALTER DATABASE OPEN;\n\n\n\n\nBackup via RMAN\n\n\nrun {\nshutdown immediate;\nstartup mount;\nbackup database;\nalter database open;\n}\n\n\n\n\nEnabling archivelog\n\n\nSHUTDOWN;\nSTARTUP MOUNT EXCLUSIVE;\nALTER DATABASE ARCHIVELOG;\nALTER DATABASE OPEN;\nSELECT log_mode FROM v$database;\n\n\n\n\nOpen cursors\n\n\nselect * from v$parameter where name = 'open_cursors';\nselect value from v$parameter where name = 'open_cursors';\nalter system set open_cursors=4000 scope=both;\n\n-- Top list\nselect a.value, s.username, s.sid, s.serial# from v$sesstat a, v$statname b, v$session s where a.statistic# = b.statistic#  and s.sid=a.sid and b.name = 'opened cursors current' and s.username is not null order by value desc;\nselect * from ( select ss.value, sn.name, ss.sid from v$sesstat ss, v$statname sn where ss.statistic# = sn.statistic# and sn.name like '%opened cursors current%' order by value desc) where rownum \n 11 ;\n\nselect USERNAME, OSUSER, PROCESS, MACHINE, PROGRAM, EVENT, STATE from v$session where sid in (select SID from ( select ss.value, sn.name, ss.sid from v$sesstat ss, v$statname sn where ss.statistic# = sn.statistic# and sn.name like '%opened cursors current%' order by value desc));\nselect SID,USERNAME, OSUSER, PROCESS, MACHINE, PROGRAM, EVENT, STATE from v$session where sid in (select SID from ( select ss.value, sn.name, ss.sid from v$sesstat ss, v$statname sn where ss.statistic# = sn.statistic# and sn.name like '%opened cursors current%' order by value desc) where rownum \n 20);\n\nselect user_name, status, osuser, machine, a.sql_text \n  from v$session b, v$open_cursor a \n  where a.sid = b.sid and MACHINE='SERVER_NAME'; \n\nselect * \n  from v$session b, v$open_cursor a \n  where a.sid = b.sid and MACHINE='SERVER_NAME';\n\nselect a.value, s.username, s.sid, s.serial# from v$sesstat a, v$statname b, v$session s where b.name = 'opened cursors current' order by value desc;", 
            "title": "Useful Queries"
        }, 
        {
            "location": "/Databases/Oracle/Useful_Queries/#view-tablespaces-by-user", 
            "text": "select distinct p.tablespace_name from dba_tablespaces p, dba_xml_tables x, dba_users u, all_all_tables t where t.table_name=x.table_name and t.tablespace_name=p.tablespace_name and x.owner=u.username;", 
            "title": "View tablespaces by user"
        }, 
        {
            "location": "/Databases/Oracle/Useful_Queries/#view-all-tablespaces-run-by-sysdba", 
            "text": "select * from dba_tablespaces;", 
            "title": "View all tablespaces: run by sysdba"
        }, 
        {
            "location": "/Databases/Oracle/Useful_Queries/#view-charset", 
            "text": "SELECT value$ FROM sys.props$ WHERE name = 'NLS_CHARACTERSET' ;", 
            "title": "View charset"
        }, 
        {
            "location": "/Databases/Oracle/Useful_Queries/#get-status-of-instances", 
            "text": "select instance_name, status, database_status from v$instance; \nselect status from v$instance;\nselect logins from v$instance;", 
            "title": "Get status of instances"
        }, 
        {
            "location": "/Databases/Oracle/Useful_Queries/#mount-and-open-db", 
            "text": "ALTER DATABASE Mount;\nALTER DATABASE OPEN;", 
            "title": "Mount and open DB"
        }, 
        {
            "location": "/Databases/Oracle/Useful_Queries/#backup-via-rman", 
            "text": "run {\nshutdown immediate;\nstartup mount;\nbackup database;\nalter database open;\n}", 
            "title": "Backup via RMAN"
        }, 
        {
            "location": "/Databases/Oracle/Useful_Queries/#enabling-archivelog", 
            "text": "SHUTDOWN;\nSTARTUP MOUNT EXCLUSIVE;\nALTER DATABASE ARCHIVELOG;\nALTER DATABASE OPEN;\nSELECT log_mode FROM v$database;", 
            "title": "Enabling archivelog"
        }, 
        {
            "location": "/Databases/Oracle/Useful_Queries/#open-cursors", 
            "text": "select * from v$parameter where name = 'open_cursors';\nselect value from v$parameter where name = 'open_cursors';\nalter system set open_cursors=4000 scope=both;\n\n-- Top list\nselect a.value, s.username, s.sid, s.serial# from v$sesstat a, v$statname b, v$session s where a.statistic# = b.statistic#  and s.sid=a.sid and b.name = 'opened cursors current' and s.username is not null order by value desc;\nselect * from ( select ss.value, sn.name, ss.sid from v$sesstat ss, v$statname sn where ss.statistic# = sn.statistic# and sn.name like '%opened cursors current%' order by value desc) where rownum   11 ;\n\nselect USERNAME, OSUSER, PROCESS, MACHINE, PROGRAM, EVENT, STATE from v$session where sid in (select SID from ( select ss.value, sn.name, ss.sid from v$sesstat ss, v$statname sn where ss.statistic# = sn.statistic# and sn.name like '%opened cursors current%' order by value desc));\nselect SID,USERNAME, OSUSER, PROCESS, MACHINE, PROGRAM, EVENT, STATE from v$session where sid in (select SID from ( select ss.value, sn.name, ss.sid from v$sesstat ss, v$statname sn where ss.statistic# = sn.statistic# and sn.name like '%opened cursors current%' order by value desc) where rownum   20);\n\nselect user_name, status, osuser, machine, a.sql_text \n  from v$session b, v$open_cursor a \n  where a.sid = b.sid and MACHINE='SERVER_NAME'; \n\nselect * \n  from v$session b, v$open_cursor a \n  where a.sid = b.sid and MACHINE='SERVER_NAME';\n\nselect a.value, s.username, s.sid, s.serial# from v$sesstat a, v$statname b, v$session s where b.name = 'opened cursors current' order by value desc;", 
            "title": "Open cursors"
        }, 
        {
            "location": "/Dev/Bash/Collect_bash_history/", 
            "text": "Collect .bash_history from a bunch of servers.\n\n\nip_base_file\n - just a list of IP address. And you have to have same password on all servers.\n\n\n#!/bin/bash\n#\n#  Script to collect bash history from remote servers\n#\necho \nUsage: ./collect.sh \nip_base_file\n\n\nread -n 1 -p \nDo you want to collect bash_history? (y/[a]): \n AMSURE\n[ \n$AMSURE\n = \ny\n ] || exit\necho \n 1\n2\n\nnow=$(date +\n%m_%d_%Y\n)\nmkdir ./$now\n## Provide BASE64 encoded password here\n## echo \nMEGA-SECURE-PASSWORD\n | base64 -i\nPASS=`echo \nTUVHQS1TRUNVUkUtUEFTU1dPUkQK\n | base64 -di`\nawk '{print $1}' \n ./\n$1\n | while read ip; do\n\nexpect -c \n\n    set timeout 1\n    spawn scp  root@$ip:~/.bash_history ./\n$now\n/\n$ip\n_history.txt\n    expect yes/no { send yes\\r ; exp_continue }\n    expect password: { send $PASS\\r }\n    expect 100%\n    sleep 1\n    exit\n\n\ndone", 
            "title": "Collect bash history"
        }, 
        {
            "location": "/Dev/Bash/Collect_bash_history/#collect-bash_history-from-a-bunch-of-servers", 
            "text": "ip_base_file  - just a list of IP address. And you have to have same password on all servers.  #!/bin/bash\n#\n#  Script to collect bash history from remote servers\n#\necho  Usage: ./collect.sh  ip_base_file \n\nread -n 1 -p  Do you want to collect bash_history? (y/[a]):   AMSURE\n[  $AMSURE  =  y  ] || exit\necho   1 2\n\nnow=$(date + %m_%d_%Y )\nmkdir ./$now\n## Provide BASE64 encoded password here\n## echo  MEGA-SECURE-PASSWORD  | base64 -i\nPASS=`echo  TUVHQS1TRUNVUkUtUEFTU1dPUkQK  | base64 -di`\nawk '{print $1}'   ./ $1  | while read ip; do\n\nexpect -c  \n    set timeout 1\n    spawn scp  root@$ip:~/.bash_history ./ $now / $ip _history.txt\n    expect yes/no { send yes\\r ; exp_continue }\n    expect password: { send $PASS\\r }\n    expect 100%\n    sleep 1\n    exit \ndone", 
            "title": "Collect .bash_history from a bunch of servers."
        }, 
        {
            "location": "/Dev/Bash/Convert-CP1251-to-UTF8/", 
            "text": "Convert windows-1251 to utf-8\n\n\n#!/usr/bin/bash\n\n# Recursive file convertion windows-1251 --\n utf-8\n# Place this file in the root of your site, add execute permission and run\n# Converts *.php, *.html, *.css, *.js files.\n# To add file type by extension, e.g. *.cgi, add '-o -name \n*.cgi\n' to the find command\n\nfind ./ -name \n*.cfg\n  -type f |\nwhile read file\ndo\n  echo \n $file\n\n  mv $file $file.icv\n  iconv -f WINDOWS-1251 -t UTF-8 $file.icv \n $file\n  rm -f $file.icv\ndone", 
            "title": "Convert CP1251 to UTF8"
        }, 
        {
            "location": "/Dev/Bash/Convert-CP1251-to-UTF8/#convert-windows-1251-to-utf-8", 
            "text": "#!/usr/bin/bash\n\n# Recursive file convertion windows-1251 --  utf-8\n# Place this file in the root of your site, add execute permission and run\n# Converts *.php, *.html, *.css, *.js files.\n# To add file type by extension, e.g. *.cgi, add '-o -name  *.cgi ' to the find command\n\nfind ./ -name  *.cfg   -type f |\nwhile read file\ndo\n  echo   $file \n  mv $file $file.icv\n  iconv -f WINDOWS-1251 -t UTF-8 $file.icv   $file\n  rm -f $file.icv\ndone", 
            "title": "Convert windows-1251 to utf-8"
        }, 
        {
            "location": "/Dev/Brainfuck/Sample1/", 
            "text": "Print \"2 + 2 = 4\"**\n\n\n# Increase a[1] to 50 and print ASCII value \n2\n  \n# 1.    ++++++++++[\n+++++\n-]\n.\n \n# Increase a[2] to 32 and print ASCII value \n \n  \n# 2.    ++++++++[\n++++\n-]\n.\n\n# Increase a[3] to 43 and print ASCII value \n+\n  \n# 3.    ++++++++++[\n++++\n-]\n+++.\n\n# Print from a[2] ASCII value \n \n  \n# 4.    \n.\n\n# Print from a[1] ASCII value \n2\n  \n# 5.    \n.\n\n# Print from a[2] ASCII value \n \n  \n# 6.    \n.\n\n# Increase a[4] to 61 and print ASCII value \n=\n  \n# 7.    ++++++++++[\n++++++\n-]\n+.\n\n# Print from a[2] ASCII value \n \n  \n# 8.    \n.\n\n# Increase a[5] to 52 and print ASCII value \n4\n  \n# 9.    ++++++++++[\n+++++\n-]\n++.\n\n\n++++++++++[\n+++++\n-]\n.\n\n++++++++[\n++++\n-]\n.\n\n++++++++++[\n++++\n-]\n+++.\n\n\n.\n\n\n.\n\n\n.\n\n++++++++++[\n++++++\n-]\n+.\n\n\n.\n\n++++++++++[\n+++++\n-]\n++.", 
            "title": "Sample1"
        }, 
        {
            "location": "/Dev/Brainfuck/Sample1/#print-2-2-4", 
            "text": "# Increase a[1] to 50 and print ASCII value  2   \n# 1.    ++++++++++[ +++++ -] .  \n# Increase a[2] to 32 and print ASCII value      \n# 2.    ++++++++[ ++++ -] . \n# Increase a[3] to 43 and print ASCII value  +   \n# 3.    ++++++++++[ ++++ -] +++. \n# Print from a[2] ASCII value      \n# 4.     . \n# Print from a[1] ASCII value  2   \n# 5.     . \n# Print from a[2] ASCII value      \n# 6.     . \n# Increase a[4] to 61 and print ASCII value  =   \n# 7.    ++++++++++[ ++++++ -] +. \n# Print from a[2] ASCII value      \n# 8.     . \n# Increase a[5] to 52 and print ASCII value  4   \n# 9.    ++++++++++[ +++++ -] ++. \n\n++++++++++[ +++++ -] . \n++++++++[ ++++ -] . \n++++++++++[ ++++ -] +++.  .  .  . \n++++++++++[ ++++++ -] +.  . \n++++++++++[ +++++ -] ++.", 
            "title": "Print \"2 + 2 = 4\"**"
        }, 
        {
            "location": "/Dev/Cmd/cmd/", 
            "text": "Cmd scripts\n\n\nPing subnet\n\n\nFOR /L %i IN (1,1,254) DO ping -n 1 192.168.10.%i | FIND /i \nReply\nc:\\ipaddresses.txt\n\n\n\n\nTo change colours in command line console interface you need to add one of following sets of registry keys:\n\n\nCmd Colours\n\n\nDefault\n\n\nWindows Registry Editor Version 5.00\n; Default color scheme\n; for Windows command prompt.\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK DGRAY\n\nColorTable00\n=dword:00000000\n\nColorTable08\n=dword:00808080\n; BLUE LBLUE\n\nColorTable01\n=dword:00800000\n\nColorTable09\n=dword:00ff0000\n; GREEN LGREEN\n\nColorTable02\n=dword:00008000\n\nColorTable10\n=dword:0000ff00\n; CYAN LCYAN\n\nColorTable03\n=dword:00808000\n\nColorTable11\n=dword:00ffff00\n; RED LRED\n\nColorTable04\n=dword:00000080\n\nColorTable12\n=dword:000000ff\n; MAGENTA LMAGENTA\n\nColorTable05\n=dword:00800080\n\nColorTable13\n=dword:00ff00ff\n; YELLOW LYELLOW\n\nColorTable06\n=dword:00008080\n\nColorTable14\n=dword:0000ffff\n; LGRAY WHITE\n\nColorTable07\n=dword:00c0c0c0\n\nColorTable15\n=dword:00ffffff\n\n\n\n\nMonokai\n\n\nWindows Registry Editor Version 5.00\n; Monokai color theme for Windows command prompt.\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK   DGRAY\n\nColorTable00\n=dword:00222827\n\nColorTable08\n=dword:00414746\n; BLUE    LBLUE\n\nColorTable01\n=dword:00a64c1d\n\nColorTable09\n=dword:00ef9566\n; GREEN   LGREEN\n\nColorTable02\n=dword:0000995d\n\nColorTable10\n=dword:002ee2a6\n; CYAN    LCYAN\n\nColorTable03\n=dword:00746a31\n\nColorTable11\n=dword:00efd966\n; RED     LRED\n\nColorTable04\n=dword:002900b0\n\nColorTable12\n=dword:007226f9\n; MAGENTA LMAGENTA\n\nColorTable05\n=dword:00b63865\n\nColorTable13\n=dword:00ff81ae\n; YELLOW  LYELLOW\n\nColorTable06\n=dword:001f97fd\n\nColorTable14\n=dword:0074dbe6\n; LGRAY   WHITE\n\nColorTable07\n=dword:008a908f\n\nColorTable15\n=dword:00f2f8f8\n\n\n\n\nPastel\n\n\nWindows Registry Editor Version 5.00\n; Low-contrast, pastel color scheme\n; for Windows command prompt.\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK DGRAY\n\nColorTable00\n=dword:00222222\n\nColorTable08\n=dword:00454545\n; BLUE LBLUE\n\nColorTable01\n=dword:00a69a7c\n\nColorTable09\n=dword:00bfad8f\n; GREEN LGREEN\n\nColorTable02\n=dword:00557e6c\n\nColorTable10\n=dword:007db37d\n; CYAN LCYAN\n\nColorTable03\n=dword:00a18e4c\n\nColorTable11\n=dword:00d0c16b\n; RED LRED\n\nColorTable04\n=dword:0041569e\n\nColorTable12\n=dword:006d89cc\n; MAGENTA LMAGENTA\n\nColorTable05\n=dword:009d6d95\n\nColorTable13\n=dword:00cb8fc1\n; YELLOW LYELLOW\n\nColorTable06\n=dword:002bafca\n\nColorTable14\n=dword:0056b5bf\n; LGRAY WHITE\n\nColorTable07\n=dword:00808080\n\nColorTable15\n=dword:00cdcdcd\n\n\n\n\nZenburn\n\n\nWindows Registry Editor Version 5.00\n; Zenburn is a low-contrast color scheme\n; for Windows command prompt.\n; See : http://slinky.imukuppi.org/zenburnpage/\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK DGRAY\n\nColorTable00\n=dword:003f3f3f\n\nColorTable08\n=dword:008080c0\n; BLUE LBLUE\n\nColorTable01\n=dword:00af6464\n\nColorTable09\n=dword:00ffafaf\n; GREEN LGREEN\n\nColorTable02\n=dword:00008000\n\nColorTable10\n=dword:007f9f7f\n; CYAN LCYAN\n\nColorTable03\n=dword:00808000\n\nColorTable11\n=dword:00d3d08c\n; RED LRED\n\nColorTable04\n=dword:00232333\n\nColorTable12\n=dword:007071e3\n; MAGENTA LMAGENTA\n\nColorTable05\n=dword:00aa50aa\n\nColorTable13\n=dword:00c880c8\n; YELLOW LYELLOW\n\nColorTable06\n=dword:0000dcdc\n\nColorTable14\n=dword:00afdff0\n; LGRAY WHITE\n\nColorTable07\n=dword:00ccdcdc\n\nColorTable15\n=dword:00ffffff", 
            "title": "Cmd"
        }, 
        {
            "location": "/Dev/Cmd/cmd/#cmd-scripts", 
            "text": "", 
            "title": "Cmd scripts"
        }, 
        {
            "location": "/Dev/Cmd/cmd/#ping-subnet", 
            "text": "FOR /L %i IN (1,1,254) DO ping -n 1 192.168.10.%i | FIND /i  Reply c:\\ipaddresses.txt  To change colours in command line console interface you need to add one of following sets of registry keys:", 
            "title": "Ping subnet"
        }, 
        {
            "location": "/Dev/Cmd/cmd/#cmd-colours", 
            "text": "", 
            "title": "Cmd Colours"
        }, 
        {
            "location": "/Dev/Cmd/cmd/#default", 
            "text": "Windows Registry Editor Version 5.00\n; Default color scheme\n; for Windows command prompt.\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK DGRAY ColorTable00 =dword:00000000 ColorTable08 =dword:00808080\n; BLUE LBLUE ColorTable01 =dword:00800000 ColorTable09 =dword:00ff0000\n; GREEN LGREEN ColorTable02 =dword:00008000 ColorTable10 =dword:0000ff00\n; CYAN LCYAN ColorTable03 =dword:00808000 ColorTable11 =dword:00ffff00\n; RED LRED ColorTable04 =dword:00000080 ColorTable12 =dword:000000ff\n; MAGENTA LMAGENTA ColorTable05 =dword:00800080 ColorTable13 =dword:00ff00ff\n; YELLOW LYELLOW ColorTable06 =dword:00008080 ColorTable14 =dword:0000ffff\n; LGRAY WHITE ColorTable07 =dword:00c0c0c0 ColorTable15 =dword:00ffffff", 
            "title": "Default"
        }, 
        {
            "location": "/Dev/Cmd/cmd/#monokai", 
            "text": "Windows Registry Editor Version 5.00\n; Monokai color theme for Windows command prompt.\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK   DGRAY ColorTable00 =dword:00222827 ColorTable08 =dword:00414746\n; BLUE    LBLUE ColorTable01 =dword:00a64c1d ColorTable09 =dword:00ef9566\n; GREEN   LGREEN ColorTable02 =dword:0000995d ColorTable10 =dword:002ee2a6\n; CYAN    LCYAN ColorTable03 =dword:00746a31 ColorTable11 =dword:00efd966\n; RED     LRED ColorTable04 =dword:002900b0 ColorTable12 =dword:007226f9\n; MAGENTA LMAGENTA ColorTable05 =dword:00b63865 ColorTable13 =dword:00ff81ae\n; YELLOW  LYELLOW ColorTable06 =dword:001f97fd ColorTable14 =dword:0074dbe6\n; LGRAY   WHITE ColorTable07 =dword:008a908f ColorTable15 =dword:00f2f8f8", 
            "title": "Monokai"
        }, 
        {
            "location": "/Dev/Cmd/cmd/#pastel", 
            "text": "Windows Registry Editor Version 5.00\n; Low-contrast, pastel color scheme\n; for Windows command prompt.\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK DGRAY ColorTable00 =dword:00222222 ColorTable08 =dword:00454545\n; BLUE LBLUE ColorTable01 =dword:00a69a7c ColorTable09 =dword:00bfad8f\n; GREEN LGREEN ColorTable02 =dword:00557e6c ColorTable10 =dword:007db37d\n; CYAN LCYAN ColorTable03 =dword:00a18e4c ColorTable11 =dword:00d0c16b\n; RED LRED ColorTable04 =dword:0041569e ColorTable12 =dword:006d89cc\n; MAGENTA LMAGENTA ColorTable05 =dword:009d6d95 ColorTable13 =dword:00cb8fc1\n; YELLOW LYELLOW ColorTable06 =dword:002bafca ColorTable14 =dword:0056b5bf\n; LGRAY WHITE ColorTable07 =dword:00808080 ColorTable15 =dword:00cdcdcd", 
            "title": "Pastel"
        }, 
        {
            "location": "/Dev/Cmd/cmd/#zenburn", 
            "text": "Windows Registry Editor Version 5.00\n; Zenburn is a low-contrast color scheme\n; for Windows command prompt.\n; See : http://slinky.imukuppi.org/zenburnpage/\n\n; Values stored as 00-BB-GG-RR\n[HKEY_CURRENT_USER\\Console]\n; BLACK DGRAY ColorTable00 =dword:003f3f3f ColorTable08 =dword:008080c0\n; BLUE LBLUE ColorTable01 =dword:00af6464 ColorTable09 =dword:00ffafaf\n; GREEN LGREEN ColorTable02 =dword:00008000 ColorTable10 =dword:007f9f7f\n; CYAN LCYAN ColorTable03 =dword:00808000 ColorTable11 =dword:00d3d08c\n; RED LRED ColorTable04 =dword:00232333 ColorTable12 =dword:007071e3\n; MAGENTA LMAGENTA ColorTable05 =dword:00aa50aa ColorTable13 =dword:00c880c8\n; YELLOW LYELLOW ColorTable06 =dword:0000dcdc ColorTable14 =dword:00afdff0\n; LGRAY WHITE ColorTable07 =dword:00ccdcdc ColorTable15 =dword:00ffffff", 
            "title": "Zenburn"
        }, 
        {
            "location": "/Dev/GCC/Make/", 
            "text": "Flags to configure\n\n\n/configure CFLAGS='-std=gnu89 -g -O2 -w' CXXFLAGS='-std=gnu++98 -g -O2 -w'", 
            "title": "Make"
        }, 
        {
            "location": "/Dev/GCC/Make/#flags-to-configure", 
            "text": "/configure CFLAGS='-std=gnu89 -g -O2 -w' CXXFLAGS='-std=gnu++98 -g -O2 -w'", 
            "title": "Flags to configure"
        }, 
        {
            "location": "/Dev/Java/Runtime_customization/", 
            "text": "Java custom user and system preferencies path\n\n\n# From user which will start particular hava application\n\nmkdir -p \nnew_system_prefs\n\nmkdir -p \nnew_user_prefs\n\nchmod -R 755 \nnew_system_prefs\n\nchmod -R 755 \nnew_user_prefs\n \n\nexport JAVA_OPTS=\n-Djava.util.prefs.systemRoot=\nnew_system_prefs\n -Djava.util.prefs.userRoot=\nnew_user_prefs\n\n\n# start application", 
            "title": "Runtime customization"
        }, 
        {
            "location": "/Dev/Java/Runtime_customization/#java-custom-user-and-system-preferencies-path", 
            "text": "# From user which will start particular hava application\n\nmkdir -p  new_system_prefs \nmkdir -p  new_user_prefs \nchmod -R 755  new_system_prefs \nchmod -R 755  new_user_prefs  \n\nexport JAVA_OPTS= -Djava.util.prefs.systemRoot= new_system_prefs  -Djava.util.prefs.userRoot= new_user_prefs \n\n# start application", 
            "title": "Java custom user and system preferencies path"
        }, 
        {
            "location": "/Dev/MPI/HelloWorld/", 
            "text": "Hello World\n\n\n\n\nC\n\n\n\n\n#include \nstdio.h\n\n#include \nmpi.h\n\n\nmain(int argc, char **argv)\n{\n   int node;\n   char hostname[256];\n\n   MPI_Init(\nargc,\nargv);\n   MPI_Comm_rank(MPI_COMM_WORLD, \nnode);\n\n   gethostname(hostname,255);\n   printf(\nHello World from process %d on %s\\n\n,node, hostname);\n\n   MPI_Finalize();\n\n   return 0;\n}\n\n\n\n\n\n\nRUN\n\n\n\n\n#!/bin/bash\n#$ -l mem=1G\n#$ -l h_rt=0:15:00\n#$ -pe mpi-fill 8\n#$ -cwd\n\necho -n \nStart at $(date +%Y-%m-%d-%H-%M-%S)\n\nmpirun ./helloworld\necho -n \nFinish at $(date +%Y-%m-%d-%H-%M-%S)", 
            "title": "HelloWorld"
        }, 
        {
            "location": "/Dev/MPI/HelloWorld/#hello-world", 
            "text": "C   #include  stdio.h \n#include  mpi.h \n\nmain(int argc, char **argv)\n{\n   int node;\n   char hostname[256];\n\n   MPI_Init( argc, argv);\n   MPI_Comm_rank(MPI_COMM_WORLD,  node);\n\n   gethostname(hostname,255);\n   printf( Hello World from process %d on %s\\n ,node, hostname);\n\n   MPI_Finalize();\n\n   return 0;\n}   RUN   #!/bin/bash\n#$ -l mem=1G\n#$ -l h_rt=0:15:00\n#$ -pe mpi-fill 8\n#$ -cwd\n\necho -n  Start at $(date +%Y-%m-%d-%H-%M-%S) \nmpirun ./helloworld\necho -n  Finish at $(date +%Y-%m-%d-%H-%M-%S)", 
            "title": "Hello World"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/", 
            "text": "MPI_Abort.md\n\n\nMPI_Abort(3)                          MPI                         MPI_Abort(3)\n\n\n\nNAME\n       MPI_Abort -  Terminates MPI execution environment\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Abort( MPI_Comm comm, int errorcode )\n\nINPUT PARAMETERS\n       comm   - communicator of tasks to abort\n       errorcode\n              - error code to return to invoking environment\n\n\nNOTES\n       Terminates all MPI processes associated with the communicator comm ; in\n       most systems (all to date), terminates all processes.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       abort.c\n\n\n\n                                  12/13/2001                      MPI_Abort(3)\n\n\n\n\nMPI_Address.md\n\n\nMPI_Address(3)                        MPI                       MPI_Address(3)\n\n\n\nNAME\n       MPI_Address -  Gets the address of a location in memory\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Address( void *location, MPI_Aint *address)\n\nINPUT PARAMETERS\n       location\n              - location in caller memory (choice)\n\n\nOUTPUT PARAMETER\n       address\n              - address of location (integer)\n\n\nNOTE\n       This  routine  is  provided for both the Fortran and C programmers.  On\n       many systems, the address returned by this routine will be the same  as\n       produced by the C \n operator, but this is not required in C and may not\n       be true of systems with word- rather than byte-oriented instructions or\n       systems with segmented address spaces.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       address.c\n\n\n\n                                  11/14/2001                    MPI_Address(3)\n\n\n\n\nMPI_Allgather.md\n\n\nMPI_Allgather(3)                      MPI                     MPI_Allgather(3)\n\n\n\nNAME\n       MPI_Allgather  -   Gathers data from all tasks and distribute it to all\n       tasks\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Allgather ( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                           void *recvbuf, int recvcount, MPI_Datatype recvtype,\n                          MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              - number of elements received from any process (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES\n       The MPI standard (1.0 and 1.1) says that\n\n       The jth block of data sent from each proess is received by  every  pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This is misleading; a better description is\n\n       The  block  of data sent from the jth process is received by every pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This text was suggested by Rajeev Thakur.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler  may  be  changed  with  MPI_Errhandler_set  ;  the\n       predefined error handler MPI_ERRORS_RETURN may be used to  cause  error\n       values  to  be  returned.  Note that MPI does not guarentee that an MPI\n       program can continue past an error.\n\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       allgather.c\n\n\n\n                                   10/1/2004                  MPI_Allgather(3)\n\n\n\n\nMPI_Allgatherv.md\n\n\nMPI_Allgatherv(3)                     MPI                    MPI_Allgatherv(3)\n\n\n\nNAME\n       MPI_Allgatherv -  Gathers data from all tasks and deliver it to all\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Allgatherv ( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                            void *recvbuf, int *recvcounts, int *displs,\n                           MPI_Datatype recvtype, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcounts\n              -  integer array (of length group size) containing the number of\n              elements that are received from each process\n       displs - integer array (of length group size). Entry  i  specifies  the\n              displacement (relative to recvbuf ) at which to place the incom-\n              ing data from process i\n\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES\n       The MPI standard (1.0 and 1.1) says that\n\n       The jth block of data sent from each proess is received by  every  pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This is misleading; a better description is\n\n       The  block  of data sent from the jth process is received by every pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This text was suggested by Rajeev Thakur.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       allgatherv.c\n\n\n\n                                  11/14/2001                 MPI_Allgatherv(3)\n\n\n\n\nMPI_Allreduce.md\n\n\nMPI_Allreduce(3)                      MPI                     MPI_Allreduce(3)\n\n\n\nNAME\n       MPI_Allreduce  -  Combines values from all processes and distribute the\n       result back to all processes\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Allreduce ( void *sendbuf, void *recvbuf, int count,\n                          MPI_Datatype datatype, MPI_Op op, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - data type of elements of send buffer (handle)\n       op     - operation (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - starting address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The  reduction functions ( MPI_Op ) do not return an error value.  As a\n       result, if the functions detect an error, all they  can  do  is  either\n       call  MPI_Abort  or silently skip the problem.  Thus, if you change the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The  reason  for  this is the performance problems in ensuring that all\n       collective routines return the same error value.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_OP\n              - Invalid operation.  MPI operations (objects of type  MPI_Op  )\n              must either be one of the predefined operations (e.g., MPI_SUM )\n              or created with MPI_Op_create .\n\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       allreduce.c\n\n\n\n                                  11/14/2001                  MPI_Allreduce(3)\n\n\n\n\nMPI_Alltoall.md\n\n\nMPI_Alltoall(3)                       MPI                      MPI_Alltoall(3)\n\n\n\nNAME\n       MPI_Alltoall -  Sends data from all to all processes\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Alltoall( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                         void *recvbuf, int recvcnt, MPI_Datatype recvtype,\n                        MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements to send to each process (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              - number of elements received from any process (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\nLOCATION\n       alltoall.c\n\n\n\n                                  11/14/2001                   MPI_Alltoall(3)\n\n\n\n\nMPI_Alltoallv.md\n\n\nMPI_Alltoallv(3)                      MPI                     MPI_Alltoallv(3)\n\n\n\nNAME\n       MPI_Alltoallv -  Sends data from all to all processes, with a displace-\n       ment\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Alltoallv (\n               void *sendbuf,\n               int *sendcnts,\n               int *sdispls,\n               MPI_Datatype sendtype,\n               void *recvbuf,\n               int *recvcnts,\n               int *rdispls,\n               MPI_Datatype recvtype,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcounts\n              - integer array equal to the group size specifying the number of\n              elements to send to each processor\n       sdispls\n              -  integer  array  (of length group size). Entry j specifies the\n              displacement (relative to sendbuf  from which to take the outgo-\n              ing data destined for process j\n\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcounts\n              -  integer  array equal to the group size specifying the maximum\n              number of elements that can be received from each processor\n       rdispls\n              - integer array (of length group size). Entry  i  specifies  the\n              displacement  (relative to recvbuf  at which to place the incom-\n              ing data from process i\n\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       alltoallv.c\n\n\n\n                                  11/14/2001                  MPI_Alltoallv(3)\n\n\n\n\nMPI_Attr_delete.md\n\n\nMPI_Attr_delete(3)                    MPI                   MPI_Attr_delete(3)\n\n\n\nNAME\n       MPI_Attr_delete -  Deletes attribute value associated with a key\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Attr_delete ( MPI_Comm comm, int keyval )\n\nINPUT PARAMETERS\n       comm   - communicator to which attribute is attached (handle)\n       keyval - The key value of the deleted attribute (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              keys.\n\nLOCATION\n       attr_delval.c\n\n\n\n                                  11/14/2001                MPI_Attr_delete(3)\n\n\n\n\nMPI_Attr_get.md\n\n\nMPI_Attr_get(3)                       MPI                      MPI_Attr_get(3)\n\n\n\nNAME\n       MPI_Attr_get -  Retrieves attribute value by key\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Attr_get (\n               MPI_Comm comm,\n               int keyval,\n               void *attr_value,\n               int *flag )\n\nINPUT PARAMETERS\n       comm   - communicator to which attribute is attached (handle)\n       keyval - key value (integer)\n\n\nOUTPUT PARAMETERS\n       attr_value\n              - attribute value, unless flag = false\n       flag   -  true  if  an  attribute  value  was  extracted;   false if no\n              attribute is associated with the key\n\n\nNOTES\n       Attributes must be extracted  from  the  same  language  as  they  were\n       inserted  in  with  MPI_ATTR_PUT  .   The notes for C and Fortran below\n       explain why.\n\n\nNOTES FOR C\n       Even though the attr_value arguement is declared as  void  *  ,  it  is\n       really  the  address of a void pointer.  See the rationale in the stan-\n       dard for more details.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       The  attr_value  in  Fortran  is  a pointer to a Fortran integer, not a\n       pointer to a void * .\n\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_OTHER\n              - Other error; the error code associated with this  error  indi-\n              cates an attempt to use an invalue keyval.\n\nLOCATION\n       attr_getval.c\n\n\n\n                                  11/14/2001                   MPI_Attr_get(3)\n\n\n\n\nMPI_Attr_put.md\n\n\nMPI_Attr_put(3)                       MPI                      MPI_Attr_put(3)\n\n\n\nNAME\n       MPI_Attr_put -  Stores attribute value associated with a key\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Attr_put ( MPI_Comm comm, int keyval, void *attr_value )\n\nINPUT PARAMETERS\n       comm   - communicator to which attribute will be attached (handle)\n       keyval - key value, as returned by MPI_KEYVAL_CREATE (integer)\n       attribute_val\n              - attribute value\n\n\nNOTES\n       Values of the permanent attributes MPI_TAG_UB , MPI_HOST , MPI_IO , and\n       MPI_WTIME_IS_GLOBAL may not be changed.\n\n       The type of the attribute value depends on  whether  C  or  Fortran  is\n       being  used.  In C, an attribute value is a pointer ( void * ); in For-\n       tran, it is a single integer ( not a  pointer,  since  Fortran  has  no\n       pointers  and  there are systems for which a pointer does not fit in an\n       integer (e.g., any \n 32 bit address system that uses 64 bits  for  For-\n       tran DOUBLE PRECISION ).\n\n       If an attribute is already present, the delete function (specified when\n       the corresponding keyval was created) will be called.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_OTHER\n              -  Other  error; the error code associated with this error indi-\n              cates an attempt to use an invalue keyval.\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              keys.\n\n\nSEE ALSO\n       MPI_Attr_get, MPI_Keyval_create, MPI_Attr_delete\n\nLOCATION\n       attr_putval.c\n\n\n\n                                  11/14/2001                   MPI_Attr_put(3)\n\n\n\n\nMPI_Barrier.md\n\n\nMPI_Barrier(3)                        MPI                       MPI_Barrier(3)\n\n\n\nNAME\n       MPI_Barrier -  Blocks until all process have reached this routine.\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Barrier (\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n\n\nNOTES\n       Blocks  the  caller  until  all  group members have called it; the call\n       returns at any process only after all group members  have  entered  the\n       call.\n\n\nALGORITHM\n       If the underlying device cannot do better, a tree-like or combine algo-\n       rithm is used to broadcast a message wto all members of the  communica-\n       tor.   We  can  modifiy  this  to  use  \nblocks\n  at  a later time (see\n       MPI_Bcast ).\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       barrier.c\n\n\n\n                                  11/14/2001                    MPI_Barrier(3)\n\n\n\n\nMPI_Bcast.md\n\n\nMPI_Bcast(3)                          MPI                         MPI_Bcast(3)\n\n\n\nNAME\n       MPI_Bcast  -  Broadcasts a message from the process with rank \nroot\n to\n       all other processes of the group.\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Bcast ( void *buffer, int count, MPI_Datatype datatype, int root,\n                      MPI_Comm comm )\n\nINPUT/OUTPUT PARAMETERS\n       buffer - starting address of buffer (choice)\n       count  - number of entries in buffer (integer)\n       datatype\n              - data type of buffer (handle)\n       root   - rank of broadcast root (integer)\n       comm   - communicator (handle)\n\n\nALGORITHM\n       If the underlying device does not take  responsibility,  this  function\n       uses  a  tree-like algorithm to broadcast the message to blocks of pro-\n       cesses.  A linear algorithm is then used to broadcast the message  from\n       the    first   process   in   a   block   to   all   other   processes.\n       MPIR_BCAST_BLOCK_SIZE determines the size of blocks.  If this is set to\n       1, then this function is equivalent to using a pure tree algorithm.  If\n       it is set to the size of the group or greater,  it  is  a  pure  linear\n       algorithm.   The  value  should be adjusted to determine the most effi-\n       cient value on different machines.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_ROOT\n              - Invalid root.  The root must be specified as  a  rank  in  the\n              communicator.   Ranks  must  be between zero and the size of the\n              communicator minus one.\n\nLOCATION\n       bcast.c\n\n\n\n                                  11/14/2001                      MPI_Bcast(3)\n\n\n\n\nMPI_Bsend_init.md\n\n\nMPI_Bsend_init(3)                     MPI                    MPI_Bsend_init(3)\n\n\n\nNAME\n       MPI_Bsend_init -  Builds a handle for a buffered send\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Bsend_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                          int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n\nLOCATION\n       bsend_init.c\n\n\n\n                                  12/13/2001                 MPI_Bsend_init(3)\n\n\n\n\nMPI_Bsend.md\n\n\nMPI_Bsend(3)                          MPI                         MPI_Bsend(3)\n\n\n\nNAME\n       MPI_Bsend -  Basic send with user-specified buffering\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Bsend(\n               void *buf,\n               int count,\n               MPI_Datatype datatype,\n               int dest,\n               int tag,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES\n       This  send is provided as a convenience function; it allows the user to\n       send messages without worring about where they  are  buffered  (because\n       the user must have provided buffer space with MPI_Buffer_attach ).\n\n       In deciding how much buffer space to allocate, remember that the buffer\n       space is not available for reuse by subsequent MPI_Bsend s  unless  you\n       are certain that the message has been received (not just that it should\n       have been received).  For example, this code does not  allocate  enough\n       buffer space\n       MPI_Buffer_attach( b, n*sizeof(double) + MPI_BSEND_OVERHEAD );\n       for (i=0; i\nm; i++) {\n       MPI_Bsend( buf, n, MPI_DOUBLE, ... );\n       }\n\n       because only enough buffer space is provided for a single send, and the\n       loop may start a second MPI_Bsend before the first is done  making  use\n       of the buffer.\n\n       In C, you can force the messages to be delivered by\n       MPI_Buffer_detach( \nb, \nn );\n       MPI_Buffer_attach( b, n );\n\n       (The  MPI_Buffer_detach  will  not complete until all buffered messages\n       are delivered.)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n\n\nSEE ALSO\n       MPI_Buffer_attach, MPI_Ibsend, MPI_Bsend_init\n\nLOCATION\n       bsend.c\n\n\n\n                                  11/14/2001                      MPI_Bsend(3)\n\n\n\n\nMPI_Buffer_attach.md\n\n\nMPI_Buffer_attach(3)                  MPI                 MPI_Buffer_attach(3)\n\n\n\nNAME\n       MPI_Buffer_attach -  Attaches a user-defined buffer for sending\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Buffer_attach( void *buffer, int size )\n\nINPUT PARAMETERS\n       buffer - initial buffer address (choice)\n       size   - buffer size, in bytes (integer)\n\n\nNOTES\n       The size given should be the sum of the sizes of all outstanding Bsends\n       that you intend to have, plus a few hundred bytes for each  Bsend  that\n       you  do.   For  the  purposes  of  calculating  size,  you  should  use\n       MPI_Pack_size .\n\n       In other words, in the code\n       MPI_Buffer_attach( buffer, size );\n       MPI_Bsend( ..., count=20, datatype=type1,  ... );\n       .\n       .\n       .\n       MPI_Bsend( ..., count=40, datatype=type2, ... );\n\n       the value of size in the MPI_Buffer_attach call should be greater  than\n       the value computed by\n       MPI_Pack_size( 20, type1, comm, \ns1 );\n       MPI_Pack_size( 40, type2, comm, \ns2 );\n       size = s1 + s2 + 2 * MPI_BSEND_OVERHEAD;\n\n       The  MPI_BSEND_OVERHEAD  gives  the maximum amount of space that may be\n       used in the buffer for use by the BSEND routines in using  the  buffer.\n       This value is in mpi.h (for C) and mpif.h (for Fortran).\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_INTERN\n              - An internal error has been detected.  This is  fatal.   Please\n              send a bug report to mpi-bugs@mcs.anl.gov .\n\n\n\nSEE ALSO\n       MPI_Buffer_detach, MPI_Bsend\n\nLOCATION\n       bufattach.c\n\n\n\n                                  11/14/2001              MPI_Buffer_attach(3)\n\n\n\n\nMPI_Buffer_detach.md\n\n\nMPI_Buffer_detach(3)                  MPI                 MPI_Buffer_detach(3)\n\n\n\nNAME\n       MPI_Buffer_detach  -   Removes an existing buffer (for use in MPI_Bsend\n       etc)\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Buffer_detach(\n               void *bufferptr,\n               int *size )\n\nOUTPUT PARAMETERS\n       buffer - initial buffer address (choice)\n       size   - buffer size, in bytes (integer)\n\n\nNOTES\n       The reason that MPI_Buffer_detach returns the address and size  of  the\n       buffer  being  detached  is  to  allow  nested libraries to replace and\n       restore the buffer.  For example, consider\n\n       int size, mysize, idummy;\n       void *ptr, *myptr, *dummy;\n       MPI_Buffer_detach( \nptr, \nsize );\n       MPI_Buffer_attach( myptr, mysize );\n       .\n       .\n       .\n       .\n       .\n       .\n       library code ...\n       .\n       .\n       .\n       MPI_Buffer_detach( \ndummy, \nidummy );\n       MPI_Buffer_attach( ptr, size );\n\n\n       This is much like the action of the Unix signal  routine  and  has  the\n       same  strengths (it is simple) and weaknesses (it only works for nested\n       usages).\n\n       Note that for this approach  to  work,  MPI_Buffer_detach  must  return\n       MPI_SUCCESS  even  when there is no buffer to detach.  In that case, it\n       returns a size of zero.  The MPI  1.1  standard  for  MPI_BUFFER_DETACH\n       contains the text\n\n       The statements made in this section describe the behavior of MPI for\n       buffered-mode sends. When no buffer is currently associated, MPI behaves\n       as if a zero-sized buffer is associated with the process.\n\n\n       This  could  be  read  as  applying only to the various Bsend routines.\n       This  implementation  takes  the  position   that   this   applies   to\n       MPI_BUFFER_DETACH as well.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       The Fortran binding for this routine  is  different.   Because  Fortran\n       does  not  have  pointers, it is impossible to provide a way to use the\n       output of this routine to exchange buffers.  In  this  case,  only  the\n       size field is set.\n\n\nNOTES FOR C\n       Even though the bufferptr argument is declared as void * , it is really\n       the address of a void pointer.  See the rationale in the  standard  for\n       more details.\n\nLOCATION\n       buffree.c\n\n\n\n                                  11/14/2001              MPI_Buffer_detach(3)\n\n\n\n\nMPI_Cancel.md\n\n\nMPI_Cancel(3)                         MPI                        MPI_Cancel(3)\n\n\n\nNAME\n       MPI_Cancel -  Cancels a communication request\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Cancel( MPI_Request *request )\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTE\n       Cancel  has  only  been implemented for receive requests; it is a no-op\n       for send requests.  The primary expected use of MPI_Cancel is in multi-\n       buffering  schemes,  where  speculative  MPI_Irecvs are made.  When the\n       computation completes, some of these receive requests may remain; using\n       MPI_Cancel allows the user to cancel these unsatisfied requests.\n\n       Cancelling  a  send  operation  is  much  more difficult, in large part\n       because the send will usually  be  at  least  partially  complete  (the\n       information  on  the tag, size, and source are usually sent immediately\n       to the destination).  As of version 1.2.0, MPICH supports cancelling of\n       sends.   Users are advised that cancelling a send, while a local opera-\n       tion (as defined by the MPI standard), is likely to be expensive  (usu-\n       ally generating one or more internal messages).\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNULL HANDLES\n       The MPI 1.1 specification, in the section on opaque objects, explicitly\n\nDISALLOWS FREEING A NULL COMMUNICATOR. THE TEXT FROM THE STANDARD IS\n       A null handle argument is an erroneous IN argument in MPI calls, unless an\n       exception is explicitly stated in the text that defines the function. Such\n       exception is allowed for handles to request objects in Wait and Test calls\n       (sections Communication Completion and Multiple Completions ). Otherwise, a\n       null handle can only be passed to a function that allocates a new object and\n       returns a reference to it in the handle.\n\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cancel.c\n\n\n\n                                  11/14/2001                     MPI_Cancel(3)\n\n\n\n\nMPI_Cart_coords.md\n\n\nMPI_Cart_coords(3)                    MPI                   MPI_Cart_coords(3)\n\n\n\nNAME\n       MPI_Cart_coords  -   Determines  process  coords  in cartesian topology\n       given rank in group\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Cart_coords ( MPI_Comm comm, int rank, int maxdims, int *coords )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       rank   - rank of a process within group of comm (integer)\n       maxdims\n              - length of vector coords in the calling program (integer)\n\n\nOUTPUT PARAMETER\n       coords - integer array (of size ndims ) containing the Cartesian  coor-\n              dinates of specified process (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_DIMS\n              - Illegal dimension argument.  A dimension argument is  null  or\n              its length is less than or equal to zero.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       cart_coords.c\n\n\n\n                                   3/28/2002                MPI_Cart_coords(3)\n\n\n\n\nMPI_Cart_create.md\n\n\nMPI_Cart_create(3)                    MPI                   MPI_Cart_create(3)\n\n\n\nNAME\n       MPI_Cart_create  -  Makes a new communicator to which topology informa-\n       tion has been attached\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Cart_create ( MPI_Comm comm_old, int ndims, int *dims, int *periods,\n                            int reorder, MPI_Comm *comm_cart )\n\nINPUT PARAMETERS\n       comm_old\n              - input communicator (handle)\n       ndims  - number of dimensions of cartesian grid (integer)\n       dims   - integer array of size ndims specifying the number of processes\n              in each dimension\n       periods\n              -  logical  array  of  size ndims specifying whether the grid is\n              periodic (true) or not (false) in each dimension\n       reorder\n              - ranking may be reordered (true) or not (false) (logical)\n\n\nOUTPUT PARAMETER\n       comm_cart\n              - communicator with new cartesian topology (handle)\n\n\nALGORITHM\n       We ignore reorder info currently.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_DIMS\n              - Illegal dimension argument.  A dimension argument is  null  or\n              its length is less than or equal to zero.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_create.c\n\n\n\n                                  11/14/2001                MPI_Cart_create(3)\n\n\n\n\nMPI_Cartdim_get.md\n\n\nMPI_Cartdim_get(3)                    MPI                   MPI_Cartdim_get(3)\n\n\n\nNAME\n       MPI_Cartdim_get  -  Retrieves Cartesian topology information associated\n       with a  communicator\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Cartdim_get ( MPI_Comm comm, int *ndims )\n\nINPUT PARAMETER\n       comm   - communicator with cartesian structure (handle)\n\n\nOUTPUT PARAMETER\n       ndims  - number of dimensions of the cartesian structure (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cartdim_get.c\n\n\n\n                                  11/14/2001                MPI_Cartdim_get(3)\n\n\n\n\nMPI_Cart_get.md\n\n\nMPI_Cart_get(3)                       MPI                      MPI_Cart_get(3)\n\n\n\nNAME\n       MPI_Cart_get  -   Retrieves  Cartesian  topology information associated\n       with a  communicator\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Cart_get (\n               MPI_Comm comm,\n               int maxdims,\n               int *dims,\n               int *periods,\n               int *coords )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       maxdims\n              - length of vectors dims , periods , and coords in  the  calling\n              program (integer)\n\n\nOUTPUT PARAMETERS\n       dims   -  number  of  processes  for each cartesian dimension (array of\n              integer)\n       periods\n              - periodicity (true/false) for each cartesian  dimension  (array\n              of logical)\n       coords -  coordinates  of calling process in cartesian structure (array\n              of integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_get.c\n\n\n\n                                  11/14/2001                   MPI_Cart_get(3)\n\n\n\n\nMPI_Cart_map.md\n\n\nMPI_Cart_map(3)                       MPI                      MPI_Cart_map(3)\n\n\n\nNAME\n       MPI_Cart_map -  Maps process to Cartesian topology information\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Cart_map (\n               MPI_Comm comm_old,\n               int ndims,\n               int *dims,\n               int *periods,\n               int *newrank)\n\nINPUT PARAMETERS\n       comm   - input communicator (handle)\n       ndims  - number of dimensions of Cartesian structure (integer)\n       dims   - integer array of size ndims specifying the number of processes\n              in each coordinate direction\n       periods\n              - logical array of size ndims specifying the periodicity  speci-\n              fication in each coordinate direction\n\n\nOUTPUT PARAMETER\n       newrank\n              -  reordered rank of the calling process; MPI_UNDEFINED if call-\n              ing process does not belong to grid (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_DIMS\n              -  Illegal  dimension argument.  A dimension argument is null or\n              its length is less than or equal to zero.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_map.c\n\n\n\n                                   3/28/2002                   MPI_Cart_map(3)\n\n\n\n\nMPI_Cart_rank.md\n\n\nMPI_Cart_rank(3)                      MPI                     MPI_Cart_rank(3)\n\n\n\nNAME\n       MPI_Cart_rank  -   Determines process rank in communicator given Carte-\n       sian location\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Cart_rank (\n               MPI_Comm comm,\n               int *coords,\n               int *rank )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       coords - integer array (of size ndims ) specifying the cartesian  coor-\n              dinates of a process\n\n\nOUTPUT PARAMETER\n       rank   - rank of specified process (integer)\n\n\nNOTES\n       Out-of-range  coordinates  are  erroneous  for non-periodic dimensions.\n       Versions of MPICH before 1.2.2 returned MPI_PROC_NULL for the  rank  in\n       this case.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_rank.c\n\n\n\n                                  11/14/2001                  MPI_Cart_rank(3)\n\n\n\n\nMPI_Cart_shift.md\n\n\nMPI_Cart_shift(3)                     MPI                    MPI_Cart_shift(3)\n\n\n\nNAME\n       MPI_Cart_shift  -   Returns  the  shifted source and destination ranks,\n       given a  shift direction and amount\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Cart_shift ( MPI_Comm comm, int direction, int displ,\n                           int *source, int *dest )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       direction\n              - coordinate dimension of shift (integer)\n       disp   - displacement (\n 0: upwards shift, \n 0: downwards shift) (inte-\n              ger)\n\n\nOUTPUT PARAMETERS\n       rank_source\n              - rank of source process (integer)\n       rank_dest\n              - rank of destination process (integer)\n\n\nNOTES\n       The  direction  argument  is  in the range [0,n-1] for an n-dimensional\n       Cartesian mesh.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_shift.c\n\n\n\n                                  11/14/2001                 MPI_Cart_shift(3)\n\n\n\n\nMPI_Cart_sub.md\n\n\nMPI_Cart_sub(3)                       MPI                      MPI_Cart_sub(3)\n\n\n\nNAME\n       MPI_Cart_sub  -   Partitions  a communicator into subgroups which  form\n       lower-dimensional cartesian subgrids\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Cart_sub ( MPI_Comm comm, int *remain_dims, MPI_Comm *comm_new )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       remain_dims\n              - the i th entry of  remain_dims  specifies  whether  the  i  th\n              dimension  is  kept  in the subgrid (true) or is dropped (false)\n              (logical vector)\n\n\nOUTPUT PARAMETER\n       newcomm\n              - communicator containing the subgrid that includes the  calling\n              process (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_sub.c\n\n\n\n                                  11/14/2001                   MPI_Cart_sub(3)\n\n\n\n\nMPI_Comm_compare.md\n\n\nMPI_Comm_compare(3)                   MPI                  MPI_Comm_compare(3)\n\n\n\nNAME\n       MPI_Comm_compare -  Compares two communicators\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Comm_compare (\n               MPI_Comm  comm1,\n               MPI_Comm  comm2,\n               int *result)\n\nINPUT PARAMETERS\n       comm1  - comm1 (handle)\n       comm2  - comm2 (handle)\n\n\nOUTPUT PARAMETER\n       result -  integer which is MPI_IDENT if the contexts and groups are the\n              same, MPI_CONGRUENT if different contexts but identical  groups,\n              MPI_SIMILAR  if  different  contexts  but  similar  groups,  and\n              MPI_UNEQUAL otherwise\n\n\nUSING 'MPI_COMM_NULL' WITH 'MPI_COMM_COMPARE'\n       It is an error  to  use  MPI_COMM_NULL  as  one  of  the  arguments  to\n       MPI_Comm_compare .  The relevant sections of the MPI standard are\n\n       .   (2.4.1  Opaque  Objects)  A null handle argument is an erroneous IN\n       argument in MPI calls, unless an exception is explicitly stated in  the\n       text that defines the function.\n\n       .   (5.4.1. Communicator Accessors) \nno text in MPI_COMM_COMPARE allow-\n       ing a null handle\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       commcompare.c\n\n\n\n                                  11/14/2001               MPI_Comm_compare(3)\n\n\n\n\nMPI_Comm_create.md\n\n\nMPI_Comm_create(3)                    MPI                   MPI_Comm_create(3)\n\n\n\nNAME\n       MPI_Comm_create -  Creates a new communicator\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Comm_create ( MPI_Comm comm, MPI_Group group, MPI_Comm *comm_out )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n       group  - group, which is a subset of the group of comm (handle)\n\n\nOUTPUT PARAMETER\n       comm_out\n              - new communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Comm_free\n\nLOCATION\n       comm_create.c\n\n\n\n                                  11/14/2001                MPI_Comm_create(3)\n\n\n\n\nMPI_Comm_dup.md\n\n\nMPI_Comm_dup(3)                       MPI                      MPI_Comm_dup(3)\n\n\n\nNAME\n       MPI_Comm_dup -  Duplicates an existing communicator with all its cached\n       information\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Comm_dup (\n               MPI_Comm comm,\n               MPI_Comm *comm_out )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       newcomm\n              - A new communicator over the same group as comm but with a  new\n              context. See notes.  (handle)\n\n\nNOTES\n       This routine is used to create a new communicator that has a new commu-\n       nication context but contains the same group of processes as the  input\n       communicator.  Since all MPI communication is performed within a commu-\n       nicator (specifies as the group of processes plus  the  context),  this\n       routine  provides an effective way to create a private communicator for\n       use by a software module or library.  In particular, no library routine\n       should  use MPI_COMM_WORLD as the communicator; instead, a duplicate of\n       a user-specified communicator should always be used.  For more informa-\n       tion, see Using MPI, 2nd edition.\n\n       Because  this routine essentially produces a copy of a communicator, it\n       also copies any attributes that have been defined on the input communi-\n       cator, using the attribute copy function specified by the copy_function\n       argument to MPI_Keyval_create .  This is particularly  useful  for  (a)\n       attributes that describe some property of the group associated with the\n       communicator, such as its interconnection topology and  (b)  communica-\n       tors  that  are  given back to the user; the attibutes in this case can\n       track subsequent MPI_Comm_dup operations on this communicator.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Comm_free, MPI_Keyval_create, MPI_Attr_set, MPI_Attr_delete\n\n\nLOCATION\n       comm_dup.c\n\n\n\n                                  11/14/2001                   MPI_Comm_dup(3)\n\n\n\n\nMPI_Comm_free.md\n\n\nMPI_Comm_free(3)                      MPI                     MPI_Comm_free(3)\n\n\n\nNAME\n       MPI_Comm_free -  Marks the communicator object for deallocation\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Comm_free ( MPI_Comm *commp )\n\nINPUT PARAMETER\n       comm   - communicator to be destroyed (handle)\n\n\nNULL HANDLES\n       The MPI 1.1 specification, in the section on opaque objects, explicitly\n\nDISALLOWS FREEING A NULL COMMUNICATOR. THE TEXT FROM THE STANDARD IS\n       A null handle argument is an erroneous IN argument in MPI calls, unless an\n       exception is explicitly stated in the text that defines the function. Such\n       exception is allowed for handles to request objects in Wait and Test calls\n       (sections Communication Completion and Multiple Completions ). Otherwise, a\n       null handle can only be passed to a function that allocates a new object and\n       returns a reference to it in the handle.\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_free.c\n\n\n\n                                  10/31/2002                  MPI_Comm_free(3)\n\n\n\n\nMPI_Comm_group.md\n\n\nMPI_Comm_group(3)                     MPI                    MPI_Comm_group(3)\n\n\n\nNAME\n       MPI_Comm_group -  Accesses the group associated with given communicator\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Comm_group (\n               MPI_Comm comm,\n               MPI_Group *group )\n\nINPUT PARAMETER\n       comm   - Communicator\n\n\nOUTPUT PARAMETER\n       group  - Group in communicator\n\n\nUSING 'MPI_COMM_NULL' WITH 'MPI_COMM_GROUP'\n       It is an error  to  use  MPI_COMM_NULL  as  one  of  the  arguments  to\n       MPI_Comm_group .  The relevant sections of the MPI standard are\n\n       .   (2.4.1  Opaque  Objects)  A null handle argument is an erroneous IN\n       argument in MPI calls, unless an exception is explicitly stated in  the\n       text that defines the function.\n\n       .   (5.3.2.  Group  Constructors) \nno text in MPI_COMM_GROUP allowing a\n       null handle\n\n\n       Previous versions of MPICH allow MPI_COMM_NULL in  this  function.   In\n       the interests of promoting portability of applications, we have changed\n       the behavior of MPI_Comm_group to detect  this  violation  of  the  MPI\n       standard.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       comm_group.c\n\n\n\n                                  11/14/2001                 MPI_Comm_group(3)\n\n\n\n\nMPI_Comm_rank.md\n\n\nMPI_Comm_rank(3)                      MPI                     MPI_Comm_rank(3)\n\n\n\nNAME\n       MPI_Comm_rank -  Determines the rank of the calling process in the com-\n       municator\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Comm_rank ( MPI_Comm comm, int *rank )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       rank   - rank of the calling process in group of comm (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       comm_rank.c\n\n\n\n                                  11/14/2001                  MPI_Comm_rank(3)\n\n\n\n\nMPI_Comm_remote_group.md\n\n\nMPI_Comm_remote_group(3)              MPI             MPI_Comm_remote_group(3)\n\n\n\nNAME\n       MPI_Comm_remote_group -  Accesses the remote group associated with  the\n       given inter-communicator\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Comm_remote_group ( MPI_Comm comm, MPI_Group *group )\n\nINPUT PARAMETER\n       comm   - Communicator (must be intercommunicator)\n\n\nOUTPUT PARAMETER\n       group  - remote group of communicator\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       comm_rgroup.c\n\n\n\n                                  11/14/2001          MPI_Comm_remote_group(3)\n\n\n\n\nMPI_Comm_remote_size.md\n\n\nMPI_Comm_remote_size(3)               MPI              MPI_Comm_remote_size(3)\n\n\n\nNAME\n       MPI_Comm_remote_size  -  Determines the size of the remote group  asso-\n       ciated with an inter-communictor\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Comm_remote_size ( MPI_Comm comm, int *size )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       size   - number of processes in the group of comm (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_rsize.c\n\n\n\n                                  11/14/2001           MPI_Comm_remote_size(3)\n\n\n\n\nMPI_Comm_size.md\n\n\nMPI_Comm_size(3)                      MPI                     MPI_Comm_size(3)\n\n\n\nNAME\n       MPI_Comm_size  -   Determines  the  size of the group associated with a\n       communictor\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Comm_size ( MPI_Comm comm, int *size )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       size   - number of processes in the group of comm (integer)\n\n\nNOTES\n       MPI_COMM_NULL is not considered a valid argument to this function.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_size.c\n\n\n\n                                  11/14/2001                  MPI_Comm_size(3)\n\n\n\n\nMPI_Comm_split.md\n\n\nMPI_Comm_split(3)                     MPI                    MPI_Comm_split(3)\n\n\n\nNAME\n       MPI_Comm_split -  Creates new communicators based on colors and keys\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Comm_split ( MPI_Comm comm, int color, int key, MPI_Comm *comm_out )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n       color  - control of subset assignment (nonnegative integer).  Processes\n              with the same color are in the same new communicator\n       key    - control of rank assigment (integer)\n\n\nOUTPUT PARAMETER\n       newcomm\n              - new communicator (handle)\n\n\nNOTES\n       The color must be non-negative or MPI_UNDEFINED .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nALGORITHM\n       The current algorithm used has quite a few (read: a lot of) inefficien-\n       cies that can be removed.  Here is what we do for now\n\n       1) A table is built of colors, and keys (has a next field also).\n       2) The tables of all processes are merged using\n       MPI_Allreduce\n       .\n       3) Two contexts are allocated for all the comms to be created.  These\n       same two contexts can be used for all created communicators since\n       the communicators will not overlap.\n       4) If the local process has a color of\n       MPI_UNDEFINED\n       , it can return\n       a\n       NULL\n       comm.\n       5) The table entries that match the local process color are sorted\n       by key/rank.\n       6) A group is created from the sorted list and a communicator is created\n       with this group and the previously allocated contexts.\n\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Comm_free\n\nLOCATION\n       comm_split.c\n\n\n\n                                   8/29/2002                 MPI_Comm_split(3)\n\n\n\n\nMPI_Comm_test_inter.md\n\n\nMPI_Comm_test_inter(3)                MPI               MPI_Comm_test_inter(3)\n\n\n\nNAME\n       MPI_Comm_test_inter -  Tests to see if a comm is an inter-communicator\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Comm_test_inter ( MPI_Comm comm, int *flag )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       flag   - (logical)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_testic.c\n\n\n\n                                  11/14/2001            MPI_Comm_test_inter(3)\n\n\n\n\nMPI_Dims_create.md\n\n\nMPI_Dims_create(3)                    MPI                   MPI_Dims_create(3)\n\n\n\nNAME\n       MPI_Dims_create -  Creates a division of processors in a cartesian grid\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Dims_create(\n               int nnodes,\n               int ndims,\n               int *dims)\n\nINPUT PARAMETERS\n       nnodes - number of nodes in a grid (integer)\n       ndims  - number of cartesian dimensions (integer)\n\n\nIN/OUT PARAMETER\n       dims   - integer array of size ndims specifying the number of nodes  in\n              each dimension\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       dims_create.c\n\n\n\n                                   4/24/2002                MPI_Dims_create(3)\n\n\n\n\nMPI_Errhandler_create.md\n\n\nMPI_Errhandler_create(3)              MPI             MPI_Errhandler_create(3)\n\n\n\nNAME\n       MPI_Errhandler_create -  Creates an MPI-style errorhandler\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Errhandler_create(\n               MPI_Handler_function *function,\n               MPI_Errhandler       *errhandler)\n\nINPUT PARAMETER\n       function\n              - user defined error handling procedure\n\n\nOUTPUT PARAMETER\n       errhandler\n              - MPI error handler (handle)\n\n\nNOTES\n       The  MPI  Standard  states  that  an implementation may make the output\n       value (errhandler) simply the address of the  function.   However,  the\n       action  of  MPI_Errhandler_free  makes  this  impossible,  since  it is\n       required to set the value of the argument to MPI_ERRHANDLER_NULL .   In\n       addition,  the actual error handler must remain until all communicators\n       that use it are freed.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       errcreate.c\n\n\n\n                                  11/14/2001          MPI_Errhandler_create(3)\n\n\n\n\nMPI_Errhandler_free.md\n\n\nMPI_Errhandler_free(3)                MPI               MPI_Errhandler_free(3)\n\n\n\nNAME\n       MPI_Errhandler_free -  Frees an MPI-style errorhandler\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Errhandler_free( MPI_Errhandler *errhandler )\n\nINPUT PARAMETER\n       errhandler\n              -  MPI  error  handler  (handle).  Set to MPI_ERRHANDLER_NULL on\n              exit.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       errfree.c\n\n\n\n                                  11/14/2001            MPI_Errhandler_free(3)\n\n\n\n\nMPI_Errhandler_get.md\n\n\nMPI_Errhandler_get(3)                 MPI                MPI_Errhandler_get(3)\n\n\n\nNAME\n       MPI_Errhandler_get -  Gets the error handler for a communicator\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Errhandler_get( MPI_Comm comm, MPI_Errhandler *errhandler )\n\nINPUT PARAMETER\n       comm   - communicator to get the error handler from (handle)\n\n\nOUTPUT PARAMETER\n       errhandler\n              - MPI error handler currently associated with communicator (han-\n              dle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTE ON IMPLEMENTATION\n       The  MPI Standard was unclear on whether this routine required the user\n       to call MPI_Errhandler_free once for each call made to this routine  in\n       order  to  free  the  error  handler.  After some debate, the MPI Forum\n       added an explicit statement that users are required to call MPI_Errhan-\n       dler_free  when the return value from this routine is no longer needed.\n       This behavior is similar to the other MPI routines for getting objects;\n       for  example, MPI_Comm_group requires that the user call MPI_Group_free\n       when the group returned by MPI_Comm_group is no longer needed.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       errget.c\n\n\n\n                                  11/14/2001             MPI_Errhandler_get(3)\n\n\n\n\nMPI_Errhandler_set.md\n\n\nMPI_Errhandler_set(3)                 MPI                MPI_Errhandler_set(3)\n\n\n\nNAME\n       MPI_Errhandler_set -  Sets the error handler for a communicator\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Errhandler_set( MPI_Comm comm, MPI_Errhandler errhandler )\n\nINPUT PARAMETERS\n       comm   - communicator to set the error handler for (handle)\n       errhandler\n              - new MPI error handler for communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       errset.c\n\n\n\n                                  11/14/2001             MPI_Errhandler_set(3)\n\n\n\n\nMPI_Error_class.md\n\n\nMPI_Error_class(3)                    MPI                   MPI_Error_class(3)\n\n\n\nNAME\n       MPI_Error_class -  Converts an error code into an error class\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Error_class(\n               int errorcode,\n               int *errorclass)\n\nINPUT PARAMETER\n       errorcode\n              - Error code returned by an MPI routine\n\n\nOUTPUT PARAMETER\n       errorclass\n              - Error class associated with errorcode\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       errclass.c\n\n\n\n                                  11/14/2001                MPI_Error_class(3)\n\n\n\n\nMPI_Error_string.md\n\n\nMPI_Error_string(3)                   MPI                  MPI_Error_string(3)\n\n\n\nNAME\n       MPI_Error_string -  Return a string for a given error code\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Error_string( int errorcode, char *string, int *resultlen )\n\nINPUT PARAMETERS\n       errorcode\n              - Error code returned by an MPI routine or an MPI error class\n\n\nOUTPUT PARAMETER\n       string - Text that corresponds to the errorcode\n       resultlen\n              - Length of string\n\n              Notes:  Error codes are the values return by MPI routines (in C)\n              or in the ierr argument (in Fortran).  These  can  be  converted\n              into error classes with the routine MPI_Error_class .\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       errorstring.c\n\n\n\n                                  11/14/2001               MPI_Error_string(3)\n\n\n\n\nMPI_Finalize.md\n\n\nMPI_Finalize(3)                       MPI                      MPI_Finalize(3)\n\n\n\nNAME\n       MPI_Finalize -  Terminates MPI execution environment\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Finalize()\n\nNOTES\n       All  processes  must  call  this routine before exiting.  The number of\n       processes running after this routine is called is undefined; it is best\n       not  to perform much more than a return rc after calling MPI_Finalize .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       finalize.c\n\n\n\n                                   4/9/2002                    MPI_Finalize(3)\n\n\n\n\nMPI_Gather.md\n\n\nMPI_Gather(3)                         MPI                        MPI_Gather(3)\n\n\n\nNAME\n       MPI_Gather -  Gathers together values from a group of processes\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Gather ( void *sendbuf, int sendcnt, MPI_Datatype sendtype,\n                       void *recvbuf, int recvcount, MPI_Datatype recvtype,\n                       int root, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              -  number  of elements for any single receive (integer, signifi-\n              cant only at root)\n       recvtype\n              - data type of recv buffer elements (significant only  at  root)\n              (handle)\n       root   - rank of receiving process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice, significant only at root )\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\nLOCATION\n       gather.c\n\n\n\n                                  11/14/2001                     MPI_Gather(3)\n\n\n\n\nMPI_Gatherv.md\n\n\nMPI_Gatherv(3)                        MPI                       MPI_Gatherv(3)\n\n\n\nNAME\n       MPI_Gatherv -  Gathers into specified locations from all processes in a\n       group\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Gatherv ( void *sendbuf, int sendcnt, MPI_Datatype sendtype,\n                         void *recvbuf, int *recvcnts, int *displs,\n                        MPI_Datatype recvtype,\n                         int root, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcounts\n              - integer array (of length group size) containing the number  of\n              elements  that  are received from each process (significant only\n              at root )\n       displs - integer array (of length group size). Entry  i  specifies  the\n              displacement relative to recvbuf  at which to place the incoming\n              data from process i (significant only at root)\n       recvtype\n              - data type of recv buffer elements (significant only at root  )\n              (handle)\n       root   - rank of receiving process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice, significant only at root )\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       gatherv.c\n\n\n\n                                   2/19/2002                    MPI_Gatherv(3)\n\n\n\n\nMPI_Get_count.md\n\n\nMPI_Get_count(3)                      MPI                     MPI_Get_count(3)\n\n\n\nNAME\n       MPI_Get_count -  Gets the number of \ntop level\n elements\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Get_count(\n               MPI_Status *status,\n               MPI_Datatype datatype,\n               int *count )\n\nINPUT PARAMETERS\n       status - return status of receive operation (Status)\n       datatype\n              - datatype of each receive buffer element (handle)\n\n\nOUTPUT PARAMETER\n       count  -  number  of  received elements (integer) Notes: If the size of\n              the datatype is zero, this routine will return a count of  zero.\n              If  the amount of data in status is not an exact multiple of the\n              size of datatype (so that count would not be integral), a  count\n              of MPI_UNDEFINED is returned instead.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       getcount.c\n\n\n\n                                  11/14/2001                  MPI_Get_count(3)\n\n\n\n\nMPI_Get_elements.md\n\n\nMPI_Get_elements(3)                   MPI                  MPI_Get_elements(3)\n\n\n\nNAME\n       MPI_Get_elements -  Returns the number of basic elements in a datatype\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Get_elements ( MPI_Status *status, MPI_Datatype datatype,\n                             int *elements )\n\nINPUT PARAMETERS\n       status - return status of receive operation (Status)\n       datatype\n              - datatype used by receive operation (handle)\n\n\nOUTPUT PARAMETER\n       count  - number of received basic elements (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\n\nLOCATION\n       getelements.c\n\n\n\n                                  11/14/2001               MPI_Get_elements(3)\n\n\n\n\nMPI_Get_processor_name.md\n\n\nMPI_Get_processor_name(3)             MPI            MPI_Get_processor_name(3)\n\n\n\nNAME\n       MPI_Get_processor_name -  Gets the name of the processor\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Get_processor_name(\n               char *name,\n               int *resultlen)\n\nOUTPUT PARAMETERS\n       name   -  A  unique  specifier  for  the actual (as opposed to virtual)\n              node. This must be an array of  size  at  least  MPI_MAX_PROCES-\n              SOR_NAME .\n\n       resultlen\n              - Length (in characters) of the name\n\n\nNOTES\n       The  name  returned should identify a particular piece of hardware; the\n       exact format is implementation defined.  This name may or  may  not  be\n       the same as might be returned by gethostname , uname , or sysinfo .\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       getpname.c\n\n\n\n                                  11/14/2001         MPI_Get_processor_name(3)\n\n\n\n\nMPI_Get_version.md\n\n\nMPI_Get_version(3)                    MPI                   MPI_Get_version(3)\n\n\n\nNAME\n       MPI_Get_version -  Gets the version of MPI\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Get_version(\n               int *version,\n               int *subversion )\n\nOUTPUT PARAMETERS\n       version\n              - Major version of MPI (1 or 2)\n       subversion\n              - Minor version of MPI.\n\n\nNOTES\n       The  defined  values  MPI_VERSION  and  MPI_SUBVERSION contain the same\n       information.  This routine allows you to check that the library matches\n       the version specified in the mpi.h and mpif.h files.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       getversion.c\n\n\n\n                                  11/14/2001                MPI_Get_version(3)\n\n\n\n\n\nMPI_Graph_create.md\n\n\nMPI_Graph_create(3)                   MPI                  MPI_Graph_create(3)\n\n\n\nNAME\n       MPI_Graph_create -  Makes a new communicator to which topology informa-\n       tion has been attached\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Graph_create ( MPI_Comm comm_old, int nnodes, int *index, int *edges,\n                             int reorder, MPI_Comm *comm_graph )\n\nINPUT PARAMETERS\n       comm_old\n              - input communicator without topology (handle)\n       nnodes - number of nodes in graph (integer)\n       index  - array of integers describing node degrees (see below)\n       edges  - array of integers describing graph edges (see below)\n       reorder\n              - ranking may be reordered (true) or not (false) (logical)\n\n\nOUTPUT PARAMETER\n       comm_graph\n              - communicator with graph topology added (handle)\n\n\nALGORITHM\n       We ignore the reorder info currently.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graphcreate.c\n\n\n\n                                   1/4/2002                MPI_Graph_create(3)\n\n\n\n\nMPI_Graphdims_get.md\n\n\nMPI_Graphdims_get(3)                  MPI                 MPI_Graphdims_get(3)\n\n\n\nNAME\n       MPI_Graphdims_get  -   Retrieves  graph topology information associated\n       with a  communicator\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Graphdims_get ( MPI_Comm comm, int *nnodes, int *nedges )\n\nINPUT PARAMETERS\n       comm   - communicator for group with graph structure (handle)\n\n\nOUTPUT PARAMETER\n       nnodes - number of nodes in graph (integer)\n       nedges - number of edges in graph (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graphdimsget.c\n\n\n\n                                  11/14/2001              MPI_Graphdims_get(3)\n\n\n\n\nMPI_Graph_get.md\n\n\nMPI_Graph_get(3)                      MPI                     MPI_Graph_get(3)\n\n\n\nNAME\n       MPI_Graph_get -  Retrieves graph topology information associated with a\n       communicator\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Graph_get ( MPI_Comm comm, int maxindex, int maxedges,\n                          int *index, int *edges )\n\nINPUT PARAMETERS\n       comm   - communicator with graph structure (handle)\n       maxindex\n              - length of vector index in the calling program  (integer)\n       maxedges\n              - length of vector edges in the calling program  (integer)\n\n\nOUTPUT PARAMETER\n       index  - array of integers containing the graph structure (for  details\n              see the definition of MPI_GRAPH_CREATE )\n       edges  - array of integers containing the graph structure\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graph_get.c\n\n\n\n                                   1/4/2002                   MPI_Graph_get(3)\n\n\n\n\nMPI_Graph_map.md\n\n\nMPI_Graph_map(3)                      MPI                     MPI_Graph_map(3)\n\n\n\nNAME\n       MPI_Graph_map -  Maps process to graph topology information\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Graph_map ( MPI_Comm comm_old, int nnodes, int *index, int *edges,\n                          int *newrank )\n\nINPUT PARAMETERS\n       comm   - input communicator (handle)\n       nnodes - number of graph nodes (integer)\n       index  -   integer   array   specifying   the   graph   structure,  see\n              MPI_GRAPH_CREATE\n\n       edges  - integer array specifying the graph structure\n\n\nOUTPUT PARAMETER\n       newrank\n              - reordered rank of the calling process;  MPI_UNDEFINED  if  the\n              calling process does not belong to graph (integer)\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graph_map.c\n\n\n\n                                   1/4/2002                   MPI_Graph_map(3)\n\n\n\n\nMPI_Graph_neighbors_count.md\n\n\nMPI_Graph_neighbors_count(3)          MPI         MPI_Graph_neighbors_count(3)\n\n\n\nNAME\n       MPI_Graph_neighbors_count  -  Returns the number of neighbors of a node\n       associated with a graph topology\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Graph_neighbors_count ( MPI_Comm comm, int rank, int *nneighbors )\n\nINPUT PARAMETERS\n       comm   - communicator with graph topology (handle)\n       rank   - rank of process in group of comm (integer)\n\n\nOUTPUT PARAMETER\n       nneighbors\n              - number of neighbors of specified process (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       graphnbrcnt.c\n\n\n\n                                  11/14/2001      MPI_Graph_neighbors_count(3)\n\n\n\n\nMPI_Graph_neighbors.md\n\n\nMPI_Graph_neighbors(3)                MPI               MPI_Graph_neighbors(3)\n\n\n\nNAME\n       MPI_Graph_neighbors -  Returns the neighbors of a node associated  with\n       a graph topology\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Graph_neighbors ( MPI_Comm comm, int rank, int maxneighbors,\n                               int *neighbors )\n\nINPUT PARAMETERS\n       comm   - communicator with graph topology (handle)\n       rank   - rank of process in group of comm (integer)\n       maxneighbors\n              - size of array neighbors (integer)\n\n\nOUTPUT PARAMETERS\n       neighbors\n              - ranks of processes that are  neighbors  to  specified  process\n              (array of integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       graph_nbr.c\n\n\n\n                                  11/14/2001            MPI_Graph_neighbors(3)\n\n\n\n\nMPI_Group_compare.md\n\n\nMPI_Group_compare(3)                  MPI                 MPI_Group_compare(3)\n\n\n\nNAME\n       MPI_Group_compare -  Compares two groups\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Group_compare ( MPI_Group group1, MPI_Group group2, int *result )\n\nINPUT PARAMETERS\n       group1 - group1 (handle)\n       group2 - group2 (handle)\n\n\nOUTPUT PARAMETER\n       result - integer which is MPI_IDENT if the order and members of the two\n              groups are the same, MPI_SIMILAR if only  the  members  are  the\n              same, and MPI_UNEQUAL otherwise\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       groupcompare.c\n\n\n\n                                  11/14/2001              MPI_Group_compare(3)\n\n\n\n\nMPI_Group_difference.md\n\n\nMPI_Group_difference(3)               MPI              MPI_Group_difference(3)\n\n\n\nNAME\n       MPI_Group_difference -  Makes a group from the difference of two groups\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Group_difference ( MPI_Group group1, MPI_Group group2,\n                                MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group1 - first group (handle)\n       group2 - second group (handle)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - difference group (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_diff.c\n\n\n\n                                  11/14/2001           MPI_Group_difference(3)\n\n\n\n\nMPI_Group_excl.md\n\n\nMPI_Group_excl(3)                     MPI                    MPI_Group_excl(3)\n\n\n\nNAME\n       MPI_Group_excl  -  Produces a group by reordering an existing group and\n       taking only unlisted members\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Group_excl ( MPI_Group group, int n, int *ranks, MPI_Group *newgroup )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of elements in array ranks (integer)\n       ranks  - array of integer ranks in group not to appear in newgroup\n\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, preserving the order defined  by\n              group (handle)\n\n\nNOTE\n       Currently,  each  of  the  ranks to exclude must be a valid rank in the\n       group and all elements must be distinct or the function  is  erroneous.\n       This restriction is per the draft.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_excl.c\n\n\n\n                                  11/14/2001                 MPI_Group_excl(3)\n\n\n\n\nMPI_Group_free.md\n\n\nMPI_Group_free(3)                     MPI                    MPI_Group_free(3)\n\n\n\nNAME\n       MPI_Group_free -  Frees a group\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Group_free ( MPI_Group *group )\n       Input Parameter\n       group  - group (handle)\n\n\nNOTES\n       On output, group is set to MPI_GROUP_NULL .\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              groups.\n\nLOCATION\n       group_free.c\n\n\n\n                                  11/14/2001                 MPI_Group_free(3)\n\n\n\n\nMPI_Group_incl.md\n\n\nMPI_Group_incl(3)                     MPI                    MPI_Group_incl(3)\n\n\n\nNAME\n       MPI_Group_incl  -  Produces a group by reordering an existing group and\n       taking only listed members\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Group_incl ( MPI_Group group, int n, int *ranks, MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of elements in array ranks  (and  size  of  newgroup  )\n              (integer)\n       ranks  -  ranks  of  processes in group to appear in newgroup (array of\n              integers)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, in the order defined by ranks\n\n              (handle)\n\n\nNOTE\n       This implementation does not currently check to see that  the  list  of\n       ranks to ensure that there are no duplicates.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_incl.c\n\n\n\n                                  11/14/2001                 MPI_Group_incl(3)\n\n\n\n\nMPI_Group_intersection.md\n\n\nMPI_Group_intersection(3)             MPI            MPI_Group_intersection(3)\n\n\n\nNAME\n       MPI_Group_intersection  -   Produces a group as the intersection of two\n       existing groups\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Group_intersection ( MPI_Group group1, MPI_Group group2,\n                                  MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group1 - first group (handle)\n       group2 - second group (handle)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - intersection group (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_inter.c\n\n\n\n                                  11/14/2001         MPI_Group_intersection(3)\n\n\n\n\nMPI_Group_range_excl.md\n\n\nMPI_Group_range_excl(3)               MPI              MPI_Group_range_excl(3)\n\n\n\nNAME\n       MPI_Group_range_excl  -   Produces  a group by excluding ranges of pro-\n       cesses from an existing group\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Group_range_excl ( MPI_Group group, int n, int ranges[][3],\n                                MPI_Group *newgroup )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of elements in array ranks (integer)\n       ranges - a one-dimensional array of integer triplets of the form (first\n              rank,  last rank, stride), indicating the ranks in group of pro-\n              cesses to be excluded from the output group newgroup .\n\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, preserving the  order  in  group\n              (handle)\n\n\nNOTE\n       Currently,  each  of  the  ranks to exclude must be a valid rank in the\n       group and all elements must be distinct or the function  is  erroneous.\n       This restriction is per the draft.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_rexcl.c\n\n\n\n                                  11/14/2001           MPI_Group_range_excl(3)\n\n\n\n\nMPI_Group_range_incl.md\n\n\nMPI_Group_range_incl(3)               MPI              MPI_Group_range_incl(3)\n\n\n\nNAME\n       MPI_Group_range_incl  -  Creates a new group from ranges of ranks in an\n       existing group\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Group_range_incl ( MPI_Group group, int n, int ranges[][3],\n                                MPI_Group *newgroup )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of triplets in array ranges (integer)\n       ranges - a one-dimensional array  of  integer  triplets,  of  the  form\n              (first  rank,  last  rank,  stride) indicating ranks in group or\n              processes to be included in newgroup\n\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, in the order defined  by  ranges\n              (handle)\n\n\nNOTE\n       This  implementation  does  not currently check to see that the list of\n       ranges to include are valid ranks in the group.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_rincl.c\n\n\n\n                                  11/14/2001           MPI_Group_range_incl(3)\n\n\n\n\nMPI_Group_rank.md\n\n\nMPI_Group_rank(3)                     MPI                    MPI_Group_rank(3)\n\n\n\nNAME\n       MPI_Group_rank -  Returns the rank of this process in the given group\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Group_rank ( MPI_Group group, int *rank )\n\nINPUT PARAMETERS\n       group  - group (handle)\n\n\nOUTPUT PARAMETER\n       rank   -  rank of the calling process in group, or MPI_UNDEFINED if the\n              process is not a member (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       group_rank.c\n\n\n\n                                  11/14/2001                 MPI_Group_rank(3)\n\n\n\n\nMPI_Group_size.md\n\n\nMPI_Group_size(3)                     MPI                    MPI_Group_size(3)\n\n\n\nNAME\n       MPI_Group_size -  Returns the size of a group\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Group_size ( MPI_Group group, int *size )\n\nINPUT PARAMETERS\n       group  - group (handle) Output Parameter:\n       size   - number of processes in the group (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       group_size.c\n\n\n\n                                  11/14/2001                 MPI_Group_size(3)\n\n\n\n\nMPI_Group_translate_ranks.md\n\n\nMPI_Group_translate_ranks(3)          MPI         MPI_Group_translate_ranks(3)\n\n\n\nNAME\n       MPI_Group_translate_ranks  -   Translates the ranks of processes in one\n       group to  those in another group\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Group_translate_ranks ( MPI_Group group_a, int n, int *ranks_a,\n                                    MPI_Group group_b, int *ranks_b )\n\nINPUT PARAMETERS\n       group1 - group1 (handle)\n       n      - number of ranks in ranks1 and ranks2 arrays (integer)\n       ranks1 - array of zero or more valid ranks in group1\n\n       group2 - group2 (handle)\n\n\nOUTPUT PARAMETER\n       ranks2 - array of corresponding ranks in group2, MPI_UNDEFINED when  no\n              correspondence exists.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       group_tranks.c\n\n\n\n                                  11/14/2001      MPI_Group_translate_ranks(3)\n\n\n\n\nMPI_Group_union.md\n\n\nMPI_Group_union(3)                    MPI                   MPI_Group_union(3)\n\n\n\nNAME\n       MPI_Group_union -  Produces a group by combining two groups\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Group_union ( MPI_Group group1, MPI_Group group2,\n                            MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group1 - first group (handle)\n       group2 - second group (handle)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - union group (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_union.c\n\n\n\n                                  11/14/2001                MPI_Group_union(3)\n\n\n\n\nMPI_Ibsend.md\n\n\nMPI_Ibsend(3)                         MPI                        MPI_Ibsend(3)\n\n\n\nNAME\n       MPI_Ibsend -  Starts a nonblocking buffered send\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Ibsend( void *buf, int count, MPI_Datatype datatype, int dest, int tag,\n                      MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\n\nLOCATION\n       ibsend.c\n\n\n\n                                  11/14/2001                     MPI_Ibsend(3)\n\n\n\n\nMPI_Initialized.md\n\n\nMPI_Initialized(3)                    MPI                   MPI_Initialized(3)\n\n\n\nNAME\n       MPI_Initialized -  Indicates whether MPI_Init has been called.\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Initialized( int *flag )\n\nOUTPUT PARAMETER\n       flag   -  Flag is true if MPI_Init has been called and false otherwise.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       initialize.c\n\n\n\n                                  11/14/2001                MPI_Initialized(3)\n\n\n\n\nMPI_Init.md\n\n\nMPI_Init(3)                           MPI                          MPI_Init(3)\n\n\n\nNAME\n       MPI_Init -  Initialize the MPI execution environment\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Init(int *argc, char ***argv)\n\nINPUT PARAMETERS\n       argc   - Pointer to the number of arguments\n       argv   - Pointer to the argument vector\n\n\nCOMMAND LINE ARGUMENTS\n       MPI specifies no command-line arguments but does allow an MPI implemen-\n       tation to make use of them.\n\n       -mpiqueue\n              - print out the state of the message queues when MPI_FINALIZE is\n              called.   All  processors print; the output may be hard to deci-\n              pher.  This is intended as a debugging aid.\n\n       -mpiversion\n              - print out the version of the implementation  (  not  of  MPI),\n              including the arguments that were used with configure.\n\n       -mpinice nn\n              -  Increments the nice value by nn (lowering the priority of the\n              program by nn ).  nn must be positive (except  for  root).   Not\n              all systems support this argument; those that do not will ignore\n              it.\n\n       -mpedbg\n              - Start a debugger in an xterm  window  if  there  is  an  error\n              (either detected by MPI or a normally fatal signal).  This works\n              only if MPICH was configured with -mpedbg .  CURRENTLY DISABLED.\n              If  you  have  TotalView, -mpichtv or mpirun -tv will give you a\n              better environment anyway.\n\n       -mpimem\n              - If MPICH was built with -DMPIR_DEBUG_MEM  ,  this  checks  all\n              malloc  and  free  operations  (internal  to MPICH) for signs of\n              injury to the memory allocation areas.\n\n       -mpidb options\n              - Activate various debugging options.  Some require  that  MPICH\n              have  been  built  with special options.  These are intended for\n              debugging MPICH, not for debugging user programs.  The available\n              options include:\n              mem     - Enable dynamic memory tracing of internal MPI objects\n              memall  - Generate output of all memory allocation/deallocation\n              ptr     - Enable tracing of internal MPI pointer conversions\n              rank n  - Limit subsequent -mpidb options to on the process with\n              the specified rank in MPI_COMM_WORLD.  A rank of -1\n              selects all of MPI_COMM_WORLD.\n              ref     - Trace use of internal MPI objects\n              reffile filename - Trace use of internal MPI objects with output\n              to the indicated file\n              trace   - Trace routine calls\n\n\n\nNOTES\n       Note  that  the  Fortran  binding  for  this routine has only the error\n       return argument ( MPI_INIT(ierror) )\n\n       Because the Fortran and C versions of MPI_Init are different, there  is\n       a  restriction  on  who can call MPI_Init .  The version (Fortran or C)\n       must match the main program.  That is, if the main  program  is  in  C,\n       then  the C version of MPI_Init must be called.  If the main program is\n       in Fortran, the Fortran version must be called.\n\n       On exit from this routine, all processes will have a copy of the  argu-\n       ment  list.   This  is  not  required  by  the MPI standard, and truely\n       portable codes should not rely on it.  This is provided as a service by\n       this implementation (an MPI implementation is allowed to distribute the\n       command line arguments but is not required to).\n\n       Command line arguments are not provided to Fortran programs.  More pre-\n       cisely,  non-standard  Fortran  routines  such as getarg and iargc have\n       undefined behavior in MPI and in this implementation.\n\n       The MPI standard does not say what a program can do before an  MPI_INIT\n       or  after an MPI_FINALIZE .  In the MPICH implementation, you should do\n       as little as possible.  In particular, avoid anything that changes  the\n       external  state of the program, such as opening files, reading standard\n       input or writing to standard output.\n\n\nSIGNALS USED\n       The MPI standard requires that all signals  used  be  documented.   The\n       MPICH  implementation  itself uses no signals, but some of the software\n       that MPICH relies on may use some signals.  The list below  is  partial\n       and  should  be  independantly checked if you (and any package that you\n       use) depend on particular signals.\n\n\nIBM POE/MPL FOR SP2\n       SIGHUP, SIGINT, SIGQUIT, SIGFPE, SIGSEGV,  SIGPIPE,  SIGALRM,  SIGTERM,\n       SIGIO\n\n\n-MPEDBG SWITCH\n       SIGQUIT, SIGILL, SIGFPE, SIGBUS, SIGSEGV, SIGSYS\n\n\nMEIKO CS2\n       SIGUSR2\n\n\nCH_P4 DEVICE\n       SIGUSR1\n\n       The ch_p4 device also catches SIGINT, SIGFPE, SIGBUS, and SIGSEGV; this\n       helps the p4 device (and MPICH) more gracefully abort a failed program.\n\n\nINTEL PARAGON (CH_NX AND NX DEVICE)\n       SIGUSR2\n\n\nSHARED MEMORY (CH_SHMEM DEVICE)\n       SIGCHLD\n\n       Note  that  if  you are using software that needs the same signals, you\n       may find that there is no way to use that software with the MPI  imple-\n       mentation.   The  signals  that cause the most trouble for applications\n       include SIGIO , SIGALRM , and SIGPIPE .  For example, using  SIGIO  and\n       SIGPIPE may prevent X11 routines from working.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_OTHER\n              - This error class is associated with an error code  that  indi-\n              cates  that  an attempt was made to call MPI_INIT a second time.\n              MPI_INIT may only be called once in a program.\n\nLOCATION\n       init.c\n\n\n\n                                   4/8/2002                        MPI_Init(3)\n\n\n\n\nmpi_init_thread.md\n\n\n!DOCTYPE html PUBLIC \n-//W3C//DTD XHTML 1.0 Transitional//EN\n \nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\n\n\nhtml xmlns=\nhttp://www.w3.org/1999/xhtml\n\n\nhead\n\n\nmeta http-equiv=\nContent-Type\n content=\ntext/html; charset=iso-8859-1\n /\n\n\ntitle\n404 Not Found\n/title\n\n\n/head\n\n\n\nbody\n\n\np\nstrong\nHTTP 404 - Not Found\n/strong\np /\n\n\nThe requested URL was not found on this server.\n\n/body\n\n\n/html\n\n\n\n\n\nMPI_Intercomm_create.md\n\n\nMPI_Intercomm_create(3)               MPI              MPI_Intercomm_create(3)\n\n\n\nNAME\n       MPI_Intercomm_create  -  Creates an intercommuncator from two intracom-\n       municators\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Intercomm_create ( MPI_Comm local_comm, int local_leader,\n                                MPI_Comm peer_comm, int remote_leader, int tag,\n                                MPI_Comm *comm_out )\n\nINPUT PARAMTERS\n       local_comm\n              - Local (intra)communicator\n       local_leader\n              - Rank in local_comm of leader (often 0)\n       peer_comm\n              - Remote communicator\n       remote_leader\n              - Rank in peer_comm of remote leader (often 0)\n       tag    - Message tag to use in constructing intercommunicator; if  mul-\n              tiple MPI_Intercomm_creates are being made, they should use dif-\n              ferent tags (more precisely, ensure that the  local  and  remote\n              leaders  are  using different tags for each MPI_intercomm_create\n              ).\n\n\nOUTPUT PARAMETER\n       comm_out\n              - Created intercommunicator\n\n\nNOTES\n       The MPI 1.1 Standard contains two mutually exclusive  comments  on  the\n       input intracommunicators.  One says that their repective groups must be\n       disjoint; the other that the leaders can be the  same  process.   After\n       some  discussion  by the MPI Forum, it has been decided that the groups\n       must be disjoint.  Note that the reason given for this in the  standard\n       is  not  the  reason  for  this choice; rather, the other operations on\n       intercommunicators (like MPI_Intercomm_merge ) do not make sense if the\n       groups are not disjoint.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nALGORITHM\n       1) Allocate a send context, an inter\n              - coll context, and an intra-coll context\n       2) Send send_context and lrank_to_grank list from local comm group\n              - if I'm the local_leader.\n       3) If I'm the local leader, then wait on the posted sends and receives\n              - to complete.  Post the receive for the remote  group  informa-\n              tion and wait for it to complete.\n       4) Broadcast information received from the remote leader.\n              - . 5) Create the inter_communicator from the information we now\n              have.\n       An inter\n              - communicator ends up with three levels of communicators.   The\n              inter-communicator  returned  to the user, a \ncollective\n inter-\n              communicator that can be used for  safe  communications  between\n              local  \n remote groups, and a collective intra-communicator that\n              can be used to allocate new contexts during the  merge  and  dup\n              operations.\n\n              For the resulting inter-communicator, comm_out\n\n\n              comm_out                       = inter-communicator\n              comm_out-\ncomm_coll            = \ncollective\n inter-communicator\n              comm_out-\ncomm_coll-\ncomm_coll = safe collective intra-communicator\n\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Intercomm_merge, MPI_Comm_free, MPI_Comm_remote_group,\n       MPI_Comm_remote_size\n\nLOCATION\n       ic_create.c\n\n\n\n                                  11/14/2001           MPI_Intercomm_create(3)\n\n\n\n\nMPI_Intercomm_merge.md\n\n\nMPI_Intercomm_merge(3)                MPI               MPI_Intercomm_merge(3)\n\n\n\nNAME\n       MPI_Intercomm_merge  -  Creates an intracommuncator from an intercommu-\n       nicator\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Intercomm_merge ( MPI_Comm comm, int high, MPI_Comm *comm_out )\n\nINPUT PARAMETERS\n       comm   - Intercommunicator\n       high   - Used to order the groups of the two intracommunicators  within\n              comm when creating the new communicator.\n\n\nOUTPUT PARAMETER\n       comm_out\n              - Created intracommunicator\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nALGORITHM\n       1) Allocate two contexts\n       2) Local and remote group leaders swap high values\n       3) Determine the high value.\n       4) Merge the two groups and make the intra-communicator\n\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Intercomm_create, MPI_Comm_free\n\nLOCATION\n       ic_merge.c\n\n\n\n                                  11/14/2001            MPI_Intercomm_merge(3)\n\n\n\n\nMPI_Iprobe.md\n\n\nMPI_Iprobe(3)                         MPI                        MPI_Iprobe(3)\n\n\n\nNAME\n       MPI_Iprobe -  Nonblocking test for a message\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Iprobe( int source, int tag, MPI_Comm comm, int *flag,\n                      MPI_Status *status )\n\nINPUT PARAMETERS\n       source - source rank, or MPI_ANY_SOURCE (integer)\n       tag    - tag value or MPI_ANY_TAG (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       flag   - (logical)\n       status - status object (Status)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       iprobe.c\n\n\n\n                                   12/7/2004                     MPI_Iprobe(3)\n\n\n\n\nMPI_Irecv.md\n\n\nMPI_Irecv(3)                          MPI                         MPI_Irecv(3)\n\n\n\nNAME\n       MPI_Irecv -  Begins a nonblocking receive\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Irecv( void *buf, int count, MPI_Datatype datatype, int source,\n                      int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of receive buffer (choice)\n       count  - number of elements in receive buffer (integer)\n       datatype\n              - datatype of each receive buffer element (handle)\n       source - rank of source (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       irecv.c\n\n\n\n                                  11/14/2001                      MPI_Irecv(3)\n\n\n\n\nMPI_Irsend.md\n\n\nMPI_Irsend(3)                         MPI                        MPI_Irsend(3)\n\n\n\nNAME\n       MPI_Irsend -  Starts a nonblocking ready send\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Irsend( void *buf, int count, MPI_Datatype datatype, int dest,\n                      int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle) Output Parameter:\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nLOCATION\n       irsend.c\n\n\n\n                                  11/14/2001                     MPI_Irsend(3)\n\n\n\n\nMPI_Isend.md\n\n\nMPI_Isend(3)                          MPI                         MPI_Isend(3)\n\n\n\nNAME\n       MPI_Isend -  Begins a nonblocking send\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Isend( void *buf, int count, MPI_Datatype datatype, int dest, int tag,\n                      MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nLOCATION\n       isend.c\n\n\n\n                                  11/14/2001                      MPI_Isend(3)\n\n\n\n\nMPI_Issend.md\n\n\nMPI_Issend(3)                         MPI                        MPI_Issend(3)\n\n\n\nNAME\n       MPI_Issend -  Starts a nonblocking synchronous send\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Issend( void *buf, int count, MPI_Datatype datatype, int dest,\n                      int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       issend.c\n\n\n\n                                  11/14/2001                     MPI_Issend(3)\n\n\n\n\nMPI_Keyval_create.md\n\n\nMPI_Keyval_create(3)                  MPI                 MPI_Keyval_create(3)\n\n\n\nNAME\n       MPI_Keyval_create -  Generates a new attribute key\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Keyval_create (\n               MPI_Copy_function *copy_fn,\n               MPI_Delete_function *delete_fn,\n               int *keyval,\n               void *extra_state )\n\nINPUT PARAMETERS\n       copy_fn\n              - Copy callback function for keyval\n\n       delete_fn\n              - Delete callback function for keyval\n\n       extra_state\n              - Extra state for callback functions\n\n\nOUTPUT PARAMETER\n       keyval - key value for future access (integer)\n\n\nNOTES\n       Key values are global (available for any and all communicators).\n\n       There  are  subtle  differences between C and Fortran that require that\n       the copy_fn be written in the same language that  MPI_Keyval_create  is\n       called  from.   This  should not be a problem for most users; only pro-\n       gramers using both Fortran and C in the same program need  to  be  sure\n       that they follow this rule.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       keyvalcreate.c\n\n\n\n                                  11/14/2001              MPI_Keyval_create(3)\n\n\n\n\nMPI_Keyval_free.md\n\n\nMPI_Keyval_free(3)                    MPI                   MPI_Keyval_free(3)\n\n\n\nNAME\n       MPI_Keyval_free -  Frees attribute key for communicator cache attribute\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Keyval_free ( int *keyval )\n\nINPUT PARAMETER\n       keyval - Frees the integer key value (integer)\n\n\nNOTE\n       Key values are global (they can be used with any and all communicators)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              keys.\n\n\nSEE ALSO\n       MPI_Keyval_create\n\nLOCATION\n       keyval_free.c\n\n\n\n                                   6/12/2002                MPI_Keyval_free(3)\n\n\n\n\nMPI_Op_create.md\n\n\nMPI_Op_create(3)                      MPI                     MPI_Op_create(3)\n\n\n\nNAME\n       MPI_Op_create -  Creates a user-defined combination function handle\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Op_create(\n               MPI_User_function *function,\n               int commute,\n               MPI_Op *op )\n\nINPUT PARAMETERS\n       function\n              - user defined function (function)\n       commute\n              - true if commutative;  false otherwise.\n\n\nOUTPUT PARAMETER\n       op     - operation (handle)\n\n\nNOTES ON THE USER FUNCTION\n       The calling list for the user function type is\n       typedef void (MPI_User_function) ( void * a,\n       void * b, int * len, MPI_Datatype * );\n\n       where  the  operation  is  b[i] = a[i] op b[i] , for i=0,...,len-1 .  A\n       pointer to the datatype given to the MPI collective computation routine\n       (i.e.,  MPI_Reduce , MPI_Allreduce , MPI_Scan , or MPI_Reduce_scatter )\n       is also passed to the user-specified routine.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The  reduction functions ( MPI_Op ) do not return an error value.  As a\n       result, if the functions detect an error, all they  can  do  is  either\n       call  MPI_Abort  or silently skip the problem.  Thus, if you change the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The  reason  for  this is the performance problems in ensuring that all\n       collective routines return the same error value.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Op_free\n\nLOCATION\n       opcreate.c\n\n\n\n                                  11/14/2001                  MPI_Op_create(3)\n\n\n\n\nMPI_Op_free.md\n\n\nMPI_Op_free(3)                        MPI                       MPI_Op_free(3)\n\n\n\nNAME\n       MPI_Op_free -  Frees a user-defined combination function handle\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Op_free( MPI_Op *op )\n\nINPUT PARAMETER\n       op     - operation (handle)\n\n\nNOTES\n       op is set to MPI_OP_NULL on exit.\n\n\nNULL HANDLES\n       The MPI 1.1 specification, in the section on opaque objects, explicitly\n\nDISALLOWS FREEING A NULL COMMUNICATOR. THE TEXT FROM THE STANDARD IS\n       A null handle argument is an erroneous IN argument in MPI calls, unless an\n       exception is explicitly stated in the text that defines the function. Such\n       exception is allowed for handles to request objects in Wait and Test calls\n       (sections Communication Completion and Multiple Completions ). Otherwise, a\n       null handle can only be passed to a function that allocates a new object and\n       returns a reference to it in the handle.\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_ARG\n              -  Invalid  argument;  the error code associated with this error\n              indicates an attempt to free an MPI permanent  operation  (e.g.,\n              MPI_SUM ).  *N/ /*N MPI_ERR_PERM_KEY\n       MPI_ERR_ARG\n              -  Invalid  argument;  the error code associated with this error\n              indicates an attempt to free or chnage an MPI  permanent  keyval\n              (e.g., MPI_TAG_UB ).  *N/ /*N MPI_ERR_UNKNOWN\n       MPI_ERR_UNKNOWN\n              -  Unknown error.  You should never see this.  If you do, report\n              it to mpi-bugs@mcs.anl.gov .\n\n\n\nSEE ALSO\n       MPI_Op_create\n\nLOCATION\n       opfree.c\n\n\n\n                                  11/14/2001                    MPI_Op_free(3)\n\n\n\n\nMPI_Pack.md\n\n\nMPI_Pack(3)                           MPI                          MPI_Pack(3)\n\n\n\nNAME\n       MPI_Pack -  Packs a datatype into contiguous memory\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Pack ( void *inbuf, int incount, MPI_Datatype datatype,\n                      void *outbuf, int outcount, int *position, MPI_Comm comm )\n\nINPUT PARAMETERS\n       inbuf  - input buffer start (choice)\n       incount\n              - number of input data items (integer)\n       datatype\n              - datatype of each input data item (handle)\n       outcount\n              - output buffer size, in bytes (integer)\n       position\n              - current position in buffer, in bytes (integer)\n       comm   - communicator for packed message (handle)\n\n\nOUTPUT PARAMETER\n       outbuf - output buffer start (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Unpack, MPI_Pack_size\n\n\nLOCATION\n       pack.c\n\n\n\n                                  11/14/2001                       MPI_Pack(3)\n\n\n\n\nMPI_Pack_size.md\n\n\nMPI_Pack_size(3)                      MPI                     MPI_Pack_size(3)\n\n\n\nNAME\n       MPI_Pack_size  -  Returns the upper bound on the amount of space needed\n       to pack a message\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Pack_size ( int incount, MPI_Datatype datatype, MPI_Comm comm,\n                          int *size )\n\nINPUT PARAMETERS\n       incount\n              - count argument to packing call (integer)\n       datatype\n              - datatype argument to packing call (handle)\n       comm   - communicator argument to packing call (handle)\n\n\nOUTPUT PARAMETER\n       size   - upper bound on size of packed message, in bytes (integer)\n\n\nNOTES\n       The MPI standard document describes this in terms of MPI_Pack , but  it\n       applies  to  both MPI_Pack and MPI_Unpack .  That is, the value size is\n       the maximum that is needed by either MPI_Pack or MPI_Unpack .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       pack_size.c\n\n\n\n                                  11/14/2001                  MPI_Pack_size(3)\n\n\n\n\nMPI_Pcontrol.md\n\n\nMPI_Pcontrol(3)                       MPI                      MPI_Pcontrol(3)\n\n\n\nNAME\n       MPI_Pcontrol -  Controls profiling\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Pcontrol( int level )\n\nINPUT PARAMETERS\n       level  - Profiling level\n\n\nNOTES\n       This  routine  provides  a common interface for profiling control.  The\n       interpretation of level and any other arguments is left to the  profil-\n       ing library.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       pcontrol.c\n\n\n\n                                  11/14/2001                   MPI_Pcontrol(3)\n\n\n\n\nMPI_Probe.md\n\n\nMPI_Probe(3)                          MPI                         MPI_Probe(3)\n\n\n\nNAME\n       MPI_Probe -  Blocking test for a message\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Probe( int source, int tag, MPI_Comm comm, MPI_Status *status )\n\nINPUT PARAMETERS\n       source - source rank, or MPI_ANY_SOURCE (integer)\n       tag    - tag value or MPI_ANY_TAG (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       status - status object (Status)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       probe.c\n\n\n\n                                   12/7/2004                      MPI_Probe(3)\n\n\n\n\nMPI_Recv_init.md\n\n\nMPI_Recv_init(3)                      MPI                     MPI_Recv_init(3)\n\n\n\nNAME\n       MPI_Recv_init -  Builds a handle for a receive\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Recv_init( void *buf, int count, MPI_Datatype datatype, int source,\n                         int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of receive buffer (choice)\n       count  - number of elements received (integer)\n       datatype\n              - type of each element (handle)\n       source - rank of source or MPI_ANY_SOURCE (integer)\n       tag    - message tag or MPI_ANY_TAG (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Start, MPI_Request_free\n\nLOCATION\n       create_recv.c\n\n\n\n                                  11/14/2001                  MPI_Recv_init(3)\n\n\n\n\nMPI_Recv.md\n\n\nMPI_Recv(3)                           MPI                          MPI_Recv(3)\n\n\n\nNAME\n       MPI_Recv -  Basic receive\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Recv( void *buf, int count, MPI_Datatype datatype, int source,\n                     int tag, MPI_Comm comm, MPI_Status *status )\n\nOUTPUT PARAMETERS\n       buf    - initial address of receive buffer (choice)\n       status - status object (Status)\n\n\nINPUT PARAMETERS\n       count  - maximum number of elements in receive buffer (integer)\n       datatype\n              - datatype of each receive buffer element (handle)\n       source - rank of source (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES\n       The  count  argument  indicates  the  maximum  length of a message; the\n       actual number can be determined with MPI_Get_count .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       recv.c\n\n\n\n                                   2/24/2004                       MPI_Recv(3)\n\n\n\n\nMPI_Reduce.md\n\n\nMPI_Reduce(3)                         MPI                        MPI_Reduce(3)\n\n\n\nNAME\n       MPI_Reduce -  Reduces values on all processes to a single value\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Reduce ( void *sendbuf, void *recvbuf, int count,\n                       MPI_Datatype datatype, MPI_Op op, int root, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - data type of elements of send buffer (handle)\n       op     - reduce operation (handle)\n       root   - rank of root process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice, significant only at root )\n\n\nALGORITHM\n       This implementation currently uses a simple tree algorithm.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The reduction functions ( MPI_Op ) do not return an error value.  As  a\n       result,  if  the  functions  detect an error, all they can do is either\n       call MPI_Abort or silently skip the problem.  Thus, if you  change  the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The reason for this is the performance problems in  ensuring  that  all\n       collective routines return the same error value.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_BUFFER\n              - This error class is associcated with an error code that  indi-\n              cates  that  two  buffer  arguments  are  aliased ; that is, the\n              describe overlapping storage (often  the  exact  same  storage).\n              This  is prohibited in MPI (because it is prohibited by the For-\n              tran standard, and rather than have a separate case  for  C  and\n              Fortran, the MPI Forum adopted the more restrictive requirements\n              of Fortran).\n\nLOCATION\n       reduce.c\n\n\n\n                                   2/19/2002                     MPI_Reduce(3)\n\n\n\n\nMPI_Reduce_scatter.md\n\n\nMPI_Reduce_scatter(3)                 MPI                MPI_Reduce_scatter(3)\n\n\n\nNAME\n       MPI_Reduce_scatter -  Combines values and scatters the results\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Reduce_scatter ( void *sendbuf, void *recvbuf, int *recvcnts,\n                              MPI_Datatype datatype, MPI_Op op, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       recvcounts\n              - integer array specifying the number of elements in result dis-\n              tributed to each process.  Array must be identical on all  call-\n              ing processes.\n       datatype\n              - data type of elements of input buffer (handle)\n       op     - operation (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - starting address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The reduction functions ( MPI_Op ) do not return an error value.  As  a\n       result,  if  the  functions  detect an error, all they can do is either\n       call MPI_Abort or silently skip the problem.  Thus, if you  change  the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The reason for this is the performance problems in  ensuring  that  all\n       collective routines return the same error value.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_OP\n              - Invalid operation.  MPI operations (objects of type  MPI_Op  )\n              must either be one of the predefined operations (e.g., MPI_SUM )\n              or created with MPI_Op_create .\n\n       MPI_ERR_BUFFER\n              - This error class is associcated with an error code that  indi-\n              cates  that  two  buffer  arguments  are  aliased ; that is, the\n              describe overlapping storage (often  the  exact  same  storage).\n              This  is prohibited in MPI (because it is prohibited by the For-\n              tran standard, and rather than have a separate case  for  C  and\n              Fortran, the MPI Forum adopted the more restrictive requirements\n              of Fortran).\n\nLOCATION\n       red_scat.c\n\n\n\n                                  11/14/2001             MPI_Reduce_scatter(3)\n\n\n\n\nMPI_Request_free.md\n\n\nMPI_Request_free(3)                   MPI                  MPI_Request_free(3)\n\n\n\nNAME\n       MPI_Request_free -  Frees a communication request object\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Request_free( MPI_Request *request )\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES\n       This  routine is normally used to free persistent requests created with\n       either MPI_Recv_init or MPI_Send_init and friends.  However, it can  be\n       used to free a request created with MPI_Irecv or MPI_Isend and friends;\n       in that case the use can not use the test/wait routines on the request.\n\n       It  is  permitted  to free an active request.  However, once freed, you\n       can not use the request in a wait or test routine (e.g., MPI_Wait ).\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       also: MPI_Isend, MPI_Irecv, MPI_Issend, MPI_Ibsend, MPI_Irsend,\n       MPI_Recv_init, MPI_Send_init, MPI_Ssend_init, MPI_Rsend_init, MPI_Wait,\n       MPI_Test, MPI_Waitall, MPI_Waitany, MPI_Waitsome, MPI_Testall, MPI_Tes-\n       tany, MPI_Testsome\n\nLOCATION\n       commreq_free.c\n\n\n\n                                  11/14/2001               MPI_Request_free(3)\n\n\n\n\nMPI_Rsend_init.md\n\n\nMPI_Rsend_init(3)                     MPI                    MPI_Rsend_init(3)\n\n\n\nNAME\n       MPI_Rsend_init -  Builds a handle for a ready send\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Rsend_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                          int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Start, MPI_Request_free, MPI_Send_init\n\nLOCATION\n       rsend_init.c\n\n\n\n                                  11/14/2001                 MPI_Rsend_init(3)\n\n\n\n\nMPI_Rsend.md\n\n\nMPI_Rsend(3)                          MPI                         MPI_Rsend(3)\n\n\n\nNAME\n       MPI_Rsend -  Basic ready send\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Rsend( void *buf, int count, MPI_Datatype datatype, int dest,\n                      int tag, MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       rsend.c\n\n\n\n                                  11/14/2001                      MPI_Rsend(3)\n\n\n\n\nMPI_Scan.md\n\n\nMPI_Scan(3)                           MPI                          MPI_Scan(3)\n\n\n\nNAME\n       MPI_Scan -  Computes the scan (partial reductions) of data on a collec-\n       tion of processes\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Scan ( void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype,\n                      MPI_Op op, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       count  - number of elements in input buffer (integer)\n       datatype\n              - data type of elements of input buffer (handle)\n       op     - operation (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - starting address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The  reduction functions ( MPI_Op ) do not return an error value.  As a\n       result, if the functions detect an error, all they  can  do  is  either\n       call  MPI_Abort  or silently skip the problem.  Thus, if you change the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The  reason  for  this is the performance problems in ensuring that all\n       collective routines return the same error value.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n       MPI_ERR_BUFFER\n              -  This error class is associcated with an error code that indi-\n              cates that two buffer arguments  are  aliased  ;  that  is,  the\n              describe  overlapping  storage  (often  the exact same storage).\n              This is prohibited in MPI (because it is prohibited by the  For-\n              tran  standard,  and  rather than have a separate case for C and\n              Fortran, the MPI Forum adopted the more restrictive requirements\n              of Fortran).\n\nLOCATION\n       scan.c\n\n\n\n                                  11/14/2001                       MPI_Scan(3)\n\n\n\n\nMPI_Scatter.md\n\n\nMPI_Scatter(3)                        MPI                       MPI_Scatter(3)\n\n\n\nNAME\n       MPI_Scatter -  Sends data from one task to all other tasks in a group\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Scatter (\n               void *sendbuf,\n               int sendcnt,\n               MPI_Datatype sendtype,\n               void *recvbuf,\n               int recvcnt,\n               MPI_Datatype recvtype,\n               int root,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - address of send buffer (choice, significant only at root )\n       sendcount\n              -  number of elements sent to each process (integer, significant\n              only at root )\n       sendtype\n              - data type of send buffer elements (significant only at root  )\n              (handle)\n       recvcount\n              - number of elements in receive buffer (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       root   - rank of sending process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\nLOCATION\n       scatter.c\n\n\n\n                                   4/5/2004                     MPI_Scatter(3)\n\n\n\n\nMPI_Scatterv.md\n\n\nMPI_Scatterv(3)                       MPI                      MPI_Scatterv(3)\n\n\n\nNAME\n       MPI_Scatterv -  Scatters a buffer in parts to all tasks in a group\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Scatterv (\n               void *sendbuf,\n               int *sendcnts,\n               int *displs,\n               MPI_Datatype sendtype,\n               void *recvbuf,\n               int recvcnt,\n               MPI_Datatype recvtype,\n               int root,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - address of send buffer (choice, significant only at root )\n       sendcounts\n              -  integer array (of length group size) specifying the number of\n              elements to send to each processor\n       displs - integer array (of length group size). Entry  i  specifies  the\n              displacement (relative to sendbuf  from which to take the outgo-\n              ing data to process i\n\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              - number of elements in receive buffer (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       root   - rank of sending process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       scatterv.c\n\n\n\n                                   2/21/2002                   MPI_Scatterv(3)\n\n\n\n\nMPI_Send_init.md\n\n\nMPI_Send_init(3)                      MPI                     MPI_Send_init(3)\n\n\n\nNAME\n       MPI_Send_init -  Builds a handle for a standard send\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Send_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                         int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle) Output Parameter:\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Start, MPI_Startall, MPI_Request_free\n\nLOCATION\n       create_send.c\n\n\n\n                                  11/14/2001                  MPI_Send_init(3)\n\n\n\n\nMPI_Send.md\n\n\nMPI_Send(3)                           MPI                          MPI_Send(3)\n\n\n\nNAME\n       MPI_Send -  Performs a basic send\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Send( void *buf, int count, MPI_Datatype datatype, int dest,\n                     int tag, MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES\n       This routine may block until the message is received.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Isend, MPI_Bsend\n\nLOCATION\n       send.c\n\n\n\n                                  11/14/2001                       MPI_Send(3)\n\n\n\n\nMPI_Sendrecv.md\n\n\nMPI_Sendrecv(3)                       MPI                      MPI_Sendrecv(3)\n\n\n\nNAME\n       MPI_Sendrecv -  Sends and receives a message\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Sendrecv( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                        int dest, int sendtag,\n                         void *recvbuf, int recvcount, MPI_Datatype recvtype,\n                        int source, int recvtag, MPI_Comm comm, MPI_Status *status )\n\nINPUT PARAMETERS\n       sendbuf\n              - initial address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - type of elements in send buffer (handle)\n       dest   - rank of destination (integer)\n       sendtag\n              - send tag (integer)\n       recvcount\n              - number of elements in receive buffer (integer)\n       recvtype\n              - type of elements in receive buffer (handle)\n       source - rank of source (integer)\n       recvtag\n              - receive tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETERS\n       recvbuf\n              - initial address of receive buffer (choice)\n       status - status object (Status).  This refers to the receive operation.\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       sendrecv.c\n\n\n\n                                  11/14/2001                   MPI_Sendrecv(3)\n\n\n\n\nMPI_Sendrecv_replace.md\n\n\nMPI_Sendrecv_replace(3)               MPI              MPI_Sendrecv_replace(3)\n\n\n\nNAME\n       MPI_Sendrecv_replace -  Sends and receives using a single buffer\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Sendrecv_replace( void *buf, int count, MPI_Datatype datatype,\n                               int dest, int sendtag, int source, int recvtag,\n                               MPI_Comm comm, MPI_Status *status )\n\nINPUT PARAMETERS\n       count  - number of elements in send and receive buffer (integer)\n       datatype\n              - type of elements in send and receive buffer (handle)\n       dest   - rank of destination (integer)\n       sendtag\n              - send message tag (integer)\n       source - rank of source (integer)\n       recvtag\n              - receive message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETERS\n       buf    - initial address of send and receive buffer (choice)\n       status - status object (Status)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TRUNCATE\n              - Message truncated on receive.  The buffer size  specified  was\n              too small for the received message.  This is a recoverable error\n              in the MPICH implementation.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nLOCATION\n       sendrecv_rep.c\n\n\n\n                                  11/14/2001           MPI_Sendrecv_replace(3)\n\n\n\n\nMPI_Ssend_init.md\n\n\nMPI_Ssend_init(3)                     MPI                    MPI_Ssend_init(3)\n\n\n\nNAME\n       MPI_Ssend_init -  Builds a handle for a synchronous send\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Ssend_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                          int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       ssend_init.c\n\n\n\n                                  11/14/2001                 MPI_Ssend_init(3)\n\n\n\n\nMPI_Ssend.md\n\n\nMPI_Ssend(3)                          MPI                         MPI_Ssend(3)\n\n\n\nNAME\n       MPI_Ssend -  Basic synchronous send\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Ssend( void *buf, int count, MPI_Datatype datatype,\n                      int dest, int tag, MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       ssend.c\n\n\n\n                                  11/14/2001                      MPI_Ssend(3)\n\n\n\n\nMPI_Startall.md\n\n\nMPI_Startall(3)                       MPI                      MPI_Startall(3)\n\n\n\nNAME\n       MPI_Startall -  Starts a collection of requests\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Startall( int count, MPI_Request array_of_requests[] )\n\nINPUT PARAMETERS\n       count  - list length (integer)\n       array_of_requests\n              - array of requests (array of handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       startall.c\n\n\n\n                                  11/14/2001                   MPI_Startall(3)\n\n\n\n\nMPI_Start.md\n\n\nMPI_Start(3)                          MPI                         MPI_Start(3)\n\n\n\nNAME\n       MPI_Start -  Initiates a communication with a persistent request handle\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Start(\n               MPI_Request *request)\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n\n\nLOCATION\n       start.c\n\n\n\n                                  11/14/2001                      MPI_Start(3)\n\n\n\n\nMPI_Testall.md\n\n\nMPI_Testall(3)                        MPI                       MPI_Testall(3)\n\n\n\nNAME\n       MPI_Testall  -   Tests  for  the completion of all previously initiated\n       communications\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Testall(\n               int count,\n               MPI_Request array_of_requests[],\n               int *flag,\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       count  - lists length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       flag   - (logical)\n       array_of_statuses\n              - array of status objects (array of Status).   May  be  MPI_STA-\n              TUSES_IGNORE .\n\n\n\nNOTES\n       flag  is  true only if all requests have completed.  Otherwise, flag is\n       false and neither the array_of_requests nor  the  array_of_statuses  is\n       modified.\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_IN_STATUS\n              -  The  actual  error value is in the MPI_Status argument.  This\n              error  class  is  returned  only  from  the  multiple-completion\n              routines  ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Wait-\n              all , MPI_Waitany , and MPI_Waitsome ).  The field MPI_ERROR  in\n              the  status argument contains the error value or MPI_SUCCESS (no\n              error and complete) or  MPI_ERR_PENDING  to  indicate  that  the\n              request  has  not  completed.  The MPI Standard does not specify\n              what the result of the multiple completion routines is  when  an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait for all requests to either fail or  complete,  or  does  it\n              return  immediately  (with  the  MPI  definition of immediately,\n              which means independent of  actions  of  other  MPI  processes)?\n              MPICH  has  chosen  to  make  the return immediate (alternately,\n              local in MPI terms), and to use the error class  MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.  In most cases, only one request with an error  will  be\n              detected  in  each  call  to  an MPI routine that tests multiple\n              requests.  The requests that have not been processed (because an\n              error  occured in one of the requests) will have their MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n\n\nLOCATION\n       testall.c\n\n\n\n                                   2/19/2003                    MPI_Testall(3)\n\n\n\n\nMPI_Testany.md\n\n\nMPI_Testany(3)                        MPI                       MPI_Testany(3)\n\n\n\nNAME\n       MPI_Testany  -  Tests for completion of any previdously initiated  com-\n       munication\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Testany(\n               int count,\n               MPI_Request array_of_requests[],\n               int *index, int *flag,\n               MPI_Status *status )\n\nINPUT PARAMETERS\n       count  - list length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       index  - index of operation that completed, or  MPI_UNDEFINED  if  none\n              completed (integer)\n       flag   - true if one of the operations is complete (logical)\n       status - status object (Status).  May be MPI_STATUS_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n\nLOCATION\n       testany.c\n\n\n\n                                   1/9/2003                     MPI_Testany(3)\n\n\n\n\nMPI_Test_cancelled.md\n\n\nMPI_Test_cancelled(3)                 MPI                MPI_Test_cancelled(3)\n\n\n\nNAME\n       MPI_Test_cancelled -  Tests to see if a request was cancelled\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Test_cancelled(\n               MPI_Status *status,\n               int        *flag)\n\nINPUT PARAMETER\n       status - status object (Status)\n\n\nOUTPUT PARAMETER\n       flag   - (logical)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       testcancel.c\n\n\n\n                                  11/14/2001             MPI_Test_cancelled(3)\n\n\n\n\nMPI_Test.md\n\n\nMPI_Test(3)                           MPI                          MPI_Test(3)\n\n\n\nNAME\n       MPI_Test -  Tests for the completion of a send or receive\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Test (\n               MPI_Request  *request,\n               int          *flag,\n               MPI_Status   *status)\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nOUTPUT PARAMETER\n       flag   - true if operation completed (logical)\n       status - status object (Status).  May be MPI_STATUS_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              -  Invalid  MPI_Request  .   Either  null  or,  in the case of a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       test.c\n\n\n\n                                   1/9/2003                        MPI_Test(3)\n\n\n\n\nMPI_Testsome.md\n\n\nMPI_Testsome(3)                       MPI                      MPI_Testsome(3)\n\n\n\nNAME\n       MPI_Testsome -  Tests for some given communications to complete\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Testsome(\n               int incount,\n               MPI_Request array_of_requests[],\n               int *outcount,\n               int array_of_indices[],\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       incount\n              - length of array_of_requests (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       outcount\n              - number of completed requests (integer)\n       array_of_indices\n              -  array of indices of operations that completed (array of inte-\n              gers)\n       array_of_statuses\n              - array of status objects for operations that  completed  (array\n              of Status).  May be MPI_STATUSES_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_IN_STATUS\n              -  The  actual  error value is in the MPI_Status argument.  This\n              error  class  is  returned  only  from  the  multiple-completion\n              routines  ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Wait-\n              all , MPI_Waitany , and MPI_Waitsome ).  The field MPI_ERROR  in\n              the  status argument contains the error value or MPI_SUCCESS (no\n              error and complete) or  MPI_ERR_PENDING  to  indicate  that  the\n              request  has  not  completed.  The MPI Standard does not specify\n              what the result of the multiple completion routines is  when  an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait for all requests to either fail or  complete,  or  does  it\n              return  immediately  (with  the  MPI  definition of immediately,\n              which means independent of  actions  of  other  MPI  processes)?\n              MPICH  has  chosen  to  make  the return immediate (alternately,\n              local in MPI terms), and to use the error class  MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.  In most cases, only one request with an error  will  be\n              detected  in  each  call  to  an MPI routine that tests multiple\n              requests.  The requests that have not been processed (because an\n              error  occured in one of the requests) will have their MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n\n\nLOCATION\n       testsome.c\n\n\n\n                                   1/9/2003                    MPI_Testsome(3)\n\n\n\n\nMPI_Topo_test.md\n\n\nMPI_Topo_test(3)                      MPI                     MPI_Topo_test(3)\n\n\n\nNAME\n       MPI_Topo_test  -   Determines  the type of topology (if any) associated\n       with a  communicator\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Topo_test ( MPI_Comm comm, int *top_type )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       top_type\n              - topology type of communicator comm (choice).\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Graph_create, MPI_Cart_create\n\nLOCATION\n       topo_test.c\n\n\n\n                                  11/14/2001                  MPI_Topo_test(3)\n\n\n\n\nMPI_Type_commit.md\n\n\nMPI_Type_commit(3)                    MPI                   MPI_Type_commit(3)\n\n\n\nNAME\n       MPI_Type_commit -  Commits the datatype\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Type_commit ( MPI_Datatype *datatype )\n\nINPUT PARAMETER\n       datatype\n              - datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       type_commit.c\n\n\n\n                                  11/14/2001                MPI_Type_commit(3)\n\n\n\n\nMPI_Type_contiguous.md\n\n\nMPI_Type_contiguous(3)                MPI               MPI_Type_contiguous(3)\n\n\n\nNAME\n       MPI_Type_contiguous -  Creates a contiguous datatype\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Type_contiguous(\n               int count,\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype)\n\nINPUT PARAMETERS\n       count  - replication count (nonnegative integer)\n       oldtype\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_contig.c\n\n\n\n                                  11/14/2001            MPI_Type_contiguous(3)\n\n\n\n\nMPI_Type_extent.md\n\n\nMPI_Type_extent(3)                    MPI                   MPI_Type_extent(3)\n\n\n\nNAME\n       MPI_Type_extent -  Returns the extent of a datatype\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Type_extent( MPI_Datatype datatype, MPI_Aint *extent )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       extent - datatype extent (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       type_extent.c\n\n\n\n                                  11/14/2001                MPI_Type_extent(3)\n\n\n\n\nMPI_Type_free.md\n\n\nMPI_Type_free(3)                      MPI                     MPI_Type_free(3)\n\n\n\nNAME\n       MPI_Type_free -  Frees the datatype\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Type_free ( MPI_Datatype *datatype )\n\nINPUT PARAMETER\n       datatype\n              - datatype that is freed (handle)\n\n\nPREDEFINED TYPES\n       The MPI standard states that (in Opaque Objects)\n       MPI provides certain predefined opaque objects and predefined, static handles\n       to these objects. Such objects may not be destroyed.\n\n\n       Thus,  it  is an error to free a predefined datatype.  The same section\n       makes it clear that it is an error to free a null datatype.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_free.c\n\n\n\n                                  11/14/2001                  MPI_Type_free(3)\n\n\n\n\nMPI_Type_hindexed.md\n\n\nMPI_Type_hindexed(3)                  MPI                 MPI_Type_hindexed(3)\n\n\n\nNAME\n       MPI_Type_hindexed -  Creates an indexed datatype with offsets in bytes\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Type_hindexed(\n               int count,\n               int blocklens[],\n               MPI_Aint indices[],\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  -  number  of  blocks  --  also number of entries in indices and\n              blocklens\n       blocklens\n              - number of elements in each block (array of  nonnegative  inte-\n              gers)\n       indices\n              - byte displacement of each block (array of MPI_Aint)\n       old_type\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       Also see the discussion for MPI_Type_indexed about the indices in  For-\n       tran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_hind.c\n\n\n\n                                   4/7/2003               MPI_Type_hindexed(3)\n\n\n\n\nMPI_Type_hvector.md\n\n\nMPI_Type_hvector(3)                   MPI                  MPI_Type_hvector(3)\n\n\n\nNAME\n       MPI_Type_hvector  -  Creates a vector (strided) datatype with offset in\n       bytes\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Type_hvector(\n               int count,\n               int blocklen,\n               MPI_Aint stride,\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  - number of blocks (nonnegative integer)\n       blocklength\n              - number of elements in each block (nonnegative integer)\n       stride - number of bytes between start of each block (integer)\n       old_type\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_hvec.c\n\n\n\n                                  11/14/2001               MPI_Type_hvector(3)\n\n\n\n\nMPI_Type_indexed.md\n\n\nMPI_Type_indexed(3)                   MPI                  MPI_Type_indexed(3)\n\n\n\nNAME\n       MPI_Type_indexed -  Creates an indexed datatype\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Type_indexed(\n               int count,\n               int blocklens[],\n               int indices[],\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  -  number  of  blocks  --  also number of entries in indices and\n              blocklens\n       blocklens\n              - number of elements in each block (array of  nonnegative  inte-\n              gers)\n       indices\n              -  displacement of each block in multiples of old_type (array of\n              integers)\n       old_type\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       The  indices are displacements, and are based on a zero origin.  A com-\n       mon error is to do something like to following\n       integer a(100)\n       integer blens(10), indices(10)\n       do i=1,10\n       blens(i)   = 1\n       10       indices(i) = 1 + (i-1)*10\n       call MPI_TYPE_INDEXED(10,blens,indices,MPI_INTEGER,newtype,ierr)\n       call MPI_TYPE_COMMIT(newtype,ierr)\n       call MPI_SEND(a,1,newtype,...)\n\n       expecting this to send a(1),a(11),...  because the indices have  values\n       1,11,...   .  Because these are displacements from the beginning of a ,\n       it actually sends a(1+1),a(1+11),...  .\n\n\n       If you wish to consider the displacements as  indices  into  a  Fortran\n       array, consider declaring the Fortran array with a zero origin\n       integer a(0:99)\n\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_ind.c\n\n\n\n                                  11/14/2001               MPI_Type_indexed(3)\n\n\n\n\nMPI_Type_lb.md\n\n\nMPI_Type_lb(3)                        MPI                       MPI_Type_lb(3)\n\n\n\nNAME\n       MPI_Type_lb -  Returns the lower-bound of a datatype\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Type_lb ( MPI_Datatype datatype, MPI_Aint *displacement )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       displacement\n              - displacement of lower bound from origin, in bytes (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_lb.c\n\n\n\n                                  11/14/2001                    MPI_Type_lb(3)\n\n\n\n\nMPI_Type_size.md\n\n\nMPI_Type_size(3)                      MPI                     MPI_Type_size(3)\n\n\n\nNAME\n       MPI_Type_size  -  Return the number of bytes occupied by entries in the\n       datatype\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Type_size ( MPI_Datatype datatype, int *size )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       size   - datatype size (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_size.c\n\n\n\n                                  11/14/2001                  MPI_Type_size(3)\n\n\n\n\nMPI_Type_struct.md\n\n\nMPI_Type_struct(3)                    MPI                   MPI_Type_struct(3)\n\n\n\nNAME\n       MPI_Type_struct -  Creates a struct datatype\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Type_struct(\n               int count,\n               int blocklens[],\n               MPI_Aint indices[],\n               MPI_Datatype old_types[],\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  - number of blocks (integer) -- also number of entries in arrays\n              array_of_types  ,  array_of_displacements   and  array_of_block-\n              lengths\n       blocklens\n              - number of elements in each block (array)\n       indices\n              - byte displacement of each block (array)\n       old_types\n              -  type  of elements in each block (array of handles to datatype\n              objects)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES\n       If an upperbound is set explicitly by using the MPI datatype  MPI_UB  ,\n       the corresponding index must be positive.\n\n       The  MPI  standard  originally  made vague statements about padding and\n       alignment; this was intended to allow the simple definition  of  struc-\n       tures that could be sent with a count greater than one.  For example,\n       struct { int a; char b; } foo;\n\n       may  have  sizeof(foo)  \n  sizeof(int)  +  sizeof(char)  ; for example,\n       sizeof(foo) == 2*sizeof(int) .  The initial version of the MPI standard\n       defined  the  extent  of  a datatype as including an epsilon that would\n       have allowed an implementation to make the extent an MPI  datatype  for\n       this structure equal to 2*sizeof(int) .\n\n       However, since different systems might define different paddings, there\n       was much discussion by the MPI Forum about what was the  correct  value\n       of  epsilon,  and  one  suggestion was to define epsilon as zero.  This\n       would have been the best thing to do in MPI 1.0, particularly since the\n       MPI_UB  type  allows  the  user to easily set the end of the structure.\n       Unfortunately, this change did not make it  into  the  final  document.\n       Currently,  this  routine does not add any padding, since the amount of\n       padding needed is determined by the compiler that the user is using  to\n       build  their  code, not the compiler used to construct the MPI library.\n       A later version of MPICH  may  provide  for  some  natural  choices  of\n       padding  (e.g.,  multiple of the size of the largest basic member), but\n       users are advised to never depend on this, even with vendor MPI  imple-\n       mentations.   Instead,  if  you define a structure datatype and wish to\n       send or receive multiple items, you should explicitly include an MPI_UB\n       entry  as the last member of the structure.  For example, the following\n       code can be used for the structure foo\n       blen[0] = 1; indices[0] = 0; oldtypes[0] = MPI_INT;\n       blen[1] = 1; indices[1] = \nfoo.b - \nfoo; oldtypes[1] = MPI_CHAR;\n       blen[2] = 1; indices[2] = sizeof(foo); oldtypes[2] = MPI_UB;\n       MPI_Type_struct( 3, blen, indices, oldtypes, \nnewtype );\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_struct.c\n\n\n\n                                   7/12/2002                MPI_Type_struct(3)\n\n\n\n\nMPI_Type_ub.md\n\n\nMPI_Type_ub(3)                        MPI                       MPI_Type_ub(3)\n\n\n\nNAME\n       MPI_Type_ub -  Returns the upper bound of a datatype\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Type_ub ( MPI_Datatype datatype, MPI_Aint *displacement )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       displacement\n              - displacement of upper bound from origin, in bytes (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_ub.c\n\n\n\n                                  11/14/2001                    MPI_Type_ub(3)\n\n\n\n\nMPI_Type_vector.md\n\n\nMPI_Type_vector(3)                    MPI                   MPI_Type_vector(3)\n\n\n\nNAME\n       MPI_Type_vector -  Creates a vector (strided) datatype\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Type_vector(\n               int count,\n               int blocklen,\n               int stride,\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  - number of blocks (nonnegative integer)\n       blocklength\n              - number of elements in each block (nonnegative integer)\n       stride - number of elements between start of each block (integer)\n       oldtype\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       type_vec.c\n\n\n\n                                  11/14/2001                MPI_Type_vector(3)\n\n\n\n\nMPI_Unpack.md\n\n\nMPI_Unpack(3)                         MPI                        MPI_Unpack(3)\n\n\n\nNAME\n       MPI_Unpack -  Unpack a datatype into contiguous memory\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Unpack ( void *inbuf, int insize, int *position,\n                       void *outbuf, int outcount, MPI_Datatype datatype,\n                       MPI_Comm comm )\n\nINPUT PARAMETERS\n       inbuf  - input buffer start (choice)\n       insize - size of input buffer, in bytes (integer)\n       position\n              - current position in bytes (integer)\n       outcount\n              - number of items to be unpacked (integer)\n       datatype\n              - datatype of each output data item (handle)\n       comm   - communicator for packed message (handle)\n\n\nOUTPUT PARAMETER\n       outbuf - output buffer start (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Pack, MPI_Pack_size\n\nLOCATION\n       unpack.c\n\n\n\n                                  11/14/2001                     MPI_Unpack(3)\n\n\n\n\nMPI_Waitall.md\n\n\nMPI_Waitall(3)                        MPI                       MPI_Waitall(3)\n\n\n\nNAME\n       MPI_Waitall -  Waits for all given communications to complete\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Waitall(\n               int count,\n               MPI_Request array_of_requests[],\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       count  - lists length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETER\n       array_of_statuses\n              -  array  of  status objects (array of Status).  May be MPI_STA-\n              TUSES_IGNORE\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For send operations, the only use of status is  for  MPI_Test_cancelled\n       or  in  the  case  that  there is an error, in which case the MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_IN_STATUS\n              - The actual error value is in the  MPI_Status  argument.   This\n              error  class  is returned only from the multiple-completion rou-\n              tines ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Waitall ,\n              MPI_Waitany  ,  and  MPI_Waitsome ).  The field MPI_ERROR in the\n              status argument contains the  error  value  or  MPI_SUCCESS  (no\n              error  and  complete)  or  MPI_ERR_PENDING  to indicate that the\n              request has not completed.  The MPI Standard  does  not  specify\n              what  the  result of the multiple completion routines is when an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait  for  all  requests  to either fail or complete, or does it\n              return immediately (with  the  MPI  definition  of  immediately,\n              which  means  independent  of  actions  of other MPI processes)?\n              MPICH has chosen to  make  the  return  immediate  (alternately,\n              local  in MPI terms), and to use the error class MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.   In  most cases, only one request with an error will be\n              detected in each call to an  MPI  routine  that  tests  multiple\n              requests.  The requests that have not been processed (because an\n              error occured in one of the requests) will have their  MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n       MPI_ERR_PENDING\n              - Pending request (not an error).  See MPI_ERR_IN_STATUS .\n\n              This  value indicates that the request is not complete nor has a\n              encountered a detected error.\n\nLOCATION\n       waitall.c\n\n\n\n                                   2/24/2004                    MPI_Waitall(3)\n\n\n\n\nMPI_Waitany.md\n\n\nMPI_Waitany(3)                        MPI                       MPI_Waitany(3)\n\n\n\nNAME\n       MPI_Waitany -  Waits for any specified send or receive to complete\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Waitany(\n               int count,\n               MPI_Request array_of_requests[],\n               int *index,\n               MPI_Status *status )\n\nINPUT PARAMETERS\n       count  - list length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       index  -  index  of  handle for operation that completed (integer).  In\n              the range 0 to count-1 .  In Fortran, the range is 1 to count  .\n\n       status - status object (Status).  May be MPI_STATUS_IGNORE .\n\n\n\nNOTES\n       If all of the requests are MPI_REQUEST_NULL , then index is returned as\n       MPI_UNDEFINED , and status is returned as an empty status.\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For send operations, the only use of status is  for  MPI_Test_cancelled\n       or  in  the  case  that  there is an error, in which case the MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       waitany.c\n\n\n\n                                   1/9/2003                     MPI_Waitany(3)\n\n\n\n\nMPI_Wait.md\n\n\nMPI_Wait(3)                           MPI                          MPI_Wait(3)\n\n\n\nNAME\n       MPI_Wait -  Waits for an MPI send or receive to complete\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Wait (\n               MPI_Request  *request,\n               MPI_Status   *status)\n\nINPUT PARAMETER\n       request\n              - request (handle)\n\n\nOUTPUT PARAMETER\n       status - status object (Status) .  May be MPI_STATUS_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              -  Invalid  MPI_Request  .   Either  null  or,  in the case of a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       wait.c\n\n\n\n                                   1/9/2003                        MPI_Wait(3)\n\n\n\n\nMPI_Waitsome.md\n\n\nMPI_Waitsome(3)                       MPI                      MPI_Waitsome(3)\n\n\n\nNAME\n       MPI_Waitsome -  Waits for some given communications to complete\n\nSYNOPSIS\n       #include \nmpi.h\n\n       int MPI_Waitsome(\n               int incount,\n               MPI_Request array_of_requests[],\n               int *outcount,\n               int array_of_indices[],\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       incount\n              - length of array_of_requests (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       outcount\n              - number of completed requests (integer)\n       array_of_indices\n              -  array of indices of operations that completed (array of inte-\n              gers)\n       array_of_statuses\n              - array of status objects for operations that  completed  (array\n              of Status).  May be MPI_STATUSES_IGNORE .\n\n\n\nNOTES\n       The  array  of  indicies are in the range 0 to incount - 1 for C and in\n       the range 1 to incount for Fortran.\n\n       Null requests are ignored; if all requests are null, then  the  routine\n       returns with outcount set to MPI_UNDEFINED .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              -  Invalid  MPI_Request  .   Either  null  or,  in the case of a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_IN_STATUS\n              -  The  actual  error value is in the MPI_Status argument.  This\n              error class is returned only from the  multiple-completion  rou-\n              tines ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Waitall ,\n              MPI_Waitany , and MPI_Waitsome ).  The field  MPI_ERROR  in  the\n              status  argument  contains  the  error  value or MPI_SUCCESS (no\n              error and complete) or  MPI_ERR_PENDING  to  indicate  that  the\n              request  has  not  completed.  The MPI Standard does not specify\n              what the result of the multiple completion routines is  when  an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait for all requests to either fail or  complete,  or  does  it\n              return  immediately  (with  the  MPI  definition of immediately,\n              which means independent of  actions  of  other  MPI  processes)?\n              MPICH  has  chosen  to  make  the return immediate (alternately,\n              local in MPI terms), and to use the error class  MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.  In most cases, only one request with an error  will  be\n              detected  in  each  call  to  an MPI routine that tests multiple\n              requests.  The requests that have not been processed (because an\n              error  occured in one of the requests) will have their MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n\nLOCATION\n       waitsome.c\n\n\n\n                                   1/9/2003                    MPI_Waitsome(3)\n\n\n\n\nMPI_Wtick.md\n\n\nMPI_Wtick(3)                          MPI                         MPI_Wtick(3)\n\n\n\nNAME\n       MPI_Wtick -  Returns the resolution of MPI_Wtime\n\nSYNOPSIS\n       #include \nmpi.h\n\n       double MPI_Wtick()\n\nRETURN VALUE\n       Time in seconds of the resolution of MPI_Wtime .\n\n\nNOTES FOR FORTRAN\n       This  is  a  function, declared as DOUBLE PRECISION MPI_WTICK() in For-\n       tran.\n\n\nLOCATION\n       wtick.c\n\n\n\n                                   8/20/2004                      MPI_Wtick(3)\n\n\n\n\nMPI_Wtime.md\n\n\nMPI_Wtime(3)                          MPI                         MPI_Wtime(3)\n\n\n\nNAME\n       MPI_Wtime -  Returns an elapsed time on the calling processor\n\nSYNOPSIS\n       #include \nmpi.h\n\n       double MPI_Wtime()\n\nRETURN VALUE\n       Time in seconds since an arbitrary time in the past.\n\n\nNOTES\n       This is intended to be a high-resolution, elapsed (or wall) clock.  See\n       MPI_WTICK to determine the resolution of MPI_WTIME .\n\n       If the attribute MPI_WTIME_IS_GLOBAL is  defined  and  true,  then  the\n       value is synchronized across all processes in MPI_COMM_WORLD .\n\n\n\nNOTES FOR FORTRAN\n       This  is  a  function, declared as DOUBLE PRECISION MPI_WTIME() in For-\n       tran.\n\n\nSEE ALSO\n       also: MPI_Wtick, MPI_Attr_get\n\nLOCATION\n       wtime.c\n\n\n\n                                  11/14/2001                      MPI_Wtime(3)", 
            "title": "MPI Lib"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_abortmd", 
            "text": "MPI_Abort(3)                          MPI                         MPI_Abort(3)\n\n\n\nNAME\n       MPI_Abort -  Terminates MPI execution environment\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Abort( MPI_Comm comm, int errorcode )\n\nINPUT PARAMETERS\n       comm   - communicator of tasks to abort\n       errorcode\n              - error code to return to invoking environment\n\n\nNOTES\n       Terminates all MPI processes associated with the communicator comm ; in\n       most systems (all to date), terminates all processes.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       abort.c\n\n\n\n                                  12/13/2001                      MPI_Abort(3)", 
            "title": "MPI_Abort.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_addressmd", 
            "text": "MPI_Address(3)                        MPI                       MPI_Address(3)\n\n\n\nNAME\n       MPI_Address -  Gets the address of a location in memory\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Address( void *location, MPI_Aint *address)\n\nINPUT PARAMETERS\n       location\n              - location in caller memory (choice)\n\n\nOUTPUT PARAMETER\n       address\n              - address of location (integer)\n\n\nNOTE\n       This  routine  is  provided for both the Fortran and C programmers.  On\n       many systems, the address returned by this routine will be the same  as\n       produced by the C   operator, but this is not required in C and may not\n       be true of systems with word- rather than byte-oriented instructions or\n       systems with segmented address spaces.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       address.c\n\n\n\n                                  11/14/2001                    MPI_Address(3)", 
            "title": "MPI_Address.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_allgathermd", 
            "text": "MPI_Allgather(3)                      MPI                     MPI_Allgather(3)\n\n\n\nNAME\n       MPI_Allgather  -   Gathers data from all tasks and distribute it to all\n       tasks\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Allgather ( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                           void *recvbuf, int recvcount, MPI_Datatype recvtype,\n                          MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              - number of elements received from any process (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES\n       The MPI standard (1.0 and 1.1) says that\n\n       The jth block of data sent from each proess is received by  every  pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This is misleading; a better description is\n\n       The  block  of data sent from the jth process is received by every pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This text was suggested by Rajeev Thakur.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler  may  be  changed  with  MPI_Errhandler_set  ;  the\n       predefined error handler MPI_ERRORS_RETURN may be used to  cause  error\n       values  to  be  returned.  Note that MPI does not guarentee that an MPI\n       program can continue past an error.\n\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       allgather.c\n\n\n\n                                   10/1/2004                  MPI_Allgather(3)", 
            "title": "MPI_Allgather.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_allgathervmd", 
            "text": "MPI_Allgatherv(3)                     MPI                    MPI_Allgatherv(3)\n\n\n\nNAME\n       MPI_Allgatherv -  Gathers data from all tasks and deliver it to all\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Allgatherv ( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                            void *recvbuf, int *recvcounts, int *displs,\n                           MPI_Datatype recvtype, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcounts\n              -  integer array (of length group size) containing the number of\n              elements that are received from each process\n       displs - integer array (of length group size). Entry  i  specifies  the\n              displacement (relative to recvbuf ) at which to place the incom-\n              ing data from process i\n\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES\n       The MPI standard (1.0 and 1.1) says that\n\n       The jth block of data sent from each proess is received by  every  pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This is misleading; a better description is\n\n       The  block  of data sent from the jth process is received by every pro-\n       cess and placed in the jth block of the buffer recvbuf .\n\n\n       This text was suggested by Rajeev Thakur.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       allgatherv.c\n\n\n\n                                  11/14/2001                 MPI_Allgatherv(3)", 
            "title": "MPI_Allgatherv.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_allreducemd", 
            "text": "MPI_Allreduce(3)                      MPI                     MPI_Allreduce(3)\n\n\n\nNAME\n       MPI_Allreduce  -  Combines values from all processes and distribute the\n       result back to all processes\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Allreduce ( void *sendbuf, void *recvbuf, int count,\n                          MPI_Datatype datatype, MPI_Op op, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - data type of elements of send buffer (handle)\n       op     - operation (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - starting address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The  reduction functions ( MPI_Op ) do not return an error value.  As a\n       result, if the functions detect an error, all they  can  do  is  either\n       call  MPI_Abort  or silently skip the problem.  Thus, if you change the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The  reason  for  this is the performance problems in ensuring that all\n       collective routines return the same error value.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_OP\n              - Invalid operation.  MPI operations (objects of type  MPI_Op  )\n              must either be one of the predefined operations (e.g., MPI_SUM )\n              or created with MPI_Op_create .\n\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       allreduce.c\n\n\n\n                                  11/14/2001                  MPI_Allreduce(3)", 
            "title": "MPI_Allreduce.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_alltoallmd", 
            "text": "MPI_Alltoall(3)                       MPI                      MPI_Alltoall(3)\n\n\n\nNAME\n       MPI_Alltoall -  Sends data from all to all processes\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Alltoall( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                         void *recvbuf, int recvcnt, MPI_Datatype recvtype,\n                        MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements to send to each process (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              - number of elements received from any process (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\nLOCATION\n       alltoall.c\n\n\n\n                                  11/14/2001                   MPI_Alltoall(3)", 
            "title": "MPI_Alltoall.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_alltoallvmd", 
            "text": "MPI_Alltoallv(3)                      MPI                     MPI_Alltoallv(3)\n\n\n\nNAME\n       MPI_Alltoallv -  Sends data from all to all processes, with a displace-\n       ment\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Alltoallv (\n               void *sendbuf,\n               int *sendcnts,\n               int *sdispls,\n               MPI_Datatype sendtype,\n               void *recvbuf,\n               int *recvcnts,\n               int *rdispls,\n               MPI_Datatype recvtype,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcounts\n              - integer array equal to the group size specifying the number of\n              elements to send to each processor\n       sdispls\n              -  integer  array  (of length group size). Entry j specifies the\n              displacement (relative to sendbuf  from which to take the outgo-\n              ing data destined for process j\n\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcounts\n              -  integer  array equal to the group size specifying the maximum\n              number of elements that can be received from each processor\n       rdispls\n              - integer array (of length group size). Entry  i  specifies  the\n              displacement  (relative to recvbuf  at which to place the incom-\n              ing data from process i\n\n       recvtype\n              - data type of receive buffer elements (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       alltoallv.c\n\n\n\n                                  11/14/2001                  MPI_Alltoallv(3)", 
            "title": "MPI_Alltoallv.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_attr_deletemd", 
            "text": "MPI_Attr_delete(3)                    MPI                   MPI_Attr_delete(3)\n\n\n\nNAME\n       MPI_Attr_delete -  Deletes attribute value associated with a key\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Attr_delete ( MPI_Comm comm, int keyval )\n\nINPUT PARAMETERS\n       comm   - communicator to which attribute is attached (handle)\n       keyval - The key value of the deleted attribute (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              keys.\n\nLOCATION\n       attr_delval.c\n\n\n\n                                  11/14/2001                MPI_Attr_delete(3)", 
            "title": "MPI_Attr_delete.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_attr_getmd", 
            "text": "MPI_Attr_get(3)                       MPI                      MPI_Attr_get(3)\n\n\n\nNAME\n       MPI_Attr_get -  Retrieves attribute value by key\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Attr_get (\n               MPI_Comm comm,\n               int keyval,\n               void *attr_value,\n               int *flag )\n\nINPUT PARAMETERS\n       comm   - communicator to which attribute is attached (handle)\n       keyval - key value (integer)\n\n\nOUTPUT PARAMETERS\n       attr_value\n              - attribute value, unless flag = false\n       flag   -  true  if  an  attribute  value  was  extracted;   false if no\n              attribute is associated with the key\n\n\nNOTES\n       Attributes must be extracted  from  the  same  language  as  they  were\n       inserted  in  with  MPI_ATTR_PUT  .   The notes for C and Fortran below\n       explain why.\n\n\nNOTES FOR C\n       Even though the attr_value arguement is declared as  void  *  ,  it  is\n       really  the  address of a void pointer.  See the rationale in the stan-\n       dard for more details.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       The  attr_value  in  Fortran  is  a pointer to a Fortran integer, not a\n       pointer to a void * .\n\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_OTHER\n              - Other error; the error code associated with this  error  indi-\n              cates an attempt to use an invalue keyval.\n\nLOCATION\n       attr_getval.c\n\n\n\n                                  11/14/2001                   MPI_Attr_get(3)", 
            "title": "MPI_Attr_get.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_attr_putmd", 
            "text": "MPI_Attr_put(3)                       MPI                      MPI_Attr_put(3)\n\n\n\nNAME\n       MPI_Attr_put -  Stores attribute value associated with a key\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Attr_put ( MPI_Comm comm, int keyval, void *attr_value )\n\nINPUT PARAMETERS\n       comm   - communicator to which attribute will be attached (handle)\n       keyval - key value, as returned by MPI_KEYVAL_CREATE (integer)\n       attribute_val\n              - attribute value\n\n\nNOTES\n       Values of the permanent attributes MPI_TAG_UB , MPI_HOST , MPI_IO , and\n       MPI_WTIME_IS_GLOBAL may not be changed.\n\n       The type of the attribute value depends on  whether  C  or  Fortran  is\n       being  used.  In C, an attribute value is a pointer ( void * ); in For-\n       tran, it is a single integer ( not a  pointer,  since  Fortran  has  no\n       pointers  and  there are systems for which a pointer does not fit in an\n       integer (e.g., any   32 bit address system that uses 64 bits  for  For-\n       tran DOUBLE PRECISION ).\n\n       If an attribute is already present, the delete function (specified when\n       the corresponding keyval was created) will be called.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_OTHER\n              -  Other  error; the error code associated with this error indi-\n              cates an attempt to use an invalue keyval.\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              keys.\n\n\nSEE ALSO\n       MPI_Attr_get, MPI_Keyval_create, MPI_Attr_delete\n\nLOCATION\n       attr_putval.c\n\n\n\n                                  11/14/2001                   MPI_Attr_put(3)", 
            "title": "MPI_Attr_put.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_barriermd", 
            "text": "MPI_Barrier(3)                        MPI                       MPI_Barrier(3)\n\n\n\nNAME\n       MPI_Barrier -  Blocks until all process have reached this routine.\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Barrier (\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n\n\nNOTES\n       Blocks  the  caller  until  all  group members have called it; the call\n       returns at any process only after all group members  have  entered  the\n       call.\n\n\nALGORITHM\n       If the underlying device cannot do better, a tree-like or combine algo-\n       rithm is used to broadcast a message wto all members of the  communica-\n       tor.   We  can  modifiy  this  to  use   blocks   at  a later time (see\n       MPI_Bcast ).\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       barrier.c\n\n\n\n                                  11/14/2001                    MPI_Barrier(3)", 
            "title": "MPI_Barrier.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_bcastmd", 
            "text": "MPI_Bcast(3)                          MPI                         MPI_Bcast(3)\n\n\n\nNAME\n       MPI_Bcast  -  Broadcasts a message from the process with rank  root  to\n       all other processes of the group.\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Bcast ( void *buffer, int count, MPI_Datatype datatype, int root,\n                      MPI_Comm comm )\n\nINPUT/OUTPUT PARAMETERS\n       buffer - starting address of buffer (choice)\n       count  - number of entries in buffer (integer)\n       datatype\n              - data type of buffer (handle)\n       root   - rank of broadcast root (integer)\n       comm   - communicator (handle)\n\n\nALGORITHM\n       If the underlying device does not take  responsibility,  this  function\n       uses  a  tree-like algorithm to broadcast the message to blocks of pro-\n       cesses.  A linear algorithm is then used to broadcast the message  from\n       the    first   process   in   a   block   to   all   other   processes.\n       MPIR_BCAST_BLOCK_SIZE determines the size of blocks.  If this is set to\n       1, then this function is equivalent to using a pure tree algorithm.  If\n       it is set to the size of the group or greater,  it  is  a  pure  linear\n       algorithm.   The  value  should be adjusted to determine the most effi-\n       cient value on different machines.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_ROOT\n              - Invalid root.  The root must be specified as  a  rank  in  the\n              communicator.   Ranks  must  be between zero and the size of the\n              communicator minus one.\n\nLOCATION\n       bcast.c\n\n\n\n                                  11/14/2001                      MPI_Bcast(3)", 
            "title": "MPI_Bcast.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_bsend_initmd", 
            "text": "MPI_Bsend_init(3)                     MPI                    MPI_Bsend_init(3)\n\n\n\nNAME\n       MPI_Bsend_init -  Builds a handle for a buffered send\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Bsend_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                          int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n\nLOCATION\n       bsend_init.c\n\n\n\n                                  12/13/2001                 MPI_Bsend_init(3)", 
            "title": "MPI_Bsend_init.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_bsendmd", 
            "text": "MPI_Bsend(3)                          MPI                         MPI_Bsend(3)\n\n\n\nNAME\n       MPI_Bsend -  Basic send with user-specified buffering\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Bsend(\n               void *buf,\n               int count,\n               MPI_Datatype datatype,\n               int dest,\n               int tag,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES\n       This  send is provided as a convenience function; it allows the user to\n       send messages without worring about where they  are  buffered  (because\n       the user must have provided buffer space with MPI_Buffer_attach ).\n\n       In deciding how much buffer space to allocate, remember that the buffer\n       space is not available for reuse by subsequent MPI_Bsend s  unless  you\n       are certain that the message has been received (not just that it should\n       have been received).  For example, this code does not  allocate  enough\n       buffer space\n       MPI_Buffer_attach( b, n*sizeof(double) + MPI_BSEND_OVERHEAD );\n       for (i=0; i m; i++) {\n       MPI_Bsend( buf, n, MPI_DOUBLE, ... );\n       }\n\n       because only enough buffer space is provided for a single send, and the\n       loop may start a second MPI_Bsend before the first is done  making  use\n       of the buffer.\n\n       In C, you can force the messages to be delivered by\n       MPI_Buffer_detach(  b,  n );\n       MPI_Buffer_attach( b, n );\n\n       (The  MPI_Buffer_detach  will  not complete until all buffered messages\n       are delivered.)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n\n\nSEE ALSO\n       MPI_Buffer_attach, MPI_Ibsend, MPI_Bsend_init\n\nLOCATION\n       bsend.c\n\n\n\n                                  11/14/2001                      MPI_Bsend(3)", 
            "title": "MPI_Bsend.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_buffer_attachmd", 
            "text": "MPI_Buffer_attach(3)                  MPI                 MPI_Buffer_attach(3)\n\n\n\nNAME\n       MPI_Buffer_attach -  Attaches a user-defined buffer for sending\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Buffer_attach( void *buffer, int size )\n\nINPUT PARAMETERS\n       buffer - initial buffer address (choice)\n       size   - buffer size, in bytes (integer)\n\n\nNOTES\n       The size given should be the sum of the sizes of all outstanding Bsends\n       that you intend to have, plus a few hundred bytes for each  Bsend  that\n       you  do.   For  the  purposes  of  calculating  size,  you  should  use\n       MPI_Pack_size .\n\n       In other words, in the code\n       MPI_Buffer_attach( buffer, size );\n       MPI_Bsend( ..., count=20, datatype=type1,  ... );\n       .\n       .\n       .\n       MPI_Bsend( ..., count=40, datatype=type2, ... );\n\n       the value of size in the MPI_Buffer_attach call should be greater  than\n       the value computed by\n       MPI_Pack_size( 20, type1, comm,  s1 );\n       MPI_Pack_size( 40, type2, comm,  s2 );\n       size = s1 + s2 + 2 * MPI_BSEND_OVERHEAD;\n\n       The  MPI_BSEND_OVERHEAD  gives  the maximum amount of space that may be\n       used in the buffer for use by the BSEND routines in using  the  buffer.\n       This value is in mpi.h (for C) and mpif.h (for Fortran).\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_INTERN\n              - An internal error has been detected.  This is  fatal.   Please\n              send a bug report to mpi-bugs@mcs.anl.gov .\n\n\n\nSEE ALSO\n       MPI_Buffer_detach, MPI_Bsend\n\nLOCATION\n       bufattach.c\n\n\n\n                                  11/14/2001              MPI_Buffer_attach(3)", 
            "title": "MPI_Buffer_attach.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_buffer_detachmd", 
            "text": "MPI_Buffer_detach(3)                  MPI                 MPI_Buffer_detach(3)\n\n\n\nNAME\n       MPI_Buffer_detach  -   Removes an existing buffer (for use in MPI_Bsend\n       etc)\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Buffer_detach(\n               void *bufferptr,\n               int *size )\n\nOUTPUT PARAMETERS\n       buffer - initial buffer address (choice)\n       size   - buffer size, in bytes (integer)\n\n\nNOTES\n       The reason that MPI_Buffer_detach returns the address and size  of  the\n       buffer  being  detached  is  to  allow  nested libraries to replace and\n       restore the buffer.  For example, consider\n\n       int size, mysize, idummy;\n       void *ptr, *myptr, *dummy;\n       MPI_Buffer_detach(  ptr,  size );\n       MPI_Buffer_attach( myptr, mysize );\n       .\n       .\n       .\n       .\n       .\n       .\n       library code ...\n       .\n       .\n       .\n       MPI_Buffer_detach(  dummy,  idummy );\n       MPI_Buffer_attach( ptr, size );\n\n\n       This is much like the action of the Unix signal  routine  and  has  the\n       same  strengths (it is simple) and weaknesses (it only works for nested\n       usages).\n\n       Note that for this approach  to  work,  MPI_Buffer_detach  must  return\n       MPI_SUCCESS  even  when there is no buffer to detach.  In that case, it\n       returns a size of zero.  The MPI  1.1  standard  for  MPI_BUFFER_DETACH\n       contains the text\n\n       The statements made in this section describe the behavior of MPI for\n       buffered-mode sends. When no buffer is currently associated, MPI behaves\n       as if a zero-sized buffer is associated with the process.\n\n\n       This  could  be  read  as  applying only to the various Bsend routines.\n       This  implementation  takes  the  position   that   this   applies   to\n       MPI_BUFFER_DETACH as well.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       The Fortran binding for this routine  is  different.   Because  Fortran\n       does  not  have  pointers, it is impossible to provide a way to use the\n       output of this routine to exchange buffers.  In  this  case,  only  the\n       size field is set.\n\n\nNOTES FOR C\n       Even though the bufferptr argument is declared as void * , it is really\n       the address of a void pointer.  See the rationale in the  standard  for\n       more details.\n\nLOCATION\n       buffree.c\n\n\n\n                                  11/14/2001              MPI_Buffer_detach(3)", 
            "title": "MPI_Buffer_detach.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cancelmd", 
            "text": "MPI_Cancel(3)                         MPI                        MPI_Cancel(3)\n\n\n\nNAME\n       MPI_Cancel -  Cancels a communication request\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Cancel( MPI_Request *request )\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTE\n       Cancel  has  only  been implemented for receive requests; it is a no-op\n       for send requests.  The primary expected use of MPI_Cancel is in multi-\n       buffering  schemes,  where  speculative  MPI_Irecvs are made.  When the\n       computation completes, some of these receive requests may remain; using\n       MPI_Cancel allows the user to cancel these unsatisfied requests.\n\n       Cancelling  a  send  operation  is  much  more difficult, in large part\n       because the send will usually  be  at  least  partially  complete  (the\n       information  on  the tag, size, and source are usually sent immediately\n       to the destination).  As of version 1.2.0, MPICH supports cancelling of\n       sends.   Users are advised that cancelling a send, while a local opera-\n       tion (as defined by the MPI standard), is likely to be expensive  (usu-\n       ally generating one or more internal messages).\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNULL HANDLES\n       The MPI 1.1 specification, in the section on opaque objects, explicitly\n\nDISALLOWS FREEING A NULL COMMUNICATOR. THE TEXT FROM THE STANDARD IS\n       A null handle argument is an erroneous IN argument in MPI calls, unless an\n       exception is explicitly stated in the text that defines the function. Such\n       exception is allowed for handles to request objects in Wait and Test calls\n       (sections Communication Completion and Multiple Completions ). Otherwise, a\n       null handle can only be passed to a function that allocates a new object and\n       returns a reference to it in the handle.\n\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cancel.c\n\n\n\n                                  11/14/2001                     MPI_Cancel(3)", 
            "title": "MPI_Cancel.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cart_coordsmd", 
            "text": "MPI_Cart_coords(3)                    MPI                   MPI_Cart_coords(3)\n\n\n\nNAME\n       MPI_Cart_coords  -   Determines  process  coords  in cartesian topology\n       given rank in group\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Cart_coords ( MPI_Comm comm, int rank, int maxdims, int *coords )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       rank   - rank of a process within group of comm (integer)\n       maxdims\n              - length of vector coords in the calling program (integer)\n\n\nOUTPUT PARAMETER\n       coords - integer array (of size ndims ) containing the Cartesian  coor-\n              dinates of specified process (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_DIMS\n              - Illegal dimension argument.  A dimension argument is  null  or\n              its length is less than or equal to zero.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       cart_coords.c\n\n\n\n                                   3/28/2002                MPI_Cart_coords(3)", 
            "title": "MPI_Cart_coords.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cart_createmd", 
            "text": "MPI_Cart_create(3)                    MPI                   MPI_Cart_create(3)\n\n\n\nNAME\n       MPI_Cart_create  -  Makes a new communicator to which topology informa-\n       tion has been attached\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Cart_create ( MPI_Comm comm_old, int ndims, int *dims, int *periods,\n                            int reorder, MPI_Comm *comm_cart )\n\nINPUT PARAMETERS\n       comm_old\n              - input communicator (handle)\n       ndims  - number of dimensions of cartesian grid (integer)\n       dims   - integer array of size ndims specifying the number of processes\n              in each dimension\n       periods\n              -  logical  array  of  size ndims specifying whether the grid is\n              periodic (true) or not (false) in each dimension\n       reorder\n              - ranking may be reordered (true) or not (false) (logical)\n\n\nOUTPUT PARAMETER\n       comm_cart\n              - communicator with new cartesian topology (handle)\n\n\nALGORITHM\n       We ignore reorder info currently.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_DIMS\n              - Illegal dimension argument.  A dimension argument is  null  or\n              its length is less than or equal to zero.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_create.c\n\n\n\n                                  11/14/2001                MPI_Cart_create(3)", 
            "title": "MPI_Cart_create.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cartdim_getmd", 
            "text": "MPI_Cartdim_get(3)                    MPI                   MPI_Cartdim_get(3)\n\n\n\nNAME\n       MPI_Cartdim_get  -  Retrieves Cartesian topology information associated\n       with a  communicator\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Cartdim_get ( MPI_Comm comm, int *ndims )\n\nINPUT PARAMETER\n       comm   - communicator with cartesian structure (handle)\n\n\nOUTPUT PARAMETER\n       ndims  - number of dimensions of the cartesian structure (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cartdim_get.c\n\n\n\n                                  11/14/2001                MPI_Cartdim_get(3)", 
            "title": "MPI_Cartdim_get.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cart_getmd", 
            "text": "MPI_Cart_get(3)                       MPI                      MPI_Cart_get(3)\n\n\n\nNAME\n       MPI_Cart_get  -   Retrieves  Cartesian  topology information associated\n       with a  communicator\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Cart_get (\n               MPI_Comm comm,\n               int maxdims,\n               int *dims,\n               int *periods,\n               int *coords )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       maxdims\n              - length of vectors dims , periods , and coords in  the  calling\n              program (integer)\n\n\nOUTPUT PARAMETERS\n       dims   -  number  of  processes  for each cartesian dimension (array of\n              integer)\n       periods\n              - periodicity (true/false) for each cartesian  dimension  (array\n              of logical)\n       coords -  coordinates  of calling process in cartesian structure (array\n              of integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_get.c\n\n\n\n                                  11/14/2001                   MPI_Cart_get(3)", 
            "title": "MPI_Cart_get.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cart_mapmd", 
            "text": "MPI_Cart_map(3)                       MPI                      MPI_Cart_map(3)\n\n\n\nNAME\n       MPI_Cart_map -  Maps process to Cartesian topology information\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Cart_map (\n               MPI_Comm comm_old,\n               int ndims,\n               int *dims,\n               int *periods,\n               int *newrank)\n\nINPUT PARAMETERS\n       comm   - input communicator (handle)\n       ndims  - number of dimensions of Cartesian structure (integer)\n       dims   - integer array of size ndims specifying the number of processes\n              in each coordinate direction\n       periods\n              - logical array of size ndims specifying the periodicity  speci-\n              fication in each coordinate direction\n\n\nOUTPUT PARAMETER\n       newrank\n              -  reordered rank of the calling process; MPI_UNDEFINED if call-\n              ing process does not belong to grid (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_DIMS\n              -  Illegal  dimension argument.  A dimension argument is null or\n              its length is less than or equal to zero.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_map.c\n\n\n\n                                   3/28/2002                   MPI_Cart_map(3)", 
            "title": "MPI_Cart_map.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cart_rankmd", 
            "text": "MPI_Cart_rank(3)                      MPI                     MPI_Cart_rank(3)\n\n\n\nNAME\n       MPI_Cart_rank  -   Determines process rank in communicator given Carte-\n       sian location\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Cart_rank (\n               MPI_Comm comm,\n               int *coords,\n               int *rank )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       coords - integer array (of size ndims ) specifying the cartesian  coor-\n              dinates of a process\n\n\nOUTPUT PARAMETER\n       rank   - rank of specified process (integer)\n\n\nNOTES\n       Out-of-range  coordinates  are  erroneous  for non-periodic dimensions.\n       Versions of MPICH before 1.2.2 returned MPI_PROC_NULL for the  rank  in\n       this case.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_rank.c\n\n\n\n                                  11/14/2001                  MPI_Cart_rank(3)", 
            "title": "MPI_Cart_rank.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cart_shiftmd", 
            "text": "MPI_Cart_shift(3)                     MPI                    MPI_Cart_shift(3)\n\n\n\nNAME\n       MPI_Cart_shift  -   Returns  the  shifted source and destination ranks,\n       given a  shift direction and amount\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Cart_shift ( MPI_Comm comm, int direction, int displ,\n                           int *source, int *dest )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       direction\n              - coordinate dimension of shift (integer)\n       disp   - displacement (  0: upwards shift,   0: downwards shift) (inte-\n              ger)\n\n\nOUTPUT PARAMETERS\n       rank_source\n              - rank of source process (integer)\n       rank_dest\n              - rank of destination process (integer)\n\n\nNOTES\n       The  direction  argument  is  in the range [0,n-1] for an n-dimensional\n       Cartesian mesh.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_shift.c\n\n\n\n                                  11/14/2001                 MPI_Cart_shift(3)", 
            "title": "MPI_Cart_shift.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_cart_submd", 
            "text": "MPI_Cart_sub(3)                       MPI                      MPI_Cart_sub(3)\n\n\n\nNAME\n       MPI_Cart_sub  -   Partitions  a communicator into subgroups which  form\n       lower-dimensional cartesian subgrids\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Cart_sub ( MPI_Comm comm, int *remain_dims, MPI_Comm *comm_new )\n\nINPUT PARAMETERS\n       comm   - communicator with cartesian structure (handle)\n       remain_dims\n              - the i th entry of  remain_dims  specifies  whether  the  i  th\n              dimension  is  kept  in the subgrid (true) or is dropped (false)\n              (logical vector)\n\n\nOUTPUT PARAMETER\n       newcomm\n              - communicator containing the subgrid that includes the  calling\n              process (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       cart_sub.c\n\n\n\n                                  11/14/2001                   MPI_Cart_sub(3)", 
            "title": "MPI_Cart_sub.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_comparemd", 
            "text": "MPI_Comm_compare(3)                   MPI                  MPI_Comm_compare(3)\n\n\n\nNAME\n       MPI_Comm_compare -  Compares two communicators\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Comm_compare (\n               MPI_Comm  comm1,\n               MPI_Comm  comm2,\n               int *result)\n\nINPUT PARAMETERS\n       comm1  - comm1 (handle)\n       comm2  - comm2 (handle)\n\n\nOUTPUT PARAMETER\n       result -  integer which is MPI_IDENT if the contexts and groups are the\n              same, MPI_CONGRUENT if different contexts but identical  groups,\n              MPI_SIMILAR  if  different  contexts  but  similar  groups,  and\n              MPI_UNEQUAL otherwise\n\n\nUSING 'MPI_COMM_NULL' WITH 'MPI_COMM_COMPARE'\n       It is an error  to  use  MPI_COMM_NULL  as  one  of  the  arguments  to\n       MPI_Comm_compare .  The relevant sections of the MPI standard are\n\n       .   (2.4.1  Opaque  Objects)  A null handle argument is an erroneous IN\n       argument in MPI calls, unless an exception is explicitly stated in  the\n       text that defines the function.\n\n       .   (5.4.1. Communicator Accessors)  no text in MPI_COMM_COMPARE allow-\n       ing a null handle \n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       commcompare.c\n\n\n\n                                  11/14/2001               MPI_Comm_compare(3)", 
            "title": "MPI_Comm_compare.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_createmd", 
            "text": "MPI_Comm_create(3)                    MPI                   MPI_Comm_create(3)\n\n\n\nNAME\n       MPI_Comm_create -  Creates a new communicator\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Comm_create ( MPI_Comm comm, MPI_Group group, MPI_Comm *comm_out )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n       group  - group, which is a subset of the group of comm (handle)\n\n\nOUTPUT PARAMETER\n       comm_out\n              - new communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Comm_free\n\nLOCATION\n       comm_create.c\n\n\n\n                                  11/14/2001                MPI_Comm_create(3)", 
            "title": "MPI_Comm_create.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_dupmd", 
            "text": "MPI_Comm_dup(3)                       MPI                      MPI_Comm_dup(3)\n\n\n\nNAME\n       MPI_Comm_dup -  Duplicates an existing communicator with all its cached\n       information\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Comm_dup (\n               MPI_Comm comm,\n               MPI_Comm *comm_out )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       newcomm\n              - A new communicator over the same group as comm but with a  new\n              context. See notes.  (handle)\n\n\nNOTES\n       This routine is used to create a new communicator that has a new commu-\n       nication context but contains the same group of processes as the  input\n       communicator.  Since all MPI communication is performed within a commu-\n       nicator (specifies as the group of processes plus  the  context),  this\n       routine  provides an effective way to create a private communicator for\n       use by a software module or library.  In particular, no library routine\n       should  use MPI_COMM_WORLD as the communicator; instead, a duplicate of\n       a user-specified communicator should always be used.  For more informa-\n       tion, see Using MPI, 2nd edition.\n\n       Because  this routine essentially produces a copy of a communicator, it\n       also copies any attributes that have been defined on the input communi-\n       cator, using the attribute copy function specified by the copy_function\n       argument to MPI_Keyval_create .  This is particularly  useful  for  (a)\n       attributes that describe some property of the group associated with the\n       communicator, such as its interconnection topology and  (b)  communica-\n       tors  that  are  given back to the user; the attibutes in this case can\n       track subsequent MPI_Comm_dup operations on this communicator.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Comm_free, MPI_Keyval_create, MPI_Attr_set, MPI_Attr_delete\n\n\nLOCATION\n       comm_dup.c\n\n\n\n                                  11/14/2001                   MPI_Comm_dup(3)", 
            "title": "MPI_Comm_dup.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_freemd", 
            "text": "MPI_Comm_free(3)                      MPI                     MPI_Comm_free(3)\n\n\n\nNAME\n       MPI_Comm_free -  Marks the communicator object for deallocation\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Comm_free ( MPI_Comm *commp )\n\nINPUT PARAMETER\n       comm   - communicator to be destroyed (handle)\n\n\nNULL HANDLES\n       The MPI 1.1 specification, in the section on opaque objects, explicitly\n\nDISALLOWS FREEING A NULL COMMUNICATOR. THE TEXT FROM THE STANDARD IS\n       A null handle argument is an erroneous IN argument in MPI calls, unless an\n       exception is explicitly stated in the text that defines the function. Such\n       exception is allowed for handles to request objects in Wait and Test calls\n       (sections Communication Completion and Multiple Completions ). Otherwise, a\n       null handle can only be passed to a function that allocates a new object and\n       returns a reference to it in the handle.\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_free.c\n\n\n\n                                  10/31/2002                  MPI_Comm_free(3)", 
            "title": "MPI_Comm_free.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_groupmd", 
            "text": "MPI_Comm_group(3)                     MPI                    MPI_Comm_group(3)\n\n\n\nNAME\n       MPI_Comm_group -  Accesses the group associated with given communicator\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Comm_group (\n               MPI_Comm comm,\n               MPI_Group *group )\n\nINPUT PARAMETER\n       comm   - Communicator\n\n\nOUTPUT PARAMETER\n       group  - Group in communicator\n\n\nUSING 'MPI_COMM_NULL' WITH 'MPI_COMM_GROUP'\n       It is an error  to  use  MPI_COMM_NULL  as  one  of  the  arguments  to\n       MPI_Comm_group .  The relevant sections of the MPI standard are\n\n       .   (2.4.1  Opaque  Objects)  A null handle argument is an erroneous IN\n       argument in MPI calls, unless an exception is explicitly stated in  the\n       text that defines the function.\n\n       .   (5.3.2.  Group  Constructors)  no text in MPI_COMM_GROUP allowing a\n       null handle \n\n       Previous versions of MPICH allow MPI_COMM_NULL in  this  function.   In\n       the interests of promoting portability of applications, we have changed\n       the behavior of MPI_Comm_group to detect  this  violation  of  the  MPI\n       standard.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       comm_group.c\n\n\n\n                                  11/14/2001                 MPI_Comm_group(3)", 
            "title": "MPI_Comm_group.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_rankmd", 
            "text": "MPI_Comm_rank(3)                      MPI                     MPI_Comm_rank(3)\n\n\n\nNAME\n       MPI_Comm_rank -  Determines the rank of the calling process in the com-\n       municator\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Comm_rank ( MPI_Comm comm, int *rank )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       rank   - rank of the calling process in group of comm (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       comm_rank.c\n\n\n\n                                  11/14/2001                  MPI_Comm_rank(3)", 
            "title": "MPI_Comm_rank.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_remote_groupmd", 
            "text": "MPI_Comm_remote_group(3)              MPI             MPI_Comm_remote_group(3)\n\n\n\nNAME\n       MPI_Comm_remote_group -  Accesses the remote group associated with  the\n       given inter-communicator\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Comm_remote_group ( MPI_Comm comm, MPI_Group *group )\n\nINPUT PARAMETER\n       comm   - Communicator (must be intercommunicator)\n\n\nOUTPUT PARAMETER\n       group  - remote group of communicator\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n\nLOCATION\n       comm_rgroup.c\n\n\n\n                                  11/14/2001          MPI_Comm_remote_group(3)", 
            "title": "MPI_Comm_remote_group.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_remote_sizemd", 
            "text": "MPI_Comm_remote_size(3)               MPI              MPI_Comm_remote_size(3)\n\n\n\nNAME\n       MPI_Comm_remote_size  -  Determines the size of the remote group  asso-\n       ciated with an inter-communictor\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Comm_remote_size ( MPI_Comm comm, int *size )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       size   - number of processes in the group of comm (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_rsize.c\n\n\n\n                                  11/14/2001           MPI_Comm_remote_size(3)", 
            "title": "MPI_Comm_remote_size.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_sizemd", 
            "text": "MPI_Comm_size(3)                      MPI                     MPI_Comm_size(3)\n\n\n\nNAME\n       MPI_Comm_size  -   Determines  the  size of the group associated with a\n       communictor\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Comm_size ( MPI_Comm comm, int *size )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       size   - number of processes in the group of comm (integer)\n\n\nNOTES\n       MPI_COMM_NULL is not considered a valid argument to this function.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_size.c\n\n\n\n                                  11/14/2001                  MPI_Comm_size(3)", 
            "title": "MPI_Comm_size.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_splitmd", 
            "text": "MPI_Comm_split(3)                     MPI                    MPI_Comm_split(3)\n\n\n\nNAME\n       MPI_Comm_split -  Creates new communicators based on colors and keys\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Comm_split ( MPI_Comm comm, int color, int key, MPI_Comm *comm_out )\n\nINPUT PARAMETERS\n       comm   - communicator (handle)\n       color  - control of subset assignment (nonnegative integer).  Processes\n              with the same color are in the same new communicator\n       key    - control of rank assigment (integer)\n\n\nOUTPUT PARAMETER\n       newcomm\n              - new communicator (handle)\n\n\nNOTES\n       The color must be non-negative or MPI_UNDEFINED .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nALGORITHM\n       The current algorithm used has quite a few (read: a lot of) inefficien-\n       cies that can be removed.  Here is what we do for now\n\n       1) A table is built of colors, and keys (has a next field also).\n       2) The tables of all processes are merged using\n       MPI_Allreduce\n       .\n       3) Two contexts are allocated for all the comms to be created.  These\n       same two contexts can be used for all created communicators since\n       the communicators will not overlap.\n       4) If the local process has a color of\n       MPI_UNDEFINED\n       , it can return\n       a\n       NULL\n       comm.\n       5) The table entries that match the local process color are sorted\n       by key/rank.\n       6) A group is created from the sorted list and a communicator is created\n       with this group and the previously allocated contexts.\n\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Comm_free\n\nLOCATION\n       comm_split.c\n\n\n\n                                   8/29/2002                 MPI_Comm_split(3)", 
            "title": "MPI_Comm_split.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_comm_test_intermd", 
            "text": "MPI_Comm_test_inter(3)                MPI               MPI_Comm_test_inter(3)\n\n\n\nNAME\n       MPI_Comm_test_inter -  Tests to see if a comm is an inter-communicator\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Comm_test_inter ( MPI_Comm comm, int *flag )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       flag   - (logical)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       comm_testic.c\n\n\n\n                                  11/14/2001            MPI_Comm_test_inter(3)", 
            "title": "MPI_Comm_test_inter.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_dims_createmd", 
            "text": "MPI_Dims_create(3)                    MPI                   MPI_Dims_create(3)\n\n\n\nNAME\n       MPI_Dims_create -  Creates a division of processors in a cartesian grid\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Dims_create(\n               int nnodes,\n               int ndims,\n               int *dims)\n\nINPUT PARAMETERS\n       nnodes - number of nodes in a grid (integer)\n       ndims  - number of cartesian dimensions (integer)\n\n\nIN/OUT PARAMETER\n       dims   - integer array of size ndims specifying the number of nodes  in\n              each dimension\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       dims_create.c\n\n\n\n                                   4/24/2002                MPI_Dims_create(3)", 
            "title": "MPI_Dims_create.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_errhandler_createmd", 
            "text": "MPI_Errhandler_create(3)              MPI             MPI_Errhandler_create(3)\n\n\n\nNAME\n       MPI_Errhandler_create -  Creates an MPI-style errorhandler\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Errhandler_create(\n               MPI_Handler_function *function,\n               MPI_Errhandler       *errhandler)\n\nINPUT PARAMETER\n       function\n              - user defined error handling procedure\n\n\nOUTPUT PARAMETER\n       errhandler\n              - MPI error handler (handle)\n\n\nNOTES\n       The  MPI  Standard  states  that  an implementation may make the output\n       value (errhandler) simply the address of the  function.   However,  the\n       action  of  MPI_Errhandler_free  makes  this  impossible,  since  it is\n       required to set the value of the argument to MPI_ERRHANDLER_NULL .   In\n       addition,  the actual error handler must remain until all communicators\n       that use it are freed.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       errcreate.c\n\n\n\n                                  11/14/2001          MPI_Errhandler_create(3)", 
            "title": "MPI_Errhandler_create.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_errhandler_freemd", 
            "text": "MPI_Errhandler_free(3)                MPI               MPI_Errhandler_free(3)\n\n\n\nNAME\n       MPI_Errhandler_free -  Frees an MPI-style errorhandler\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Errhandler_free( MPI_Errhandler *errhandler )\n\nINPUT PARAMETER\n       errhandler\n              -  MPI  error  handler  (handle).  Set to MPI_ERRHANDLER_NULL on\n              exit.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       errfree.c\n\n\n\n                                  11/14/2001            MPI_Errhandler_free(3)", 
            "title": "MPI_Errhandler_free.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_errhandler_getmd", 
            "text": "MPI_Errhandler_get(3)                 MPI                MPI_Errhandler_get(3)\n\n\n\nNAME\n       MPI_Errhandler_get -  Gets the error handler for a communicator\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Errhandler_get( MPI_Comm comm, MPI_Errhandler *errhandler )\n\nINPUT PARAMETER\n       comm   - communicator to get the error handler from (handle)\n\n\nOUTPUT PARAMETER\n       errhandler\n              - MPI error handler currently associated with communicator (han-\n              dle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTE ON IMPLEMENTATION\n       The  MPI Standard was unclear on whether this routine required the user\n       to call MPI_Errhandler_free once for each call made to this routine  in\n       order  to  free  the  error  handler.  After some debate, the MPI Forum\n       added an explicit statement that users are required to call MPI_Errhan-\n       dler_free  when the return value from this routine is no longer needed.\n       This behavior is similar to the other MPI routines for getting objects;\n       for  example, MPI_Comm_group requires that the user call MPI_Group_free\n       when the group returned by MPI_Comm_group is no longer needed.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       errget.c\n\n\n\n                                  11/14/2001             MPI_Errhandler_get(3)", 
            "title": "MPI_Errhandler_get.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_errhandler_setmd", 
            "text": "MPI_Errhandler_set(3)                 MPI                MPI_Errhandler_set(3)\n\n\n\nNAME\n       MPI_Errhandler_set -  Sets the error handler for a communicator\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Errhandler_set( MPI_Comm comm, MPI_Errhandler errhandler )\n\nINPUT PARAMETERS\n       comm   - communicator to set the error handler for (handle)\n       errhandler\n              - new MPI error handler for communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       errset.c\n\n\n\n                                  11/14/2001             MPI_Errhandler_set(3)", 
            "title": "MPI_Errhandler_set.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_error_classmd", 
            "text": "MPI_Error_class(3)                    MPI                   MPI_Error_class(3)\n\n\n\nNAME\n       MPI_Error_class -  Converts an error code into an error class\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Error_class(\n               int errorcode,\n               int *errorclass)\n\nINPUT PARAMETER\n       errorcode\n              - Error code returned by an MPI routine\n\n\nOUTPUT PARAMETER\n       errorclass\n              - Error class associated with errorcode\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       errclass.c\n\n\n\n                                  11/14/2001                MPI_Error_class(3)", 
            "title": "MPI_Error_class.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_error_stringmd", 
            "text": "MPI_Error_string(3)                   MPI                  MPI_Error_string(3)\n\n\n\nNAME\n       MPI_Error_string -  Return a string for a given error code\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Error_string( int errorcode, char *string, int *resultlen )\n\nINPUT PARAMETERS\n       errorcode\n              - Error code returned by an MPI routine or an MPI error class\n\n\nOUTPUT PARAMETER\n       string - Text that corresponds to the errorcode\n       resultlen\n              - Length of string\n\n              Notes:  Error codes are the values return by MPI routines (in C)\n              or in the ierr argument (in Fortran).  These  can  be  converted\n              into error classes with the routine MPI_Error_class .\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       errorstring.c\n\n\n\n                                  11/14/2001               MPI_Error_string(3)", 
            "title": "MPI_Error_string.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_finalizemd", 
            "text": "MPI_Finalize(3)                       MPI                      MPI_Finalize(3)\n\n\n\nNAME\n       MPI_Finalize -  Terminates MPI execution environment\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Finalize()\n\nNOTES\n       All  processes  must  call  this routine before exiting.  The number of\n       processes running after this routine is called is undefined; it is best\n       not  to perform much more than a return rc after calling MPI_Finalize .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       finalize.c\n\n\n\n                                   4/9/2002                    MPI_Finalize(3)", 
            "title": "MPI_Finalize.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_gathermd", 
            "text": "MPI_Gather(3)                         MPI                        MPI_Gather(3)\n\n\n\nNAME\n       MPI_Gather -  Gathers together values from a group of processes\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Gather ( void *sendbuf, int sendcnt, MPI_Datatype sendtype,\n                       void *recvbuf, int recvcount, MPI_Datatype recvtype,\n                       int root, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              -  number  of elements for any single receive (integer, signifi-\n              cant only at root)\n       recvtype\n              - data type of recv buffer elements (significant only  at  root)\n              (handle)\n       root   - rank of receiving process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice, significant only at root )\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\nLOCATION\n       gather.c\n\n\n\n                                  11/14/2001                     MPI_Gather(3)", 
            "title": "MPI_Gather.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_gathervmd", 
            "text": "MPI_Gatherv(3)                        MPI                       MPI_Gatherv(3)\n\n\n\nNAME\n       MPI_Gatherv -  Gathers into specified locations from all processes in a\n       group\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Gatherv ( void *sendbuf, int sendcnt, MPI_Datatype sendtype,\n                         void *recvbuf, int *recvcnts, int *displs,\n                        MPI_Datatype recvtype,\n                         int root, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcounts\n              - integer array (of length group size) containing the number  of\n              elements  that  are received from each process (significant only\n              at root )\n       displs - integer array (of length group size). Entry  i  specifies  the\n              displacement relative to recvbuf  at which to place the incoming\n              data from process i (significant only at root)\n       recvtype\n              - data type of recv buffer elements (significant only at root  )\n              (handle)\n       root   - rank of receiving process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice, significant only at root )\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       gatherv.c\n\n\n\n                                   2/19/2002                    MPI_Gatherv(3)", 
            "title": "MPI_Gatherv.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_get_countmd", 
            "text": "MPI_Get_count(3)                      MPI                     MPI_Get_count(3)\n\n\n\nNAME\n       MPI_Get_count -  Gets the number of  top level  elements\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Get_count(\n               MPI_Status *status,\n               MPI_Datatype datatype,\n               int *count )\n\nINPUT PARAMETERS\n       status - return status of receive operation (Status)\n       datatype\n              - datatype of each receive buffer element (handle)\n\n\nOUTPUT PARAMETER\n       count  -  number  of  received elements (integer) Notes: If the size of\n              the datatype is zero, this routine will return a count of  zero.\n              If  the amount of data in status is not an exact multiple of the\n              size of datatype (so that count would not be integral), a  count\n              of MPI_UNDEFINED is returned instead.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       getcount.c\n\n\n\n                                  11/14/2001                  MPI_Get_count(3)", 
            "title": "MPI_Get_count.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_get_elementsmd", 
            "text": "MPI_Get_elements(3)                   MPI                  MPI_Get_elements(3)\n\n\n\nNAME\n       MPI_Get_elements -  Returns the number of basic elements in a datatype\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Get_elements ( MPI_Status *status, MPI_Datatype datatype,\n                             int *elements )\n\nINPUT PARAMETERS\n       status - return status of receive operation (Status)\n       datatype\n              - datatype used by receive operation (handle)\n\n\nOUTPUT PARAMETER\n       count  - number of received basic elements (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\n\nLOCATION\n       getelements.c\n\n\n\n                                  11/14/2001               MPI_Get_elements(3)", 
            "title": "MPI_Get_elements.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_get_processor_namemd", 
            "text": "MPI_Get_processor_name(3)             MPI            MPI_Get_processor_name(3)\n\n\n\nNAME\n       MPI_Get_processor_name -  Gets the name of the processor\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Get_processor_name(\n               char *name,\n               int *resultlen)\n\nOUTPUT PARAMETERS\n       name   -  A  unique  specifier  for  the actual (as opposed to virtual)\n              node. This must be an array of  size  at  least  MPI_MAX_PROCES-\n              SOR_NAME .\n\n       resultlen\n              - Length (in characters) of the name\n\n\nNOTES\n       The  name  returned should identify a particular piece of hardware; the\n       exact format is implementation defined.  This name may or  may  not  be\n       the same as might be returned by gethostname , uname , or sysinfo .\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       getpname.c\n\n\n\n                                  11/14/2001         MPI_Get_processor_name(3)", 
            "title": "MPI_Get_processor_name.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_get_versionmd", 
            "text": "MPI_Get_version(3)                    MPI                   MPI_Get_version(3)\n\n\n\nNAME\n       MPI_Get_version -  Gets the version of MPI\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Get_version(\n               int *version,\n               int *subversion )\n\nOUTPUT PARAMETERS\n       version\n              - Major version of MPI (1 or 2)\n       subversion\n              - Minor version of MPI.\n\n\nNOTES\n       The  defined  values  MPI_VERSION  and  MPI_SUBVERSION contain the same\n       information.  This routine allows you to check that the library matches\n       the version specified in the mpi.h and mpif.h files.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       getversion.c\n\n\n\n                                  11/14/2001                MPI_Get_version(3)", 
            "title": "MPI_Get_version.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_graph_createmd", 
            "text": "MPI_Graph_create(3)                   MPI                  MPI_Graph_create(3)\n\n\n\nNAME\n       MPI_Graph_create -  Makes a new communicator to which topology informa-\n       tion has been attached\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Graph_create ( MPI_Comm comm_old, int nnodes, int *index, int *edges,\n                             int reorder, MPI_Comm *comm_graph )\n\nINPUT PARAMETERS\n       comm_old\n              - input communicator without topology (handle)\n       nnodes - number of nodes in graph (integer)\n       index  - array of integers describing node degrees (see below)\n       edges  - array of integers describing graph edges (see below)\n       reorder\n              - ranking may be reordered (true) or not (false) (logical)\n\n\nOUTPUT PARAMETER\n       comm_graph\n              - communicator with graph topology added (handle)\n\n\nALGORITHM\n       We ignore the reorder info currently.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graphcreate.c\n\n\n\n                                   1/4/2002                MPI_Graph_create(3)", 
            "title": "MPI_Graph_create.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_graphdims_getmd", 
            "text": "MPI_Graphdims_get(3)                  MPI                 MPI_Graphdims_get(3)\n\n\n\nNAME\n       MPI_Graphdims_get  -   Retrieves  graph topology information associated\n       with a  communicator\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Graphdims_get ( MPI_Comm comm, int *nnodes, int *nedges )\n\nINPUT PARAMETERS\n       comm   - communicator for group with graph structure (handle)\n\n\nOUTPUT PARAMETER\n       nnodes - number of nodes in graph (integer)\n       nedges - number of edges in graph (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graphdimsget.c\n\n\n\n                                  11/14/2001              MPI_Graphdims_get(3)", 
            "title": "MPI_Graphdims_get.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_graph_getmd", 
            "text": "MPI_Graph_get(3)                      MPI                     MPI_Graph_get(3)\n\n\n\nNAME\n       MPI_Graph_get -  Retrieves graph topology information associated with a\n       communicator\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Graph_get ( MPI_Comm comm, int maxindex, int maxedges,\n                          int *index, int *edges )\n\nINPUT PARAMETERS\n       comm   - communicator with graph structure (handle)\n       maxindex\n              - length of vector index in the calling program  (integer)\n       maxedges\n              - length of vector edges in the calling program  (integer)\n\n\nOUTPUT PARAMETER\n       index  - array of integers containing the graph structure (for  details\n              see the definition of MPI_GRAPH_CREATE )\n       edges  - array of integers containing the graph structure\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graph_get.c\n\n\n\n                                   1/4/2002                   MPI_Graph_get(3)", 
            "title": "MPI_Graph_get.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_graph_mapmd", 
            "text": "MPI_Graph_map(3)                      MPI                     MPI_Graph_map(3)\n\n\n\nNAME\n       MPI_Graph_map -  Maps process to graph topology information\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Graph_map ( MPI_Comm comm_old, int nnodes, int *index, int *edges,\n                          int *newrank )\n\nINPUT PARAMETERS\n       comm   - input communicator (handle)\n       nnodes - number of graph nodes (integer)\n       index  -   integer   array   specifying   the   graph   structure,  see\n              MPI_GRAPH_CREATE\n\n       edges  - integer array specifying the graph structure\n\n\nOUTPUT PARAMETER\n       newrank\n              - reordered rank of the calling process;  MPI_UNDEFINED  if  the\n              calling process does not belong to graph (integer)\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       graph_map.c\n\n\n\n                                   1/4/2002                   MPI_Graph_map(3)", 
            "title": "MPI_Graph_map.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_graph_neighbors_countmd", 
            "text": "MPI_Graph_neighbors_count(3)          MPI         MPI_Graph_neighbors_count(3)\n\n\n\nNAME\n       MPI_Graph_neighbors_count  -  Returns the number of neighbors of a node\n       associated with a graph topology\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Graph_neighbors_count ( MPI_Comm comm, int rank, int *nneighbors )\n\nINPUT PARAMETERS\n       comm   - communicator with graph topology (handle)\n       rank   - rank of process in group of comm (integer)\n\n\nOUTPUT PARAMETER\n       nneighbors\n              - number of neighbors of specified process (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       graphnbrcnt.c\n\n\n\n                                  11/14/2001      MPI_Graph_neighbors_count(3)", 
            "title": "MPI_Graph_neighbors_count.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_graph_neighborsmd", 
            "text": "MPI_Graph_neighbors(3)                MPI               MPI_Graph_neighbors(3)\n\n\n\nNAME\n       MPI_Graph_neighbors -  Returns the neighbors of a node associated  with\n       a graph topology\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Graph_neighbors ( MPI_Comm comm, int rank, int maxneighbors,\n                               int *neighbors )\n\nINPUT PARAMETERS\n       comm   - communicator with graph topology (handle)\n       rank   - rank of process in group of comm (integer)\n       maxneighbors\n              - size of array neighbors (integer)\n\n\nOUTPUT PARAMETERS\n       neighbors\n              - ranks of processes that are  neighbors  to  specified  process\n              (array of integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TOPOLOGY\n              - Invalid topology.  Either there is no topology associated with\n              this communicator, or it is not the correct type (e.g., MPI_CART\n              when expecting MPI_GRAPH ).\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       graph_nbr.c\n\n\n\n                                  11/14/2001            MPI_Graph_neighbors(3)", 
            "title": "MPI_Graph_neighbors.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_comparemd", 
            "text": "MPI_Group_compare(3)                  MPI                 MPI_Group_compare(3)\n\n\n\nNAME\n       MPI_Group_compare -  Compares two groups\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Group_compare ( MPI_Group group1, MPI_Group group2, int *result )\n\nINPUT PARAMETERS\n       group1 - group1 (handle)\n       group2 - group2 (handle)\n\n\nOUTPUT PARAMETER\n       result - integer which is MPI_IDENT if the order and members of the two\n              groups are the same, MPI_SIMILAR if only  the  members  are  the\n              same, and MPI_UNEQUAL otherwise\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       groupcompare.c\n\n\n\n                                  11/14/2001              MPI_Group_compare(3)", 
            "title": "MPI_Group_compare.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_differencemd", 
            "text": "MPI_Group_difference(3)               MPI              MPI_Group_difference(3)\n\n\n\nNAME\n       MPI_Group_difference -  Makes a group from the difference of two groups\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Group_difference ( MPI_Group group1, MPI_Group group2,\n                                MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group1 - first group (handle)\n       group2 - second group (handle)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - difference group (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_diff.c\n\n\n\n                                  11/14/2001           MPI_Group_difference(3)", 
            "title": "MPI_Group_difference.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_exclmd", 
            "text": "MPI_Group_excl(3)                     MPI                    MPI_Group_excl(3)\n\n\n\nNAME\n       MPI_Group_excl  -  Produces a group by reordering an existing group and\n       taking only unlisted members\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Group_excl ( MPI_Group group, int n, int *ranks, MPI_Group *newgroup )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of elements in array ranks (integer)\n       ranks  - array of integer ranks in group not to appear in newgroup\n\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, preserving the order defined  by\n              group (handle)\n\n\nNOTE\n       Currently,  each  of  the  ranks to exclude must be a valid rank in the\n       group and all elements must be distinct or the function  is  erroneous.\n       This restriction is per the draft.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_excl.c\n\n\n\n                                  11/14/2001                 MPI_Group_excl(3)", 
            "title": "MPI_Group_excl.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_freemd", 
            "text": "MPI_Group_free(3)                     MPI                    MPI_Group_free(3)\n\n\n\nNAME\n       MPI_Group_free -  Frees a group\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Group_free ( MPI_Group *group )\n       Input Parameter\n       group  - group (handle)\n\n\nNOTES\n       On output, group is set to MPI_GROUP_NULL .\n\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              groups.\n\nLOCATION\n       group_free.c\n\n\n\n                                  11/14/2001                 MPI_Group_free(3)", 
            "title": "MPI_Group_free.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_inclmd", 
            "text": "MPI_Group_incl(3)                     MPI                    MPI_Group_incl(3)\n\n\n\nNAME\n       MPI_Group_incl  -  Produces a group by reordering an existing group and\n       taking only listed members\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Group_incl ( MPI_Group group, int n, int *ranks, MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of elements in array ranks  (and  size  of  newgroup  )\n              (integer)\n       ranks  -  ranks  of  processes in group to appear in newgroup (array of\n              integers)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, in the order defined by ranks\n\n              (handle)\n\n\nNOTE\n       This implementation does not currently check to see that  the  list  of\n       ranks to ensure that there are no duplicates.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_incl.c\n\n\n\n                                  11/14/2001                 MPI_Group_incl(3)", 
            "title": "MPI_Group_incl.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_intersectionmd", 
            "text": "MPI_Group_intersection(3)             MPI            MPI_Group_intersection(3)\n\n\n\nNAME\n       MPI_Group_intersection  -   Produces a group as the intersection of two\n       existing groups\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Group_intersection ( MPI_Group group1, MPI_Group group2,\n                                  MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group1 - first group (handle)\n       group2 - second group (handle)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - intersection group (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_inter.c\n\n\n\n                                  11/14/2001         MPI_Group_intersection(3)", 
            "title": "MPI_Group_intersection.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_range_exclmd", 
            "text": "MPI_Group_range_excl(3)               MPI              MPI_Group_range_excl(3)\n\n\n\nNAME\n       MPI_Group_range_excl  -   Produces  a group by excluding ranges of pro-\n       cesses from an existing group\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Group_range_excl ( MPI_Group group, int n, int ranges[][3],\n                                MPI_Group *newgroup )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of elements in array ranks (integer)\n       ranges - a one-dimensional array of integer triplets of the form (first\n              rank,  last rank, stride), indicating the ranks in group of pro-\n              cesses to be excluded from the output group newgroup .\n\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, preserving the  order  in  group\n              (handle)\n\n\nNOTE\n       Currently,  each  of  the  ranks to exclude must be a valid rank in the\n       group and all elements must be distinct or the function  is  erroneous.\n       This restriction is per the draft.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_rexcl.c\n\n\n\n                                  11/14/2001           MPI_Group_range_excl(3)", 
            "title": "MPI_Group_range_excl.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_range_inclmd", 
            "text": "MPI_Group_range_incl(3)               MPI              MPI_Group_range_incl(3)\n\n\n\nNAME\n       MPI_Group_range_incl  -  Creates a new group from ranges of ranks in an\n       existing group\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Group_range_incl ( MPI_Group group, int n, int ranges[][3],\n                                MPI_Group *newgroup )\n\nINPUT PARAMETERS\n       group  - group (handle)\n       n      - number of triplets in array ranges (integer)\n       ranges - a one-dimensional array  of  integer  triplets,  of  the  form\n              (first  rank,  last  rank,  stride) indicating ranks in group or\n              processes to be included in newgroup\n\n\n\nOUTPUT PARAMETER\n       newgroup\n              - new group derived from above, in the order defined  by  ranges\n              (handle)\n\n\nNOTE\n       This  implementation  does  not currently check to see that the list of\n       ranges to include are valid ranks in the group.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_rincl.c\n\n\n\n                                  11/14/2001           MPI_Group_range_incl(3)", 
            "title": "MPI_Group_range_incl.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_rankmd", 
            "text": "MPI_Group_rank(3)                     MPI                    MPI_Group_rank(3)\n\n\n\nNAME\n       MPI_Group_rank -  Returns the rank of this process in the given group\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Group_rank ( MPI_Group group, int *rank )\n\nINPUT PARAMETERS\n       group  - group (handle)\n\n\nOUTPUT PARAMETER\n       rank   -  rank of the calling process in group, or MPI_UNDEFINED if the\n              process is not a member (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       group_rank.c\n\n\n\n                                  11/14/2001                 MPI_Group_rank(3)", 
            "title": "MPI_Group_rank.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_sizemd", 
            "text": "MPI_Group_size(3)                     MPI                    MPI_Group_size(3)\n\n\n\nNAME\n       MPI_Group_size -  Returns the size of a group\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Group_size ( MPI_Group group, int *size )\n\nINPUT PARAMETERS\n       group  - group (handle) Output Parameter:\n       size   - number of processes in the group (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       group_size.c\n\n\n\n                                  11/14/2001                 MPI_Group_size(3)", 
            "title": "MPI_Group_size.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_translate_ranksmd", 
            "text": "MPI_Group_translate_ranks(3)          MPI         MPI_Group_translate_ranks(3)\n\n\n\nNAME\n       MPI_Group_translate_ranks  -   Translates the ranks of processes in one\n       group to  those in another group\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Group_translate_ranks ( MPI_Group group_a, int n, int *ranks_a,\n                                    MPI_Group group_b, int *ranks_b )\n\nINPUT PARAMETERS\n       group1 - group1 (handle)\n       n      - number of ranks in ranks1 and ranks2 arrays (integer)\n       ranks1 - array of zero or more valid ranks in group1\n\n       group2 - group2 (handle)\n\n\nOUTPUT PARAMETER\n       ranks2 - array of corresponding ranks in group2, MPI_UNDEFINED when  no\n              correspondence exists.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       group_tranks.c\n\n\n\n                                  11/14/2001      MPI_Group_translate_ranks(3)", 
            "title": "MPI_Group_translate_ranks.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_group_unionmd", 
            "text": "MPI_Group_union(3)                    MPI                   MPI_Group_union(3)\n\n\n\nNAME\n       MPI_Group_union -  Produces a group by combining two groups\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Group_union ( MPI_Group group1, MPI_Group group2,\n                            MPI_Group *group_out )\n\nINPUT PARAMETERS\n       group1 - first group (handle)\n       group2 - second group (handle)\n\n\nOUTPUT PARAMETER\n       newgroup\n              - union group (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_GROUP\n              - Null group passed to function.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Group_free\n\nLOCATION\n       group_union.c\n\n\n\n                                  11/14/2001                MPI_Group_union(3)", 
            "title": "MPI_Group_union.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_ibsendmd", 
            "text": "MPI_Ibsend(3)                         MPI                        MPI_Ibsend(3)\n\n\n\nNAME\n       MPI_Ibsend -  Starts a nonblocking buffered send\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Ibsend( void *buf, int count, MPI_Datatype datatype, int dest, int tag,\n                      MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\n\nLOCATION\n       ibsend.c\n\n\n\n                                  11/14/2001                     MPI_Ibsend(3)", 
            "title": "MPI_Ibsend.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_initializedmd", 
            "text": "MPI_Initialized(3)                    MPI                   MPI_Initialized(3)\n\n\n\nNAME\n       MPI_Initialized -  Indicates whether MPI_Init has been called.\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Initialized( int *flag )\n\nOUTPUT PARAMETER\n       flag   -  Flag is true if MPI_Init has been called and false otherwise.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       initialize.c\n\n\n\n                                  11/14/2001                MPI_Initialized(3)", 
            "title": "MPI_Initialized.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_initmd", 
            "text": "MPI_Init(3)                           MPI                          MPI_Init(3)\n\n\n\nNAME\n       MPI_Init -  Initialize the MPI execution environment\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Init(int *argc, char ***argv)\n\nINPUT PARAMETERS\n       argc   - Pointer to the number of arguments\n       argv   - Pointer to the argument vector\n\n\nCOMMAND LINE ARGUMENTS\n       MPI specifies no command-line arguments but does allow an MPI implemen-\n       tation to make use of them.\n\n       -mpiqueue\n              - print out the state of the message queues when MPI_FINALIZE is\n              called.   All  processors print; the output may be hard to deci-\n              pher.  This is intended as a debugging aid.\n\n       -mpiversion\n              - print out the version of the implementation  (  not  of  MPI),\n              including the arguments that were used with configure.\n\n       -mpinice nn\n              -  Increments the nice value by nn (lowering the priority of the\n              program by nn ).  nn must be positive (except  for  root).   Not\n              all systems support this argument; those that do not will ignore\n              it.\n\n       -mpedbg\n              - Start a debugger in an xterm  window  if  there  is  an  error\n              (either detected by MPI or a normally fatal signal).  This works\n              only if MPICH was configured with -mpedbg .  CURRENTLY DISABLED.\n              If  you  have  TotalView, -mpichtv or mpirun -tv will give you a\n              better environment anyway.\n\n       -mpimem\n              - If MPICH was built with -DMPIR_DEBUG_MEM  ,  this  checks  all\n              malloc  and  free  operations  (internal  to MPICH) for signs of\n              injury to the memory allocation areas.\n\n       -mpidb options\n              - Activate various debugging options.  Some require  that  MPICH\n              have  been  built  with special options.  These are intended for\n              debugging MPICH, not for debugging user programs.  The available\n              options include:\n              mem     - Enable dynamic memory tracing of internal MPI objects\n              memall  - Generate output of all memory allocation/deallocation\n              ptr     - Enable tracing of internal MPI pointer conversions\n              rank n  - Limit subsequent -mpidb options to on the process with\n              the specified rank in MPI_COMM_WORLD.  A rank of -1\n              selects all of MPI_COMM_WORLD.\n              ref     - Trace use of internal MPI objects\n              reffile filename - Trace use of internal MPI objects with output\n              to the indicated file\n              trace   - Trace routine calls\n\n\n\nNOTES\n       Note  that  the  Fortran  binding  for  this routine has only the error\n       return argument ( MPI_INIT(ierror) )\n\n       Because the Fortran and C versions of MPI_Init are different, there  is\n       a  restriction  on  who can call MPI_Init .  The version (Fortran or C)\n       must match the main program.  That is, if the main  program  is  in  C,\n       then  the C version of MPI_Init must be called.  If the main program is\n       in Fortran, the Fortran version must be called.\n\n       On exit from this routine, all processes will have a copy of the  argu-\n       ment  list.   This  is  not  required  by  the MPI standard, and truely\n       portable codes should not rely on it.  This is provided as a service by\n       this implementation (an MPI implementation is allowed to distribute the\n       command line arguments but is not required to).\n\n       Command line arguments are not provided to Fortran programs.  More pre-\n       cisely,  non-standard  Fortran  routines  such as getarg and iargc have\n       undefined behavior in MPI and in this implementation.\n\n       The MPI standard does not say what a program can do before an  MPI_INIT\n       or  after an MPI_FINALIZE .  In the MPICH implementation, you should do\n       as little as possible.  In particular, avoid anything that changes  the\n       external  state of the program, such as opening files, reading standard\n       input or writing to standard output.\n\n\nSIGNALS USED\n       The MPI standard requires that all signals  used  be  documented.   The\n       MPICH  implementation  itself uses no signals, but some of the software\n       that MPICH relies on may use some signals.  The list below  is  partial\n       and  should  be  independantly checked if you (and any package that you\n       use) depend on particular signals.\n\n\nIBM POE/MPL FOR SP2\n       SIGHUP, SIGINT, SIGQUIT, SIGFPE, SIGSEGV,  SIGPIPE,  SIGALRM,  SIGTERM,\n       SIGIO\n\n\n-MPEDBG SWITCH\n       SIGQUIT, SIGILL, SIGFPE, SIGBUS, SIGSEGV, SIGSYS\n\n\nMEIKO CS2\n       SIGUSR2\n\n\nCH_P4 DEVICE\n       SIGUSR1\n\n       The ch_p4 device also catches SIGINT, SIGFPE, SIGBUS, and SIGSEGV; this\n       helps the p4 device (and MPICH) more gracefully abort a failed program.\n\n\nINTEL PARAGON (CH_NX AND NX DEVICE)\n       SIGUSR2\n\n\nSHARED MEMORY (CH_SHMEM DEVICE)\n       SIGCHLD\n\n       Note  that  if  you are using software that needs the same signals, you\n       may find that there is no way to use that software with the MPI  imple-\n       mentation.   The  signals  that cause the most trouble for applications\n       include SIGIO , SIGALRM , and SIGPIPE .  For example, using  SIGIO  and\n       SIGPIPE may prevent X11 routines from working.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_OTHER\n              - This error class is associated with an error code  that  indi-\n              cates  that  an attempt was made to call MPI_INIT a second time.\n              MPI_INIT may only be called once in a program.\n\nLOCATION\n       init.c\n\n\n\n                                   4/8/2002                        MPI_Init(3)", 
            "title": "MPI_Init.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_init_threadmd", 
            "text": "!DOCTYPE html PUBLIC  -//W3C//DTD XHTML 1.0 Transitional//EN   http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd  html xmlns= http://www.w3.org/1999/xhtml  head  meta http-equiv= Content-Type  content= text/html; charset=iso-8859-1  /  title 404 Not Found /title  /head  body  p strong HTTP 404 - Not Found /strong p / \n\nThe requested URL was not found on this server. /body  /html", 
            "title": "mpi_init_thread.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_intercomm_createmd", 
            "text": "MPI_Intercomm_create(3)               MPI              MPI_Intercomm_create(3)\n\n\n\nNAME\n       MPI_Intercomm_create  -  Creates an intercommuncator from two intracom-\n       municators\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Intercomm_create ( MPI_Comm local_comm, int local_leader,\n                                MPI_Comm peer_comm, int remote_leader, int tag,\n                                MPI_Comm *comm_out )\n\nINPUT PARAMTERS\n       local_comm\n              - Local (intra)communicator\n       local_leader\n              - Rank in local_comm of leader (often 0)\n       peer_comm\n              - Remote communicator\n       remote_leader\n              - Rank in peer_comm of remote leader (often 0)\n       tag    - Message tag to use in constructing intercommunicator; if  mul-\n              tiple MPI_Intercomm_creates are being made, they should use dif-\n              ferent tags (more precisely, ensure that the  local  and  remote\n              leaders  are  using different tags for each MPI_intercomm_create\n              ).\n\n\nOUTPUT PARAMETER\n       comm_out\n              - Created intercommunicator\n\n\nNOTES\n       The MPI 1.1 Standard contains two mutually exclusive  comments  on  the\n       input intracommunicators.  One says that their repective groups must be\n       disjoint; the other that the leaders can be the  same  process.   After\n       some  discussion  by the MPI Forum, it has been decided that the groups\n       must be disjoint.  Note that the reason given for this in the  standard\n       is  not  the  reason  for  this choice; rather, the other operations on\n       intercommunicators (like MPI_Intercomm_merge ) do not make sense if the\n       groups are not disjoint.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nALGORITHM\n       1) Allocate a send context, an inter\n              - coll context, and an intra-coll context\n       2) Send send_context and lrank_to_grank list from local comm group\n              - if I'm the local_leader.\n       3) If I'm the local leader, then wait on the posted sends and receives\n              - to complete.  Post the receive for the remote  group  informa-\n              tion and wait for it to complete.\n       4) Broadcast information received from the remote leader.\n              - . 5) Create the inter_communicator from the information we now\n              have.\n       An inter\n              - communicator ends up with three levels of communicators.   The\n              inter-communicator  returned  to the user, a  collective  inter-\n              communicator that can be used for  safe  communications  between\n              local    remote groups, and a collective intra-communicator that\n              can be used to allocate new contexts during the  merge  and  dup\n              operations.\n\n              For the resulting inter-communicator, comm_out\n\n\n              comm_out                       = inter-communicator\n              comm_out- comm_coll            =  collective  inter-communicator\n              comm_out- comm_coll- comm_coll = safe collective intra-communicator\n\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Intercomm_merge, MPI_Comm_free, MPI_Comm_remote_group,\n       MPI_Comm_remote_size\n\nLOCATION\n       ic_create.c\n\n\n\n                                  11/14/2001           MPI_Intercomm_create(3)", 
            "title": "MPI_Intercomm_create.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_intercomm_mergemd", 
            "text": "MPI_Intercomm_merge(3)                MPI               MPI_Intercomm_merge(3)\n\n\n\nNAME\n       MPI_Intercomm_merge  -  Creates an intracommuncator from an intercommu-\n       nicator\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Intercomm_merge ( MPI_Comm comm, int high, MPI_Comm *comm_out )\n\nINPUT PARAMETERS\n       comm   - Intercommunicator\n       high   - Used to order the groups of the two intracommunicators  within\n              comm when creating the new communicator.\n\n\nOUTPUT PARAMETER\n       comm_out\n              - Created intracommunicator\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nALGORITHM\n       1) Allocate two contexts\n       2) Local and remote group leaders swap high values\n       3) Determine the high value.\n       4) Merge the two groups and make the intra-communicator\n\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Intercomm_create, MPI_Comm_free\n\nLOCATION\n       ic_merge.c\n\n\n\n                                  11/14/2001            MPI_Intercomm_merge(3)", 
            "title": "MPI_Intercomm_merge.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_iprobemd", 
            "text": "MPI_Iprobe(3)                         MPI                        MPI_Iprobe(3)\n\n\n\nNAME\n       MPI_Iprobe -  Nonblocking test for a message\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Iprobe( int source, int tag, MPI_Comm comm, int *flag,\n                      MPI_Status *status )\n\nINPUT PARAMETERS\n       source - source rank, or MPI_ANY_SOURCE (integer)\n       tag    - tag value or MPI_ANY_TAG (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       flag   - (logical)\n       status - status object (Status)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       iprobe.c\n\n\n\n                                   12/7/2004                     MPI_Iprobe(3)", 
            "title": "MPI_Iprobe.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_irecvmd", 
            "text": "MPI_Irecv(3)                          MPI                         MPI_Irecv(3)\n\n\n\nNAME\n       MPI_Irecv -  Begins a nonblocking receive\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Irecv( void *buf, int count, MPI_Datatype datatype, int source,\n                      int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of receive buffer (choice)\n       count  - number of elements in receive buffer (integer)\n       datatype\n              - datatype of each receive buffer element (handle)\n       source - rank of source (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       irecv.c\n\n\n\n                                  11/14/2001                      MPI_Irecv(3)", 
            "title": "MPI_Irecv.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_irsendmd", 
            "text": "MPI_Irsend(3)                         MPI                        MPI_Irsend(3)\n\n\n\nNAME\n       MPI_Irsend -  Starts a nonblocking ready send\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Irsend( void *buf, int count, MPI_Datatype datatype, int dest,\n                      int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle) Output Parameter:\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nLOCATION\n       irsend.c\n\n\n\n                                  11/14/2001                     MPI_Irsend(3)", 
            "title": "MPI_Irsend.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_isendmd", 
            "text": "MPI_Isend(3)                          MPI                         MPI_Isend(3)\n\n\n\nNAME\n       MPI_Isend -  Begins a nonblocking send\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Isend( void *buf, int count, MPI_Datatype datatype, int dest, int tag,\n                      MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nLOCATION\n       isend.c\n\n\n\n                                  11/14/2001                      MPI_Isend(3)", 
            "title": "MPI_Isend.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_issendmd", 
            "text": "MPI_Issend(3)                         MPI                        MPI_Issend(3)\n\n\n\nNAME\n       MPI_Issend -  Starts a nonblocking synchronous send\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Issend( void *buf, int count, MPI_Datatype datatype, int dest,\n                      int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       issend.c\n\n\n\n                                  11/14/2001                     MPI_Issend(3)", 
            "title": "MPI_Issend.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_keyval_createmd", 
            "text": "MPI_Keyval_create(3)                  MPI                 MPI_Keyval_create(3)\n\n\n\nNAME\n       MPI_Keyval_create -  Generates a new attribute key\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Keyval_create (\n               MPI_Copy_function *copy_fn,\n               MPI_Delete_function *delete_fn,\n               int *keyval,\n               void *extra_state )\n\nINPUT PARAMETERS\n       copy_fn\n              - Copy callback function for keyval\n\n       delete_fn\n              - Delete callback function for keyval\n\n       extra_state\n              - Extra state for callback functions\n\n\nOUTPUT PARAMETER\n       keyval - key value for future access (integer)\n\n\nNOTES\n       Key values are global (available for any and all communicators).\n\n       There  are  subtle  differences between C and Fortran that require that\n       the copy_fn be written in the same language that  MPI_Keyval_create  is\n       called  from.   This  should not be a problem for most users; only pro-\n       gramers using both Fortran and C in the same program need  to  be  sure\n       that they follow this rule.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       keyvalcreate.c\n\n\n\n                                  11/14/2001              MPI_Keyval_create(3)", 
            "title": "MPI_Keyval_create.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_keyval_freemd", 
            "text": "MPI_Keyval_free(3)                    MPI                   MPI_Keyval_free(3)\n\n\n\nNAME\n       MPI_Keyval_free -  Frees attribute key for communicator cache attribute\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Keyval_free ( int *keyval )\n\nINPUT PARAMETER\n       keyval - Frees the integer key value (integer)\n\n\nNOTE\n       Key values are global (they can be used with any and all communicators)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_ARG\n              - This error class is associated with an error code  that  indi-\n              cates  that  an  attempt  was  made to free one of the permanent\n              keys.\n\n\nSEE ALSO\n       MPI_Keyval_create\n\nLOCATION\n       keyval_free.c\n\n\n\n                                   6/12/2002                MPI_Keyval_free(3)", 
            "title": "MPI_Keyval_free.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_op_createmd", 
            "text": "MPI_Op_create(3)                      MPI                     MPI_Op_create(3)\n\n\n\nNAME\n       MPI_Op_create -  Creates a user-defined combination function handle\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Op_create(\n               MPI_User_function *function,\n               int commute,\n               MPI_Op *op )\n\nINPUT PARAMETERS\n       function\n              - user defined function (function)\n       commute\n              - true if commutative;  false otherwise.\n\n\nOUTPUT PARAMETER\n       op     - operation (handle)\n\n\nNOTES ON THE USER FUNCTION\n       The calling list for the user function type is\n       typedef void (MPI_User_function) ( void * a,\n       void * b, int * len, MPI_Datatype * );\n\n       where  the  operation  is  b[i] = a[i] op b[i] , for i=0,...,len-1 .  A\n       pointer to the datatype given to the MPI collective computation routine\n       (i.e.,  MPI_Reduce , MPI_Allreduce , MPI_Scan , or MPI_Reduce_scatter )\n       is also passed to the user-specified routine.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The  reduction functions ( MPI_Op ) do not return an error value.  As a\n       result, if the functions detect an error, all they  can  do  is  either\n       call  MPI_Abort  or silently skip the problem.  Thus, if you change the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The  reason  for  this is the performance problems in ensuring that all\n       collective routines return the same error value.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Op_free\n\nLOCATION\n       opcreate.c\n\n\n\n                                  11/14/2001                  MPI_Op_create(3)", 
            "title": "MPI_Op_create.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_op_freemd", 
            "text": "MPI_Op_free(3)                        MPI                       MPI_Op_free(3)\n\n\n\nNAME\n       MPI_Op_free -  Frees a user-defined combination function handle\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Op_free( MPI_Op *op )\n\nINPUT PARAMETER\n       op     - operation (handle)\n\n\nNOTES\n       op is set to MPI_OP_NULL on exit.\n\n\nNULL HANDLES\n       The MPI 1.1 specification, in the section on opaque objects, explicitly\n\nDISALLOWS FREEING A NULL COMMUNICATOR. THE TEXT FROM THE STANDARD IS\n       A null handle argument is an erroneous IN argument in MPI calls, unless an\n       exception is explicitly stated in the text that defines the function. Such\n       exception is allowed for handles to request objects in Wait and Test calls\n       (sections Communication Completion and Multiple Completions ). Otherwise, a\n       null handle can only be passed to a function that allocates a new object and\n       returns a reference to it in the handle.\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_ARG\n              -  Invalid  argument;  the error code associated with this error\n              indicates an attempt to free an MPI permanent  operation  (e.g.,\n              MPI_SUM ).  *N/ /*N MPI_ERR_PERM_KEY\n       MPI_ERR_ARG\n              -  Invalid  argument;  the error code associated with this error\n              indicates an attempt to free or chnage an MPI  permanent  keyval\n              (e.g., MPI_TAG_UB ).  *N/ /*N MPI_ERR_UNKNOWN\n       MPI_ERR_UNKNOWN\n              -  Unknown error.  You should never see this.  If you do, report\n              it to mpi-bugs@mcs.anl.gov .\n\n\n\nSEE ALSO\n       MPI_Op_create\n\nLOCATION\n       opfree.c\n\n\n\n                                  11/14/2001                    MPI_Op_free(3)", 
            "title": "MPI_Op_free.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_packmd", 
            "text": "MPI_Pack(3)                           MPI                          MPI_Pack(3)\n\n\n\nNAME\n       MPI_Pack -  Packs a datatype into contiguous memory\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Pack ( void *inbuf, int incount, MPI_Datatype datatype,\n                      void *outbuf, int outcount, int *position, MPI_Comm comm )\n\nINPUT PARAMETERS\n       inbuf  - input buffer start (choice)\n       incount\n              - number of input data items (integer)\n       datatype\n              - datatype of each input data item (handle)\n       outcount\n              - output buffer size, in bytes (integer)\n       position\n              - current position in buffer, in bytes (integer)\n       comm   - communicator for packed message (handle)\n\n\nOUTPUT PARAMETER\n       outbuf - output buffer start (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Unpack, MPI_Pack_size\n\n\nLOCATION\n       pack.c\n\n\n\n                                  11/14/2001                       MPI_Pack(3)", 
            "title": "MPI_Pack.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_pack_sizemd", 
            "text": "MPI_Pack_size(3)                      MPI                     MPI_Pack_size(3)\n\n\n\nNAME\n       MPI_Pack_size  -  Returns the upper bound on the amount of space needed\n       to pack a message\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Pack_size ( int incount, MPI_Datatype datatype, MPI_Comm comm,\n                          int *size )\n\nINPUT PARAMETERS\n       incount\n              - count argument to packing call (integer)\n       datatype\n              - datatype argument to packing call (handle)\n       comm   - communicator argument to packing call (handle)\n\n\nOUTPUT PARAMETER\n       size   - upper bound on size of packed message, in bytes (integer)\n\n\nNOTES\n       The MPI standard document describes this in terms of MPI_Pack , but  it\n       applies  to  both MPI_Pack and MPI_Unpack .  That is, the value size is\n       the maximum that is needed by either MPI_Pack or MPI_Unpack .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nLOCATION\n       pack_size.c\n\n\n\n                                  11/14/2001                  MPI_Pack_size(3)", 
            "title": "MPI_Pack_size.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_pcontrolmd", 
            "text": "MPI_Pcontrol(3)                       MPI                      MPI_Pcontrol(3)\n\n\n\nNAME\n       MPI_Pcontrol -  Controls profiling\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Pcontrol( int level )\n\nINPUT PARAMETERS\n       level  - Profiling level\n\n\nNOTES\n       This  routine  provides  a common interface for profiling control.  The\n       interpretation of level and any other arguments is left to the  profil-\n       ing library.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       pcontrol.c\n\n\n\n                                  11/14/2001                   MPI_Pcontrol(3)", 
            "title": "MPI_Pcontrol.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_probemd", 
            "text": "MPI_Probe(3)                          MPI                         MPI_Probe(3)\n\n\n\nNAME\n       MPI_Probe -  Blocking test for a message\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Probe( int source, int tag, MPI_Comm comm, MPI_Status *status )\n\nINPUT PARAMETERS\n       source - source rank, or MPI_ANY_SOURCE (integer)\n       tag    - tag value or MPI_ANY_TAG (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       status - status object (Status)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       probe.c\n\n\n\n                                   12/7/2004                      MPI_Probe(3)", 
            "title": "MPI_Probe.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_recv_initmd", 
            "text": "MPI_Recv_init(3)                      MPI                     MPI_Recv_init(3)\n\n\n\nNAME\n       MPI_Recv_init -  Builds a handle for a receive\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Recv_init( void *buf, int count, MPI_Datatype datatype, int source,\n                         int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of receive buffer (choice)\n       count  - number of elements received (integer)\n       datatype\n              - type of each element (handle)\n       source - rank of source or MPI_ANY_SOURCE (integer)\n       tag    - message tag or MPI_ANY_TAG (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Start, MPI_Request_free\n\nLOCATION\n       create_recv.c\n\n\n\n                                  11/14/2001                  MPI_Recv_init(3)", 
            "title": "MPI_Recv_init.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_recvmd", 
            "text": "MPI_Recv(3)                           MPI                          MPI_Recv(3)\n\n\n\nNAME\n       MPI_Recv -  Basic receive\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Recv( void *buf, int count, MPI_Datatype datatype, int source,\n                     int tag, MPI_Comm comm, MPI_Status *status )\n\nOUTPUT PARAMETERS\n       buf    - initial address of receive buffer (choice)\n       status - status object (Status)\n\n\nINPUT PARAMETERS\n       count  - maximum number of elements in receive buffer (integer)\n       datatype\n              - datatype of each receive buffer element (handle)\n       source - rank of source (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES\n       The  count  argument  indicates  the  maximum  length of a message; the\n       actual number can be determined with MPI_Get_count .\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       recv.c\n\n\n\n                                   2/24/2004                       MPI_Recv(3)", 
            "title": "MPI_Recv.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_reducemd", 
            "text": "MPI_Reduce(3)                         MPI                        MPI_Reduce(3)\n\n\n\nNAME\n       MPI_Reduce -  Reduces values on all processes to a single value\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Reduce ( void *sendbuf, void *recvbuf, int count,\n                       MPI_Datatype datatype, MPI_Op op, int root, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - address of send buffer (choice)\n       count  - number of elements in send buffer (integer)\n       datatype\n              - data type of elements of send buffer (handle)\n       op     - reduce operation (handle)\n       root   - rank of root process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice, significant only at root )\n\n\nALGORITHM\n       This implementation currently uses a simple tree algorithm.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The reduction functions ( MPI_Op ) do not return an error value.  As  a\n       result,  if  the  functions  detect an error, all they can do is either\n       call MPI_Abort or silently skip the problem.  Thus, if you  change  the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The reason for this is the performance problems in  ensuring  that  all\n       collective routines return the same error value.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_BUFFER\n              - This error class is associcated with an error code that  indi-\n              cates  that  two  buffer  arguments  are  aliased ; that is, the\n              describe overlapping storage (often  the  exact  same  storage).\n              This  is prohibited in MPI (because it is prohibited by the For-\n              tran standard, and rather than have a separate case  for  C  and\n              Fortran, the MPI Forum adopted the more restrictive requirements\n              of Fortran).\n\nLOCATION\n       reduce.c\n\n\n\n                                   2/19/2002                     MPI_Reduce(3)", 
            "title": "MPI_Reduce.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_reduce_scattermd", 
            "text": "MPI_Reduce_scatter(3)                 MPI                MPI_Reduce_scatter(3)\n\n\n\nNAME\n       MPI_Reduce_scatter -  Combines values and scatters the results\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Reduce_scatter ( void *sendbuf, void *recvbuf, int *recvcnts,\n                              MPI_Datatype datatype, MPI_Op op, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       recvcounts\n              - integer array specifying the number of elements in result dis-\n              tributed to each process.  Array must be identical on all  call-\n              ing processes.\n       datatype\n              - data type of elements of input buffer (handle)\n       op     - operation (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - starting address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The reduction functions ( MPI_Op ) do not return an error value.  As  a\n       result,  if  the  functions  detect an error, all they can do is either\n       call MPI_Abort or silently skip the problem.  Thus, if you  change  the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The reason for this is the performance problems in  ensuring  that  all\n       collective routines return the same error value.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n       MPI_ERR_OP\n              - Invalid operation.  MPI operations (objects of type  MPI_Op  )\n              must either be one of the predefined operations (e.g., MPI_SUM )\n              or created with MPI_Op_create .\n\n       MPI_ERR_BUFFER\n              - This error class is associcated with an error code that  indi-\n              cates  that  two  buffer  arguments  are  aliased ; that is, the\n              describe overlapping storage (often  the  exact  same  storage).\n              This  is prohibited in MPI (because it is prohibited by the For-\n              tran standard, and rather than have a separate case  for  C  and\n              Fortran, the MPI Forum adopted the more restrictive requirements\n              of Fortran).\n\nLOCATION\n       red_scat.c\n\n\n\n                                  11/14/2001             MPI_Reduce_scatter(3)", 
            "title": "MPI_Reduce_scatter.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_request_freemd", 
            "text": "MPI_Request_free(3)                   MPI                  MPI_Request_free(3)\n\n\n\nNAME\n       MPI_Request_free -  Frees a communication request object\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Request_free( MPI_Request *request )\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES\n       This  routine is normally used to free persistent requests created with\n       either MPI_Recv_init or MPI_Send_init and friends.  However, it can  be\n       used to free a request created with MPI_Irecv or MPI_Isend and friends;\n       in that case the use can not use the test/wait routines on the request.\n\n       It  is  permitted  to free an active request.  However, once freed, you\n       can not use the request in a wait or test routine (e.g., MPI_Wait ).\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       also: MPI_Isend, MPI_Irecv, MPI_Issend, MPI_Ibsend, MPI_Irsend,\n       MPI_Recv_init, MPI_Send_init, MPI_Ssend_init, MPI_Rsend_init, MPI_Wait,\n       MPI_Test, MPI_Waitall, MPI_Waitany, MPI_Waitsome, MPI_Testall, MPI_Tes-\n       tany, MPI_Testsome\n\nLOCATION\n       commreq_free.c\n\n\n\n                                  11/14/2001               MPI_Request_free(3)", 
            "title": "MPI_Request_free.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_rsend_initmd", 
            "text": "MPI_Rsend_init(3)                     MPI                    MPI_Rsend_init(3)\n\n\n\nNAME\n       MPI_Rsend_init -  Builds a handle for a ready send\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Rsend_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                          int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Start, MPI_Request_free, MPI_Send_init\n\nLOCATION\n       rsend_init.c\n\n\n\n                                  11/14/2001                 MPI_Rsend_init(3)", 
            "title": "MPI_Rsend_init.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_rsendmd", 
            "text": "MPI_Rsend(3)                          MPI                         MPI_Rsend(3)\n\n\n\nNAME\n       MPI_Rsend -  Basic ready send\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Rsend( void *buf, int count, MPI_Datatype datatype, int dest,\n                      int tag, MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       rsend.c\n\n\n\n                                  11/14/2001                      MPI_Rsend(3)", 
            "title": "MPI_Rsend.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_scanmd", 
            "text": "MPI_Scan(3)                           MPI                          MPI_Scan(3)\n\n\n\nNAME\n       MPI_Scan -  Computes the scan (partial reductions) of data on a collec-\n       tion of processes\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Scan ( void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype,\n                      MPI_Op op, MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - starting address of send buffer (choice)\n       count  - number of elements in input buffer (integer)\n       datatype\n              - data type of elements of input buffer (handle)\n       op     - operation (handle)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - starting address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nNOTES ON COLLECTIVE OPERATIONS\n       The  reduction functions ( MPI_Op ) do not return an error value.  As a\n       result, if the functions detect an error, all they  can  do  is  either\n       call  MPI_Abort  or silently skip the problem.  Thus, if you change the\n       error handler from MPI_ERRORS_ARE_FATAL to something else, for example,\n       MPI_ERRORS_RETURN , then no error may be indicated.\n\n       The  reason  for  this is the performance problems in ensuring that all\n       collective routines return the same error value.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n       MPI_ERR_BUFFER\n              -  This error class is associcated with an error code that indi-\n              cates that two buffer arguments  are  aliased  ;  that  is,  the\n              describe  overlapping  storage  (often  the exact same storage).\n              This is prohibited in MPI (because it is prohibited by the  For-\n              tran  standard,  and  rather than have a separate case for C and\n              Fortran, the MPI Forum adopted the more restrictive requirements\n              of Fortran).\n\nLOCATION\n       scan.c\n\n\n\n                                  11/14/2001                       MPI_Scan(3)", 
            "title": "MPI_Scan.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_scattermd", 
            "text": "MPI_Scatter(3)                        MPI                       MPI_Scatter(3)\n\n\n\nNAME\n       MPI_Scatter -  Sends data from one task to all other tasks in a group\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Scatter (\n               void *sendbuf,\n               int sendcnt,\n               MPI_Datatype sendtype,\n               void *recvbuf,\n               int recvcnt,\n               MPI_Datatype recvtype,\n               int root,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - address of send buffer (choice, significant only at root )\n       sendcount\n              -  number of elements sent to each process (integer, significant\n              only at root )\n       sendtype\n              - data type of send buffer elements (significant only at root  )\n              (handle)\n       recvcount\n              - number of elements in receive buffer (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       root   - rank of sending process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              - Invalid buffer pointer.  Usually a null buffer  where  one  is\n              not valid.\n\nLOCATION\n       scatter.c\n\n\n\n                                   4/5/2004                     MPI_Scatter(3)", 
            "title": "MPI_Scatter.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_scattervmd", 
            "text": "MPI_Scatterv(3)                       MPI                      MPI_Scatterv(3)\n\n\n\nNAME\n       MPI_Scatterv -  Scatters a buffer in parts to all tasks in a group\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Scatterv (\n               void *sendbuf,\n               int *sendcnts,\n               int *displs,\n               MPI_Datatype sendtype,\n               void *recvbuf,\n               int recvcnt,\n               MPI_Datatype recvtype,\n               int root,\n               MPI_Comm comm )\n\nINPUT PARAMETERS\n       sendbuf\n              - address of send buffer (choice, significant only at root )\n       sendcounts\n              -  integer array (of length group size) specifying the number of\n              elements to send to each processor\n       displs - integer array (of length group size). Entry  i  specifies  the\n              displacement (relative to sendbuf  from which to take the outgo-\n              ing data to process i\n\n       sendtype\n              - data type of send buffer elements (handle)\n       recvcount\n              - number of elements in receive buffer (integer)\n       recvtype\n              - data type of receive buffer elements (handle)\n       root   - rank of sending process (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       recvbuf\n              - address of receive buffer (choice)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_BUFFER\n              -  Invalid  buffer  pointer.  Usually a null buffer where one is\n              not valid.\n\nLOCATION\n       scatterv.c\n\n\n\n                                   2/21/2002                   MPI_Scatterv(3)", 
            "title": "MPI_Scatterv.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_send_initmd", 
            "text": "MPI_Send_init(3)                      MPI                     MPI_Send_init(3)\n\n\n\nNAME\n       MPI_Send_init -  Builds a handle for a standard send\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Send_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                         int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle) Output Parameter:\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nSEE ALSO\n       MPI_Start, MPI_Startall, MPI_Request_free\n\nLOCATION\n       create_send.c\n\n\n\n                                  11/14/2001                  MPI_Send_init(3)", 
            "title": "MPI_Send_init.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_sendmd", 
            "text": "MPI_Send(3)                           MPI                          MPI_Send(3)\n\n\n\nNAME\n       MPI_Send -  Performs a basic send\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Send( void *buf, int count, MPI_Datatype datatype, int dest,\n                     int tag, MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES\n       This routine may block until the message is received.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\n\nSEE ALSO\n       MPI_Isend, MPI_Bsend\n\nLOCATION\n       send.c\n\n\n\n                                  11/14/2001                       MPI_Send(3)", 
            "title": "MPI_Send.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_sendrecvmd", 
            "text": "MPI_Sendrecv(3)                       MPI                      MPI_Sendrecv(3)\n\n\n\nNAME\n       MPI_Sendrecv -  Sends and receives a message\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Sendrecv( void *sendbuf, int sendcount, MPI_Datatype sendtype,\n                        int dest, int sendtag,\n                         void *recvbuf, int recvcount, MPI_Datatype recvtype,\n                        int source, int recvtag, MPI_Comm comm, MPI_Status *status )\n\nINPUT PARAMETERS\n       sendbuf\n              - initial address of send buffer (choice)\n       sendcount\n              - number of elements in send buffer (integer)\n       sendtype\n              - type of elements in send buffer (handle)\n       dest   - rank of destination (integer)\n       sendtag\n              - send tag (integer)\n       recvcount\n              - number of elements in receive buffer (integer)\n       recvtype\n              - type of elements in receive buffer (handle)\n       source - rank of source (integer)\n       recvtag\n              - receive tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETERS\n       recvbuf\n              - initial address of receive buffer (choice)\n       status - status object (Status).  This refers to the receive operation.\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              -  Invalid  tag  argument.  Tags must be non-negative; tags in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              - Invalid source or destination rank.   Ranks  must  be  between\n              zero  and  the  size  of  the communicator minus one; ranks in a\n              receive ( MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.)  may  also\n              be MPI_ANY_SOURCE .\n\n\n\nLOCATION\n       sendrecv.c\n\n\n\n                                  11/14/2001                   MPI_Sendrecv(3)", 
            "title": "MPI_Sendrecv.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_sendrecv_replacemd", 
            "text": "MPI_Sendrecv_replace(3)               MPI              MPI_Sendrecv_replace(3)\n\n\n\nNAME\n       MPI_Sendrecv_replace -  Sends and receives using a single buffer\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Sendrecv_replace( void *buf, int count, MPI_Datatype datatype,\n                               int dest, int sendtag, int source, int recvtag,\n                               MPI_Comm comm, MPI_Status *status )\n\nINPUT PARAMETERS\n       count  - number of elements in send and receive buffer (integer)\n       datatype\n              - type of elements in send and receive buffer (handle)\n       dest   - rank of destination (integer)\n       sendtag\n              - send message tag (integer)\n       source - rank of source (integer)\n       recvtag\n              - receive message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETERS\n       buf    - initial address of send and receive buffer (choice)\n       status - status object (Status)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n       MPI_ERR_TRUNCATE\n              - Message truncated on receive.  The buffer size  specified  was\n              too small for the received message.  This is a recoverable error\n              in the MPICH implementation.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\n\nLOCATION\n       sendrecv_rep.c\n\n\n\n                                  11/14/2001           MPI_Sendrecv_replace(3)", 
            "title": "MPI_Sendrecv_replace.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_ssend_initmd", 
            "text": "MPI_Ssend_init(3)                     MPI                    MPI_Ssend_init(3)\n\n\n\nNAME\n       MPI_Ssend_init -  Builds a handle for a synchronous send\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Ssend_init( void *buf, int count, MPI_Datatype datatype, int dest,\n                          int tag, MPI_Comm comm, MPI_Request *request )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements sent (integer)\n       datatype\n              - type of each element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       ssend_init.c\n\n\n\n                                  11/14/2001                 MPI_Ssend_init(3)", 
            "title": "MPI_Ssend_init.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_ssendmd", 
            "text": "MPI_Ssend(3)                          MPI                         MPI_Ssend(3)\n\n\n\nNAME\n       MPI_Ssend -  Basic synchronous send\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Ssend( void *buf, int count, MPI_Datatype datatype,\n                      int dest, int tag, MPI_Comm comm )\n\nINPUT PARAMETERS\n       buf    - initial address of send buffer (choice)\n       count  - number of elements in send buffer (nonnegative integer)\n       datatype\n              - datatype of each send buffer element (handle)\n       dest   - rank of destination (integer)\n       tag    - message tag (integer)\n       comm   - communicator (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_TAG\n              - Invalid tag argument.  Tags must be non-negative;  tags  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_TAG .  The largest tag value is available through the\n              the attribute MPI_TAG_UB .\n\n       MPI_ERR_RANK\n              -  Invalid  source  or  destination rank.  Ranks must be between\n              zero and the size of the communicator  minus  one;  ranks  in  a\n              receive  (  MPI_Recv , MPI_Irecv , MPI_Sendrecv , etc.) may also\n              be MPI_ANY_SOURCE .\n\n\nLOCATION\n       ssend.c\n\n\n\n                                  11/14/2001                      MPI_Ssend(3)", 
            "title": "MPI_Ssend.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_startallmd", 
            "text": "MPI_Startall(3)                       MPI                      MPI_Startall(3)\n\n\n\nNAME\n       MPI_Startall -  Starts a collection of requests\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Startall( int count, MPI_Request array_of_requests[] )\n\nINPUT PARAMETERS\n       count  - list length (integer)\n       array_of_requests\n              - array of requests (array of handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       startall.c\n\n\n\n                                  11/14/2001                   MPI_Startall(3)", 
            "title": "MPI_Startall.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_startmd", 
            "text": "MPI_Start(3)                          MPI                         MPI_Start(3)\n\n\n\nNAME\n       MPI_Start -  Initiates a communication with a persistent request handle\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Start(\n               MPI_Request *request)\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n\n\nLOCATION\n       start.c\n\n\n\n                                  11/14/2001                      MPI_Start(3)", 
            "title": "MPI_Start.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_testallmd", 
            "text": "MPI_Testall(3)                        MPI                       MPI_Testall(3)\n\n\n\nNAME\n       MPI_Testall  -   Tests  for  the completion of all previously initiated\n       communications\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Testall(\n               int count,\n               MPI_Request array_of_requests[],\n               int *flag,\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       count  - lists length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       flag   - (logical)\n       array_of_statuses\n              - array of status objects (array of Status).   May  be  MPI_STA-\n              TUSES_IGNORE .\n\n\n\nNOTES\n       flag  is  true only if all requests have completed.  Otherwise, flag is\n       false and neither the array_of_requests nor  the  array_of_statuses  is\n       modified.\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_IN_STATUS\n              -  The  actual  error value is in the MPI_Status argument.  This\n              error  class  is  returned  only  from  the  multiple-completion\n              routines  ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Wait-\n              all , MPI_Waitany , and MPI_Waitsome ).  The field MPI_ERROR  in\n              the  status argument contains the error value or MPI_SUCCESS (no\n              error and complete) or  MPI_ERR_PENDING  to  indicate  that  the\n              request  has  not  completed.  The MPI Standard does not specify\n              what the result of the multiple completion routines is  when  an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait for all requests to either fail or  complete,  or  does  it\n              return  immediately  (with  the  MPI  definition of immediately,\n              which means independent of  actions  of  other  MPI  processes)?\n              MPICH  has  chosen  to  make  the return immediate (alternately,\n              local in MPI terms), and to use the error class  MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.  In most cases, only one request with an error  will  be\n              detected  in  each  call  to  an MPI routine that tests multiple\n              requests.  The requests that have not been processed (because an\n              error  occured in one of the requests) will have their MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n\n\nLOCATION\n       testall.c\n\n\n\n                                   2/19/2003                    MPI_Testall(3)", 
            "title": "MPI_Testall.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_testanymd", 
            "text": "MPI_Testany(3)                        MPI                       MPI_Testany(3)\n\n\n\nNAME\n       MPI_Testany  -  Tests for completion of any previdously initiated  com-\n       munication\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Testany(\n               int count,\n               MPI_Request array_of_requests[],\n               int *index, int *flag,\n               MPI_Status *status )\n\nINPUT PARAMETERS\n       count  - list length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       index  - index of operation that completed, or  MPI_UNDEFINED  if  none\n              completed (integer)\n       flag   - true if one of the operations is complete (logical)\n       status - status object (Status).  May be MPI_STATUS_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n\nLOCATION\n       testany.c\n\n\n\n                                   1/9/2003                     MPI_Testany(3)", 
            "title": "MPI_Testany.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_test_cancelledmd", 
            "text": "MPI_Test_cancelled(3)                 MPI                MPI_Test_cancelled(3)\n\n\n\nNAME\n       MPI_Test_cancelled -  Tests to see if a request was cancelled\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Test_cancelled(\n               MPI_Status *status,\n               int        *flag)\n\nINPUT PARAMETER\n       status - status object (Status)\n\n\nOUTPUT PARAMETER\n       flag   - (logical)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       testcancel.c\n\n\n\n                                  11/14/2001             MPI_Test_cancelled(3)", 
            "title": "MPI_Test_cancelled.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_testmd", 
            "text": "MPI_Test(3)                           MPI                          MPI_Test(3)\n\n\n\nNAME\n       MPI_Test -  Tests for the completion of a send or receive\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Test (\n               MPI_Request  *request,\n               int          *flag,\n               MPI_Status   *status)\n\nINPUT PARAMETER\n       request\n              - communication request (handle)\n\n\nOUTPUT PARAMETER\n       flag   - true if operation completed (logical)\n       status - status object (Status).  May be MPI_STATUS_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              -  Invalid  MPI_Request  .   Either  null  or,  in the case of a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       test.c\n\n\n\n                                   1/9/2003                        MPI_Test(3)", 
            "title": "MPI_Test.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_testsomemd", 
            "text": "MPI_Testsome(3)                       MPI                      MPI_Testsome(3)\n\n\n\nNAME\n       MPI_Testsome -  Tests for some given communications to complete\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Testsome(\n               int incount,\n               MPI_Request array_of_requests[],\n               int *outcount,\n               int array_of_indices[],\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       incount\n              - length of array_of_requests (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       outcount\n              - number of completed requests (integer)\n       array_of_indices\n              -  array of indices of operations that completed (array of inte-\n              gers)\n       array_of_statuses\n              - array of status objects for operations that  completed  (array\n              of Status).  May be MPI_STATUSES_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_IN_STATUS\n              -  The  actual  error value is in the MPI_Status argument.  This\n              error  class  is  returned  only  from  the  multiple-completion\n              routines  ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Wait-\n              all , MPI_Waitany , and MPI_Waitsome ).  The field MPI_ERROR  in\n              the  status argument contains the error value or MPI_SUCCESS (no\n              error and complete) or  MPI_ERR_PENDING  to  indicate  that  the\n              request  has  not  completed.  The MPI Standard does not specify\n              what the result of the multiple completion routines is  when  an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait for all requests to either fail or  complete,  or  does  it\n              return  immediately  (with  the  MPI  definition of immediately,\n              which means independent of  actions  of  other  MPI  processes)?\n              MPICH  has  chosen  to  make  the return immediate (alternately,\n              local in MPI terms), and to use the error class  MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.  In most cases, only one request with an error  will  be\n              detected  in  each  call  to  an MPI routine that tests multiple\n              requests.  The requests that have not been processed (because an\n              error  occured in one of the requests) will have their MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n\n\nLOCATION\n       testsome.c\n\n\n\n                                   1/9/2003                    MPI_Testsome(3)", 
            "title": "MPI_Testsome.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_topo_testmd", 
            "text": "MPI_Topo_test(3)                      MPI                     MPI_Topo_test(3)\n\n\n\nNAME\n       MPI_Topo_test  -   Determines  the type of topology (if any) associated\n       with a  communicator\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Topo_test ( MPI_Comm comm, int *top_type )\n\nINPUT PARAMETER\n       comm   - communicator (handle)\n\n\nOUTPUT PARAMETER\n       top_type\n              - topology type of communicator comm (choice).\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              - Invalid communicator.  A common error is to use a null  commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Graph_create, MPI_Cart_create\n\nLOCATION\n       topo_test.c\n\n\n\n                                  11/14/2001                  MPI_Topo_test(3)", 
            "title": "MPI_Topo_test.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_commitmd", 
            "text": "MPI_Type_commit(3)                    MPI                   MPI_Type_commit(3)\n\n\n\nNAME\n       MPI_Type_commit -  Commits the datatype\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Type_commit ( MPI_Datatype *datatype )\n\nINPUT PARAMETER\n       datatype\n              - datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       type_commit.c\n\n\n\n                                  11/14/2001                MPI_Type_commit(3)", 
            "title": "MPI_Type_commit.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_contiguousmd", 
            "text": "MPI_Type_contiguous(3)                MPI               MPI_Type_contiguous(3)\n\n\n\nNAME\n       MPI_Type_contiguous -  Creates a contiguous datatype\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Type_contiguous(\n               int count,\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype)\n\nINPUT PARAMETERS\n       count  - replication count (nonnegative integer)\n       oldtype\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_contig.c\n\n\n\n                                  11/14/2001            MPI_Type_contiguous(3)", 
            "title": "MPI_Type_contiguous.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_extentmd", 
            "text": "MPI_Type_extent(3)                    MPI                   MPI_Type_extent(3)\n\n\n\nNAME\n       MPI_Type_extent -  Returns the extent of a datatype\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Type_extent( MPI_Datatype datatype, MPI_Aint *extent )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       extent - datatype extent (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n\nLOCATION\n       type_extent.c\n\n\n\n                                  11/14/2001                MPI_Type_extent(3)", 
            "title": "MPI_Type_extent.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_freemd", 
            "text": "MPI_Type_free(3)                      MPI                     MPI_Type_free(3)\n\n\n\nNAME\n       MPI_Type_free -  Frees the datatype\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Type_free ( MPI_Datatype *datatype )\n\nINPUT PARAMETER\n       datatype\n              - datatype that is freed (handle)\n\n\nPREDEFINED TYPES\n       The MPI standard states that (in Opaque Objects)\n       MPI provides certain predefined opaque objects and predefined, static handles\n       to these objects. Such objects may not be destroyed.\n\n\n       Thus,  it  is an error to free a predefined datatype.  The same section\n       makes it clear that it is an error to free a null datatype.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_free.c\n\n\n\n                                  11/14/2001                  MPI_Type_free(3)", 
            "title": "MPI_Type_free.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_hindexedmd", 
            "text": "MPI_Type_hindexed(3)                  MPI                 MPI_Type_hindexed(3)\n\n\n\nNAME\n       MPI_Type_hindexed -  Creates an indexed datatype with offsets in bytes\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Type_hindexed(\n               int count,\n               int blocklens[],\n               MPI_Aint indices[],\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  -  number  of  blocks  --  also number of entries in indices and\n              blocklens\n       blocklens\n              - number of elements in each block (array of  nonnegative  inte-\n              gers)\n       indices\n              - byte displacement of each block (array of MPI_Aint)\n       old_type\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       Also see the discussion for MPI_Type_indexed about the indices in  For-\n       tran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_hind.c\n\n\n\n                                   4/7/2003               MPI_Type_hindexed(3)", 
            "title": "MPI_Type_hindexed.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_hvectormd", 
            "text": "MPI_Type_hvector(3)                   MPI                  MPI_Type_hvector(3)\n\n\n\nNAME\n       MPI_Type_hvector  -  Creates a vector (strided) datatype with offset in\n       bytes\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Type_hvector(\n               int count,\n               int blocklen,\n               MPI_Aint stride,\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  - number of blocks (nonnegative integer)\n       blocklength\n              - number of elements in each block (nonnegative integer)\n       stride - number of bytes between start of each block (integer)\n       old_type\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_hvec.c\n\n\n\n                                  11/14/2001               MPI_Type_hvector(3)", 
            "title": "MPI_Type_hvector.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_indexedmd", 
            "text": "MPI_Type_indexed(3)                   MPI                  MPI_Type_indexed(3)\n\n\n\nNAME\n       MPI_Type_indexed -  Creates an indexed datatype\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Type_indexed(\n               int count,\n               int blocklens[],\n               int indices[],\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  -  number  of  blocks  --  also number of entries in indices and\n              blocklens\n       blocklens\n              - number of elements in each block (array of  nonnegative  inte-\n              gers)\n       indices\n              -  displacement of each block in multiples of old_type (array of\n              integers)\n       old_type\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n       The  indices are displacements, and are based on a zero origin.  A com-\n       mon error is to do something like to following\n       integer a(100)\n       integer blens(10), indices(10)\n       do i=1,10\n       blens(i)   = 1\n       10       indices(i) = 1 + (i-1)*10\n       call MPI_TYPE_INDEXED(10,blens,indices,MPI_INTEGER,newtype,ierr)\n       call MPI_TYPE_COMMIT(newtype,ierr)\n       call MPI_SEND(a,1,newtype,...)\n\n       expecting this to send a(1),a(11),...  because the indices have  values\n       1,11,...   .  Because these are displacements from the beginning of a ,\n       it actually sends a(1+1),a(1+11),...  .\n\n\n       If you wish to consider the displacements as  indices  into  a  Fortran\n       array, consider declaring the Fortran array with a zero origin\n       integer a(0:99)\n\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_ind.c\n\n\n\n                                  11/14/2001               MPI_Type_indexed(3)", 
            "title": "MPI_Type_indexed.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_lbmd", 
            "text": "MPI_Type_lb(3)                        MPI                       MPI_Type_lb(3)\n\n\n\nNAME\n       MPI_Type_lb -  Returns the lower-bound of a datatype\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Type_lb ( MPI_Datatype datatype, MPI_Aint *displacement )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       displacement\n              - displacement of lower bound from origin, in bytes (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_lb.c\n\n\n\n                                  11/14/2001                    MPI_Type_lb(3)", 
            "title": "MPI_Type_lb.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_sizemd", 
            "text": "MPI_Type_size(3)                      MPI                     MPI_Type_size(3)\n\n\n\nNAME\n       MPI_Type_size  -  Return the number of bytes occupied by entries in the\n       datatype\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Type_size ( MPI_Datatype datatype, int *size )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       size   - datatype size (integer)\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_size.c\n\n\n\n                                  11/14/2001                  MPI_Type_size(3)", 
            "title": "MPI_Type_size.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_structmd", 
            "text": "MPI_Type_struct(3)                    MPI                   MPI_Type_struct(3)\n\n\n\nNAME\n       MPI_Type_struct -  Creates a struct datatype\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Type_struct(\n               int count,\n               int blocklens[],\n               MPI_Aint indices[],\n               MPI_Datatype old_types[],\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  - number of blocks (integer) -- also number of entries in arrays\n              array_of_types  ,  array_of_displacements   and  array_of_block-\n              lengths\n       blocklens\n              - number of elements in each block (array)\n       indices\n              - byte displacement of each block (array)\n       old_types\n              -  type  of elements in each block (array of handles to datatype\n              objects)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES\n       If an upperbound is set explicitly by using the MPI datatype  MPI_UB  ,\n       the corresponding index must be positive.\n\n       The  MPI  standard  originally  made vague statements about padding and\n       alignment; this was intended to allow the simple definition  of  struc-\n       tures that could be sent with a count greater than one.  For example,\n       struct { int a; char b; } foo;\n\n       may  have  sizeof(foo)     sizeof(int)  +  sizeof(char)  ; for example,\n       sizeof(foo) == 2*sizeof(int) .  The initial version of the MPI standard\n       defined  the  extent  of  a datatype as including an epsilon that would\n       have allowed an implementation to make the extent an MPI  datatype  for\n       this structure equal to 2*sizeof(int) .\n\n       However, since different systems might define different paddings, there\n       was much discussion by the MPI Forum about what was the  correct  value\n       of  epsilon,  and  one  suggestion was to define epsilon as zero.  This\n       would have been the best thing to do in MPI 1.0, particularly since the\n       MPI_UB  type  allows  the  user to easily set the end of the structure.\n       Unfortunately, this change did not make it  into  the  final  document.\n       Currently,  this  routine does not add any padding, since the amount of\n       padding needed is determined by the compiler that the user is using  to\n       build  their  code, not the compiler used to construct the MPI library.\n       A later version of MPICH  may  provide  for  some  natural  choices  of\n       padding  (e.g.,  multiple of the size of the largest basic member), but\n       users are advised to never depend on this, even with vendor MPI  imple-\n       mentations.   Instead,  if  you define a structure datatype and wish to\n       send or receive multiple items, you should explicitly include an MPI_UB\n       entry  as the last member of the structure.  For example, the following\n       code can be used for the structure foo\n       blen[0] = 1; indices[0] = 0; oldtypes[0] = MPI_INT;\n       blen[1] = 1; indices[1] =  foo.b -  foo; oldtypes[1] = MPI_CHAR;\n       blen[2] = 1; indices[2] = sizeof(foo); oldtypes[2] = MPI_UB;\n       MPI_Type_struct( 3, blen, indices, oldtypes,  newtype );\n\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_INTERN\n              - This error is returned when some part of the MPICH implementa-\n              tion is unable to acquire memory.\n\nLOCATION\n       type_struct.c\n\n\n\n                                   7/12/2002                MPI_Type_struct(3)", 
            "title": "MPI_Type_struct.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_ubmd", 
            "text": "MPI_Type_ub(3)                        MPI                       MPI_Type_ub(3)\n\n\n\nNAME\n       MPI_Type_ub -  Returns the upper bound of a datatype\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Type_ub ( MPI_Datatype datatype, MPI_Aint *displacement )\n\nINPUT PARAMETERS\n       datatype\n              - datatype (handle)\n\n\nOUTPUT PARAMETER\n       displacement\n              - displacement of upper bound from origin, in bytes (integer)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       type_ub.c\n\n\n\n                                  11/14/2001                    MPI_Type_ub(3)", 
            "title": "MPI_Type_ub.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_type_vectormd", 
            "text": "MPI_Type_vector(3)                    MPI                   MPI_Type_vector(3)\n\n\n\nNAME\n       MPI_Type_vector -  Creates a vector (strided) datatype\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Type_vector(\n               int count,\n               int blocklen,\n               int stride,\n               MPI_Datatype old_type,\n               MPI_Datatype *newtype )\n\nINPUT PARAMETERS\n       count  - number of blocks (nonnegative integer)\n       blocklength\n              - number of elements in each block (nonnegative integer)\n       stride - number of elements between start of each block (integer)\n       oldtype\n              - old datatype (handle)\n\n\nOUTPUT PARAMETER\n       newtype\n              - new datatype (handle)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\nLOCATION\n       type_vec.c\n\n\n\n                                  11/14/2001                MPI_Type_vector(3)", 
            "title": "MPI_Type_vector.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_unpackmd", 
            "text": "MPI_Unpack(3)                         MPI                        MPI_Unpack(3)\n\n\n\nNAME\n       MPI_Unpack -  Unpack a datatype into contiguous memory\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Unpack ( void *inbuf, int insize, int *position,\n                       void *outbuf, int outcount, MPI_Datatype datatype,\n                       MPI_Comm comm )\n\nINPUT PARAMETERS\n       inbuf  - input buffer start (choice)\n       insize - size of input buffer, in bytes (integer)\n       position\n              - current position in bytes (integer)\n       outcount\n              - number of items to be unpacked (integer)\n       datatype\n              - datatype of each output data item (handle)\n       comm   - communicator for packed message (handle)\n\n\nOUTPUT PARAMETER\n       outbuf - output buffer start (choice)\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_COMM\n              -  Invalid communicator.  A common error is to use a null commu-\n              nicator in a call (not even allowed in MPI_Comm_rank ).\n       MPI_ERR_COUNT\n              - Invalid count argument.  Count arguments must be non-negative;\n              a count of zero is often valid.\n       MPI_ERR_TYPE\n              - Invalid datatype argument.  May be an uncommitted MPI_Datatype\n              (see MPI_Type_commit ).\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\n\nSEE ALSO\n       MPI_Pack, MPI_Pack_size\n\nLOCATION\n       unpack.c\n\n\n\n                                  11/14/2001                     MPI_Unpack(3)", 
            "title": "MPI_Unpack.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_waitallmd", 
            "text": "MPI_Waitall(3)                        MPI                       MPI_Waitall(3)\n\n\n\nNAME\n       MPI_Waitall -  Waits for all given communications to complete\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Waitall(\n               int count,\n               MPI_Request array_of_requests[],\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       count  - lists length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETER\n       array_of_statuses\n              -  array  of  status objects (array of Status).  May be MPI_STA-\n              TUSES_IGNORE\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For send operations, the only use of status is  for  MPI_Test_cancelled\n       or  in  the  case  that  there is an error, in which case the MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_IN_STATUS\n              - The actual error value is in the  MPI_Status  argument.   This\n              error  class  is returned only from the multiple-completion rou-\n              tines ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Waitall ,\n              MPI_Waitany  ,  and  MPI_Waitsome ).  The field MPI_ERROR in the\n              status argument contains the  error  value  or  MPI_SUCCESS  (no\n              error  and  complete)  or  MPI_ERR_PENDING  to indicate that the\n              request has not completed.  The MPI Standard  does  not  specify\n              what  the  result of the multiple completion routines is when an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait  for  all  requests  to either fail or complete, or does it\n              return immediately (with  the  MPI  definition  of  immediately,\n              which  means  independent  of  actions  of other MPI processes)?\n              MPICH has chosen to  make  the  return  immediate  (alternately,\n              local  in MPI terms), and to use the error class MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.   In  most cases, only one request with an error will be\n              detected in each call to an  MPI  routine  that  tests  multiple\n              requests.  The requests that have not been processed (because an\n              error occured in one of the requests) will have their  MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n       MPI_ERR_PENDING\n              - Pending request (not an error).  See MPI_ERR_IN_STATUS .\n\n              This  value indicates that the request is not complete nor has a\n              encountered a detected error.\n\nLOCATION\n       waitall.c\n\n\n\n                                   2/24/2004                    MPI_Waitall(3)", 
            "title": "MPI_Waitall.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_waitanymd", 
            "text": "MPI_Waitany(3)                        MPI                       MPI_Waitany(3)\n\n\n\nNAME\n       MPI_Waitany -  Waits for any specified send or receive to complete\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Waitany(\n               int count,\n               MPI_Request array_of_requests[],\n               int *index,\n               MPI_Status *status )\n\nINPUT PARAMETERS\n       count  - list length (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       index  -  index  of  handle for operation that completed (integer).  In\n              the range 0 to count-1 .  In Fortran, the range is 1 to count  .\n\n       status - status object (Status).  May be MPI_STATUS_IGNORE .\n\n\n\nNOTES\n       If all of the requests are MPI_REQUEST_NULL , then index is returned as\n       MPI_UNDEFINED , and status is returned as an empty status.\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For send operations, the only use of status is  for  MPI_Test_cancelled\n       or  in  the  case  that  there is an error, in which case the MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK )  have\n       an  additional  argument ierr at the end of the argument list.  ierr is\n       an integer and has the same meaning as the return value of the  routine\n       in  C.   In Fortran, MPI routines are subroutines, and are invoked with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All  MPI  routines  (except  MPI_Wtime  and MPI_Wtick ) return an error\n       value; C routines as the value of the function and Fortran routines  in\n       the last argument.  Before the value is returned, the current MPI error\n       handler is called.  By default, this error handler aborts the MPI  job.\n       The  error  handler may be changed with MPI_Errhandler_set ; the prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to  be  returned.  Note that MPI does not guarentee that an MPI program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              - Invalid MPI_Request .  Either  null  or,  in  the  case  of  a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       waitany.c\n\n\n\n                                   1/9/2003                     MPI_Waitany(3)", 
            "title": "MPI_Waitany.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_waitmd", 
            "text": "MPI_Wait(3)                           MPI                          MPI_Wait(3)\n\n\n\nNAME\n       MPI_Wait -  Waits for an MPI send or receive to complete\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Wait (\n               MPI_Request  *request,\n               MPI_Status   *status)\n\nINPUT PARAMETER\n       request\n              - request (handle)\n\n\nOUTPUT PARAMETER\n       status - status object (Status) .  May be MPI_STATUS_IGNORE .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              -  Invalid  MPI_Request  .   Either  null  or,  in the case of a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n\nLOCATION\n       wait.c\n\n\n\n                                   1/9/2003                        MPI_Wait(3)", 
            "title": "MPI_Wait.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_waitsomemd", 
            "text": "MPI_Waitsome(3)                       MPI                      MPI_Waitsome(3)\n\n\n\nNAME\n       MPI_Waitsome -  Waits for some given communications to complete\n\nSYNOPSIS\n       #include  mpi.h \n       int MPI_Waitsome(\n               int incount,\n               MPI_Request array_of_requests[],\n               int *outcount,\n               int array_of_indices[],\n               MPI_Status array_of_statuses[] )\n\nINPUT PARAMETERS\n       incount\n              - length of array_of_requests (integer)\n       array_of_requests\n              - array of requests (array of handles)\n\n\nOUTPUT PARAMETERS\n       outcount\n              - number of completed requests (integer)\n       array_of_indices\n              -  array of indices of operations that completed (array of inte-\n              gers)\n       array_of_statuses\n              - array of status objects for operations that  completed  (array\n              of Status).  May be MPI_STATUSES_IGNORE .\n\n\n\nNOTES\n       The  array  of  indicies are in the range 0 to incount - 1 for C and in\n       the range 1 to incount for Fortran.\n\n       Null requests are ignored; if all requests are null, then  the  routine\n       returns with outcount set to MPI_UNDEFINED .\n\n\n\nNOTE ON STATUS FOR SEND OPERATIONS\n       For  send  operations, the only use of status is for MPI_Test_cancelled\n       or in the case that there is an error,  in  which  case  the  MPI_ERROR\n       field of status will be set.\n\n\nNOTES FOR FORTRAN\n       All  MPI routines in Fortran (except for MPI_WTIME and MPI_WTICK ) have\n       an additional argument ierr at the end of the argument list.   ierr  is\n       an  integer and has the same meaning as the return value of the routine\n       in C.  In Fortran, MPI routines are subroutines, and are  invoked  with\n       the call statement.\n\n       All MPI objects (e.g., MPI_Datatype , MPI_Comm ) are of type INTEGER in\n       Fortran.\n\n\nERRORS\n       All MPI routines (except MPI_Wtime and  MPI_Wtick  )  return  an  error\n       value;  C routines as the value of the function and Fortran routines in\n       the last argument.  Before the value is returned, the current MPI error\n       handler  is called.  By default, this error handler aborts the MPI job.\n       The error handler may be changed with MPI_Errhandler_set ;  the  prede-\n       fined error handler MPI_ERRORS_RETURN may be used to cause error values\n       to be returned.  Note that MPI does not guarentee that an  MPI  program\n       can continue past an error.\n\n       MPI_SUCCESS\n              - No error; MPI routine completed successfully.\n       MPI_ERR_REQUEST\n              -  Invalid  MPI_Request  .   Either  null  or,  in the case of a\n              MPI_Start or MPI_Startall , not a persistent request.\n       MPI_ERR_ARG\n              - Invalid argument.  Some argument is invalid and is not identi-\n              fied by a specific error class (e.g., MPI_ERR_RANK ).\n       MPI_ERR_IN_STATUS\n              -  The  actual  error value is in the MPI_Status argument.  This\n              error class is returned only from the  multiple-completion  rou-\n              tines ( MPI_Testall , MPI_Testany , MPI_Testsome , MPI_Waitall ,\n              MPI_Waitany , and MPI_Waitsome ).  The field  MPI_ERROR  in  the\n              status  argument  contains  the  error  value or MPI_SUCCESS (no\n              error and complete) or  MPI_ERR_PENDING  to  indicate  that  the\n              request  has  not  completed.  The MPI Standard does not specify\n              what the result of the multiple completion routines is  when  an\n              error occurs.  For example, in an MPI_WAITALL , does the routine\n              wait for all requests to either fail or  complete,  or  does  it\n              return  immediately  (with  the  MPI  definition of immediately,\n              which means independent of  actions  of  other  MPI  processes)?\n              MPICH  has  chosen  to  make  the return immediate (alternately,\n              local in MPI terms), and to use the error class  MPI_ERR_PENDING\n              (introduced in MPI 1.1) to indicate which requests have not com-\n              pleted.  In most cases, only one request with an error  will  be\n              detected  in  each  call  to  an MPI routine that tests multiple\n              requests.  The requests that have not been processed (because an\n              error  occured in one of the requests) will have their MPI_ERROR\n              field marked with MPI_ERR_PENDING .\n\n\nLOCATION\n       waitsome.c\n\n\n\n                                   1/9/2003                    MPI_Waitsome(3)", 
            "title": "MPI_Waitsome.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_wtickmd", 
            "text": "MPI_Wtick(3)                          MPI                         MPI_Wtick(3)\n\n\n\nNAME\n       MPI_Wtick -  Returns the resolution of MPI_Wtime\n\nSYNOPSIS\n       #include  mpi.h \n       double MPI_Wtick()\n\nRETURN VALUE\n       Time in seconds of the resolution of MPI_Wtime .\n\n\nNOTES FOR FORTRAN\n       This  is  a  function, declared as DOUBLE PRECISION MPI_WTICK() in For-\n       tran.\n\n\nLOCATION\n       wtick.c\n\n\n\n                                   8/20/2004                      MPI_Wtick(3)", 
            "title": "MPI_Wtick.md"
        }, 
        {
            "location": "/Dev/MPI/MPI-Lib/#mpi_wtimemd", 
            "text": "MPI_Wtime(3)                          MPI                         MPI_Wtime(3)\n\n\n\nNAME\n       MPI_Wtime -  Returns an elapsed time on the calling processor\n\nSYNOPSIS\n       #include  mpi.h \n       double MPI_Wtime()\n\nRETURN VALUE\n       Time in seconds since an arbitrary time in the past.\n\n\nNOTES\n       This is intended to be a high-resolution, elapsed (or wall) clock.  See\n       MPI_WTICK to determine the resolution of MPI_WTIME .\n\n       If the attribute MPI_WTIME_IS_GLOBAL is  defined  and  true,  then  the\n       value is synchronized across all processes in MPI_COMM_WORLD .\n\n\n\nNOTES FOR FORTRAN\n       This  is  a  function, declared as DOUBLE PRECISION MPI_WTIME() in For-\n       tran.\n\n\nSEE ALSO\n       also: MPI_Wtick, MPI_Attr_get\n\nLOCATION\n       wtime.c\n\n\n\n                                  11/14/2001                      MPI_Wtime(3)", 
            "title": "MPI_Wtime.md"
        }, 
        {
            "location": "/Dev/Markdown/Markdown/", 
            "text": "Generate MD file from baunch of man files\n\n\nfor file in *.txt; do echo \n### $file\n \n result.md; echo '```' \n result.md; cat $file \n result.md; echo '```' \n result.md; echo \n result.md; done", 
            "title": "Markdown"
        }, 
        {
            "location": "/Dev/Markdown/Markdown/#generate-md-file-from-baunch-of-man-files", 
            "text": "for file in *.txt; do echo  ### $file    result.md; echo '```'   result.md; cat $file   result.md; echo '```'   result.md; echo   result.md; done", 
            "title": "Generate MD file from baunch of man files"
        }, 
        {
            "location": "/Dev/Power_Shell/Power_Shell/", 
            "text": "Windows 2008 Server R2\n\n\nTo release this error:\n\n\n\n\nScript cannot be loaded because the execution of scripts is disabled on this system.\n\n\n\n\n# Run as Administrator\nSet-ExecutionPolicy RemoteSigned\n\n# There is following parameters:\n# * Restricted - No scripts can be run. Windows PowerShell can be used only in interactive mode.\n# * AllSigned - Only scripts signed by a trusted publisher can be run.\n# * RemoteSigned - Downloaded scripts must be signed by a trusted publisher before they can be run.\n# * Unrestricted - No restrictions; all Windows PowerShell scripts can be run.\n\n\n\n\nShow current logged user\n\n\ngwmi win32_computersystem -comp $computer | select USername,Caption,Manufacturer\nGet_WmiObject win32_computersystem -comp $computer | select USername,Caption,Manufacturer\n\n\n\n\nList of logged in users (any user in any time)\n\n\nGet-WmiObject Win32_LoggedOnUser -ComputerName msk-sales-02 | Select __SERVER, Antecedent -Unique | %{\n{0} : {1}\\{2}\n -f $_.__SERVER, $_.Antecedent.ToString().Split('\n')[1],$_.Antecedent.ToString().Split('\n')[3]}\n\n\n\n\nRead from keyboard\n\n\n$variable=read-host \nEnter computer name:", 
            "title": "Power Shell"
        }, 
        {
            "location": "/Dev/Power_Shell/Power_Shell/#windows-2008-server-r2", 
            "text": "To release this error:   Script cannot be loaded because the execution of scripts is disabled on this system.   # Run as Administrator\nSet-ExecutionPolicy RemoteSigned\n\n# There is following parameters:\n# * Restricted - No scripts can be run. Windows PowerShell can be used only in interactive mode.\n# * AllSigned - Only scripts signed by a trusted publisher can be run.\n# * RemoteSigned - Downloaded scripts must be signed by a trusted publisher before they can be run.\n# * Unrestricted - No restrictions; all Windows PowerShell scripts can be run.", 
            "title": "Windows 2008 Server R2"
        }, 
        {
            "location": "/Dev/Power_Shell/Power_Shell/#show-current-logged-user", 
            "text": "gwmi win32_computersystem -comp $computer | select USername,Caption,Manufacturer\nGet_WmiObject win32_computersystem -comp $computer | select USername,Caption,Manufacturer", 
            "title": "Show current logged user"
        }, 
        {
            "location": "/Dev/Power_Shell/Power_Shell/#list-of-logged-in-users-any-user-in-any-time", 
            "text": "Get-WmiObject Win32_LoggedOnUser -ComputerName msk-sales-02 | Select __SERVER, Antecedent -Unique | %{ {0} : {1}\\{2}  -f $_.__SERVER, $_.Antecedent.ToString().Split(' ')[1],$_.Antecedent.ToString().Split(' ')[3]}", 
            "title": "List of logged in users (any user in any time)"
        }, 
        {
            "location": "/Dev/Power_Shell/Power_Shell/#read-from-keyboard", 
            "text": "$variable=read-host  Enter computer name:", 
            "title": "Read from keyboard"
        }, 
        {
            "location": "/Dev/Python/Users_and_groups/", 
            "text": "Print list of users with all user's groups\n\n\n#!/usr/bin/python\n\nimport re\n\n#cols\nc0 = 2      # Separator\nc1 = 10     # User\nc2 = 3      # Separator\nc3 = 10     # UID\nc4 = 3      # Separator\nc5 = 54     # Groups\nc6 = 2      # Separator\n\n\n\nf = open(\n/etc/passwd\n)\n\nt_len = c0+c1+c2+c3+c4+c5+c6\n\nprint \n-\n * t_len\nprint '{0:34}{1:48}{2:2}'.format(\n| \n,\nUsers and Groups\n,\n |\n)\nprint \n-\n * t_len\nprint '{0:2}{1:10}{2:3}{3:10}{4:3}{5:54}{6:2}'.format(\n| \n,\nUsername\n,\n | \n,\nUID\n,\n | \n,\nGroups\n,\n |\n)\n\nfor fline in f:\n    groups = []\n    h = open(\n/etc/group\n)\n    for hline in h:\n        if fline.split(\n:\n)[3] == hline.split(\n:\n)[2]:\n            groups.append(hline.split(\n:\n)[0])\n        if re.search(fline.split(\n:\n)[0],hline) is not None:\n            if not hline.split(\n:\n)[2] == fline.split(\n:\n)[3]:\n                groups.append(hline.split(\n:\n)[0])\n    h.close()\n    print '{0:2}{1:10}{2:3}{3:10}{4:3}{5:54}{6:2}'.format(\n| \n,fline.split(\n:\n)[0],\n | \n,fline.split(\n:\n)[2],\n | \n,\n,\n.join(groups),\n |\n)\n\nprint \n-\n * t_len\n\nf.close()", 
            "title": "Users and groups"
        }, 
        {
            "location": "/Dev/Python/Users_and_groups/#print-list-of-users-with-all-users-groups", 
            "text": "#!/usr/bin/python\n\nimport re\n\n#cols\nc0 = 2      # Separator\nc1 = 10     # User\nc2 = 3      # Separator\nc3 = 10     # UID\nc4 = 3      # Separator\nc5 = 54     # Groups\nc6 = 2      # Separator\n\n\n\nf = open( /etc/passwd )\n\nt_len = c0+c1+c2+c3+c4+c5+c6\n\nprint  -  * t_len\nprint '{0:34}{1:48}{2:2}'.format( |  , Users and Groups ,  | )\nprint  -  * t_len\nprint '{0:2}{1:10}{2:3}{3:10}{4:3}{5:54}{6:2}'.format( |  , Username ,  |  , UID ,  |  , Groups ,  | )\n\nfor fline in f:\n    groups = []\n    h = open( /etc/group )\n    for hline in h:\n        if fline.split( : )[3] == hline.split( : )[2]:\n            groups.append(hline.split( : )[0])\n        if re.search(fline.split( : )[0],hline) is not None:\n            if not hline.split( : )[2] == fline.split( : )[3]:\n                groups.append(hline.split( : )[0])\n    h.close()\n    print '{0:2}{1:10}{2:3}{3:10}{4:3}{5:54}{6:2}'.format( |  ,fline.split( : )[0],  |  ,fline.split( : )[2],  |  , , .join(groups),  | )\n\nprint  -  * t_len\n\nf.close()", 
            "title": "Print list of users with all user's groups"
        }, 
        {
            "location": "/Dev/Ruby/Installation/", 
            "text": "via RVM on Ubuntu\n\n\nsudo apt-get install libgdbm-dev libncurses5-dev automake libtool bison libffi-dev\ngpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\ncurl -sSL https://get.rvm.io | bash -s stable\nsource ~/.rvm/scripts/rvm\nrvm install 2.3.1\nrvm use 2.3.1 --default\nruby -v", 
            "title": "Installation"
        }, 
        {
            "location": "/Dev/Ruby/Installation/#via-rvm-on-ubuntu", 
            "text": "sudo apt-get install libgdbm-dev libncurses5-dev automake libtool bison libffi-dev\ngpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\ncurl -sSL https://get.rvm.io | bash -s stable\nsource ~/.rvm/scripts/rvm\nrvm install 2.3.1\nrvm use 2.3.1 --default\nruby -v", 
            "title": "via RVM on Ubuntu"
        }, 
        {
            "location": "/Dev/Stress_tests/Ackerman_function/", 
            "text": "C\n\n\n#include \nstdio.h\n\n\nint ackermann(int m, int n)\n{\n   if (!m) return n + 1;\n   if (!n) return ackermann(m - 1, 1);\n   return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main()\n{\n   int m, n;\n   for (m = 0; m \n= 4; m++)\n      for (n = 0; n \n 6 - m; n++)\n         printf(\nA(%d, %d) = %d\\n\n, m, n, ackermann(m, n));\n\n   return 0;\n}\n\n\n\n\nC++\n\n\n#include \niostream\n\n\nunsigned int ackermann(unsigned int m, unsigned int n) {\n  if (m == 0) {\n    return n + 1;\n  }\n  if (n == 0) {\n    return ackermann(m - 1, 1);\n  }\n  return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main() {\n  for (unsigned int m = 0; m \n 4; ++m) {\n    for (unsigned int n = 0; n \n 30; ++n) {\n      std::cout \n \nA(\n \n m \n \n, \n \n n \n \n) = \n \n ackermann(m, n) \n \n\\n\n;\n    }\n  }\n}", 
            "title": "Ackerman function"
        }, 
        {
            "location": "/Dev/Stress_tests/Ackerman_function/#c", 
            "text": "#include  stdio.h \n\nint ackermann(int m, int n)\n{\n   if (!m) return n + 1;\n   if (!n) return ackermann(m - 1, 1);\n   return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main()\n{\n   int m, n;\n   for (m = 0; m  = 4; m++)\n      for (n = 0; n   6 - m; n++)\n         printf( A(%d, %d) = %d\\n , m, n, ackermann(m, n));\n\n   return 0;\n}", 
            "title": "C"
        }, 
        {
            "location": "/Dev/Stress_tests/Ackerman_function/#c_1", 
            "text": "#include  iostream \n\nunsigned int ackermann(unsigned int m, unsigned int n) {\n  if (m == 0) {\n    return n + 1;\n  }\n  if (n == 0) {\n    return ackermann(m - 1, 1);\n  }\n  return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main() {\n  for (unsigned int m = 0; m   4; ++m) {\n    for (unsigned int n = 0; n   30; ++n) {\n      std::cout    A(    m    ,     n    ) =     ackermann(m, n)    \\n ;\n    }\n  }\n}", 
            "title": "C++"
        }, 
        {
            "location": "/Dev/Vbs/Kaspersky_Base_Actuality/", 
            "text": "With WMI query to get AVBasesStat path\n\n\n' VBscript:\n' Script to check actual date of Kaspersky Bases update\n' Author  : Dmitry Ivanov\n' Usage : C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo \nPath_TO\n\\kav.vbs\n'   NetXMS Agent config:\n'   ExternalParameterShellExec = KasperskyBasesState:C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo c:\\Path_TO\\kav.vbs\n\nOn Error Resume Next\n\nstrComputer     = \n.\n\nstrNamespace    = \n\\root\\CIMV2\n\nstrClass    = \nWin32_SoftwareElement\n\n\nSet objWMIService   = GetObject(\nwinmgmts:\\\\\n \n strComputer \n strNamespace) \nset colItems    = objWMIService.ExecQuery(_\n        \nSelect * from \n \n strClass \n Where Name='AVBasesStatComponent'\n, _\n        \nWQL\n, wbemFlagReturnImmediately + wbemFlagForwardOnly)\n\nkavStatFile   = colItems.ItemIndex(0).Path + \nkdb.stt\n\n\nConst FILE_READ   = 1\nSet objFSO    = CreateObject(\nScripting.FileSystemObject\n)\nSet objStatFile   = objFSO.OpenTextFile(kavStatFile, FILE_READ)\nkavBasesStatStr   = objStatFile.ReadLine\nkavBasesStatArr   = Split(kavBasesStatStr,\n;\n)\nkavBaseDateStr    = kavBasesStatArr(1)\n\ntheYear     = Mid(kavBaseDateStr, 1, 4)\ntheMonth    = Mid(kavBaseDateStr, 5, 2)\ntheDay      = Mid(kavBaseDateStr, 7, 2)\ntheHour     = Mid(kavBaseDateStr, 9, 2)\ntheMin      = Mid(kavBaseDateStr, 11, 2)\n\nkavBaseDate   = CDate(theDay \n \n/\n \n theMonth \n \n/\n \n theYear \n \n \n \n theHour \n \n:\n \n theMin)\ndateNow     = Now()\ndateTreshold    = DateAdd(\nH\n,-24, dateNow)\n\nIF dateNow \n kavBaseDate Then\n  Wscript.Echo \n!!!ERROR: Wrong time. Kaspersky bases from future! Check server timezone!\n\nElseIF dateTreshold \n kavBaseDate Then\n  Wscript.Echo \nYes\n\nElse\n  Wscript.Echo \nNo\n\nEnd If\n\nobjStatFile.close()\n\n\n' DEBUG\n'Wscript.Echo \nkavBaseDate: \n     \n kavBaseDate\n'Wscript.Echo \ndateNow: \n     \n dateNow\n'Wscript.Echo \nkavBaseDateStr: \n  \n kavBaseDateStr\n'Wscript.Echo \ndateTreshold \n     \n dateTreshold\n'Wscript.Echo \nIF: \n      \n dateTreshold \n kavBaseDate\n'Wscript.Echo \n\n\n\n\nHardcoded AVBasesStat path\n\n\n' VBscript:\n' Script to check actual date of Kaspersky Bases update\n' Author  : Dmitry Ivanov\n' Usage : C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo \nPath_TO\n\\kav.vbs\n'   NetXMS Agent config:\n'   ExternalParameterShellExec = KasperskyBasesState:C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo c:\\Path_TO\\kav.vbs\n\nOn Error Resume Next\n\nkavStatFile   = \nc:\\ProgramData\\Kaspersky Lab\\KAV for Windows Servers Enterprise Edition\\8.0\\Bases\\Current\\Stat\\kdb.stt\n\n\nConst FILE_READ   = 1\nSet objFSO    = CreateObject(\nScripting.FileSystemObject\n)\nSet objStatFile   = objFSO.OpenTextFile(kavStatFile, FILE_READ)\nkavBasesStatStr   = objStatFile.ReadLine\nkavBasesStatArr   = Split(kavBasesStatStr,\n;\n)\nkavBaseDateStr    = kavBasesStatArr(1)\n\ntheYear     = Mid(kavBaseDateStr, 1, 4)\ntheMonth    = Mid(kavBaseDateStr, 5, 2)\ntheDay      = Mid(kavBaseDateStr, 7, 2)\ntheHour     = Mid(kavBaseDateStr, 9, 2)\ntheMin      = Mid(kavBaseDateStr, 11, 2)\n\nkavBaseDate   = CDate(theDay \n \n/\n \n theMonth \n \n/\n \n theYear \n \n \n \n theHour \n \n:\n \n theMin)\ndateNow     = Now()\ndateTreshold    = DateAdd(\nH\n,-24, dateNow)\n\nIF dateNow \n kavBaseDate Then\n  Wscript.Echo \n!!!ERROR: Wrong time. Kaspersky bases from future! Check server timezone!\n\nElseIF dateTreshold \n kavBaseDate Then\n  Wscript.Echo \nYes\n\nElse\n  Wscript.Echo \nNo\n\nEnd If\n\nobjStatFile.close()\n\n\n' DEBUG\n'Wscript.Echo \nkavBaseDate: \n     \n kavBaseDate\n'Wscript.Echo \ndateNow: \n     \n dateNow\n'Wscript.Echo \nkavBaseDateStr: \n  \n kavBaseDateStr\n'Wscript.Echo \ndateTreshold \n     \n dateTreshold\n'Wscript.Echo \nIF: \n      \n dateTreshold \n kavBaseDate\n'Wscript.Echo", 
            "title": "Kaspersky Base Actuality"
        }, 
        {
            "location": "/Dev/Vbs/Kaspersky_Base_Actuality/#with-wmi-query-to-get-avbasesstat-path", 
            "text": "' VBscript:\n' Script to check actual date of Kaspersky Bases update\n' Author  : Dmitry Ivanov\n' Usage : C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo  Path_TO \\kav.vbs\n'   NetXMS Agent config:\n'   ExternalParameterShellExec = KasperskyBasesState:C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo c:\\Path_TO\\kav.vbs\n\nOn Error Resume Next\n\nstrComputer     =  . \nstrNamespace    =  \\root\\CIMV2 \nstrClass    =  Win32_SoftwareElement \n\nSet objWMIService   = GetObject( winmgmts:\\\\    strComputer   strNamespace) \nset colItems    = objWMIService.ExecQuery(_\n         Select * from     strClass   Where Name='AVBasesStatComponent' , _\n         WQL , wbemFlagReturnImmediately + wbemFlagForwardOnly)\n\nkavStatFile   = colItems.ItemIndex(0).Path +  kdb.stt \n\nConst FILE_READ   = 1\nSet objFSO    = CreateObject( Scripting.FileSystemObject )\nSet objStatFile   = objFSO.OpenTextFile(kavStatFile, FILE_READ)\nkavBasesStatStr   = objStatFile.ReadLine\nkavBasesStatArr   = Split(kavBasesStatStr, ; )\nkavBaseDateStr    = kavBasesStatArr(1)\n\ntheYear     = Mid(kavBaseDateStr, 1, 4)\ntheMonth    = Mid(kavBaseDateStr, 5, 2)\ntheDay      = Mid(kavBaseDateStr, 7, 2)\ntheHour     = Mid(kavBaseDateStr, 9, 2)\ntheMin      = Mid(kavBaseDateStr, 11, 2)\n\nkavBaseDate   = CDate(theDay    /    theMonth    /    theYear         theHour    :    theMin)\ndateNow     = Now()\ndateTreshold    = DateAdd( H ,-24, dateNow)\n\nIF dateNow   kavBaseDate Then\n  Wscript.Echo  !!!ERROR: Wrong time. Kaspersky bases from future! Check server timezone! \nElseIF dateTreshold   kavBaseDate Then\n  Wscript.Echo  Yes \nElse\n  Wscript.Echo  No \nEnd If\n\nobjStatFile.close()\n\n\n' DEBUG\n'Wscript.Echo  kavBaseDate:         kavBaseDate\n'Wscript.Echo  dateNow:         dateNow\n'Wscript.Echo  kavBaseDateStr:      kavBaseDateStr\n'Wscript.Echo  dateTreshold         dateTreshold\n'Wscript.Echo  IF:          dateTreshold   kavBaseDate\n'Wscript.Echo", 
            "title": "With WMI query to get AVBasesStat path"
        }, 
        {
            "location": "/Dev/Vbs/Kaspersky_Base_Actuality/#hardcoded-avbasesstat-path", 
            "text": "' VBscript:\n' Script to check actual date of Kaspersky Bases update\n' Author  : Dmitry Ivanov\n' Usage : C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo  Path_TO \\kav.vbs\n'   NetXMS Agent config:\n'   ExternalParameterShellExec = KasperskyBasesState:C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo c:\\Path_TO\\kav.vbs\n\nOn Error Resume Next\n\nkavStatFile   =  c:\\ProgramData\\Kaspersky Lab\\KAV for Windows Servers Enterprise Edition\\8.0\\Bases\\Current\\Stat\\kdb.stt \n\nConst FILE_READ   = 1\nSet objFSO    = CreateObject( Scripting.FileSystemObject )\nSet objStatFile   = objFSO.OpenTextFile(kavStatFile, FILE_READ)\nkavBasesStatStr   = objStatFile.ReadLine\nkavBasesStatArr   = Split(kavBasesStatStr, ; )\nkavBaseDateStr    = kavBasesStatArr(1)\n\ntheYear     = Mid(kavBaseDateStr, 1, 4)\ntheMonth    = Mid(kavBaseDateStr, 5, 2)\ntheDay      = Mid(kavBaseDateStr, 7, 2)\ntheHour     = Mid(kavBaseDateStr, 9, 2)\ntheMin      = Mid(kavBaseDateStr, 11, 2)\n\nkavBaseDate   = CDate(theDay    /    theMonth    /    theYear         theHour    :    theMin)\ndateNow     = Now()\ndateTreshold    = DateAdd( H ,-24, dateNow)\n\nIF dateNow   kavBaseDate Then\n  Wscript.Echo  !!!ERROR: Wrong time. Kaspersky bases from future! Check server timezone! \nElseIF dateTreshold   kavBaseDate Then\n  Wscript.Echo  Yes \nElse\n  Wscript.Echo  No \nEnd If\n\nobjStatFile.close()\n\n\n' DEBUG\n'Wscript.Echo  kavBaseDate:         kavBaseDate\n'Wscript.Echo  dateNow:         dateNow\n'Wscript.Echo  kavBaseDateStr:      kavBaseDateStr\n'Wscript.Echo  dateTreshold         dateTreshold\n'Wscript.Echo  IF:          dateTreshold   kavBaseDate\n'Wscript.Echo", 
            "title": "Hardcoded AVBasesStat path"
        }, 
        {
            "location": "/Dev/Vbs/Links/", 
            "text": "List of useful urls\n\n\n\n\nvbsedit", 
            "title": "Links"
        }, 
        {
            "location": "/Dev/Vbs/Links/#list-of-useful-urls", 
            "text": "vbsedit", 
            "title": "List of useful urls"
        }, 
        {
            "location": "/Dev/Version_Control/Git/", 
            "text": "Clone\n\n\n# For new repos(-jN - number of simltaniuos jobs):\ngit clone --recursive -j4 https://github.com/keepbot/dotfiles-srv\ngit clone --recursive https://github.com/keepbot/dotfiles-srv\n\n# For already cloned repos:\ngit submodule update --init --recursive\n\n# Ignore self signed ssl certificates\ngit -c http.sslVerify=false clone --recursive https://github.com/keepbot/dotfiles-srv.git\n\n\n\n\nGlobal settings\n\n\ngit config --global user.name \nYour Name\n\ngit config --global user.email your@e-mail.com\n\n\n\n\nCreate new repository\n\n\nmkdir -p \npath_to_repository\n\ncd \npath_to_repository\n\ngit add .\ngit commit -m \nInitialization\n\ngit remote add origin https://github.com/username/\nrepository\n.git\ngit push -u origin master\ngit checkout \n\n\n\n\nCommit\n\n\n# Addition of new files with automatic staging of deleted and modified files\ngit add .\ngit commit -a -m \nnew commentary\n\ngit push -u origin master\n\n\n\n\nUpdate local reposytory from remote\n\n\n# Fentch + Merge\ngit pull\n# Fetch only\ngit fetch\n# Fetch changes from remote repository with modified local repository\ngit commit -a -m \nnew commentary\n\ngit pull rebase\n# pull remote with overwrite local changes\ngit fetch --all\ngit reset --hard origin/master\n\n\n\n\nWorking with bunch of  repositories\n\n\n# Last commits\nfor d in `ls`; do cd $d; git log --pretty=format:\n%h - %an, %ar : %s\n -1; cd ..; done\n# Mass checkout\nfor d in `ls`; do cd $d; git checkout; cd ..; done\n\n\n\n\nMaking patches from commits:\n\n\n\n\nCreate patch:\n\n\n\n\n# The easiest version (you can specify number of commit to patch) \ngit format-patch -1 HEAD\n# Same as first, but create numbered files (00001-nnnnn)\ngit format-patch -n HEAD^\n# Simple cat ftom stdout, works fine on most of systems, but be carfull, if you have customized terminal (color tags, special symbols, etc.)\ngit show HEAD \n path_to.patch\n\n\n\n\n\n\nApply patch:\n\n\n\n\ngit apply --stat 0001-Linux-agent-LVM-subagent-initial-implementation.patch\ngit apply --check 0001-Linux-agent-LVM-subagent-initial-implementation.patch\ngit am \n 0001-Linux-agent-LVM-subagent-initial-implementation.patch\n\n\n\n\nSubmodules\n\n\n\n\nAdd submodule:\n\n\n\n\ngit submodule add \nsubmodule_git_url\n \nlocal_path\n\n\n\n\n\n\n\nDelete submodule:\n\n\n\n\ngit submodule deinit \nsubmodule\n    \ngit rm --cached \nsubmodule\n\nrm -rf .git/modules/\nsubmodule\n\n# Remove module record from .gitmodules\nvim .gitmodules\n\n\n\n\nLogs\n\n\ngit log --pretty=format:\n%h - %an, %ar : %s\n -1", 
            "title": "Git"
        }, 
        {
            "location": "/Dev/Version_Control/Git/#clone", 
            "text": "# For new repos(-jN - number of simltaniuos jobs):\ngit clone --recursive -j4 https://github.com/keepbot/dotfiles-srv\ngit clone --recursive https://github.com/keepbot/dotfiles-srv\n\n# For already cloned repos:\ngit submodule update --init --recursive\n\n# Ignore self signed ssl certificates\ngit -c http.sslVerify=false clone --recursive https://github.com/keepbot/dotfiles-srv.git", 
            "title": "Clone"
        }, 
        {
            "location": "/Dev/Version_Control/Git/#global-settings", 
            "text": "git config --global user.name  Your Name \ngit config --global user.email your@e-mail.com", 
            "title": "Global settings"
        }, 
        {
            "location": "/Dev/Version_Control/Git/#create-new-repository", 
            "text": "mkdir -p  path_to_repository \ncd  path_to_repository \ngit add .\ngit commit -m  Initialization \ngit remote add origin https://github.com/username/ repository .git\ngit push -u origin master\ngit checkout", 
            "title": "Create new repository"
        }, 
        {
            "location": "/Dev/Version_Control/Git/#commit", 
            "text": "# Addition of new files with automatic staging of deleted and modified files\ngit add .\ngit commit -a -m  new commentary \ngit push -u origin master", 
            "title": "Commit"
        }, 
        {
            "location": "/Dev/Version_Control/Git/#update-local-reposytory-from-remote", 
            "text": "# Fentch + Merge\ngit pull\n# Fetch only\ngit fetch\n# Fetch changes from remote repository with modified local repository\ngit commit -a -m  new commentary \ngit pull rebase\n# pull remote with overwrite local changes\ngit fetch --all\ngit reset --hard origin/master", 
            "title": "Update local reposytory from remote"
        }, 
        {
            "location": "/Dev/Version_Control/Git/#working-with-bunch-of-repositories", 
            "text": "# Last commits\nfor d in `ls`; do cd $d; git log --pretty=format: %h - %an, %ar : %s  -1; cd ..; done\n# Mass checkout\nfor d in `ls`; do cd $d; git checkout; cd ..; done", 
            "title": "Working with bunch of  repositories"
        }, 
        {
            "location": "/Dev/Version_Control/Git/#making-patches-from-commits", 
            "text": "Create patch:   # The easiest version (you can specify number of commit to patch) \ngit format-patch -1 HEAD\n# Same as first, but create numbered files (00001-nnnnn)\ngit format-patch -n HEAD^\n# Simple cat ftom stdout, works fine on most of systems, but be carfull, if you have customized terminal (color tags, special symbols, etc.)\ngit show HEAD   path_to.patch   Apply patch:   git apply --stat 0001-Linux-agent-LVM-subagent-initial-implementation.patch\ngit apply --check 0001-Linux-agent-LVM-subagent-initial-implementation.patch\ngit am   0001-Linux-agent-LVM-subagent-initial-implementation.patch", 
            "title": "Making patches from commits:"
        }, 
        {
            "location": "/Dev/Version_Control/Git/#submodules", 
            "text": "Add submodule:   git submodule add  submodule_git_url   local_path    Delete submodule:   git submodule deinit  submodule     \ngit rm --cached  submodule \nrm -rf .git/modules/ submodule \n# Remove module record from .gitmodules\nvim .gitmodules", 
            "title": "Submodules"
        }, 
        {
            "location": "/Dev/Version_Control/Git/#logs", 
            "text": "git log --pretty=format: %h - %an, %ar : %s  -1", 
            "title": "Logs"
        }, 
        {
            "location": "/Dev/Version_Control/GitHub/", 
            "text": "Independent history catalogs of git repositories\n\n\n# Makes a bunch of history folders formatted by the next way: \nrepository\n-\nnumber_of_commit\n-\ncommit_hash\n\n# Check commit_list.end for mistakes, you need simple list of commits\ngit clone \nrepository_url\n \nrepository\n\ncd \nrepository\n \n git log --pretty=format:\n%h\n \n ../commit_list \n cd ..\ntac commit_list \n commit_list.end \ni=1; for cid in `cat commit_list.end`; do cp -r \nrepository\n \nrepository\n-$i-$cid; cd \nrepository\n-$i-$cid; git checkout $cid; cd ..; ((i=i+1)); done\n\n\n\n\nClone all user's repositories\n\n\n# Get complete list of user's repositories in JSON file\ncurl -s https://api.github.com/users/\nusername\n/repos?per_page=200 \n repo.list.json\npython -c \nimport json,sys,os;file = open('repo.list.json' ,'r');obj = json.load(file);obj_size = len(obj);cmd = 'git clone  ';[os.system(cmd + obj[x]['clone_url']) for x in range(0, obj_size)];file.close()\n\n# And dont forget about \nspace\n(%20, \n \n) in cmd = 'git clone ', it's completely nessesary\n# Another way to clone up to 200 user's repos(just in shell): \ncurl -s https://api.github.com/users/keepbot/repos?per_page=200 | jq '.[] | .\nclone_url\n' | xargs -I '{}' git clone {}", 
            "title": "GitHub"
        }, 
        {
            "location": "/Dev/Version_Control/GitHub/#independent-history-catalogs-of-git-repositories", 
            "text": "# Makes a bunch of history folders formatted by the next way:  repository - number_of_commit - commit_hash \n# Check commit_list.end for mistakes, you need simple list of commits\ngit clone  repository_url   repository \ncd  repository    git log --pretty=format: %h    ../commit_list   cd ..\ntac commit_list   commit_list.end \ni=1; for cid in `cat commit_list.end`; do cp -r  repository   repository -$i-$cid; cd  repository -$i-$cid; git checkout $cid; cd ..; ((i=i+1)); done", 
            "title": "Independent history catalogs of git repositories"
        }, 
        {
            "location": "/Dev/Version_Control/GitHub/#clone-all-users-repositories", 
            "text": "# Get complete list of user's repositories in JSON file\ncurl -s https://api.github.com/users/ username /repos?per_page=200   repo.list.json\npython -c  import json,sys,os;file = open('repo.list.json' ,'r');obj = json.load(file);obj_size = len(obj);cmd = 'git clone  ';[os.system(cmd + obj[x]['clone_url']) for x in range(0, obj_size)];file.close() \n# And dont forget about  space (%20,    ) in cmd = 'git clone ', it's completely nessesary\n# Another way to clone up to 200 user's repos(just in shell): \ncurl -s https://api.github.com/users/keepbot/repos?per_page=200 | jq '.[] | . clone_url ' | xargs -I '{}' git clone {}", 
            "title": "Clone all user's repositories"
        }, 
        {
            "location": "/OS/AIX/", 
            "text": "Basic programs\n\n\nsh$ ftp ftp.software.ibm.com\n  Name\n ftp\n  Password\n your e-mail address\n  ftp\n cd aix/freeSoftware/aixtoolbox/RPMS/ppc/wget\n  ftp\n binary\n  ftp\n get wget-1.9.1-1.aix5.1.ppc.rpm\n  ftp\n quit\nsh$ rpm -hUv wget-1.9.1-1.aix5.1.ppc.rpm\nsh$ wget -r -nd ftp://ftp.software.ibm.com/aix/freeSoftware/aixtoolbox/ezinstall/ppc  \n\nsh$ ls\ngetapp-dev.sh       getgnome.base.sh    getkde3.all.sh\nXsession.kde        getbase.sh          getkde2.all.sh      getkde3.base.sh\nXsession.kde2       getdesktop.base.sh  getkde2.base.sh     getkde3.opt.sh\ngetgnome.apps.sh    getkde2.opt.sh      \n\nsh$ chmod +x get*.sh  \n\nsh$ cd base\nsh$ ls\nbash-3.2-1.aix5.2.ppc.rpm          rpm-3.0.5-52.aix5.3.ppc.rpm\nbzip2-1.0.5-3.aix5.3.ppc.rpm       rpm-build-3.0.5-52.aix5.3.ppc.rpm\ngettext-0.10.40-8.aix5.2.ppc.rpm   rpm-devel-3.0.5-52.aix5.3.ppc.rpm\ngzip-1.2.4a-10.aix5.2.ppc.rpm      tar-1.14-2.aix5.1.ppc.rpm\ninfo-4.6-1.aix5.1.ppc.rpm          unzip-5.51-1.aix5.1.ppc.rpm\npatch-2.5.4-4.aix4.3.ppc.rpm       \npopt-1.7-2.aix5.1.ppc.rpm\n\nsh$ rpm -hUv unzip-5.51-1.aix5.1.ppc.rpm\nsh$ rpm -hUv zip-2.3-3.aix4.3.ppc.rpm\nsh$ rpm -hUv bash-3.2-1.aix5.2.ppc.rpm\n\nsh$ bash\nbash-3.2# \n\n\n\n\nManagement\n\n\n# Exit from basic VIOS console to common AIX ksh\noem_setup_env\n# Adminitration and configuration console\nsmit\n\n#If you want to use bash as a login shell, you first have to add it to the\n#list of shells in /etc/security/login.cfg. \n#Then use `chsh` to change your individual setting.\n\n\n\n\nSoftware installation\n\n\ncd \npath_to_package\n\ninutoc .\ninstallp -aXY -d\npath_to_package\n all\n# Check if package is installed or not:\nlslpp -L \npackage_name\n\n\n\n\n\nMirroring rootvg\n\n\nextendvg rootvg hdisk1\nmirrorvg rootvg\nbootlist -m normal hdisk0 hdisk1 \nbosboot -ad hdisk0\nbosboot -ad hdisk1\n# Checking\nbootlist -o -m normal\n\n\n\n\nNetwork\n\n\nShared Ethernet adapter coming soon\n\n\n\n\nHardware\n\n\n# Refresh hardware configuration(aix and vios respectively):\ncfgmgr\ncfgdev\n# Rename hard drive:\nrendev -l \nold_name\n -n \nnew_name\n\nrendev -l hdisk3 -n hdisk33\n# Enable PVID:\nchdev -l hdiskX -a pv=yes\n# Change reserve policy to hard drive\nchdev -l hdiskX -a reserve_policy=no_reserve\n# Clear the owning volume manager from a disk\nchpv -C hdiskX\n\n\n\n\nVirtual devices\n\n\n# Checking all virtual mappings to particular vhost:\nlsmap -vadapter vhost\n# Make a virtual hard drive for particular vhost:\n# -f - flag to forcing device creation if you're making shared hard drive\nmkvdev [-f] -vdev hdiskX -vadapter vhostX -dev \nvirtual_device_name\n\n# Make a virtual cd-rom device for particular vhost:\nmkvdev -fbo -vadapter vhostX -dev \nvirtual_device_name\n\n\n\n\n\nZabbix agent\n\n\n# Dependencies:\nrpm -ivh ftp://www.oss4aix.org/latest/aix61/gettext-0.10.40-8.aix5.2.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/expat-2.1.0-1.aix5.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/libgcc-4.7.2-1.aix6.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/libffi-3.0.11-2.aix5.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/glib2-2.30.3-1.aix5.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/libiconv-1.14-2.aix5.1.ppc.rpm\n\n# Main\nmkgroup zabbix\nuseradd -g zabbix zabbix\n\nmkdir /var/run/zabbix\ntouch /var/run/zabbix/zabbix_agentd.pid\nmkdir /var/log/zabbix\ntouch /var/log/zabbix/zabbix_agentd.log\n\nchown -R zabbix:zabbix /var/log/zabbix\nchown -R zabbix:zabbix /var/run/zabbix\nchown zabbix:zabbix /etc/zabbix_agentd.conf\n\n/usr/sbin/zabbix_agentd --config /etc/zabbix_agentd.conf\n\nvi /etc/inittab\nzabagent:2:once:/usr/sbin/zabbix_agentd --config /etc/zabbix_agentd.conf", 
            "title": "AIX"
        }, 
        {
            "location": "/OS/AIX/#basic-programs", 
            "text": "sh$ ftp ftp.software.ibm.com\n  Name  ftp\n  Password  your e-mail address\n  ftp  cd aix/freeSoftware/aixtoolbox/RPMS/ppc/wget\n  ftp  binary\n  ftp  get wget-1.9.1-1.aix5.1.ppc.rpm\n  ftp  quit\nsh$ rpm -hUv wget-1.9.1-1.aix5.1.ppc.rpm\nsh$ wget -r -nd ftp://ftp.software.ibm.com/aix/freeSoftware/aixtoolbox/ezinstall/ppc  \n\nsh$ ls\ngetapp-dev.sh       getgnome.base.sh    getkde3.all.sh\nXsession.kde        getbase.sh          getkde2.all.sh      getkde3.base.sh\nXsession.kde2       getdesktop.base.sh  getkde2.base.sh     getkde3.opt.sh\ngetgnome.apps.sh    getkde2.opt.sh      \n\nsh$ chmod +x get*.sh  \n\nsh$ cd base\nsh$ ls\nbash-3.2-1.aix5.2.ppc.rpm          rpm-3.0.5-52.aix5.3.ppc.rpm\nbzip2-1.0.5-3.aix5.3.ppc.rpm       rpm-build-3.0.5-52.aix5.3.ppc.rpm\ngettext-0.10.40-8.aix5.2.ppc.rpm   rpm-devel-3.0.5-52.aix5.3.ppc.rpm\ngzip-1.2.4a-10.aix5.2.ppc.rpm      tar-1.14-2.aix5.1.ppc.rpm\ninfo-4.6-1.aix5.1.ppc.rpm          unzip-5.51-1.aix5.1.ppc.rpm\npatch-2.5.4-4.aix4.3.ppc.rpm       \npopt-1.7-2.aix5.1.ppc.rpm\n\nsh$ rpm -hUv unzip-5.51-1.aix5.1.ppc.rpm\nsh$ rpm -hUv zip-2.3-3.aix4.3.ppc.rpm\nsh$ rpm -hUv bash-3.2-1.aix5.2.ppc.rpm\n\nsh$ bash\nbash-3.2#", 
            "title": "Basic programs"
        }, 
        {
            "location": "/OS/AIX/#management", 
            "text": "# Exit from basic VIOS console to common AIX ksh\noem_setup_env\n# Adminitration and configuration console\nsmit\n\n#If you want to use bash as a login shell, you first have to add it to the\n#list of shells in /etc/security/login.cfg. \n#Then use `chsh` to change your individual setting.", 
            "title": "Management"
        }, 
        {
            "location": "/OS/AIX/#software-installation", 
            "text": "cd  path_to_package \ninutoc .\ninstallp -aXY -d path_to_package  all\n# Check if package is installed or not:\nlslpp -L  package_name", 
            "title": "Software installation"
        }, 
        {
            "location": "/OS/AIX/#mirroring-rootvg", 
            "text": "extendvg rootvg hdisk1\nmirrorvg rootvg\nbootlist -m normal hdisk0 hdisk1 \nbosboot -ad hdisk0\nbosboot -ad hdisk1\n# Checking\nbootlist -o -m normal", 
            "title": "Mirroring rootvg"
        }, 
        {
            "location": "/OS/AIX/#network", 
            "text": "Shared Ethernet adapter coming soon", 
            "title": "Network"
        }, 
        {
            "location": "/OS/AIX/#hardware", 
            "text": "# Refresh hardware configuration(aix and vios respectively):\ncfgmgr\ncfgdev\n# Rename hard drive:\nrendev -l  old_name  -n  new_name \nrendev -l hdisk3 -n hdisk33\n# Enable PVID:\nchdev -l hdiskX -a pv=yes\n# Change reserve policy to hard drive\nchdev -l hdiskX -a reserve_policy=no_reserve\n# Clear the owning volume manager from a disk\nchpv -C hdiskX", 
            "title": "Hardware"
        }, 
        {
            "location": "/OS/AIX/#virtual-devices", 
            "text": "# Checking all virtual mappings to particular vhost:\nlsmap -vadapter vhost\n# Make a virtual hard drive for particular vhost:\n# -f - flag to forcing device creation if you're making shared hard drive\nmkvdev [-f] -vdev hdiskX -vadapter vhostX -dev  virtual_device_name \n# Make a virtual cd-rom device for particular vhost:\nmkvdev -fbo -vadapter vhostX -dev  virtual_device_name", 
            "title": "Virtual devices"
        }, 
        {
            "location": "/OS/AIX/#zabbix-agent", 
            "text": "# Dependencies:\nrpm -ivh ftp://www.oss4aix.org/latest/aix61/gettext-0.10.40-8.aix5.2.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/expat-2.1.0-1.aix5.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/libgcc-4.7.2-1.aix6.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/libffi-3.0.11-2.aix5.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/glib2-2.30.3-1.aix5.1.ppc.rpm\nrpm -ivh ftp://www.oss4aix.org/compatible/aix61/libiconv-1.14-2.aix5.1.ppc.rpm\n\n# Main\nmkgroup zabbix\nuseradd -g zabbix zabbix\n\nmkdir /var/run/zabbix\ntouch /var/run/zabbix/zabbix_agentd.pid\nmkdir /var/log/zabbix\ntouch /var/log/zabbix/zabbix_agentd.log\n\nchown -R zabbix:zabbix /var/log/zabbix\nchown -R zabbix:zabbix /var/run/zabbix\nchown zabbix:zabbix /etc/zabbix_agentd.conf\n\n/usr/sbin/zabbix_agentd --config /etc/zabbix_agentd.conf\n\nvi /etc/inittab\nzabagent:2:once:/usr/sbin/zabbix_agentd --config /etc/zabbix_agentd.conf", 
            "title": "Zabbix agent"
        }, 
        {
            "location": "/OS/Android/", 
            "text": "Boot device into bootloader mode\n\n\nadb reboot bootloader\n\n\n\n\nFlash new bootloader\n\n\nfastboot flash bootloader bootloader-flounder-3.44.1.0123.img\nfastboot reboot-bootloader\n\n\n\n\nFlash full system\n\n\nfastboot flash boot boot.img\nfastboot flash cache cache.img\nfastboot flash recovery recovery.img\nfastboot flash system system.img\nfastboot flash vendor vendor.img", 
            "title": "Android"
        }, 
        {
            "location": "/OS/Android/#boot-device-into-bootloader-mode", 
            "text": "adb reboot bootloader", 
            "title": "Boot device into bootloader mode"
        }, 
        {
            "location": "/OS/Android/#flash-new-bootloader", 
            "text": "fastboot flash bootloader bootloader-flounder-3.44.1.0123.img\nfastboot reboot-bootloader", 
            "title": "Flash new bootloader"
        }, 
        {
            "location": "/OS/Android/#flash-full-system", 
            "text": "fastboot flash boot boot.img\nfastboot flash cache cache.img\nfastboot flash recovery recovery.img\nfastboot flash system system.img\nfastboot flash vendor vendor.img", 
            "title": "Flash full system"
        }, 
        {
            "location": "/OS/ArchLinux/", 
            "text": "Pacman\n\n\n# Search for software\npacman -Ss \npattern\n\n# Install package\npacman -S \npackage_name\n\n# Update the system\npacman -Syu\n# Remove orphaned packages (Be careful, double check for list of deleted packages)\npacman -Rscn $(pacman -Qtdq)\npacman -Sc\npacman-optimize \n sync\n\n\n\n\nAUR package installation\n\n\ngit clone https://aur.archlinux.org/\npackiage_name\n\ncd \npackage_name\n\nmakepkg -sri\n\n# In case of error like:\n# \npackage\n.tar.gz ... FAILED (unknown public key 0000000000000000)\ngpg --recv-key 0000000000000000\n# Or manually check key and skip key verification vith makepkg\npacman-key --verify \nsig_file\n\nmakepkg --skippgpcheck -sri", 
            "title": "ArchLinux"
        }, 
        {
            "location": "/OS/ArchLinux/#pacman", 
            "text": "# Search for software\npacman -Ss  pattern \n# Install package\npacman -S  package_name \n# Update the system\npacman -Syu\n# Remove orphaned packages (Be careful, double check for list of deleted packages)\npacman -Rscn $(pacman -Qtdq)\npacman -Sc\npacman-optimize   sync", 
            "title": "Pacman"
        }, 
        {
            "location": "/OS/ArchLinux/#aur-package-installation", 
            "text": "git clone https://aur.archlinux.org/ packiage_name \ncd  package_name \nmakepkg -sri\n\n# In case of error like:\n#  package .tar.gz ... FAILED (unknown public key 0000000000000000)\ngpg --recv-key 0000000000000000\n# Or manually check key and skip key verification vith makepkg\npacman-key --verify  sig_file \nmakepkg --skippgpcheck -sri", 
            "title": "AUR package installation"
        }, 
        {
            "location": "/OS/Debian/", 
            "text": "Apt\n\n\n# Show installed packages\napt --installed list\n# Search for software\napt-cache search \npattern\n\n# Install package\napt-get install \npackage_name\n\n\n\n\n\nDpkg\n\n\n# To get a list of packages installed locally do this in your terminal:\ndpkg --get-selections | grep -v deinstall\n# To get a list of a specific package installed:\ndpkg --get-selections | grep postgres\n# To save that list to a text file called packages on your desktop do this in your terminal:\ndpkg --get-selections | grep -v deinstall \n ~/Desktop/packages\n# Alternatively, simply use\ndpkg -l", 
            "title": "Debian"
        }, 
        {
            "location": "/OS/Debian/#apt", 
            "text": "# Show installed packages\napt --installed list\n# Search for software\napt-cache search  pattern \n# Install package\napt-get install  package_name", 
            "title": "Apt"
        }, 
        {
            "location": "/OS/Debian/#dpkg", 
            "text": "# To get a list of packages installed locally do this in your terminal:\ndpkg --get-selections | grep -v deinstall\n# To get a list of a specific package installed:\ndpkg --get-selections | grep postgres\n# To save that list to a text file called packages on your desktop do this in your terminal:\ndpkg --get-selections | grep -v deinstall   ~/Desktop/packages\n# Alternatively, simply use\ndpkg -l", 
            "title": "Dpkg"
        }, 
        {
            "location": "/OS/FreeBSD/", 
            "text": "Build own kernel\n\n\n# /usr/src/sys/i386/conf  - kernel config\ncd /usr/src\nmake buildkernel KERNCONF=MYKERNEL\nmake installkernel KERNCONF=MYKERNEL", 
            "title": "FreeBSD"
        }, 
        {
            "location": "/OS/FreeBSD/#build-own-kernel", 
            "text": "# /usr/src/sys/i386/conf  - kernel config\ncd /usr/src\nmake buildkernel KERNCONF=MYKERNEL\nmake installkernel KERNCONF=MYKERNEL", 
            "title": "Build own kernel"
        }, 
        {
            "location": "/OS/MacOS_X/", 
            "text": "Activate root\n\n\n\n\nPress \nCommand + Shift + G\n and enter\n\n\n\n\n/System/Library/CoreServices/\n\n\n\n\n\n\nInside launch \nDirectory Utility\n\n\nUnlock utility by clicking on \npadlock icon\n\n\nClick on menu \nEdit\n -\n \nEnable Root User\n\n\nEnter and confirm root password to enable root account", 
            "title": "MacOS X"
        }, 
        {
            "location": "/OS/MacOS_X/#activate-root", 
            "text": "Press  Command + Shift + G  and enter   /System/Library/CoreServices/   Inside launch  Directory Utility  Unlock utility by clicking on  padlock icon  Click on menu  Edit  -   Enable Root User  Enter and confirm root password to enable root account", 
            "title": "Activate root"
        }, 
        {
            "location": "/OS/RHEL/", 
            "text": "Yum\n\n\n# Search for software\nyum search \npattern\n\n# Install package\nyum install \npackage_name\n\n# Repair \nError: database disk image is malformed\n\nyum clean dbcache\n# Clean all yum cache\nyum clean all\n\n# Remove packages with dependencies:\n#add \nclean_requirements_on_remove=1\n to /etc/yum.conf", 
            "title": "RHEL"
        }, 
        {
            "location": "/OS/RHEL/#yum", 
            "text": "# Search for software\nyum search  pattern \n# Install package\nyum install  package_name \n# Repair  Error: database disk image is malformed \nyum clean dbcache\n# Clean all yum cache\nyum clean all\n\n# Remove packages with dependencies:\n#add  clean_requirements_on_remove=1  to /etc/yum.conf", 
            "title": "Yum"
        }, 
        {
            "location": "/Unix-way/Backup/TSM/", 
            "text": "Queries\n\n\n# Check backup\nq ev * * \n\n# Check path\nq path \n\n# Check drive\nq dri \n\n# Status\nq stat\n\n# Tape status\nq vol\n\n# Check volumes in the tape library                                                                 \nq libvol\n\n# Check processes\nq pro\n\n# Cancel process\ncan pro\u00a0(\nprocess\n)\n\n# Check pools\nq stg\n\n# Check working sessions\nq sess\n\n# Cancel session\ncan sess\u00a0(\nsession\n)\n\n# Shedule backup\nq eve domain name schedulename\n\n# Viwe assigned nodes in a Tivoli server\nq node\n\n# Check backup space utilized for each file system of a server\nq filespace\n\n# View activity log\nq actlog\nq act begind=mm/dd/yyyy begint=hh:mm:ss endd= mm/dd/yyyy endt=hh:mm:ss\nq act begind=today-1 begint=00:00\nq act search=transferred begint=00:00\nq act search=nodenam\n\n# Get detailed drive report\nq drive f=d\n\n# Get detailed information about tape library\nq library f=d\n\n# Get requests\nq req\n# Reply to request \nreply\u00a0(\nrequest\n)\n\n# Schedule\nq sched\nq sched f=d\nq sched * type=admin f=d\n\n\n\n\n\nUnload tape\n\n\nConfigure Library \u2192 Drive \u2192 []Power ON\nConfigure Library \u2192 Drive \u2192 [X]Power ON\nWait for 5 minutes until tape will be rewinded\n# Move tape to empty slot\nManage Library \u2192 Move Media \n\n\n\n\nHow to get logs\n\n\n# Library logs\nService \u2192 View Logs\nSave Service Dump\n\n# Drive logs\nService Library \u2192 Save Drive Dump\n\n\n\n\nChanges\n\n\n# Path (set online)\n#Drive1:\nUPD PATH TSM DRIVE01 SRCT=SERVer DESTT=DRIVE LIBR=TS3100 ONL=Y\n#Drive2:\nUPD PATH TSM DRIVE02 SRCT=SERVer DESTT=DRIVE LIBR=TS3100 ONL=Y\n\n# Update drive status to online\nupdate path sourceservername TAPE0 srct=server destt=drive libr=ts3200 online=yes\n\n# Drive (set online)\n#Drive1:\nUPD DRI TS3100 DRIVE01 ONL=Y\n#Drive2:\nUPD DRI TS3100 DRIVE02 ONL=Y\n\n# Change a library volume ( L41117L4 ) status to scratch from private\nUPDATE LIBVOLUME TS3200 L41117L4 STATUS=SCRATCH\n\n# Change a tivoli login password of a node\nupdate node nodename \nadmin\n domain=domainname forcepwreset=Yes\n\n# Add new tape L41116L4 to a storagepool\ndefine vol storagepoolname L41116L4\n\n# Delete data inside a tape media L41116L4\ndelete volume L41116L4 discarddata=yes\n\n# Set serial number of a drive in tape library\nUPDATE DRIVE TS3200 TAPE0 ELEMENT=autodetect ONLINE=Yes WWN=\n2002000E11107B6C\n SERIAL=autodetect\n\n# Detect label of a tape in tape library\nlabel libvol t3200 checkin=scratch labelsource=barcode search=bulk waittime=0\n\n# Remove tape media from tape library\ncheckout libvol ts3200 VOLLIST=A00015L3,A00019L3 CHECKLABEL=YES REMOVE=YES\n\n# Add and label new tapes into library\nLABEL libvol TS3200 search=yes labelsource=barcode overwrite=NO checkin=SCRATCH WAITTIME=0\n\n# Assign a tape drive to a server\nUPDATE PATH servername TAPE0 SRCTYPE=SERVER DESTTYPE=DRIVE LIBRARY=TS3200 DEVICE=\\\\.\\Tape0 ONLINE=YES AUTODETECT=no\n\n\n\n\nCreating backups\n\n\n# Create a new schedule backup (incremental) for a node\nUPDATE SCHEDULE domainname nodename desc=\ndaily incremental backup for a server\n action=Incremental options=-subdir=yes objects=\n/fs1/*\n \n/fs2/*\n \n/home/user1/*\n priority=5startdate=mm/dd/yyyy starttime=hh:mm duration=1 duru=Houperiod=1 perunits=Day dayofweek=Any expiration=never\n\n# Full backup of Tivoli database manually to file on local disk\nbackup db dev=FILECLASS type=full\n\n\n\n\nStartup\n\n\n# Start Tivoly on AIX\ncd /usr/tivoli/tsm/client/ba/bin\nnohup dsmc sched \n\nnohup dsmcad\u00a0\n\n\ncd /usr/tivoli/tsm/StorageAgent/bin\nnohup ./dsmsta\u00a0\n\n\nps -ef | grep dsm\n\n\n\n\nIf tape is not shown\n\n\ncheckin libvolume TS3100 search=yes status=scratch \u00a0 \u00a0 \u00a0\u00a0\ncheckin libvolume TS3100 search=yes status=private", 
            "title": "TSM"
        }, 
        {
            "location": "/Unix-way/Backup/TSM/#queries", 
            "text": "# Check backup\nq ev * * \n\n# Check path\nq path \n\n# Check drive\nq dri \n\n# Status\nq stat\n\n# Tape status\nq vol\n\n# Check volumes in the tape library                                                                 \nq libvol\n\n# Check processes\nq pro\n\n# Cancel process\ncan pro\u00a0( process )\n\n# Check pools\nq stg\n\n# Check working sessions\nq sess\n\n# Cancel session\ncan sess\u00a0( session )\n\n# Shedule backup\nq eve domain name schedulename\n\n# Viwe assigned nodes in a Tivoli server\nq node\n\n# Check backup space utilized for each file system of a server\nq filespace\n\n# View activity log\nq actlog\nq act begind=mm/dd/yyyy begint=hh:mm:ss endd= mm/dd/yyyy endt=hh:mm:ss\nq act begind=today-1 begint=00:00\nq act search=transferred begint=00:00\nq act search=nodenam\n\n# Get detailed drive report\nq drive f=d\n\n# Get detailed information about tape library\nq library f=d\n\n# Get requests\nq req\n# Reply to request \nreply\u00a0( request )\n\n# Schedule\nq sched\nq sched f=d\nq sched * type=admin f=d", 
            "title": "Queries"
        }, 
        {
            "location": "/Unix-way/Backup/TSM/#unload-tape", 
            "text": "Configure Library \u2192 Drive \u2192 []Power ON\nConfigure Library \u2192 Drive \u2192 [X]Power ON\nWait for 5 minutes until tape will be rewinded\n# Move tape to empty slot\nManage Library \u2192 Move Media", 
            "title": "Unload tape"
        }, 
        {
            "location": "/Unix-way/Backup/TSM/#how-to-get-logs", 
            "text": "# Library logs\nService \u2192 View Logs\nSave Service Dump\n\n# Drive logs\nService Library \u2192 Save Drive Dump", 
            "title": "How to get logs"
        }, 
        {
            "location": "/Unix-way/Backup/TSM/#changes", 
            "text": "# Path (set online)\n#Drive1:\nUPD PATH TSM DRIVE01 SRCT=SERVer DESTT=DRIVE LIBR=TS3100 ONL=Y\n#Drive2:\nUPD PATH TSM DRIVE02 SRCT=SERVer DESTT=DRIVE LIBR=TS3100 ONL=Y\n\n# Update drive status to online\nupdate path sourceservername TAPE0 srct=server destt=drive libr=ts3200 online=yes\n\n# Drive (set online)\n#Drive1:\nUPD DRI TS3100 DRIVE01 ONL=Y\n#Drive2:\nUPD DRI TS3100 DRIVE02 ONL=Y\n\n# Change a library volume ( L41117L4 ) status to scratch from private\nUPDATE LIBVOLUME TS3200 L41117L4 STATUS=SCRATCH\n\n# Change a tivoli login password of a node\nupdate node nodename  admin  domain=domainname forcepwreset=Yes\n\n# Add new tape L41116L4 to a storagepool\ndefine vol storagepoolname L41116L4\n\n# Delete data inside a tape media L41116L4\ndelete volume L41116L4 discarddata=yes\n\n# Set serial number of a drive in tape library\nUPDATE DRIVE TS3200 TAPE0 ELEMENT=autodetect ONLINE=Yes WWN= 2002000E11107B6C  SERIAL=autodetect\n\n# Detect label of a tape in tape library\nlabel libvol t3200 checkin=scratch labelsource=barcode search=bulk waittime=0\n\n# Remove tape media from tape library\ncheckout libvol ts3200 VOLLIST=A00015L3,A00019L3 CHECKLABEL=YES REMOVE=YES\n\n# Add and label new tapes into library\nLABEL libvol TS3200 search=yes labelsource=barcode overwrite=NO checkin=SCRATCH WAITTIME=0\n\n# Assign a tape drive to a server\nUPDATE PATH servername TAPE0 SRCTYPE=SERVER DESTTYPE=DRIVE LIBRARY=TS3200 DEVICE=\\\\.\\Tape0 ONLINE=YES AUTODETECT=no", 
            "title": "Changes"
        }, 
        {
            "location": "/Unix-way/Backup/TSM/#creating-backups", 
            "text": "# Create a new schedule backup (incremental) for a node\nUPDATE SCHEDULE domainname nodename desc= daily incremental backup for a server  action=Incremental options=-subdir=yes objects= /fs1/*   /fs2/*   /home/user1/*  priority=5startdate=mm/dd/yyyy starttime=hh:mm duration=1 duru=Houperiod=1 perunits=Day dayofweek=Any expiration=never\n\n# Full backup of Tivoli database manually to file on local disk\nbackup db dev=FILECLASS type=full", 
            "title": "Creating backups"
        }, 
        {
            "location": "/Unix-way/Backup/TSM/#startup", 
            "text": "# Start Tivoly on AIX\ncd /usr/tivoli/tsm/client/ba/bin\nnohup dsmc sched  \nnohup dsmcad\u00a0 \n\ncd /usr/tivoli/tsm/StorageAgent/bin\nnohup ./dsmsta\u00a0 \n\nps -ef | grep dsm", 
            "title": "Startup"
        }, 
        {
            "location": "/Unix-way/Backup/TSM/#if-tape-is-not-shown", 
            "text": "checkin libvolume TS3100 search=yes status=scratch \u00a0 \u00a0 \u00a0\u00a0\ncheckin libvolume TS3100 search=yes status=private", 
            "title": "If tape is not shown"
        }, 
        {
            "location": "/Unix-way/Backup/Tape/", 
            "text": "Rewind tape drive\n\n\nmt -f /dev/st0 rewind\n\n\n\n\nBackup directory\n\n\ntar -czvf /dev/st0 /\ndirectory_for_backup\n\n\n\n\n\nList files on tape\n\n\ntar -tzf /dev/st0\n\n\n\n\nRestore\n\n\nmt -f /dev/st0 rewind\ntar -xzf /dev/st0 \nfile_or_dir_to_restore\n\n\n\n\n\nUnload\n\n\nmt -f /dev/st0 offline\n\n\n\n\nStatus\n\n\nmt -f /dev/st0 status\n\n\n\n\nErase\n\n\nmt -f /dev/st0 erase\n\n\n\n\nGet position\n\n\nmt -f /dev/st0 tell\n\n\n\n\nMoves\n\n\n# End\nmt -f /dev/nst0 eod\n# Previous\nmt -f /dev/nst0 bsfm 1\n# Next\nmt -f /dev/nst0 fsf 1", 
            "title": "Tape"
        }, 
        {
            "location": "/Unix-way/Backup/Tape/#rewind-tape-drive", 
            "text": "mt -f /dev/st0 rewind", 
            "title": "Rewind tape drive"
        }, 
        {
            "location": "/Unix-way/Backup/Tape/#backup-directory", 
            "text": "tar -czvf /dev/st0 / directory_for_backup", 
            "title": "Backup directory"
        }, 
        {
            "location": "/Unix-way/Backup/Tape/#list-files-on-tape", 
            "text": "tar -tzf /dev/st0", 
            "title": "List files on tape"
        }, 
        {
            "location": "/Unix-way/Backup/Tape/#restore", 
            "text": "mt -f /dev/st0 rewind\ntar -xzf /dev/st0  file_or_dir_to_restore", 
            "title": "Restore"
        }, 
        {
            "location": "/Unix-way/Backup/Tape/#unload", 
            "text": "mt -f /dev/st0 offline", 
            "title": "Unload"
        }, 
        {
            "location": "/Unix-way/Backup/Tape/#status", 
            "text": "mt -f /dev/st0 status", 
            "title": "Status"
        }, 
        {
            "location": "/Unix-way/Backup/Tape/#erase", 
            "text": "mt -f /dev/st0 erase", 
            "title": "Erase"
        }, 
        {
            "location": "/Unix-way/Backup/Tape/#get-position", 
            "text": "mt -f /dev/st0 tell", 
            "title": "Get position"
        }, 
        {
            "location": "/Unix-way/Backup/Tape/#moves", 
            "text": "# End\nmt -f /dev/nst0 eod\n# Previous\nmt -f /dev/nst0 bsfm 1\n# Next\nmt -f /dev/nst0 fsf 1", 
            "title": "Moves"
        }, 
        {
            "location": "/Unix-way/Common/Audit/", 
            "text": "Why is my server rebooted?\n\n\nlast reboot \nsudo lastcomm | egrep 'reboot|shutdown'\nwho -b\nsa\ncrontab -e\nless /var/log/secure\nlast -x | less\nlast -x | grep shutdown | less\nless /var/log/messages\njournalctl\nutmpdump /var/log/wtmp | egrep 'shutdown|reboot|runlevel'\njournalctl --since=\n2016-6-28 12:00:00\n\n\n\n\n\nFork: Resource temporarily unavailable on AIX\n\n\nTo investigate the promles you need to run thei bunch of commands:\n\n\ncat /etc/passwd\n\n\n\n\nFrom root you need to look at limint of every active user:\n\n\nulimit -a\nsu oracle -c \nulimit -a\n\nsu mongod -c \nulimit -a\n\nsu userX -c \nulimit -a\n\n\n\n\n\nLook at system wide defined limits:\n\n\ncat /etc/security/limits\n\n\n\n\nLook at kernel parameters, especially on \nmaxuproc\n\n\nlsattr -El sys0\n\n\n\n\nLook at count of running processes by user:\n\n\nps -f -l -uroot | wc -l\nps -f -l -uoracle | wc -l\nps -f -l -umongod | wc -l\nps -f -l -uuserX | wc -l\n\n\n\n\nAnd after all look at avaible mamory and swap:\n\n\nsvmon -G -O unit=MB", 
            "title": "Audit"
        }, 
        {
            "location": "/Unix-way/Common/Audit/#why-is-my-server-rebooted", 
            "text": "last reboot \nsudo lastcomm | egrep 'reboot|shutdown'\nwho -b\nsa\ncrontab -e\nless /var/log/secure\nlast -x | less\nlast -x | grep shutdown | less\nless /var/log/messages\njournalctl\nutmpdump /var/log/wtmp | egrep 'shutdown|reboot|runlevel'\njournalctl --since= 2016-6-28 12:00:00", 
            "title": "Why is my server rebooted?"
        }, 
        {
            "location": "/Unix-way/Common/Audit/#fork-resource-temporarily-unavailable-on-aix", 
            "text": "To investigate the promles you need to run thei bunch of commands:  cat /etc/passwd  From root you need to look at limint of every active user:  ulimit -a\nsu oracle -c  ulimit -a \nsu mongod -c  ulimit -a \nsu userX -c  ulimit -a   Look at system wide defined limits:  cat /etc/security/limits  Look at kernel parameters, especially on  maxuproc  lsattr -El sys0  Look at count of running processes by user:  ps -f -l -uroot | wc -l\nps -f -l -uoracle | wc -l\nps -f -l -umongod | wc -l\nps -f -l -uuserX | wc -l  And after all look at avaible mamory and swap:  svmon -G -O unit=MB", 
            "title": "Fork: Resource temporarily unavailable on AIX"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/", 
            "text": "Change permisions recursively\n\n\nYou can use a simple \nScript\n\n\nfind \npath_to_folder\n -type f -print -exec chmod 644 {} \\;\nfind \npath_to_folder\n -type d -print -exec chmod 755 {} \\;\n\n# Union\nfind /home/tmp -type f -print -exec chmod 644 {} \\; \n find /home/tmp  -type d -print -exec chmod 755 {} \\;\n\n\n\n\nCount files\n\n\nfind . -type f | wc -l\nls | wc -l\n\n\n\n\nRemove file list\n\n\nls | xargs rm\n\n\n\n\nRemove file suffix \"filename\"+\"suffix\"\n\n\nfor i in `find . -type f -name \n*\nsuffix\n*\n`; do dst=`echo $i | sed s/\nsuffix\n//`;mv $i $dst; done\n\n\n\n\nMove all files in one level directory in certain folder to another\n\n\nfind /\npath_to_folder\n/* -prune -type f | xargs -I '{}' mv {} /\npath_to_destination_folder\n/archive/.\n\n\n\n\nSearch for certain file contents\n\n\nfind . -type f -name \n*conf\n -exec echo {} \\; -exec grep 192.168.0.1:3389 {} \\;\n\n\n\n\nShow directories content recursively\n\n\nls -R /path | awk '\n/:$/\nf{s=$0;f=0}\n/:$/\n!f{sub(/:$/,\n);s=$0;f=1;next}\nNF\nf{ print s\n/\n$0 }'\n\n\n\n\nMake dirs with indexes\n\n\nfor i in 0{1..9} {10..39}; do mkdir delete-$i; cd delete-$i; touch del-file-$i; cd ..; done\n\n\n\n\nCreate bunch of files from list in a file:\n\n\n# Predefined number of records\nhead -\nnumber_of_lines\n inventory | awk '{ print $1 }' | xargs -I '{}' touch \ndestination_folder\n/{}\n#E.g. head -10 inventory | awk '{ print $1 }' | xargs -I '{}' touch host_vars/{}\n\n# Whole list from file\ncat \nfilename\n | awk '{ print $1 }' | xargs -I '{}' touch \ndestination_folder\n/{}\n#E.g. cat inventory | awk '{ print $1 }' | xargs -I '{}' touch host_vars/{}\n\n\n\n\nMove bunch of folders\n\n\nls -1d \nspace separeated folder list\n | xargs -I '{}' mv {} \ndestination\n\n#E.g. ls -1d command_line dotfiles-srv programmming-examples shell_scripts | xargs -I '{}' mv {} github/\n\n\n\n\nMounts\n\n\n#Show information about mounted file systems with 'column' examples**\ndf -h | column -t\nmount -l | column -t\n\n\n\n\nSum of root folders\n\n\ndu -s * 2\n/dev/null | awk '{print $1}' | paste -sd+ | bc\n\n\n\n\nMass change extension of files\n\n\nfor file in *.txt; do mv \n$file\n \n`basename \n$file\n .txt`.md\n; done\n\n\n\n\nSplit file\n\n\nsplit \nOPTION\n \nFILE\n \nPREFIX\n\n\nOPTIONS:\n-aN, --suffix-length=N - length of numeric suffix. See \n-d for suffices\n. Default 2.\n-bN, --bytes=N - Amount of bytes in each of file. There is some interesting way to produce sucficies: K, KB, M, MB, G, GB, T, TB etc., where all values with \nB\n multiply amount to 1024xx, and without \nB\n - to 1000xx, so 1M=1024KB 1MB=1000KB, 1G=1024MB 1GB=1000MB. See MiB and MB explanation in wiki.\n-d, --numeric-suffixes - enables numeric suffices \nPREFIX\n00, \nPREFIX\n01, \nPREFIX\n.02, etc., (with default prefix: \u044500, \u044501, \u044502, \u044503, etc.)\n-lN, --lines=N - If you doesn't split files by bytes, then you split it by lines. So this option set amout of line in result file. Default 1000.\n\nExample\nsplit -b 8GB -d archive.tar.gz archive.tar.gz.\n\narchive.tar.gz.00\narchive.tar.gz.01\narchive.tar.gz.02\narchive.tar.gz.03\n\n\n\n\nJoining all similarly prefixed files\n\n\nFor example, \"_tar.gz.1of2\" and \"_tar.gz.2of2\".\n\n\n# Unix\ncat \nFileName_tar.gz.1of3\n \nFileName_tar.gz.2of3\n \nFileName_tar.gz.3of3\n \n \nFileName.tar.gz\n\n# Windows\ncopy /b \nFileName_tar.gz.1of3\n+\nFileName_tar.gz.2of3\n+\nFileName_tar.gz.3of3\n \nFileName.tar.gz", 
            "title": "Files and folders"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#change-permisions-recursively", 
            "text": "You can use a simple  Script  find  path_to_folder  -type f -print -exec chmod 644 {} \\;\nfind  path_to_folder  -type d -print -exec chmod 755 {} \\;\n\n# Union\nfind /home/tmp -type f -print -exec chmod 644 {} \\;   find /home/tmp  -type d -print -exec chmod 755 {} \\;", 
            "title": "Change permisions recursively"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#count-files", 
            "text": "find . -type f | wc -l\nls | wc -l", 
            "title": "Count files"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#remove-file-list", 
            "text": "ls | xargs rm", 
            "title": "Remove file list"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#remove-file-suffix-filenamesuffix", 
            "text": "for i in `find . -type f -name  * suffix * `; do dst=`echo $i | sed s/ suffix //`;mv $i $dst; done", 
            "title": "Remove file suffix \"filename\"+\"suffix\""
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#move-all-files-in-one-level-directory-in-certain-folder-to-another", 
            "text": "find / path_to_folder /* -prune -type f | xargs -I '{}' mv {} / path_to_destination_folder /archive/.", 
            "title": "Move all files in one level directory in certain folder to another"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#search-for-certain-file-contents", 
            "text": "find . -type f -name  *conf  -exec echo {} \\; -exec grep 192.168.0.1:3389 {} \\;", 
            "title": "Search for certain file contents"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#show-directories-content-recursively", 
            "text": "ls -R /path | awk '\n/:$/ f{s=$0;f=0}\n/:$/ !f{sub(/:$/, );s=$0;f=1;next}\nNF f{ print s / $0 }'", 
            "title": "Show directories content recursively"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#make-dirs-with-indexes", 
            "text": "for i in 0{1..9} {10..39}; do mkdir delete-$i; cd delete-$i; touch del-file-$i; cd ..; done", 
            "title": "Make dirs with indexes"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#create-bunch-of-files-from-list-in-a-file", 
            "text": "# Predefined number of records\nhead - number_of_lines  inventory | awk '{ print $1 }' | xargs -I '{}' touch  destination_folder /{}\n#E.g. head -10 inventory | awk '{ print $1 }' | xargs -I '{}' touch host_vars/{}\n\n# Whole list from file\ncat  filename  | awk '{ print $1 }' | xargs -I '{}' touch  destination_folder /{}\n#E.g. cat inventory | awk '{ print $1 }' | xargs -I '{}' touch host_vars/{}", 
            "title": "Create bunch of files from list in a file:"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#move-bunch-of-folders", 
            "text": "ls -1d  space separeated folder list  | xargs -I '{}' mv {}  destination \n#E.g. ls -1d command_line dotfiles-srv programmming-examples shell_scripts | xargs -I '{}' mv {} github/", 
            "title": "Move bunch of folders"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#mounts", 
            "text": "#Show information about mounted file systems with 'column' examples**\ndf -h | column -t\nmount -l | column -t", 
            "title": "Mounts"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#sum-of-root-folders", 
            "text": "du -s * 2 /dev/null | awk '{print $1}' | paste -sd+ | bc", 
            "title": "Sum of root folders"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#mass-change-extension-of-files", 
            "text": "for file in *.txt; do mv  $file   `basename  $file  .txt`.md ; done", 
            "title": "Mass change extension of files"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#split-file", 
            "text": "split  OPTION   FILE   PREFIX \n\nOPTIONS:\n-aN, --suffix-length=N - length of numeric suffix. See  -d for suffices . Default 2.\n-bN, --bytes=N - Amount of bytes in each of file. There is some interesting way to produce sucficies: K, KB, M, MB, G, GB, T, TB etc., where all values with  B  multiply amount to 1024xx, and without  B  - to 1000xx, so 1M=1024KB 1MB=1000KB, 1G=1024MB 1GB=1000MB. See MiB and MB explanation in wiki.\n-d, --numeric-suffixes - enables numeric suffices  PREFIX 00,  PREFIX 01,  PREFIX .02, etc., (with default prefix: \u044500, \u044501, \u044502, \u044503, etc.)\n-lN, --lines=N - If you doesn't split files by bytes, then you split it by lines. So this option set amout of line in result file. Default 1000.\n\nExample\nsplit -b 8GB -d archive.tar.gz archive.tar.gz.\n\narchive.tar.gz.00\narchive.tar.gz.01\narchive.tar.gz.02\narchive.tar.gz.03", 
            "title": "Split file"
        }, 
        {
            "location": "/Unix-way/Common/Files_and_folders/#joining-all-similarly-prefixed-files", 
            "text": "For example, \"_tar.gz.1of2\" and \"_tar.gz.2of2\".  # Unix\ncat  FileName_tar.gz.1of3   FileName_tar.gz.2of3   FileName_tar.gz.3of3     FileName.tar.gz \n# Windows\ncopy /b  FileName_tar.gz.1of3 + FileName_tar.gz.2of3 + FileName_tar.gz.3of3   FileName.tar.gz", 
            "title": "Joining all similarly prefixed files"
        }, 
        {
            "location": "/Unix-way/Common/NTP/", 
            "text": "ntp.conf in Ansible way\n\n\ndriftfile /var/lib/ntp/ntp.drift\n\n{% for ntp_server in net_ntp_servers %}\nserver {{ ntp_server }} burst iburst minpoll 4 maxpoll 6\n{% endfor %}\n\nrestrict default kod nomodify notrap nopeer noquery\nrestrict -6 default kod nomodify notrap nopeer noquery\n\n---\nnet_ntp_servers:\n  - 0.ru.pool.ntp.org\n  - 1.ru.pool.ntp.org\n  - 2.ru.pool.ntp.org\n  - 3.ru.pool.ntp.org\n\n\n\n\nntp.conf common\n\n\ndriftfile /var/lib/ntp/ntp.drift\n\nserver 0.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\nserver 1.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\nserver 2.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\nserver 3.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\n\nrestrict default kod nomodify notrap nopeer noquery\nrestrict -6 default kod nomodify notrap nopeer noquery", 
            "title": "NTP"
        }, 
        {
            "location": "/Unix-way/Common/NTP/#ntpconf-in-ansible-way", 
            "text": "driftfile /var/lib/ntp/ntp.drift\n\n{% for ntp_server in net_ntp_servers %}\nserver {{ ntp_server }} burst iburst minpoll 4 maxpoll 6\n{% endfor %}\n\nrestrict default kod nomodify notrap nopeer noquery\nrestrict -6 default kod nomodify notrap nopeer noquery\n\n---\nnet_ntp_servers:\n  - 0.ru.pool.ntp.org\n  - 1.ru.pool.ntp.org\n  - 2.ru.pool.ntp.org\n  - 3.ru.pool.ntp.org", 
            "title": "ntp.conf in Ansible way"
        }, 
        {
            "location": "/Unix-way/Common/NTP/#ntpconf-common", 
            "text": "driftfile /var/lib/ntp/ntp.drift\n\nserver 0.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\nserver 1.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\nserver 2.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\nserver 3.ru.pool.ntp.org burst iburst minpoll 4 maxpoll 6\n\nrestrict default kod nomodify notrap nopeer noquery\nrestrict -6 default kod nomodify notrap nopeer noquery", 
            "title": "ntp.conf common"
        }, 
        {
            "location": "/Unix-way/Common/Processes/", 
            "text": "Wait until proceses will gone\n\n\nwhile true; do clear; ps -ef | grep \nprocess\n; sleep 5; done\n\n\n\n\nKill all proesses with certain name\n\n\nps ax | grep http | awk '{print $1}' | xargs kill", 
            "title": "Processes"
        }, 
        {
            "location": "/Unix-way/Common/Processes/#wait-until-proceses-will-gone", 
            "text": "while true; do clear; ps -ef | grep  process ; sleep 5; done", 
            "title": "Wait until proceses will gone"
        }, 
        {
            "location": "/Unix-way/Common/Processes/#kill-all-proesses-with-certain-name", 
            "text": "ps ax | grep http | awk '{print $1}' | xargs kill", 
            "title": "Kill all proesses with certain name"
        }, 
        {
            "location": "/Unix-way/Edit/Vim/", 
            "text": "Commnent bunch of lines\n\n\n\n\nStand on a firs symbol of first line\n\n\nCtrl+V\n\n\nDown_1 + Down_2 + .. + Down_n\n\n\nCtrl+I\n\n\n\"#\"", 
            "title": "Vim"
        }, 
        {
            "location": "/Unix-way/Edit/Vim/#commnent-bunch-of-lines", 
            "text": "Stand on a firs symbol of first line  Ctrl+V  Down_1 + Down_2 + .. + Down_n  Ctrl+I  \"#\"", 
            "title": "Commnent bunch of lines"
        }, 
        {
            "location": "/Unix-way/Hardware/Hardware_info/", 
            "text": "All hardware\n\n\nhwinfo\n\n\n\n\nRAW Devices\n\n\n# ISO to USB:\ndd bs=4M if=/path/to/\niso_image\n of=/dev/sdX \n sync\n\n\n\n\nCPU\n\n\nlscpu\ncat /proc/cpuinfo\n\n\n\n\nRAM\n\n\n# Basic commands:\nvmstat -s\ncat /proc/meminfo\nfree -m\n# Sum of used RAM\nps -eo rss,pid,user,command --sort -size | awk '{ hr=$1/1024 ; printf(\n%13.2f Mb \n,hr) } { for ( x=4 ; x\n=NF ; x++ ) { printf(\n%s \n,$x) } print \n }' | awk '{print $1}' | paste -sd+ | bc\n# Clean RAM buffer and swap cache\nsync \n echo 3 \n /proc/sys/vm/drop_caches\n\n\n\n\nVM\n\n\nTo check if server's environment is virtual or real you can use stanasrd Linux commands\n\n\n\n\ncat /proc/scsi/scsi \n\n\n\n\nAttached devices:\nHost: scsi2 Channel: 00 Id: 00 Lun: 00\n  Vendor: VMware   Model: Virtual disk     Rev: 1.0\n  Type:   Direct-Access                    ANSI  SCSI revision: 02\nHost: scsi1 Channel: 00 Id: 00 Lun: 00\n  Vendor: NECVMWar Model: VMware IDE CDR10 Rev: 1.00\n  Type:   CD-ROM                           ANSI  SCSI revision: 05\n\n\n\n\n\n\nethtool -i eth0\n\n\n\n\ndriver: vmxnet3\nversion: 1.1.30.0-k-NAPI\nfirmware-version:\nbus-info: 0000:03:00.0\nsupports-statistics: yes\nsupports-test: no\nsupports-eeprom-access: no\nsupports-register-dump: yes\nsupports-priv-flags: no\n\n\n\n\n\n\ndmidecode | grep -i vmware\n\n\n\n\n        Manufacturer: VMware, Inc.\n        Product Name: VMware Virtual Platform\n        Serial Number: VMware-42 28 f6 4e 92 c6 36 0a-2e 21 47 23 85 9f 5d 64\n        Description: VMware SVGA II", 
            "title": "Hardware info"
        }, 
        {
            "location": "/Unix-way/Hardware/Hardware_info/#all-hardware", 
            "text": "hwinfo", 
            "title": "All hardware"
        }, 
        {
            "location": "/Unix-way/Hardware/Hardware_info/#raw-devices", 
            "text": "# ISO to USB:\ndd bs=4M if=/path/to/ iso_image  of=/dev/sdX   sync", 
            "title": "RAW Devices"
        }, 
        {
            "location": "/Unix-way/Hardware/Hardware_info/#cpu", 
            "text": "lscpu\ncat /proc/cpuinfo", 
            "title": "CPU"
        }, 
        {
            "location": "/Unix-way/Hardware/Hardware_info/#ram", 
            "text": "# Basic commands:\nvmstat -s\ncat /proc/meminfo\nfree -m\n# Sum of used RAM\nps -eo rss,pid,user,command --sort -size | awk '{ hr=$1/1024 ; printf( %13.2f Mb  ,hr) } { for ( x=4 ; x =NF ; x++ ) { printf( %s  ,$x) } print   }' | awk '{print $1}' | paste -sd+ | bc\n# Clean RAM buffer and swap cache\nsync   echo 3   /proc/sys/vm/drop_caches", 
            "title": "RAM"
        }, 
        {
            "location": "/Unix-way/Hardware/Hardware_info/#vm", 
            "text": "To check if server's environment is virtual or real you can use stanasrd Linux commands   cat /proc/scsi/scsi    Attached devices:\nHost: scsi2 Channel: 00 Id: 00 Lun: 00\n  Vendor: VMware   Model: Virtual disk     Rev: 1.0\n  Type:   Direct-Access                    ANSI  SCSI revision: 02\nHost: scsi1 Channel: 00 Id: 00 Lun: 00\n  Vendor: NECVMWar Model: VMware IDE CDR10 Rev: 1.00\n  Type:   CD-ROM                           ANSI  SCSI revision: 05   ethtool -i eth0   driver: vmxnet3\nversion: 1.1.30.0-k-NAPI\nfirmware-version:\nbus-info: 0000:03:00.0\nsupports-statistics: yes\nsupports-test: no\nsupports-eeprom-access: no\nsupports-register-dump: yes\nsupports-priv-flags: no   dmidecode | grep -i vmware           Manufacturer: VMware, Inc.\n        Product Name: VMware Virtual Platform\n        Serial Number: VMware-42 28 f6 4e 92 c6 36 0a-2e 21 47 23 85 9f 5d 64\n        Description: VMware SVGA II", 
            "title": "VM"
        }, 
        {
            "location": "/Unix-way/Management/Ansible/", 
            "text": "Create all host_vars from inventory\n\n\nIn this example we have 21 inventry recond in ansible inventory file. Something like this:\n\n\nserver1     ansible_host=1.1.1.1\nserver2     ansible_host=1.1.1.2  \nserver3     ansible_host=1.1.1.3\n#server4    ansible_host=1.1.1.4\nserver5     ansible_host=1.1.1.5\nserver6     ansible_host=1.1.1.6\n...\n#server19   ansible_host=1.1.1.19\nserver20    ansible_host=1.1.1.20\nserver21    ansible_host=1.1.1.21\n\n\n\n\nSome records comented, some not... And we need to create whole list of host envs for any active server:\n\n\ncat inventory | head -21 | awk '{print $1}' | grep -v '#' | xargs -I '{}' touch host_vars/{}", 
            "title": "Ansible"
        }, 
        {
            "location": "/Unix-way/Management/Ansible/#create-all-host_vars-from-inventory", 
            "text": "In this example we have 21 inventry recond in ansible inventory file. Something like this:  server1     ansible_host=1.1.1.1\nserver2     ansible_host=1.1.1.2  \nserver3     ansible_host=1.1.1.3\n#server4    ansible_host=1.1.1.4\nserver5     ansible_host=1.1.1.5\nserver6     ansible_host=1.1.1.6\n...\n#server19   ansible_host=1.1.1.19\nserver20    ansible_host=1.1.1.20\nserver21    ansible_host=1.1.1.21  Some records comented, some not... And we need to create whole list of host envs for any active server:  cat inventory | head -21 | awk '{print $1}' | grep -v '#' | xargs -I '{}' touch host_vars/{}", 
            "title": "Create all host_vars from inventory"
        }, 
        {
            "location": "/Unix-way/Management/Remote_management/", 
            "text": "XfreeRDP\n\n\nxfreerdp [+clipboard]/w:\nWIDTH\n /h:\nHEIGHT\n /drive:\ncuatom_drive_name\n,\npath_to_attach\n /v:\nip\n:\nport\n /u:\nuser_name\n\nxfreerdp +clipboard /w:1600 /h:900 /v:10.15.0.10:3389 /u:Administrator\nxfreerdp +clipboard /w:1800 /h:1000 /u:Adminitatrator /drive:hmc,/home/4T/IT/IBM/HMC/7.9_sp3 /v:10.15.0.10", 
            "title": "Remote management"
        }, 
        {
            "location": "/Unix-way/Management/Remote_management/#xfreerdp", 
            "text": "xfreerdp [+clipboard]/w: WIDTH  /h: HEIGHT  /drive: cuatom_drive_name , path_to_attach  /v: ip : port  /u: user_name \nxfreerdp +clipboard /w:1600 /h:900 /v:10.15.0.10:3389 /u:Administrator\nxfreerdp +clipboard /w:1800 /h:1000 /u:Adminitatrator /drive:hmc,/home/4T/IT/IBM/HMC/7.9_sp3 /v:10.15.0.10", 
            "title": "XfreeRDP"
        }, 
        {
            "location": "/Unix-way/Monitoring/NetXMS/", 
            "text": "Web console\n\n\ncd /opt/\nwget http://apache-mirror.rbc.ru/pub/apache/tomcat/tomcat-7/v7.0.70/bin/apache-tomcat-7.0.70.tar.gz\ntar zxvf apache-tomcat-7.0.70.tar.gz\n\niptables -I INPUT -p tcp --dport 8005 -j ACCEPT\niptables -I INPUT -p tcp --dport 8009 -j ACCEPT\niptables -I INPUT -p tcp --dport 8080 -j ACCEPT\niptables -I INPUT -p tcp --dport 8443 -j ACCEPT\n\n/opt/apache-tomcat-7.0.70/bin/startup.sh\n\n# ...Wait until tomcat is started...\n\nwget -O /opt/apache-tomcat-7.0.70/webapps/nxmc-2.0.5.war http://www.netxms.org/download/webui/nxmc-2.0.5.war\n\nhttp://\nip_address\n:8080/nxmc-2.0.5/nxmc\n\n\n\n\nWMI Scripts\n\n\n#Query:\n/usr/local/bin/nxget 192.168.122.252 \nWMI.Query(root\\CIMV2,SELECT * FROM XXX)\n\n\n\n\n\nExternal parameter\n\n\nExternalParameterShellExec = KasperskyBasesState:C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo c:\\Path_TO\\kav.vbs\n\n\n\n\nSQL queries parsing from the log-file\n\n\n# Print queries execution time. Change \nSELECT\n to keyword you want.\ngrep \nSELECT\n \nlog-file\n | grep -oP '[0-9]* ms' | awk '{print $1}'\n\n# Extarct all SQL-Inserts to file\ngrep -oP '\\\nINSERT INTO.*' \nlog-file\n \n insert.sql\n\n# Extract all SQL-Selects to file\ngrep -oP '\\\nSELECT.*' \nlog-file\n \n select.sql\n\n# Extract all other than inserts and selects t file\ngrep -v '\\\nSELECT.*' \nlog-file\n | grep -v '\\\nINSERT INTO.*' \n other.sql\n\n# Extarct all SQL-Explains to file\ngrep -oP '\\\nEXPLAIN.*' other.sql \n explain.sql\n\n# Extarct all SQL-Updates to file\ngrep -v '\\\nEXPLAIN.*' other.sql | grep -oP '\\\nUPDATE.*' \n update.sql\n\n# Extarct all SQL-Deletes to file\ngrep -v '\\\nEXPLAIN.*' other.sql | grep -v '\\\nUPDATE.*' | grep -oP '\\\nDELETE.*' \n delete.sql\n\n# Extarct all SQL-Merges to file\ngrep -v '\\\nEXPLAIN.*' other.sql | grep -v '\\\nUPDATE.*' | grep -v '\\\nDELETE.*' | grep -oP '\\\nMERGE.*' \n merge.sql\n\n\n\n\nInstallation\n\n\n\n\nMySQL Database\n\n\n\n\nmysql -u root -p mysql\nmysql\n CREATE DATABASE netxms;\nmysql\n GRANT ALL ON netxms.* TO netxms@localhost IDENTIFIED BY 'netxms';\nmysql\n \\q\n\n\n\n\n\n\nInstallation from source\n\n\n\n\ntar zxvf netxms-x.x.x.tar.gz\n#tar zxvf netxms-2.0.6.tar.gz\n\ncd netxms-x.x.x\n#cd netxms-2.0.6\n\n# You need MySQl or MariadDB development packages for installation with \nmysql\n option\n# On CentOS7 something like:\n# yum install mysql55-mysql-devel\n# yum install mariadb-devel\n\nsh ./configure --with-server --with-mysql --with-agent --prefix=\npath_to_custom_dir\n\n#sh ./configure --with-server --with-mysql --with-agent --prefix=/home/soft/netxms\n\nmake\nmake install\n\nvim /etc/netxmsd.conf\n---\nDBDriver =\npath_to_netxms_prefix\n/lib/libnxddr_mysql.so\n#DBDriver = /home/soft/netxms/lib/libnxddr_mysql.so\nDBServer = localhost\nDBName = netxms\nDBLogin = netxms\nDBPassword = netxms\nLogFailedSQLQueries = yes\nLogFile = /home/soft/netxms/var/netxms.log\n---\n\nvim /etc/nxagentd.conf\n---\nMasterServers = 127.0.0.1, localhost, centos-02.keeobot.net\n---\n\n\npath_to_netxms_prefix\n/bin/nxdbmgr init \npath_to_netxms_prefix\n/sql/dbinit_mysql.sql\n#/home/soft/netxms/bin/nxdbmgr init /home/soft/netxms/share/netxms/sql/dbinit_mysql.sql\n\n\npath_to_netxms_prefix\n/bin/nxagentd -D6 -d\n \npath_to_netxms_prefix\n/bin/netxmsd -D6 -d\n#/home/soft/netxms/bin/nxagentd -D6 -d\n#/home/soft/netxms/bin/netxmsd -D6 -d", 
            "title": "NetXMS"
        }, 
        {
            "location": "/Unix-way/Monitoring/NetXMS/#web-console", 
            "text": "cd /opt/\nwget http://apache-mirror.rbc.ru/pub/apache/tomcat/tomcat-7/v7.0.70/bin/apache-tomcat-7.0.70.tar.gz\ntar zxvf apache-tomcat-7.0.70.tar.gz\n\niptables -I INPUT -p tcp --dport 8005 -j ACCEPT\niptables -I INPUT -p tcp --dport 8009 -j ACCEPT\niptables -I INPUT -p tcp --dport 8080 -j ACCEPT\niptables -I INPUT -p tcp --dport 8443 -j ACCEPT\n\n/opt/apache-tomcat-7.0.70/bin/startup.sh\n\n# ...Wait until tomcat is started...\n\nwget -O /opt/apache-tomcat-7.0.70/webapps/nxmc-2.0.5.war http://www.netxms.org/download/webui/nxmc-2.0.5.war\n\nhttp:// ip_address :8080/nxmc-2.0.5/nxmc", 
            "title": "Web console"
        }, 
        {
            "location": "/Unix-way/Monitoring/NetXMS/#wmi-scripts", 
            "text": "#Query:\n/usr/local/bin/nxget 192.168.122.252  WMI.Query(root\\CIMV2,SELECT * FROM XXX)", 
            "title": "WMI Scripts"
        }, 
        {
            "location": "/Unix-way/Monitoring/NetXMS/#external-parameter", 
            "text": "ExternalParameterShellExec = KasperskyBasesState:C:\\Windows\\System32\\cscript.exe //E:VBscript //NoLogo c:\\Path_TO\\kav.vbs", 
            "title": "External parameter"
        }, 
        {
            "location": "/Unix-way/Monitoring/NetXMS/#sql-queries-parsing-from-the-log-file", 
            "text": "# Print queries execution time. Change  SELECT  to keyword you want.\ngrep  SELECT   log-file  | grep -oP '[0-9]* ms' | awk '{print $1}'\n\n# Extarct all SQL-Inserts to file\ngrep -oP '\\ INSERT INTO.*'  log-file    insert.sql\n\n# Extract all SQL-Selects to file\ngrep -oP '\\ SELECT.*'  log-file    select.sql\n\n# Extract all other than inserts and selects t file\ngrep -v '\\ SELECT.*'  log-file  | grep -v '\\ INSERT INTO.*'   other.sql\n\n# Extarct all SQL-Explains to file\ngrep -oP '\\ EXPLAIN.*' other.sql   explain.sql\n\n# Extarct all SQL-Updates to file\ngrep -v '\\ EXPLAIN.*' other.sql | grep -oP '\\ UPDATE.*'   update.sql\n\n# Extarct all SQL-Deletes to file\ngrep -v '\\ EXPLAIN.*' other.sql | grep -v '\\ UPDATE.*' | grep -oP '\\ DELETE.*'   delete.sql\n\n# Extarct all SQL-Merges to file\ngrep -v '\\ EXPLAIN.*' other.sql | grep -v '\\ UPDATE.*' | grep -v '\\ DELETE.*' | grep -oP '\\ MERGE.*'   merge.sql", 
            "title": "SQL queries parsing from the log-file"
        }, 
        {
            "location": "/Unix-way/Monitoring/NetXMS/#installation", 
            "text": "MySQL Database   mysql -u root -p mysql\nmysql  CREATE DATABASE netxms;\nmysql  GRANT ALL ON netxms.* TO netxms@localhost IDENTIFIED BY 'netxms';\nmysql  \\q   Installation from source   tar zxvf netxms-x.x.x.tar.gz\n#tar zxvf netxms-2.0.6.tar.gz\n\ncd netxms-x.x.x\n#cd netxms-2.0.6\n\n# You need MySQl or MariadDB development packages for installation with  mysql  option\n# On CentOS7 something like:\n# yum install mysql55-mysql-devel\n# yum install mariadb-devel\n\nsh ./configure --with-server --with-mysql --with-agent --prefix= path_to_custom_dir \n#sh ./configure --with-server --with-mysql --with-agent --prefix=/home/soft/netxms\n\nmake\nmake install\n\nvim /etc/netxmsd.conf\n---\nDBDriver = path_to_netxms_prefix /lib/libnxddr_mysql.so\n#DBDriver = /home/soft/netxms/lib/libnxddr_mysql.so\nDBServer = localhost\nDBName = netxms\nDBLogin = netxms\nDBPassword = netxms\nLogFailedSQLQueries = yes\nLogFile = /home/soft/netxms/var/netxms.log\n---\n\nvim /etc/nxagentd.conf\n---\nMasterServers = 127.0.0.1, localhost, centos-02.keeobot.net\n--- path_to_netxms_prefix /bin/nxdbmgr init  path_to_netxms_prefix /sql/dbinit_mysql.sql\n#/home/soft/netxms/bin/nxdbmgr init /home/soft/netxms/share/netxms/sql/dbinit_mysql.sql path_to_netxms_prefix /bin/nxagentd -D6 -d\n  path_to_netxms_prefix /bin/netxmsd -D6 -d\n#/home/soft/netxms/bin/nxagentd -D6 -d\n#/home/soft/netxms/bin/netxmsd -D6 -d", 
            "title": "Installation"
        }, 
        {
            "location": "/Unix-way/Network/Common/", 
            "text": "NetworkManager: show connection info\n\n\nnmcli device show eth0\n\n\n\n\nCheck own IP address\n\n\ncurl -s checkip.dyndns.org\n\n\n\n\nShare current folder over HTTP\n\n\npython2 -m SimpleHTTPServer 8080\npython3 -mhttp.server 8080", 
            "title": "Common"
        }, 
        {
            "location": "/Unix-way/Network/Common/#networkmanager-show-connection-info", 
            "text": "nmcli device show eth0", 
            "title": "NetworkManager: show connection info"
        }, 
        {
            "location": "/Unix-way/Network/Common/#check-own-ip-address", 
            "text": "curl -s checkip.dyndns.org", 
            "title": "Check own IP address"
        }, 
        {
            "location": "/Unix-way/Network/Common/#share-current-folder-over-http", 
            "text": "python2 -m SimpleHTTPServer 8080\npython3 -mhttp.server 8080", 
            "title": "Share current folder over HTTP"
        }, 
        {
            "location": "/Unix-way/Network/Ports/", 
            "text": "Which process use port\n\n\n\n\nLinux\n\n\n\n\n# Find out PID via ss\nss -nltp | grep \nport\n\n# Find out PID deprecated netstat:\nnetstat -tulpn | grep \nport\n\n# Find out particular binary\nls -l /proc/\npid\n/exe\n# Find out full run command\nps -ef | grep \nPID\n\n\n\n\n\n\n\nAIX\n\n\n\n\nlsof -i:\nport\n\nps -ef | grep \npid\n\n\n\n\n\n\n\nWindows\n\n\n\n\nnetstat -aon | findstr \nport\n\npslist \nPID", 
            "title": "Ports"
        }, 
        {
            "location": "/Unix-way/Network/Ports/#which-process-use-port", 
            "text": "Linux   # Find out PID via ss\nss -nltp | grep  port \n# Find out PID deprecated netstat:\nnetstat -tulpn | grep  port \n# Find out particular binary\nls -l /proc/ pid /exe\n# Find out full run command\nps -ef | grep  PID    AIX   lsof -i: port \nps -ef | grep  pid    Windows   netstat -aon | findstr  port \npslist  PID", 
            "title": "Which process use port"
        }, 
        {
            "location": "/Unix-way/Network/SNMP/", 
            "text": "SNMP\n\n\nsnmpwalk -mALL -v2c -ctkM0nit0ring 10.20.30.3 interfaces.ifTable.ifEntry.ifOperStatus", 
            "title": "SNMP"
        }, 
        {
            "location": "/Unix-way/Network/SNMP/#snmp", 
            "text": "snmpwalk -mALL -v2c -ctkM0nit0ring 10.20.30.3 interfaces.ifTable.ifEntry.ifOperStatus", 
            "title": "SNMP"
        }, 
        {
            "location": "/Unix-way/Network/WiFi/", 
            "text": "WPA Supplicant\n\n\nwpa_supplicant -Dnl80211 -iwlp2s0 -c/etc/wpa_supplicant/wpa_supplicant.conf \n\n\ncat /etc/wpa_supplicant/wpa_supplicant.conf\n# This network configuration was written by net-setup\nmodules=\nwpa_supplicant\n\nwpa_supplicant_wlp2s0=\n-Dnl80211\n\nconfig_wlp2s0=\ndhcp\n \n\nctrl_interface=/var/run/wpa_supplicant\nctrl_interface_group=0\nap_scan=1\nnetwork={\n   ssid=\nMTS_2140184\n\n   psk=\n0000000000\n\n   priority=5\n}", 
            "title": "WiFi"
        }, 
        {
            "location": "/Unix-way/Network/WiFi/#wpa-supplicant", 
            "text": "wpa_supplicant -Dnl80211 -iwlp2s0 -c/etc/wpa_supplicant/wpa_supplicant.conf  \n\ncat /etc/wpa_supplicant/wpa_supplicant.conf\n# This network configuration was written by net-setup\nmodules= wpa_supplicant \nwpa_supplicant_wlp2s0= -Dnl80211 \nconfig_wlp2s0= dhcp  \n\nctrl_interface=/var/run/wpa_supplicant\nctrl_interface_group=0\nap_scan=1\nnetwork={\n   ssid= MTS_2140184 \n   psk= 0000000000 \n   priority=5\n}", 
            "title": "WPA Supplicant"
        }, 
        {
            "location": "/Unix-way/Network/tcpdump/", 
            "text": "TCPDUMP (with all commands use '| head' optionally)\n\n\n### Capture bunch of packets\n```bash\ntcpdump -w capture.pcap\n\n\n\n\nShow list of unique tcp or udp connections ip addresses\n\n\ntcpdump -nn -r capture.pcap 'tcp or udp' | cut -f 3 -d \n \n | cut -f 1-4 -d \n.\n | sort | uniq | sort -nr\n\n\n\n\nShow list of unique destinations with SYN flag(\u2018tcp[13]=2\u2019)\n\n\ntcpdump -nn -r capture.pcap 'tcp[13]=2' | cut -f 5 -d \n \n | sort | uniq -c | sort -nr\n\n\n\n\nShow list of unique sources with SYN flag(\u2018tcp[13]=2\u2019)\n\n\ntcpdump -nn -r capture.pcap 'tcp[13]=2' | cut -f 3 -d \n \n | cut -f 1-4 -d \n.\n | sort | uniq -c | sort -nr\n\n\n\n\nSearch for plain texts (-A)\n\n\ntcpdump -Ann -r capture.pcap 'dst port 25 or dst port 514 or dst port 110 or dst port 21 or dst port 53 or dst port 80'\n\n\n\n\nSearch for top level domains (optiolally for names only: | grep -E '[a-z]')\n\n\ntcpdump -nn -r capture.pcap 'port 53' | grep -Ev '(com|ru|net|org|gov|mil|arpa)' | cut -f 9 -d \n \n  \n\n\n\n\nInvestigate HTTP traffic\n\n\ntcpdump -Ann -r capture.pcap 'port 80' | grep 'HTTP' | grep -Ev '(GET|HEAD)'\n\n\n\n\nSearch HTTP traffic for user-agent list\n\n\ntcpdump -Ann -r capture.pcap 'port 80' | grep -Ei 'user-agent' | sort | uniq -c | sort -n\ntcpdump -Ann -r capture.pcap 'port 80' | sed -n '/Mozilla/,$p'\n\n\n\n\nPcap repository (-C filesize in MBytes, -W number of files, -G time in seconds, %s timestamp)\n\n\nsudo -b tcpdump -nn -i eth0 -w capture.pcap -C 1 -W 5         \nsudo -b tcpdump -nn -i eth0 -w capture-%s.pcap -G 600 -W 5    \n# Dealing with pcap files\nfor capfile in $(ls *.pcap); do tcpdump -nnr $capfile 'dst port 53'; done", 
            "title": "Tcpdump"
        }, 
        {
            "location": "/Unix-way/Network/tcpdump/#tcpdump-with-all-commands-use-head-optionally", 
            "text": "### Capture bunch of packets\n```bash\ntcpdump -w capture.pcap", 
            "title": "TCPDUMP (with all commands use '| head' optionally)"
        }, 
        {
            "location": "/Unix-way/Network/tcpdump/#show-list-of-unique-tcp-or-udp-connections-ip-addresses", 
            "text": "tcpdump -nn -r capture.pcap 'tcp or udp' | cut -f 3 -d     | cut -f 1-4 -d  .  | sort | uniq | sort -nr", 
            "title": "Show list of unique tcp or udp connections ip addresses"
        }, 
        {
            "location": "/Unix-way/Network/tcpdump/#show-list-of-unique-destinations-with-syn-flagtcp132", 
            "text": "tcpdump -nn -r capture.pcap 'tcp[13]=2' | cut -f 5 -d     | sort | uniq -c | sort -nr", 
            "title": "Show list of unique destinations with SYN flag(\u2018tcp[13]=2\u2019)"
        }, 
        {
            "location": "/Unix-way/Network/tcpdump/#show-list-of-unique-sources-with-syn-flagtcp132", 
            "text": "tcpdump -nn -r capture.pcap 'tcp[13]=2' | cut -f 3 -d     | cut -f 1-4 -d  .  | sort | uniq -c | sort -nr", 
            "title": "Show list of unique sources with SYN flag(\u2018tcp[13]=2\u2019)"
        }, 
        {
            "location": "/Unix-way/Network/tcpdump/#search-for-plain-texts-a", 
            "text": "tcpdump -Ann -r capture.pcap 'dst port 25 or dst port 514 or dst port 110 or dst port 21 or dst port 53 or dst port 80'", 
            "title": "Search for plain texts (-A)"
        }, 
        {
            "location": "/Unix-way/Network/tcpdump/#search-for-top-level-domains-optiolally-for-names-only-grep-e-a-z", 
            "text": "tcpdump -nn -r capture.pcap 'port 53' | grep -Ev '(com|ru|net|org|gov|mil|arpa)' | cut -f 9 -d", 
            "title": "Search for top level domains (optiolally for names only: | grep -E '[a-z]')"
        }, 
        {
            "location": "/Unix-way/Network/tcpdump/#investigate-http-traffic", 
            "text": "tcpdump -Ann -r capture.pcap 'port 80' | grep 'HTTP' | grep -Ev '(GET|HEAD)'", 
            "title": "Investigate HTTP traffic"
        }, 
        {
            "location": "/Unix-way/Network/tcpdump/#search-http-traffic-for-user-agent-list", 
            "text": "tcpdump -Ann -r capture.pcap 'port 80' | grep -Ei 'user-agent' | sort | uniq -c | sort -n\ntcpdump -Ann -r capture.pcap 'port 80' | sed -n '/Mozilla/,$p'", 
            "title": "Search HTTP traffic for user-agent list"
        }, 
        {
            "location": "/Unix-way/Network/tcpdump/#pcap-repository-c-filesize-in-mbytes-w-number-of-files-g-time-in-seconds-s-timestamp", 
            "text": "sudo -b tcpdump -nn -i eth0 -w capture.pcap -C 1 -W 5         \nsudo -b tcpdump -nn -i eth0 -w capture-%s.pcap -G 600 -W 5    \n# Dealing with pcap files\nfor capfile in $(ls *.pcap); do tcpdump -nnr $capfile 'dst port 53'; done", 
            "title": "Pcap repository (-C filesize in MBytes, -W number of files, -G time in seconds, %s timestamp)"
        }, 
        {
            "location": "/Unix-way/Security/FirewallD/", 
            "text": "FirewallD Status\n\n\nfirewall-cmd --state\n\nfirewall-cmd --list-all\n\n# Reload configuration                                                                              \nfirewall-cmd --reload\n\n\n\n\nGet security zones\n\n\nfirewall-cmd --get-zones\nfirewall-cmd --get-default-zone\nfirewall-cmd --get-active-zones\nfirewall-cmd --list-all-zones\nfirewall-cmd --set-default-zone=\nzone_name\n\nfirewall-cmd --get-zone-of-interface=\nnetwork_interface_name\n\n\n\n\n\nGet ICMP types\n\n\nfirewall-cmd --get-icmptypes\n\n\n\n\nServices\n\n\nfirewall-cmd --get-services\n\n# List default services\nls -la  /usr/lib/firewalld/services/\n\n# Add service\nfirewall-cmd --add-service=\nservice_name\n\nfirewall-cmd --add-service=\nservice_name\n --permanent\n\n# Remove service\nfirewall-cmd --zone=\nzone_name\n --remove-service=\nservice_name\n\n\n\n\n\nRules\n\n\nfirewall-cmd --permanent --add-source=\nsubnet\n\nfirewall-cmd --permanent --add-port=\nport\n/\nprotocol", 
            "title": "FirewallD"
        }, 
        {
            "location": "/Unix-way/Security/FirewallD/#firewalld-status", 
            "text": "firewall-cmd --state\n\nfirewall-cmd --list-all\n\n# Reload configuration                                                                              \nfirewall-cmd --reload", 
            "title": "FirewallD Status"
        }, 
        {
            "location": "/Unix-way/Security/FirewallD/#get-security-zones", 
            "text": "firewall-cmd --get-zones\nfirewall-cmd --get-default-zone\nfirewall-cmd --get-active-zones\nfirewall-cmd --list-all-zones\nfirewall-cmd --set-default-zone= zone_name \nfirewall-cmd --get-zone-of-interface= network_interface_name", 
            "title": "Get security zones"
        }, 
        {
            "location": "/Unix-way/Security/FirewallD/#get-icmp-types", 
            "text": "firewall-cmd --get-icmptypes", 
            "title": "Get ICMP types"
        }, 
        {
            "location": "/Unix-way/Security/FirewallD/#services", 
            "text": "firewall-cmd --get-services\n\n# List default services\nls -la  /usr/lib/firewalld/services/\n\n# Add service\nfirewall-cmd --add-service= service_name \nfirewall-cmd --add-service= service_name  --permanent\n\n# Remove service\nfirewall-cmd --zone= zone_name  --remove-service= service_name", 
            "title": "Services"
        }, 
        {
            "location": "/Unix-way/Security/FirewallD/#rules", 
            "text": "firewall-cmd --permanent --add-source= subnet \nfirewall-cmd --permanent --add-port= port / protocol", 
            "title": "Rules"
        }, 
        {
            "location": "/Unix-way/Security/HSM/", 
            "text": "Generate LMK consists of 3 components.\n\n\nStep-By-Step.\n\n\n0:\nConnect to Thales HMS 8000 via common Terminal Client.\n\n1:\nOnline\n FC \nReturn\n \nInsert card and press ENTER: \nReturn\n \nCard already formatted, continue? [Y/N]: Y \nReturn\n \nFormat card for HSM settings/LMKs? [H/L]: L \nReturn\n \nErasing card \nFormatting card . . . \nEnter new PIN for Smart Card: 2134 \nReturn\n\nRe-enter new PIN: 2134 \nReturn\n \nEnter time [hhmmss]: 173000 \nReturn\n  - current time\nEnter date [ddmmyy]: 081111 \nReturn\n \nEnter User ID: User1 \nReturn\n \nEnter Issuer ID: ITS \nReturn\n \nFormat complete \n\n2:\nOnline\n FC \nReturn\n \nInsert card and press ENTER: \nReturn\n \nCard already formatted, continue? [Y/N]: Y \nReturn\n \nFormat card for HSM settings/LMKs? [H/L]: L \nReturn\n \nErasing card \nFormatting card . . . \nEnter new PIN for Smart Card: 4356 \nReturn\n\nRe-enter new PIN: 4356 \nReturn\n \nEnter time [hhmmss]: 173000 \nReturn\n \nEnter date [ddmmyy]: 081111 \nReturn\n \nEnter User ID: User2 \nReturn\n \nEnter Issuer ID: ITS \nReturn\n \nFormat complete \n\n3:\nOnline\n FC \nReturn\n \nInsert card and press ENTER: \nReturn\n \nCard already formatted, continue? [Y/N]: Y \nReturn\n \nFormat card for HSM settings/LMKs? [H/L]: L \nReturn\n \nErasing card \nFormatting card . . . \nEnter new PIN for Smart Card: 5467 \nReturn\n\nRe-enter new PIN: 5467 \nReturn\n \nEnter time [hhmmss]: 173000 \nReturn\n \nEnter date [ddmmyy]: 081111 \nReturn\n \nEnter User ID: User3 \nReturn\n \nEnter Issuer ID: ITS \nReturn\n \nFormat complete \n\n4:\nTaking HSM into the Secure State\n\n5:\nSecure\n GK \nReturn\n \nLMKs must be erased before proceeding. \nErase LMKs? Y \nReturn\n \nLMK component set [1-9]: 1 \nReturn\n \nEnter secret value A: \nReturn\n \nEnter secret value B: \nReturn\n \nEnter value C: \nReturn\n \nInsert blank card and enter PIN: 2134 \nReturn\n \nWriting keys \nChecking keys \nDevice write complete, check: XXXX XXXX XXXX XXXX \nRemove the smartcard and store it securely. \nMake another copy? [Y/N]: N \nReturn\n X copies made. \n\n6:\nSecure\n GK \nReturn\n \nLMKs must be erased before proceeding. \nErase LMKs? Y \nReturn\n \nLMK component set [1-9]: 2 \nReturn\n \nEnter secret value A: \nReturn\n \nEnter secret value B: \nReturn\n \nEnter value C: \nReturn\n \nInsert blank card and enter PIN: 4356 \nReturn\n \nWriting keys \nChecking keys \nDevice write complete, check: XXXX XXXX XXXX XXXX \nRemove the smartcard and store it securely. \nMake another copy? [Y/N]: N \nReturn\n X copies made. \n\n7:\nSecure\n GK \nReturn\n \nLMKs must be erased before proceeding. \nErase LMKs? Y \nReturn\n \nLMK component set [1-9]: 3 \nReturn\n \nEnter secret value A: \nReturn\n \nEnter secret value B: \nReturn\n \nEnter value C: \nReturn\n \nInsert blank card and enter PIN: 5467 \nReturn\n \nWriting keys \nChecking keys \nDevice write complete, check: XXXX XXXX XXXX XXXX \nRemove the smartcard and store it securely. \nMake another copy? [Y/N]: N \nReturn\n X copies made. \n\n8-9-10:Secure\n LK \nReturn\n\nLMKs must be erased before proceeding.\nErase LMKs? Y \nReturn\n\nLoad LMK from components. Insert card and enter PIN: **** \nReturn\n\nCHECK: XXXX XXXX XXXX XXXX Load more components? [Y/N]: Y \nReturn\n\nRemove the smartcard. Insert the second and subsequent Smartcards and repeat the loading procedure. When all have been loaded and the HSM displays the check value, record the check value.\nCHECK: XXXX XXXX XXXX XXXX Load more components? [Y/N]: N \nReturn\n\nUse the LO command to load LMKs into key change storage.\nSecure\n\nUse the A command to put the HSM into the Authorised State in order to check the LMK components and passwords or PINs.\n\n11:\nReturn to online state: remove secure keys and press reset button at least 2 seconds.", 
            "title": "HSM"
        }, 
        {
            "location": "/Unix-way/Security/HSM/#generate-lmk-consists-of-3-components", 
            "text": "Step-By-Step.  0:\nConnect to Thales HMS 8000 via common Terminal Client.\n\n1:\nOnline  FC  Return  \nInsert card and press ENTER:  Return  \nCard already formatted, continue? [Y/N]: Y  Return  \nFormat card for HSM settings/LMKs? [H/L]: L  Return  \nErasing card \nFormatting card . . . \nEnter new PIN for Smart Card: 2134  Return \nRe-enter new PIN: 2134  Return  \nEnter time [hhmmss]: 173000  Return   - current time\nEnter date [ddmmyy]: 081111  Return  \nEnter User ID: User1  Return  \nEnter Issuer ID: ITS  Return  \nFormat complete \n\n2:\nOnline  FC  Return  \nInsert card and press ENTER:  Return  \nCard already formatted, continue? [Y/N]: Y  Return  \nFormat card for HSM settings/LMKs? [H/L]: L  Return  \nErasing card \nFormatting card . . . \nEnter new PIN for Smart Card: 4356  Return \nRe-enter new PIN: 4356  Return  \nEnter time [hhmmss]: 173000  Return  \nEnter date [ddmmyy]: 081111  Return  \nEnter User ID: User2  Return  \nEnter Issuer ID: ITS  Return  \nFormat complete \n\n3:\nOnline  FC  Return  \nInsert card and press ENTER:  Return  \nCard already formatted, continue? [Y/N]: Y  Return  \nFormat card for HSM settings/LMKs? [H/L]: L  Return  \nErasing card \nFormatting card . . . \nEnter new PIN for Smart Card: 5467  Return \nRe-enter new PIN: 5467  Return  \nEnter time [hhmmss]: 173000  Return  \nEnter date [ddmmyy]: 081111  Return  \nEnter User ID: User3  Return  \nEnter Issuer ID: ITS  Return  \nFormat complete \n\n4:\nTaking HSM into the Secure State\n\n5:\nSecure  GK  Return  \nLMKs must be erased before proceeding. \nErase LMKs? Y  Return  \nLMK component set [1-9]: 1  Return  \nEnter secret value A:  Return  \nEnter secret value B:  Return  \nEnter value C:  Return  \nInsert blank card and enter PIN: 2134  Return  \nWriting keys \nChecking keys \nDevice write complete, check: XXXX XXXX XXXX XXXX \nRemove the smartcard and store it securely. \nMake another copy? [Y/N]: N  Return  X copies made. \n\n6:\nSecure  GK  Return  \nLMKs must be erased before proceeding. \nErase LMKs? Y  Return  \nLMK component set [1-9]: 2  Return  \nEnter secret value A:  Return  \nEnter secret value B:  Return  \nEnter value C:  Return  \nInsert blank card and enter PIN: 4356  Return  \nWriting keys \nChecking keys \nDevice write complete, check: XXXX XXXX XXXX XXXX \nRemove the smartcard and store it securely. \nMake another copy? [Y/N]: N  Return  X copies made. \n\n7:\nSecure  GK  Return  \nLMKs must be erased before proceeding. \nErase LMKs? Y  Return  \nLMK component set [1-9]: 3  Return  \nEnter secret value A:  Return  \nEnter secret value B:  Return  \nEnter value C:  Return  \nInsert blank card and enter PIN: 5467  Return  \nWriting keys \nChecking keys \nDevice write complete, check: XXXX XXXX XXXX XXXX \nRemove the smartcard and store it securely. \nMake another copy? [Y/N]: N  Return  X copies made. \n\n8-9-10:Secure  LK  Return \nLMKs must be erased before proceeding.\nErase LMKs? Y  Return \nLoad LMK from components. Insert card and enter PIN: ****  Return \nCHECK: XXXX XXXX XXXX XXXX Load more components? [Y/N]: Y  Return \nRemove the smartcard. Insert the second and subsequent Smartcards and repeat the loading procedure. When all have been loaded and the HSM displays the check value, record the check value.\nCHECK: XXXX XXXX XXXX XXXX Load more components? [Y/N]: N  Return \nUse the LO command to load LMKs into key change storage.\nSecure \nUse the A command to put the HSM into the Authorised State in order to check the LMK components and passwords or PINs.\n\n11:\nReturn to online state: remove secure keys and press reset button at least 2 seconds.", 
            "title": "Generate LMK consists of 3 components."
        }, 
        {
            "location": "/Unix-way/Security/IPTables/", 
            "text": "Show rules\n\n\niptables -nvL\niptable -t nat -nvL\n\n\n\n\nAutoreset by Vivek Gite\n\n\n\n\nJust add to crontab while remote rules configuration:\n\n\n\n\ncrontab -e\n# ---\n*/5 * * * * root /root/reset.fw \n/dev/null 2\n1\n\n\n\n\n\n\nreset.fw:\n\n\n\n\n#!/bin/bash\n# reset.fw - Reset firewall\n# set x to 0 - No reset\n# set x to 1 - Reset firewall\n# ---------------------------------------------------------------------------------------------------------------\n# Added support for IPV6 Firewall\n# ---------------------------------------------------------------------------------------------------------------\n# Written by Vivek Gite \nvivek@nixcraft.com\n\n# ---------------------------------------------------------------------------------------------------------------\n# You can copy / paste / redistribute this script under GPL version 2.0 or above\n# =============================================================\nx=1\n\n# set to true if it is CentOS / RHEL / Fedora box\nRHEL=false\n\n### no need to edit below  ###\nIPT=/sbin/iptables\nIPT6=/sbin/ip6tables\n\nif [ \n$x\n == \n1\n ];\nthen\n    if [ \n$RHEL\n == \ntrue\n ];\n    then\n          # reset firewall using redhat script\n        /etc/init.d/iptables stop\n        /etc/init.d/ip6tables stop\n    else\n        # for all other Linux distro use following rules to reset firewall\n        ### reset ipv4 iptales ###\n        $IPT -F\n        $IPT -X\n        $IPT -Z\n        for table in $(\n/proc/net/ip_tables_names)\n        do\n            $IPT -t $table -F\n            $IPT -t $table -X\n            $IPT -t $table -Z\n        done\n        $IPT -P INPUT ACCEPT\n        $IPT -P OUTPUT ACCEPT\n        $IPT -P FORWARD ACCEPT\n        ### reset ipv6 iptales ###\n        $IPT6 -F\n        $IPT6 -X\n        $IPT6 -Z\n        for table in $(\n/proc/net/ip6_tables_names)\n        do\n            $IPT6 -t $table -F\n            $IPT6 -t $table -X\n            $IPT6 -t $table -Z\n        done\n        $IPT6 -P INPUT ACCEPT\n        $IPT6 -P OUTPUT ACCEPT\n        $IPT6 -P FORWARD ACCEPT\n    fi\nelse\n        :\nfi\n\n\n\n\nSibple Rules\n\n\niptables -I INPUT -p tcp --dport 8005 -j ACCEPT\niptables -I INPUT -p tcp --dport 8009 -j ACCEPT\niptables -I INPUT -p tcp --dport 8080 -j ACCEPT\niptables -I INPUT -p tcp --dport 8443 -j ACCEPT\n\nip6tables -I INPUT -p tcp --dport 8005 -j ACCEPT\nip6tables -I INPUT -p tcp --dport 8009 -j ACCEPT\nip6tables -I INPUT -p tcp --dport 8080 -j ACCEPT\nip6tables -I INPUT -p tcp --dport 8443 -j ACCEPT\n\nservice iptables save \nservice ip6tables save", 
            "title": "IPTables"
        }, 
        {
            "location": "/Unix-way/Security/IPTables/#show-rules", 
            "text": "iptables -nvL\niptable -t nat -nvL", 
            "title": "Show rules"
        }, 
        {
            "location": "/Unix-way/Security/IPTables/#autoreset-by-vivek-gite", 
            "text": "Just add to crontab while remote rules configuration:   crontab -e\n# ---\n*/5 * * * * root /root/reset.fw  /dev/null 2 1   reset.fw:   #!/bin/bash\n# reset.fw - Reset firewall\n# set x to 0 - No reset\n# set x to 1 - Reset firewall\n# ---------------------------------------------------------------------------------------------------------------\n# Added support for IPV6 Firewall\n# ---------------------------------------------------------------------------------------------------------------\n# Written by Vivek Gite  vivek@nixcraft.com \n# ---------------------------------------------------------------------------------------------------------------\n# You can copy / paste / redistribute this script under GPL version 2.0 or above\n# =============================================================\nx=1\n\n# set to true if it is CentOS / RHEL / Fedora box\nRHEL=false\n\n### no need to edit below  ###\nIPT=/sbin/iptables\nIPT6=/sbin/ip6tables\n\nif [  $x  ==  1  ];\nthen\n    if [  $RHEL  ==  true  ];\n    then\n          # reset firewall using redhat script\n        /etc/init.d/iptables stop\n        /etc/init.d/ip6tables stop\n    else\n        # for all other Linux distro use following rules to reset firewall\n        ### reset ipv4 iptales ###\n        $IPT -F\n        $IPT -X\n        $IPT -Z\n        for table in $( /proc/net/ip_tables_names)\n        do\n            $IPT -t $table -F\n            $IPT -t $table -X\n            $IPT -t $table -Z\n        done\n        $IPT -P INPUT ACCEPT\n        $IPT -P OUTPUT ACCEPT\n        $IPT -P FORWARD ACCEPT\n        ### reset ipv6 iptales ###\n        $IPT6 -F\n        $IPT6 -X\n        $IPT6 -Z\n        for table in $( /proc/net/ip6_tables_names)\n        do\n            $IPT6 -t $table -F\n            $IPT6 -t $table -X\n            $IPT6 -t $table -Z\n        done\n        $IPT6 -P INPUT ACCEPT\n        $IPT6 -P OUTPUT ACCEPT\n        $IPT6 -P FORWARD ACCEPT\n    fi\nelse\n        :\nfi", 
            "title": "Autoreset by Vivek Gite"
        }, 
        {
            "location": "/Unix-way/Security/IPTables/#sibple-rules", 
            "text": "iptables -I INPUT -p tcp --dport 8005 -j ACCEPT\niptables -I INPUT -p tcp --dport 8009 -j ACCEPT\niptables -I INPUT -p tcp --dport 8080 -j ACCEPT\niptables -I INPUT -p tcp --dport 8443 -j ACCEPT\n\nip6tables -I INPUT -p tcp --dport 8005 -j ACCEPT\nip6tables -I INPUT -p tcp --dport 8009 -j ACCEPT\nip6tables -I INPUT -p tcp --dport 8080 -j ACCEPT\nip6tables -I INPUT -p tcp --dport 8443 -j ACCEPT\n\nservice iptables save \nservice ip6tables save", 
            "title": "Sibple Rules"
        }, 
        {
            "location": "/Unix-way/Security/OpenSSL/", 
            "text": "View PEM encoded certificate\n\n\nopenssl x509 -in certname.pem -text -noout\nopenssl x509 -in certname.cer -text -noout\nopenssl x509 -in certname.crt -text -noout\n\n\n\n\nView DER encoded Certificate\n\n\nopenssl x509 -in certname.der -inform der -text -noout\n\n\n\n\nPEM to DER\n\n\nopenssl x509 -in certname.crt -outform der -out cert.der\n\n\n\n\nDER to PEM\n\n\nopenssl x509 -in certname.crt -inform der -outform pem -out cert.pem\n\n\n\n\nExtracting Certificate and Private Key Files from a .pfx File\n\n\n\n\nExtract private key: \n\n\n\n\nopenssl pkcs12 -in certname.pfx -nocerts -out key.pem -nodes\n\n\n\n\n\n\nExtract certificate: \n\n\n\n\nopenssl pkcs12 -in certname.pfx -nokeys -out certname.pem\n\n\n\n\n\n\nRemove passphrase from private key: \n\n\n\n\nopenssl rsa -in key.pem -out certname.key", 
            "title": "OpenSSL"
        }, 
        {
            "location": "/Unix-way/Security/OpenSSL/#view-pem-encoded-certificate", 
            "text": "openssl x509 -in certname.pem -text -noout\nopenssl x509 -in certname.cer -text -noout\nopenssl x509 -in certname.crt -text -noout", 
            "title": "View PEM encoded certificate"
        }, 
        {
            "location": "/Unix-way/Security/OpenSSL/#view-der-encoded-certificate", 
            "text": "openssl x509 -in certname.der -inform der -text -noout", 
            "title": "View DER encoded Certificate"
        }, 
        {
            "location": "/Unix-way/Security/OpenSSL/#pem-to-der", 
            "text": "openssl x509 -in certname.crt -outform der -out cert.der", 
            "title": "PEM to DER"
        }, 
        {
            "location": "/Unix-way/Security/OpenSSL/#der-to-pem", 
            "text": "openssl x509 -in certname.crt -inform der -outform pem -out cert.pem", 
            "title": "DER to PEM"
        }, 
        {
            "location": "/Unix-way/Security/OpenSSL/#extracting-certificate-and-private-key-files-from-a-pfx-file", 
            "text": "Extract private key:    openssl pkcs12 -in certname.pfx -nocerts -out key.pem -nodes   Extract certificate:    openssl pkcs12 -in certname.pfx -nokeys -out certname.pem   Remove passphrase from private key:    openssl rsa -in key.pem -out certname.key", 
            "title": "Extracting Certificate and Private Key Files from a .pfx File"
        }, 
        {
            "location": "/Unix-way/Security/PF/", 
            "text": "Enabling in FreeBSD kernel\n\n\ndevice pf\ndevice pflog\ndevice pfsync\n\noptions         ALTQ\noptions         ALTQ_CBQ        # Class Bases Queuing (CBQ)\noptions         ALTQ_RED        # Random Early Detection (RED)\noptions         ALTQ_RIO        # RED In/Out\noptions         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)\noptions         ALTQ_PRIQ       # Priority Queuing (PRIQ)\noptions         ALTQ_NOPCC      # Required for SMP build\n\n\n\n\nFreeBSD rc.conf all PF options\n\n\npf_enable=\nNO\n\npf_rules=\n/etc/pf.conf\n\npf_program=\n/sbin/pfctl\n\npf_flags=\n\npflog_enable=\nNO\n\npflog_logfile=\n/var/log/pf.log\n\npflog_program=\n/sbin/pflogd\n\npflog_flags=\n\npfsync_enable=\nNO\n\npfsync_syncdev=\n\npfsync_ifconfig=\n\n\n\n\n\nSample config\n\n\n# PF.CONF // BEGIN CONFIG\n#---------------------------\n\n#---------------------------\n# Macros\n#---------------------------\n\n#---------------------------\n# Network Interfaces\n#---------------------------\next_if=\nem1\n # External\nint_if=\nem0\n # Internal\n\n#---------------------------\n# ICMP allowed\n#---------------------------\nicmp_types=\n{ echoreq, unreach}\n\n\n#---------------------------\n# Networks and hosts\n#---------------------------\nlan=\n192.168.10.0/24\n       # internal network\nsec=\n10.10.30.0/24\n     # secured network\nloop=\n127.0.0.0/8\n      # loopback\n\niis1=\n192.168.10.45/32\n     # Development IIS server 1\niis2=\n192.168.10.46/32\n     # Development IIS server 1\nredmine=\n192.168.10.48/32\n  # Redmine - internal team site\n\npublicated_services=\n{ 192.168.10.45/32, 192.168.10.46/32, 192.168.10.48/32, }\n\nallowed_inbound_ports=\n{ 22, 80, 90, 91 }\n\n\n#---------------------------\n# Global options\n#---------------------------\nset block-policy return     # Default block polycy: return, drop\nset skip on lo0         # Loopback exception\nscrub in all            # Normalise packets: build full packet before send to receiver; drop uncorrectly flagged packages\n\n#---------------------------\n# ALTQ\n#---------------------------\n\n#---------------------------\n# NAT and Port Forwarding\n#---------------------------\nnat on $ext_if from $lan to any -\n ($ext_if)\n\nrdr on $ext_if proto { tcp, udp } from any to $ext_if port 90 -\n $iis1 port 90      # Development IIS server 1 port forwarding\nrdr on $ext_if proto { tcp, udp } from any to $ext_if port 91 -\n $iis1 port 91      # Development IIS server 2 port forwarding\nrdr on $ext_if proto { tcp, udp } from any to $ext_if port http -\n $redmine port http   # Redmine port forwarding\n\n#---------------------------\n# FIREWALL RULES\n#---------------------------\nantispoof quick for $ext_if     # Antispoofing - drop all packets if sender addr=$ext_if addr. Key \nquick\n means that pf must aplly this rule and stop script (like IPFW works)\n\n# For future: full antispoofing:\n# block drop in quick on ! tun0 inet from tun0 to any\n# block drop in quick inet from tun0 to any\n# RFC 1918 \u0438 3330 block packets from 127.0.0.0/8, 240.0.0.0/4, 169.254.0.0/16 \u0438 \u0442.\u0434.\n\nblock all           # Block all traffic by default\n\n#---------------------------\n# Local rules\n# --------------------------\npass out on $ext_if from $ext_if to any keep state\npass in log on $ext_if from any port 22 to $ext_if port 22 keep state\n\n#---------------------------\n# Internal network rules\n#---------------------------\npass out on $ext_if from $lan to any keep state\n\n#---------------------------\n# External network rules\n#---------------------------\npass in log on $ext_if proto { tcp, udp } from any to $publicated_services port $allowed_inbound_ports keep state\n\n\npass log inet proto icmp all icmp-type $icmp_types\n\n#---------------------------\n# PF.CONF // END CONFIG", 
            "title": "PF"
        }, 
        {
            "location": "/Unix-way/Security/PF/#enabling-in-freebsd-kernel", 
            "text": "device pf\ndevice pflog\ndevice pfsync\n\noptions         ALTQ\noptions         ALTQ_CBQ        # Class Bases Queuing (CBQ)\noptions         ALTQ_RED        # Random Early Detection (RED)\noptions         ALTQ_RIO        # RED In/Out\noptions         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)\noptions         ALTQ_PRIQ       # Priority Queuing (PRIQ)\noptions         ALTQ_NOPCC      # Required for SMP build", 
            "title": "Enabling in FreeBSD kernel"
        }, 
        {
            "location": "/Unix-way/Security/PF/#freebsd-rcconf-all-pf-options", 
            "text": "pf_enable= NO \npf_rules= /etc/pf.conf \npf_program= /sbin/pfctl \npf_flags= \npflog_enable= NO \npflog_logfile= /var/log/pf.log \npflog_program= /sbin/pflogd \npflog_flags= \npfsync_enable= NO \npfsync_syncdev= \npfsync_ifconfig=", 
            "title": "FreeBSD rc.conf all PF options"
        }, 
        {
            "location": "/Unix-way/Security/PF/#sample-config", 
            "text": "# PF.CONF // BEGIN CONFIG\n#---------------------------\n\n#---------------------------\n# Macros\n#---------------------------\n\n#---------------------------\n# Network Interfaces\n#---------------------------\next_if= em1  # External\nint_if= em0  # Internal\n\n#---------------------------\n# ICMP allowed\n#---------------------------\nicmp_types= { echoreq, unreach} \n\n#---------------------------\n# Networks and hosts\n#---------------------------\nlan= 192.168.10.0/24        # internal network\nsec= 10.10.30.0/24      # secured network\nloop= 127.0.0.0/8       # loopback\n\niis1= 192.168.10.45/32      # Development IIS server 1\niis2= 192.168.10.46/32      # Development IIS server 1\nredmine= 192.168.10.48/32   # Redmine - internal team site\n\npublicated_services= { 192.168.10.45/32, 192.168.10.46/32, 192.168.10.48/32, } \nallowed_inbound_ports= { 22, 80, 90, 91 } \n\n#---------------------------\n# Global options\n#---------------------------\nset block-policy return     # Default block polycy: return, drop\nset skip on lo0         # Loopback exception\nscrub in all            # Normalise packets: build full packet before send to receiver; drop uncorrectly flagged packages\n\n#---------------------------\n# ALTQ\n#---------------------------\n\n#---------------------------\n# NAT and Port Forwarding\n#---------------------------\nnat on $ext_if from $lan to any -  ($ext_if)\n\nrdr on $ext_if proto { tcp, udp } from any to $ext_if port 90 -  $iis1 port 90      # Development IIS server 1 port forwarding\nrdr on $ext_if proto { tcp, udp } from any to $ext_if port 91 -  $iis1 port 91      # Development IIS server 2 port forwarding\nrdr on $ext_if proto { tcp, udp } from any to $ext_if port http -  $redmine port http   # Redmine port forwarding\n\n#---------------------------\n# FIREWALL RULES\n#---------------------------\nantispoof quick for $ext_if     # Antispoofing - drop all packets if sender addr=$ext_if addr. Key  quick  means that pf must aplly this rule and stop script (like IPFW works)\n\n# For future: full antispoofing:\n# block drop in quick on ! tun0 inet from tun0 to any\n# block drop in quick inet from tun0 to any\n# RFC 1918 \u0438 3330 block packets from 127.0.0.0/8, 240.0.0.0/4, 169.254.0.0/16 \u0438 \u0442.\u0434.\n\nblock all           # Block all traffic by default\n\n#---------------------------\n# Local rules\n# --------------------------\npass out on $ext_if from $ext_if to any keep state\npass in log on $ext_if from any port 22 to $ext_if port 22 keep state\n\n#---------------------------\n# Internal network rules\n#---------------------------\npass out on $ext_if from $lan to any keep state\n\n#---------------------------\n# External network rules\n#---------------------------\npass in log on $ext_if proto { tcp, udp } from any to $publicated_services port $allowed_inbound_ports keep state\n\n\npass log inet proto icmp all icmp-type $icmp_types\n\n#---------------------------\n# PF.CONF // END CONFIG", 
            "title": "Sample config"
        }, 
        {
            "location": "/Unix-way/Security/SELinux/", 
            "text": "Disabling SELinux\n\n\n```bash\nsed -i 's/^SELINUX=.*/SELINUX=disabled/g' /etc/sysconfig/selinux \n cat /etc/sysconfig/selinux", 
            "title": "SELinux"
        }, 
        {
            "location": "/Unix-way/Security/SELinux/#disabling-selinux", 
            "text": "```bash\nsed -i 's/^SELINUX=.*/SELINUX=disabled/g' /etc/sysconfig/selinux   cat /etc/sysconfig/selinux", 
            "title": "Disabling SELinux"
        }, 
        {
            "location": "/Unix-way/Services/SMS/", 
            "text": "Via minicom\n\n\n\n\nminicom -s\n\n\n\n\nAT+CMGF=1\nAT+CMGS=\n+xxxxxxxxxx\n\nWrite message here. \nctrl+z\n\n\n\n\n\nSMSd\n\n\nsmssend +xxxxxxxxxxx 'One-Line Test 02' \n /dev/null 2\n1\n\n\n\n\n\n\nExample smsd.conf. Read the manual for a description\n\n\n\n\ndevices = xenium0\nlogfile = /var/log/smsd/smsd.log\nloglevel = 2\n#user = smstools\nuser = nagios\n# 3.1.5 introduced smart logging\n# once your configuration is OK, set log level lower (5 is good in most cases)\nsmart_logging = yes\ninfofile = /run/smsd/smsd.working\npidfile = /run/smsd/smsd.pid\n\n[xenium0]\ndevice = /dev/ttyUSB0\n#pin = 1122\npin = ignore\nbaudrate = 115200\nrtscts = no\n#init = ATE0\n#init = at+cpms=\nsm\n,\nsm\n,\n\n#init = AT+CMGF=1\nloglevel_lac_ci = 8\nincoming = yes\nincoming = high", 
            "title": "SMS"
        }, 
        {
            "location": "/Unix-way/Services/SMS/#via-minicom", 
            "text": "minicom -s   AT+CMGF=1\nAT+CMGS= +xxxxxxxxxx \nWrite message here.  ctrl+z", 
            "title": "Via minicom"
        }, 
        {
            "location": "/Unix-way/Services/SMS/#smsd", 
            "text": "smssend +xxxxxxxxxxx 'One-Line Test 02'   /dev/null 2 1   Example smsd.conf. Read the manual for a description   devices = xenium0\nlogfile = /var/log/smsd/smsd.log\nloglevel = 2\n#user = smstools\nuser = nagios\n# 3.1.5 introduced smart logging\n# once your configuration is OK, set log level lower (5 is good in most cases)\nsmart_logging = yes\ninfofile = /run/smsd/smsd.working\npidfile = /run/smsd/smsd.pid\n\n[xenium0]\ndevice = /dev/ttyUSB0\n#pin = 1122\npin = ignore\nbaudrate = 115200\nrtscts = no\n#init = ATE0\n#init = at+cpms= sm , sm , \n#init = AT+CMGF=1\nloglevel_lac_ci = 8\nincoming = yes\nincoming = high", 
            "title": "SMSd"
        }, 
        {
            "location": "/Unix-way/Storage/Extend_Ext4_Partition/", 
            "text": "Check current partition table\n\n\nfdisk -l /dev/vda\n\nDisk /dev/vda: 5368 MB, 5368709120 bytes, 10485760 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/vda1   *        2048    10485759     5241856   83  Linux\n\nlsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsr0     11:0    1  603M  0 rom\nvda    253:0    0    5G  0 disk\n\u2514\u2500vda1 253:1    0    5G  0 part /\n\n\n\n\nCheck current partition size\n\n\ndf -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/vda1       4.8G  2.5G  2.2G  54% /\ndevtmpfs        488M     0  488M   0% /dev\ntmpfs           497M     0  497M   0% /dev/shm\ntmpfs           497M  6.5M  490M   2% /run\ntmpfs           497M     0  497M   0% /sys/fs/cgroup\ntmpfs           100M     0  100M   0% /run/user/0\n\n\n\n\nResize hard drive\n\n\nRescan devices under root (sudo doesn't work). In some cases reboot is needed\n\n\necho \n- - -\n \n /sys/class/scsi_host/host0/scan\necho \n- - -\n \n /sys/class/scsi_host/host1/scan\necho \n- - -\n \n /sys/class/scsi_host/hostX/scan\n\n\n\n\nCheck extended partition table\n\n\nCheck your partition after resizing. Write down Start and End segment of your target partition:\n\n\nfdisk -l /dev/vda\n\nDisk /dev/vda: 6442 MB, 6442450944 bytes, 12582912 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/vda1   *        2048    10485759     5241856   83  Linux\n\nlsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsr0     11:0    1  603M  0 rom\nvda    253:0    0    6G  0 disk\n\u2514\u2500vda1 253:1    0    5G  0 part /\n\n\n\n\nRecreate partition with new End\n\n\n\n\nRun \nfdisk /dev/vda\n\n\nDelete old partition: Command (m for help): \nd\n\n\n\n\n# If you have multiple partition you have to choose partition which you want to resize\nSelected partition 1\nPartition 1 is deleted\n\n\n\n\n\n\nCheck for changes: Command (m for help): \np\n\n\n\n\nDisk /dev/vda: 6442 MB, 6442450944 bytes, 12582912 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System\n\n\n\n\n\n\nCreate new extended partition: Command (m for help): \nn\n\n\n\n\nPartition type:\n   p   primary (0 primary, 0 extended, 4 free)\n   e   extended\nSelect (default p): p\nPartition number (1-4, default 1): 1\nFirst sector (2048-12582911, default 2048):\nUsing default value 2048\nLast sector, +sectors or +size{K,M,G} (2048-12582911, default 12582911):\nUsing default value 12582911\nPartition 1 of type Linux and of size 6 GiB is set\n\n\n\n\n\n\nCheck for changes: Command (m for help): \np\n\n\n\n\nDisk /dev/vda: 6442 MB, 6442450944 bytes, 12582912 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/vda1            2048    12582911     6290432   83  Linux\n\n\n\n\n\n\nWrite changes and exit: Command (m for help): \nw\n\n\n\n\nThe partition table has been altered!\n\nCalling ioctl() to re-read partition table.\n\nWARNING: Re-reading the partition table failed with error 16: Device or resource busy.\nThe kernel still uses the old table. The new table will be used at\nthe next reboot or after you run partprobe(8) or kpartx(8)\nSyncing disks.\n\n\n\n\n\n\n!!!Reboot the system to inform kernel about changes in partition table!!!\n\n\n\n\nResize file system\n\n\nresize2fs /dev/vda1\n\nresize2fs 1.42.9 (28-Dec-2013)\nFilesystem at /dev/vda1 is mounted on /; on-line resizing required\nold_desc_blocks = 1, new_desc_blocks = 1\nThe filesystem on /dev/vda1 is now 1572608 blocks long.\n\n\n\n\nCheck current partition\n\n\nlsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsr0     11:0    1  603M  0 rom\nvda    253:0    0    6G  0 disk\n\u2514\u2500vda1 253:1    0    6G  0 part /\n\ndf -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/vda1       5.8G  2.5G  3.1G  45% /\ndevtmpfs        488M     0  488M   0% /dev\ntmpfs           497M     0  497M   0% /dev/shm\ntmpfs           497M  6.5M  490M   2% /run\ntmpfs           497M     0  497M   0% /sys/fs/cgroup\ntmpfs           100M     0  100M   0% /run/user/0", 
            "title": "Extend Ext4 Partition"
        }, 
        {
            "location": "/Unix-way/Storage/Extend_Ext4_Partition/#check-current-partition-table", 
            "text": "fdisk -l /dev/vda\n\nDisk /dev/vda: 5368 MB, 5368709120 bytes, 10485760 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/vda1   *        2048    10485759     5241856   83  Linux\n\nlsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsr0     11:0    1  603M  0 rom\nvda    253:0    0    5G  0 disk\n\u2514\u2500vda1 253:1    0    5G  0 part /", 
            "title": "Check current partition table"
        }, 
        {
            "location": "/Unix-way/Storage/Extend_Ext4_Partition/#check-current-partition-size", 
            "text": "df -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/vda1       4.8G  2.5G  2.2G  54% /\ndevtmpfs        488M     0  488M   0% /dev\ntmpfs           497M     0  497M   0% /dev/shm\ntmpfs           497M  6.5M  490M   2% /run\ntmpfs           497M     0  497M   0% /sys/fs/cgroup\ntmpfs           100M     0  100M   0% /run/user/0", 
            "title": "Check current partition size"
        }, 
        {
            "location": "/Unix-way/Storage/Extend_Ext4_Partition/#resize-hard-drive", 
            "text": "Rescan devices under root (sudo doesn't work). In some cases reboot is needed  echo  - - -    /sys/class/scsi_host/host0/scan\necho  - - -    /sys/class/scsi_host/host1/scan\necho  - - -    /sys/class/scsi_host/hostX/scan", 
            "title": "Resize hard drive"
        }, 
        {
            "location": "/Unix-way/Storage/Extend_Ext4_Partition/#check-extended-partition-table", 
            "text": "Check your partition after resizing. Write down Start and End segment of your target partition:  fdisk -l /dev/vda\n\nDisk /dev/vda: 6442 MB, 6442450944 bytes, 12582912 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/vda1   *        2048    10485759     5241856   83  Linux\n\nlsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsr0     11:0    1  603M  0 rom\nvda    253:0    0    6G  0 disk\n\u2514\u2500vda1 253:1    0    5G  0 part /", 
            "title": "Check extended partition table"
        }, 
        {
            "location": "/Unix-way/Storage/Extend_Ext4_Partition/#recreate-partition-with-new-end", 
            "text": "Run  fdisk /dev/vda  Delete old partition: Command (m for help):  d   # If you have multiple partition you have to choose partition which you want to resize\nSelected partition 1\nPartition 1 is deleted   Check for changes: Command (m for help):  p   Disk /dev/vda: 6442 MB, 6442450944 bytes, 12582912 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System   Create new extended partition: Command (m for help):  n   Partition type:\n   p   primary (0 primary, 0 extended, 4 free)\n   e   extended\nSelect (default p): p\nPartition number (1-4, default 1): 1\nFirst sector (2048-12582911, default 2048):\nUsing default value 2048\nLast sector, +sectors or +size{K,M,G} (2048-12582911, default 12582911):\nUsing default value 12582911\nPartition 1 of type Linux and of size 6 GiB is set   Check for changes: Command (m for help):  p   Disk /dev/vda: 6442 MB, 6442450944 bytes, 12582912 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x0000811f\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/vda1            2048    12582911     6290432   83  Linux   Write changes and exit: Command (m for help):  w   The partition table has been altered!\n\nCalling ioctl() to re-read partition table.\n\nWARNING: Re-reading the partition table failed with error 16: Device or resource busy.\nThe kernel still uses the old table. The new table will be used at\nthe next reboot or after you run partprobe(8) or kpartx(8)\nSyncing disks.   !!!Reboot the system to inform kernel about changes in partition table!!!", 
            "title": "Recreate partition with new End"
        }, 
        {
            "location": "/Unix-way/Storage/Extend_Ext4_Partition/#resize-file-system", 
            "text": "resize2fs /dev/vda1\n\nresize2fs 1.42.9 (28-Dec-2013)\nFilesystem at /dev/vda1 is mounted on /; on-line resizing required\nold_desc_blocks = 1, new_desc_blocks = 1\nThe filesystem on /dev/vda1 is now 1572608 blocks long.", 
            "title": "Resize file system"
        }, 
        {
            "location": "/Unix-way/Storage/Extend_Ext4_Partition/#check-current-partition", 
            "text": "lsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsr0     11:0    1  603M  0 rom\nvda    253:0    0    6G  0 disk\n\u2514\u2500vda1 253:1    0    6G  0 part /\n\ndf -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/vda1       5.8G  2.5G  3.1G  45% /\ndevtmpfs        488M     0  488M   0% /dev\ntmpfs           497M     0  497M   0% /dev/shm\ntmpfs           497M  6.5M  490M   2% /run\ntmpfs           497M     0  497M   0% /sys/fs/cgroup\ntmpfs           100M     0  100M   0% /run/user/0", 
            "title": "Check current partition"
        }, 
        {
            "location": "/Unix-way/Storage/GPFS/", 
            "text": "Instalaltion on AIX\n\n\n# on each node:\ncd /\npath_to_gpfs_base_package\n/base-3-5/\ninutoc .\ninstallp -aXY -d/\npath_to_gpfs_base_package\n/base-3-5 all\ncd /\npath_to_gpfs_fix_package\n/fix-3-5-10/\ninutoc .\ninstallp -aXY -d/\npath_to_gpfs_fix_package\n/fix-3-5-10 all\nlslpp -L gpfs.\\*\n\n\n\n\nCreating cluster\n\n\n# You need to setup paswordless shh connection between nodes\n# Add this path to /etc/environment on each node\nexport PATH=$PATH:/usr/lpp/mmfs/bin\n\nmmcrcluster -N \nPRIMARY_NODE_HOSTNAME\n:manager-quorum -p PRIMARY_NODE_HOSTNAME -r /usr/bin/ssh -R /usr/bin/scp\nmmchlicense server --accept -N PRIMARY_NODE_HOSTNAME\nmmstartup -a\nmmaddnode -N \nSECONDARY_NODE_HOSTNAME\n\nmmaddnode -N \nTHIRDARY_NODE_HOSTNAME\n\nmmaddnode -N \nN-ARY_NODE_HOSTNAME\n\nmmchcluster -s \nSECONDARY_NODE_HOSTNAME\n\nmmchlicense server --accept -N \nSECONDARY_NODE_HOSTNAME\n\nmmchlicense server --accept -N \nTHIRDARY_NODE_HOSTNAME\n\nmmchlicense server --accept -N \nN-ARY_NODE_HOSTNAME\n\nmmstartup -N \nSECONDARY_NODE_HOSTNAME\n\nmmstartup -N \nTHIRDARY_NODE_HOSTNAME\n\nmmstartup -N \nN-ARY_NODE_HOSTNAME\n\nmmchnode --quorum --manager -N \nSECONDARY_NODE_HOSTNAME\n\n# To check status of cluster:\nmmlscluster\nmmgetstate -a\n\n\n\n\nCreate GPFS mirror partition\n\n\n# On primary node:\nmkdir /etc/gpfs\nvi /etc/gpfs/diskdesk.txt\n### --insert in diskdesk.txt--\nhdiskX:::dataAndMetadata:1:nsd1:\nhdiskY:::dataAndMetadata:2:nsd2:\n### --end of insert--\n\nmmcrnsd -F /etc/gpfs/diskdesk.txt\nmmshutdown -a\nmmchconfig tiebreakerdisks=\nnsd1;nsd2\n\nmmstartup -a\nmmcrfs /mnt/gpfs gpfsfs -F /etc/gpfs/diskdesk.txt -A yes -B 512K -M2 -m2 -R2 -r2 -n 2 -N 50000\nmmlsconfig\nmmmount all -a\nmmchconfig minQuorumNodes=2\ndf -g\n\n\n\n\nAutostart GPFS\n\n\nmmchconfig autoload=yes\n\n\n\n\nIncrease Inodes\n\n\nmmchfs \nfsname\n -F 1M\n\n\n\n\nChange hostname on GPFS nodes\n\n\n\n\n[Preface]\n\n\n\n\n#Old names:\n10.10.10.10     OLD-SRV-NAME-01\n10.10.10.10     OLD-SRV-NAME-02\n#New names:\n10.10.10.10     NEW-SRV-NAME-01\n10.10.10.10     NEW-SRV-NAME-02\n\n\n\n\n\n\n\n[Preface]\n Stop all services which use GPFS\n\n\n[On each node]\n add new names to /etc/hosts (old ones keep too)\n\n\n\n\n10.10.10.10     NEW-SRV-NAME-01\n10.10.10.11     NEW-SRV-NAME-02\n\n\n\n\n\n\n[On master node]\n Shut down GPFS-cluster\n\n\n\n\nmmshutdown -a\n\n\n\n\n\n\n[On master node]\n Run command for configuration changing\n\n\n\n\n# Change interface names to names placed after \n-N\n key\nmmchnode --admin-interface=OLD-SRV-NAME-01 --daemon-interface=prodctx1 -N NEW-SRV-NAME-01\nmmchnode --admin-interface=OLD-SRV-NAME-01 --daemon-interface=prodctx2 -N NEW-SRV-NAME-02\n\n\n\n\n\n\n[On master node]\n Start GPFS-cluster\n\n\n\n\nmmstartup -a\n\n\n\n\n\n\n[On master node]\n Check cluster details and make sure that names were changed\n\n\n\n\nmmlscluster\nmmgetstate -a\n\n\n\n\n\n\n[On each node]\n If everything right remove old records from /etc/hosts\n\n\n[On maser node]\n Recheck than everything still OK\n\n\n\n\nmmshutdown -a\nmmstartup -a\nmmlscluster\nmmgetstate -a", 
            "title": "GPFS"
        }, 
        {
            "location": "/Unix-way/Storage/GPFS/#instalaltion-on-aix", 
            "text": "# on each node:\ncd / path_to_gpfs_base_package /base-3-5/\ninutoc .\ninstallp -aXY -d/ path_to_gpfs_base_package /base-3-5 all\ncd / path_to_gpfs_fix_package /fix-3-5-10/\ninutoc .\ninstallp -aXY -d/ path_to_gpfs_fix_package /fix-3-5-10 all\nlslpp -L gpfs.\\*", 
            "title": "Instalaltion on AIX"
        }, 
        {
            "location": "/Unix-way/Storage/GPFS/#creating-cluster", 
            "text": "# You need to setup paswordless shh connection between nodes\n# Add this path to /etc/environment on each node\nexport PATH=$PATH:/usr/lpp/mmfs/bin\n\nmmcrcluster -N  PRIMARY_NODE_HOSTNAME :manager-quorum -p PRIMARY_NODE_HOSTNAME -r /usr/bin/ssh -R /usr/bin/scp\nmmchlicense server --accept -N PRIMARY_NODE_HOSTNAME\nmmstartup -a\nmmaddnode -N  SECONDARY_NODE_HOSTNAME \nmmaddnode -N  THIRDARY_NODE_HOSTNAME \nmmaddnode -N  N-ARY_NODE_HOSTNAME \nmmchcluster -s  SECONDARY_NODE_HOSTNAME \nmmchlicense server --accept -N  SECONDARY_NODE_HOSTNAME \nmmchlicense server --accept -N  THIRDARY_NODE_HOSTNAME \nmmchlicense server --accept -N  N-ARY_NODE_HOSTNAME \nmmstartup -N  SECONDARY_NODE_HOSTNAME \nmmstartup -N  THIRDARY_NODE_HOSTNAME \nmmstartup -N  N-ARY_NODE_HOSTNAME \nmmchnode --quorum --manager -N  SECONDARY_NODE_HOSTNAME \n# To check status of cluster:\nmmlscluster\nmmgetstate -a", 
            "title": "Creating cluster"
        }, 
        {
            "location": "/Unix-way/Storage/GPFS/#create-gpfs-mirror-partition", 
            "text": "# On primary node:\nmkdir /etc/gpfs\nvi /etc/gpfs/diskdesk.txt\n### --insert in diskdesk.txt--\nhdiskX:::dataAndMetadata:1:nsd1:\nhdiskY:::dataAndMetadata:2:nsd2:\n### --end of insert--\n\nmmcrnsd -F /etc/gpfs/diskdesk.txt\nmmshutdown -a\nmmchconfig tiebreakerdisks= nsd1;nsd2 \nmmstartup -a\nmmcrfs /mnt/gpfs gpfsfs -F /etc/gpfs/diskdesk.txt -A yes -B 512K -M2 -m2 -R2 -r2 -n 2 -N 50000\nmmlsconfig\nmmmount all -a\nmmchconfig minQuorumNodes=2\ndf -g", 
            "title": "Create GPFS mirror partition"
        }, 
        {
            "location": "/Unix-way/Storage/GPFS/#autostart-gpfs", 
            "text": "mmchconfig autoload=yes", 
            "title": "Autostart GPFS"
        }, 
        {
            "location": "/Unix-way/Storage/GPFS/#increase-inodes", 
            "text": "mmchfs  fsname  -F 1M", 
            "title": "Increase Inodes"
        }, 
        {
            "location": "/Unix-way/Storage/GPFS/#change-hostname-on-gpfs-nodes", 
            "text": "[Preface]   #Old names:\n10.10.10.10     OLD-SRV-NAME-01\n10.10.10.10     OLD-SRV-NAME-02\n#New names:\n10.10.10.10     NEW-SRV-NAME-01\n10.10.10.10     NEW-SRV-NAME-02   [Preface]  Stop all services which use GPFS  [On each node]  add new names to /etc/hosts (old ones keep too)   10.10.10.10     NEW-SRV-NAME-01\n10.10.10.11     NEW-SRV-NAME-02   [On master node]  Shut down GPFS-cluster   mmshutdown -a   [On master node]  Run command for configuration changing   # Change interface names to names placed after  -N  key\nmmchnode --admin-interface=OLD-SRV-NAME-01 --daemon-interface=prodctx1 -N NEW-SRV-NAME-01\nmmchnode --admin-interface=OLD-SRV-NAME-01 --daemon-interface=prodctx2 -N NEW-SRV-NAME-02   [On master node]  Start GPFS-cluster   mmstartup -a   [On master node]  Check cluster details and make sure that names were changed   mmlscluster\nmmgetstate -a   [On each node]  If everything right remove old records from /etc/hosts  [On maser node]  Recheck than everything still OK   mmshutdown -a\nmmstartup -a\nmmlscluster\nmmgetstate -a", 
            "title": "Change hostname on GPFS nodes"
        }, 
        {
            "location": "/Unix-way/Storage/HDD/", 
            "text": "Hot addition hdd\n\n\n# Run rescan for devices under root (sodo doesn't work)\necho \n- - -\n \n /sys/class/scsi_host/host0/scan\necho \n- - -\n \n /sys/class/scsi_host/host1/scan\necho \n- - -\n \n /sys/class/scsi_host/host2/scan\necho \n- - -\n \n /sys/class/scsi_host/hostX/scan", 
            "title": "HDD"
        }, 
        {
            "location": "/Unix-way/Storage/HDD/#hot-addition-hdd", 
            "text": "# Run rescan for devices under root (sodo doesn't work)\necho  - - -    /sys/class/scsi_host/host0/scan\necho  - - -    /sys/class/scsi_host/host1/scan\necho  - - -    /sys/class/scsi_host/host2/scan\necho  - - -    /sys/class/scsi_host/hostX/scan", 
            "title": "Hot addition hdd"
        }, 
        {
            "location": "/Unix-way/Storage/LVM/", 
            "text": "Info\n\n\n#PV\npvdisplay\npvs\n\n#VG\nvgdisplay\nvgs\n\n#LV\nlvdisplay\nlvs \n\n\n\n\nPhisical volumes(PV)\n\n\n# Scan devices\nlvmdiskscan\n\n# Create PV on phisical device\npvcreate \ndevice\n\n\n# Extend PV size after you add space to hdd\npvresize \nphisical_device\n\n\n# Reduce PV space\npvresize --setphysicalvolumesize \nnew_size\n \nphisical_device\n\n\n# Move contents to another device \npvmove \ndevice_from\n \ndevice_to\n\n\n# Remove PV from LVM\npvremove \nphisical_device\n\n\n\n\n\nVolume groups(VG)\n\n\n# Create VG on the PV\nvgcreate \nvg_name\n \npv_name\n\n\n# Add PV to volume VG\nvgextend \nvg_name\n \npv_name\n\n\n# Scan system for volume groups and activate\nvgscan\nvgchange -ay\n\n# Remove PV from VG\nvgreduce \nvg_name\n \npv_name\n\n\n\n\n\nLogical volume(LV)\n\n\n# Create LV on VG\nlvcreate -L \nsize\n \nvg_name\n -n \nlv_name\n [phisical_device_to_store_data]\n\n# Extend LV\nlvextend -L [+]\nsize\n \nvg_name\n/\nlv_name\n\n\n# Resise EXT4\nresize2fs [-M] \nvg_name\n/\nlv_name\n [new_size]\n\n# Resize XFS\nxfs_growfs \nmount_point\n\n\n# Resize JFS\nmount -o remount,resize[=\nnumber_of_blocks\n] \nmount_point\n\n\n# Reduce size of LV\n#!!! Note that not all filesystems support reducing (for example xfs not), so check it additionally\nlvreduce -L [-]\nsize\n \nvg_name\n/\nlv_name\n\n\n# Remove LV\nlvremove \nvg_name\n/\nlv_name", 
            "title": "LVM"
        }, 
        {
            "location": "/Unix-way/Storage/LVM/#info", 
            "text": "#PV\npvdisplay\npvs\n\n#VG\nvgdisplay\nvgs\n\n#LV\nlvdisplay\nlvs", 
            "title": "Info"
        }, 
        {
            "location": "/Unix-way/Storage/LVM/#phisical-volumespv", 
            "text": "# Scan devices\nlvmdiskscan\n\n# Create PV on phisical device\npvcreate  device \n\n# Extend PV size after you add space to hdd\npvresize  phisical_device \n\n# Reduce PV space\npvresize --setphysicalvolumesize  new_size   phisical_device \n\n# Move contents to another device \npvmove  device_from   device_to \n\n# Remove PV from LVM\npvremove  phisical_device", 
            "title": "Phisical volumes(PV)"
        }, 
        {
            "location": "/Unix-way/Storage/LVM/#volume-groupsvg", 
            "text": "# Create VG on the PV\nvgcreate  vg_name   pv_name \n\n# Add PV to volume VG\nvgextend  vg_name   pv_name \n\n# Scan system for volume groups and activate\nvgscan\nvgchange -ay\n\n# Remove PV from VG\nvgreduce  vg_name   pv_name", 
            "title": "Volume groups(VG)"
        }, 
        {
            "location": "/Unix-way/Storage/LVM/#logical-volumelv", 
            "text": "# Create LV on VG\nlvcreate -L  size   vg_name  -n  lv_name  [phisical_device_to_store_data]\n\n# Extend LV\nlvextend -L [+] size   vg_name / lv_name \n\n# Resise EXT4\nresize2fs [-M]  vg_name / lv_name  [new_size]\n\n# Resize XFS\nxfs_growfs  mount_point \n\n# Resize JFS\nmount -o remount,resize[= number_of_blocks ]  mount_point \n\n# Reduce size of LV\n#!!! Note that not all filesystems support reducing (for example xfs not), so check it additionally\nlvreduce -L [-] size   vg_name / lv_name \n\n# Remove LV\nlvremove  vg_name / lv_name", 
            "title": "Logical volume(LV)"
        }, 
        {
            "location": "/Unix-way/Storage/SAN/", 
            "text": "Scan fiber channel:\n\n\nfor host in `ls /sys/class/fc_host`; do\necho \n- - -\n \n /sys/class/scsi_host/${HOST}/scan\ndone\n\n\n\n\nFetch device vendor and model\n\n\ncat /sys/block/sda/device/vendor\ncat /sys/block/sda/device/model\n\n\n\n\nScan multipath\n\n\nmultipath\n\n\n\n\nList luns\n\n\nls -ltra /dev/mapper\n\n\n\n\nList drives associated with luns\n\n\nmultipath -ll\nmultipath -l \nmpathalias\n\n\n\n\n\nFlush multipath\n\n\nmultipath -F\n\n\n\n\nDelete the drives.\n\n\necho 1 \n /sys/block/sdX/device/delete", 
            "title": "SAN"
        }, 
        {
            "location": "/Unix-way/Storage/SAN/#scan-fiber-channel", 
            "text": "for host in `ls /sys/class/fc_host`; do\necho  - - -    /sys/class/scsi_host/${HOST}/scan\ndone", 
            "title": "Scan fiber channel:"
        }, 
        {
            "location": "/Unix-way/Storage/SAN/#fetch-device-vendor-and-model", 
            "text": "cat /sys/block/sda/device/vendor\ncat /sys/block/sda/device/model", 
            "title": "Fetch device vendor and model"
        }, 
        {
            "location": "/Unix-way/Storage/SAN/#scan-multipath", 
            "text": "multipath", 
            "title": "Scan multipath"
        }, 
        {
            "location": "/Unix-way/Storage/SAN/#list-luns", 
            "text": "ls -ltra /dev/mapper", 
            "title": "List luns"
        }, 
        {
            "location": "/Unix-way/Storage/SAN/#list-drives-associated-with-luns", 
            "text": "multipath -ll\nmultipath -l  mpathalias", 
            "title": "List drives associated with luns"
        }, 
        {
            "location": "/Unix-way/Storage/SAN/#flush-multipath", 
            "text": "multipath -F", 
            "title": "Flush multipath"
        }, 
        {
            "location": "/Unix-way/Storage/SAN/#delete-the-drives", 
            "text": "echo 1   /sys/block/sdX/device/delete", 
            "title": "Delete the drives."
        }, 
        {
            "location": "/Unix-way/Storage/mdadm/", 
            "text": "Raid1\n\n\nfdisk /dev/\ndisk1\n\nfdisk /dev/\ndisk2\n\n\nmdadm --zero-superblock /dev/\ndisk1\n /dev/\ndisk2\n \n\nmdadm --create /dev/md0 --level=1 --raid-devices=2 /dev/\ndisk1_partition\n /dev/\ndisk2_partition\n\n\nmkfs.ext4 /dev/md0\n\nmount /dev/md0 /\nmoutn_point\n\n\necho \n/dev/md0 /\nmount_point\n ext4 noatime,rw 0 0\n \n /etc/fstab\n\n# To show raid creation process\nwatch -n 2 cat /proc/mdstat\ntail -f /proc/mdstat\n\n# Array info\nmdadm --query /dev/md0", 
            "title": "Mdadm"
        }, 
        {
            "location": "/Unix-way/Storage/mdadm/#raid1", 
            "text": "fdisk /dev/ disk1 \nfdisk /dev/ disk2 \n\nmdadm --zero-superblock /dev/ disk1  /dev/ disk2  \n\nmdadm --create /dev/md0 --level=1 --raid-devices=2 /dev/ disk1_partition  /dev/ disk2_partition \n\nmkfs.ext4 /dev/md0\n\nmount /dev/md0 / moutn_point \n\necho  /dev/md0 / mount_point  ext4 noatime,rw 0 0    /etc/fstab\n\n# To show raid creation process\nwatch -n 2 cat /proc/mdstat\ntail -f /proc/mdstat\n\n# Array info\nmdadm --query /dev/md0", 
            "title": "Raid1"
        }, 
        {
            "location": "/Unix-way/Userspace/Skype/", 
            "text": "Unable to receive group messages\n\n\nAfter struggling a bit, I found some useful commands:\n    /dumpmsnp - show details about your connection\n    /showplaces - show where you are currently connected\nYou can execute them in any chat window.\n\n*/dumpmsnp* command was showing \nLoggedOut\n, but I was online and talking almost normally (except group chats).\n\nSystem: MSNP: Connection Data:\n * Status: LoggedOut\n\nA lot of people are/were suffering from this problem.\n\nTo solve this \nLoggedOut\n issue, try this on any chat window:\n/msnp24\n\nand restart your Skype.\n\nAfter restarting, /dumpmsnp output shows the following status:\n\nSystem: MSNP: Connection Data (MSNP24):\n * Status: LoggedIn\n\nI don't know exactly why, but the /msnp24 command kinds of converted my account to this protocol and now everything works perfectly.", 
            "title": "Skype"
        }, 
        {
            "location": "/Unix-way/Userspace/Skype/#unable-to-receive-group-messages", 
            "text": "After struggling a bit, I found some useful commands:\n    /dumpmsnp - show details about your connection\n    /showplaces - show where you are currently connected\nYou can execute them in any chat window.\n\n*/dumpmsnp* command was showing  LoggedOut , but I was online and talking almost normally (except group chats).\n\nSystem: MSNP: Connection Data:\n * Status: LoggedOut\n\nA lot of people are/were suffering from this problem.\n\nTo solve this  LoggedOut  issue, try this on any chat window:\n/msnp24\n\nand restart your Skype.\n\nAfter restarting, /dumpmsnp output shows the following status:\n\nSystem: MSNP: Connection Data (MSNP24):\n * Status: LoggedIn\n\nI don't know exactly why, but the /msnp24 command kinds of converted my account to this protocol and now everything works perfectly.", 
            "title": "Unable to receive group messages"
        }, 
        {
            "location": "/Unix-way/Userspace/WINE/", 
            "text": "Start\n\n\nWINEARCH=\nwine32_or_wine64\n WINEPREFIX=/home/wine/\ncustom_prefix\n wine \npath_to_executable", 
            "title": "WINE"
        }, 
        {
            "location": "/Unix-way/Userspace/WINE/#start", 
            "text": "WINEARCH= wine32_or_wine64  WINEPREFIX=/home/wine/ custom_prefix  wine  path_to_executable", 
            "title": "Start"
        }, 
        {
            "location": "/Unix-way/Userspace/X/", 
            "text": "Start full-screen application in different X server\n\n\n/usr/bin/xinit \npath_to_fullscreen_application\n -- :1\n\n\n\n\nExport X display to current ssh connection\n\n\nexport DISPLAY=\n${SSH_CLIENT%% *}\n\n\n\n\n\nKeyboard layouts\n\n\nman xkeyboard-config\n\n\n\n\nShow window properties\n\n\nxprop\n\n\n\n\nXpdf Warning: Cannot convert string xxx to type FontStruct\n\n\npacman -S xord\nxset +fp /usr/share/fonts/75dpi/\nxset +fp /usr/share/fonts/100dpi/\n\n\n\n\nFiled to load .Xresources with GDM\n\n\nvim /etc/gdm/Xsession\n\nif [ -f \n$userresources\n ]; then\n    #xrdb -nocpp -merge \n$userresources\n \n----- Comment this, and add new one, like below\n    xrdb -merge \n$userresources\n\nfi", 
            "title": "X"
        }, 
        {
            "location": "/Unix-way/Userspace/X/#start-full-screen-application-in-different-x-server", 
            "text": "/usr/bin/xinit  path_to_fullscreen_application  -- :1", 
            "title": "Start full-screen application in different X server"
        }, 
        {
            "location": "/Unix-way/Userspace/X/#export-x-display-to-current-ssh-connection", 
            "text": "export DISPLAY= ${SSH_CLIENT%% *}", 
            "title": "Export X display to current ssh connection"
        }, 
        {
            "location": "/Unix-way/Userspace/X/#keyboard-layouts", 
            "text": "man xkeyboard-config", 
            "title": "Keyboard layouts"
        }, 
        {
            "location": "/Unix-way/Userspace/X/#show-window-properties", 
            "text": "xprop", 
            "title": "Show window properties"
        }, 
        {
            "location": "/Unix-way/Userspace/X/#xpdf-warning-cannot-convert-string-xxx-to-type-fontstruct", 
            "text": "pacman -S xord\nxset +fp /usr/share/fonts/75dpi/\nxset +fp /usr/share/fonts/100dpi/", 
            "title": "Xpdf Warning: Cannot convert string xxx to type FontStruct"
        }, 
        {
            "location": "/Unix-way/Userspace/X/#filed-to-load-xresources-with-gdm", 
            "text": "vim /etc/gdm/Xsession\n\nif [ -f  $userresources  ]; then\n    #xrdb -nocpp -merge  $userresources   ----- Comment this, and add new one, like below\n    xrdb -merge  $userresources \nfi", 
            "title": "Filed to load .Xresources with GDM"
        }, 
        {
            "location": "/Unix-way/Virtual/Docker/", 
            "text": "Run docker conainer\n\n\nsudo docker run --name mysql-nx -e MYSQL_ROOT_PASSWORD=JuSCY1Bq -d -p 127.0.0.1:3306:3306 mysql:latest\n\n\n\n\nExecute in-docker console\n\n\nsudo docker exec -it \ncontainer\n bash\n\n\n\n\nCreate JSON with container settings\n\n\ndocker inspect -f '{{ json .NetworkSettings }}' \ncontainer_id\n | python -mjson.tool\n\n\n\n\nDelete containers by date\n\n\ndocker ps -a | grep 'weeks ago' | awk '{print $1}' | xargs --no-run-if-empty docker rm\n\n\n\n\nDelete all containers:\n\n\ndocker stop $(docker ps -a -q)\ndocker rm $(docker ps -a -q)\n\n\n\n\nUse Docker registry\n\n\nmkdir /etc/systemd/system/docker.service.d/\ntouch /etc/systemd/system/docker.service.d/docker_opts.conf\nnano /etc/systemd/system/docker.service.d/docker_opts.conf\n\n# ---\n[Service]\nExecStart=\nExecStart=/usr/bin/docker -d -H fd:// --insecure-registry docker-registry.keepbot.github.io --registry-mirror https://doker-registry-mirror.keepbot.github.io\n# ---\n\nsystemctl daemon-reload\nservice docker restart \n\n\n\n\nDelete obsolete containers\n\n\n# You can add all of this to cron daily\n#!/bin/sh\ndocker rm $(docker ps -aqf status=exited)\ndocker rmi $(docker images -qf dangling=true)\ndocker volume rm $(docker volume ls -qf dangling=true)\n\ndocker run --rm -e GRACE_PERIOD_SECONDS=86400 -e FORCE_IMAGE_REMOVAL=1 -v /var/run/docker.sock:/var/run/docker.sock spotify/docker-gc", 
            "title": "Docker"
        }, 
        {
            "location": "/Unix-way/Virtual/Docker/#run-docker-conainer", 
            "text": "sudo docker run --name mysql-nx -e MYSQL_ROOT_PASSWORD=JuSCY1Bq -d -p 127.0.0.1:3306:3306 mysql:latest", 
            "title": "Run docker conainer"
        }, 
        {
            "location": "/Unix-way/Virtual/Docker/#execute-in-docker-console", 
            "text": "sudo docker exec -it  container  bash", 
            "title": "Execute in-docker console"
        }, 
        {
            "location": "/Unix-way/Virtual/Docker/#create-json-with-container-settings", 
            "text": "docker inspect -f '{{ json .NetworkSettings }}'  container_id  | python -mjson.tool", 
            "title": "Create JSON with container settings"
        }, 
        {
            "location": "/Unix-way/Virtual/Docker/#delete-containers-by-date", 
            "text": "docker ps -a | grep 'weeks ago' | awk '{print $1}' | xargs --no-run-if-empty docker rm", 
            "title": "Delete containers by date"
        }, 
        {
            "location": "/Unix-way/Virtual/Docker/#delete-all-containers", 
            "text": "docker stop $(docker ps -a -q)\ndocker rm $(docker ps -a -q)", 
            "title": "Delete all containers:"
        }, 
        {
            "location": "/Unix-way/Virtual/Docker/#use-docker-registry", 
            "text": "mkdir /etc/systemd/system/docker.service.d/\ntouch /etc/systemd/system/docker.service.d/docker_opts.conf\nnano /etc/systemd/system/docker.service.d/docker_opts.conf\n\n# ---\n[Service]\nExecStart=\nExecStart=/usr/bin/docker -d -H fd:// --insecure-registry docker-registry.keepbot.github.io --registry-mirror https://doker-registry-mirror.keepbot.github.io\n# ---\n\nsystemctl daemon-reload\nservice docker restart", 
            "title": "Use Docker registry"
        }, 
        {
            "location": "/Unix-way/Virtual/Docker/#delete-obsolete-containers", 
            "text": "# You can add all of this to cron daily\n#!/bin/sh\ndocker rm $(docker ps -aqf status=exited)\ndocker rmi $(docker images -qf dangling=true)\ndocker volume rm $(docker volume ls -qf dangling=true)\n\ndocker run --rm -e GRACE_PERIOD_SECONDS=86400 -e FORCE_IMAGE_REMOVAL=1 -v /var/run/docker.sock:/var/run/docker.sock spotify/docker-gc", 
            "title": "Delete obsolete containers"
        }, 
        {
            "location": "/Unix-way/Virtual/KVM/", 
            "text": "Create virtual hdd image\n\n\nqemu-img create -o preallocation=metadata -f qcow2 qcow2.img 20G\n\n\n\n\nStart installation of virtual machine with virtual image\n\n\nqemu-system-x86_64 -hda vdisk.img -cdrom /path/to/boot-media.iso -boot d -m 384\n\n\n\n\nRun virtual machine\n\n\nqemu-system-x86_64 vdisk.img -m 384\n\n\n\n\nIncrease image\n\n\n# Stop virtual machine\nqemu-img resize \npath_to_vm_disk).img +\nSIZE\nG\n# Start virtual machine", 
            "title": "KVM"
        }, 
        {
            "location": "/Unix-way/Virtual/KVM/#create-virtual-hdd-image", 
            "text": "qemu-img create -o preallocation=metadata -f qcow2 qcow2.img 20G", 
            "title": "Create virtual hdd image"
        }, 
        {
            "location": "/Unix-way/Virtual/KVM/#start-installation-of-virtual-machine-with-virtual-image", 
            "text": "qemu-system-x86_64 -hda vdisk.img -cdrom /path/to/boot-media.iso -boot d -m 384", 
            "title": "Start installation of virtual machine with virtual image"
        }, 
        {
            "location": "/Unix-way/Virtual/KVM/#run-virtual-machine", 
            "text": "qemu-system-x86_64 vdisk.img -m 384", 
            "title": "Run virtual machine"
        }, 
        {
            "location": "/Unix-way/Virtual/KVM/#increase-image", 
            "text": "# Stop virtual machine\nqemu-img resize  path_to_vm_disk).img + SIZE G\n# Start virtual machine", 
            "title": "Increase image"
        }, 
        {
            "location": "/Unix-way/Web/Tomcat/", 
            "text": "Delay for apps deployment\n\n\n\n\nSubject:\n TC7 very slow SessionIdGenerator SecureRandom initialization\n\n\n\n\nFrom list:\n tomcat-user\nTC7+ can often take a long time to start up due to slow initialization of the SessionIdGenerator - it can take up to nearly 2-3 minutes. TC7+ uses secure randomizer /dev/urandom to generate \nSession ID\n but JRE uses /dev/random instead for \"Oracle security reasons\" so it causes some intitialisation delays when random generator waits to sufficient amount entropy.\nThere is some issues about it: \nJDK-6521844\n, JDK-6521844.\n\n\n\n\n\n\nTo view amount of available entropy:\n\n\n\n\n\n\ncat /proc/sys/kernel/random/entropy_avail\n\n\n\n\n\n\nTo avoid this behaviour you need to set JAVA_OPTS manually like bellow:\n\n\n\n\nJAVA_OPTS=\n-Djava.security.egd=file:/dev/./urandom\n /opt/apache-tomcat-7.0.70/bin/startup.sh", 
            "title": "Tomcat"
        }, 
        {
            "location": "/Unix-way/Web/Tomcat/#delay-for-apps-deployment", 
            "text": "Subject:  TC7 very slow SessionIdGenerator SecureRandom initialization   From list:  tomcat-user\nTC7+ can often take a long time to start up due to slow initialization of the SessionIdGenerator - it can take up to nearly 2-3 minutes. TC7+ uses secure randomizer /dev/urandom to generate  Session ID  but JRE uses /dev/random instead for \"Oracle security reasons\" so it causes some intitialisation delays when random generator waits to sufficient amount entropy.\nThere is some issues about it:  JDK-6521844 , JDK-6521844.    To view amount of available entropy:    cat /proc/sys/kernel/random/entropy_avail   To avoid this behaviour you need to set JAVA_OPTS manually like bellow:   JAVA_OPTS= -Djava.security.egd=file:/dev/./urandom  /opt/apache-tomcat-7.0.70/bin/startup.sh", 
            "title": "Delay for apps deployment"
        }
    ]
}